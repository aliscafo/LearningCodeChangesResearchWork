347
#method_before
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    RequestDispatcher dispatcher = null;
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    HttpSession session = request.getSession(true);
    PageType referTo = PageType.TREE;
    if (session.getAttribute("treeDefault") != null) {
        boolean treeDefault = (boolean) session.getAttribute("treeDefault");
        if (!treeDefault) {
            referTo = PageType.TABLE;
        }
    }
    List<TestDisplay> displayedTests = new ArrayList<>();
    List<String> allTestNames = new ArrayList<>();
    List<Key> unprocessedTestKeys = new ArrayList<>();
    // map from table key to TestDisplay
    Map<Key, TestDisplay> testMap = new HashMap<>();
    Map<String, String> subscriptionMap = new HashMap<>();
    boolean showAll = request.getParameter("showAll") != null;
    String error = null;
    Query query = new Query(TestEntity.KIND).setKeysOnly();
    for (Entity test : datastore.prepare(query).asIterable()) {
        allTestNames.add(test.getKey().getName());
    }
    List<Key> favoriteKeyList = new ArrayList<Key>();
    Filter userFilter = new FilterPredicate(UserFavoriteEntity.USER, FilterOperator.EQUAL, currentUser);
    Query filterQuery = new Query(UserFavoriteEntity.KIND).setFilter(userFilter);
    Iterable<Entity> favoriteIter = datastore.prepare(filterQuery).asIterable();
    favoriteIter.forEach(fe -> {
        Key testKey = UserFavoriteEntity.fromEntity(fe).testKey;
        favoriteKeyList.add(testKey);
        subscriptionMap.put(testKey.getName(), KeyFactory.keyToString(fe.getKey()));
    });
    query = new Query(TestStatusEntity.KIND).addProjection(new PropertyProjection(TestStatusEntity.PASS_COUNT, Long.class)).addProjection(new PropertyProjection(TestStatusEntity.FAIL_COUNT, Long.class));
    for (Entity status : datastore.prepare(query).asIterable()) {
        TestStatusEntity statusEntity = TestStatusEntity.fromEntity(status);
        if (statusEntity == null)
            continue;
        Key testKey = KeyFactory.createKey(TestEntity.KIND, statusEntity.testName);
        boolean isFavorite = favoriteKeyList.contains(testKey);
        TestDisplay display = new TestDisplay(testKey, -1, -1, false, isFavorite);
        if (unprocessedTestKeys.contains(testKey)) {
        // Process tests without statuses
        // This is default value so do not need to do anything here
        } else {
            display = new TestDisplay(testKey, statusEntity.passCount, statusEntity.failCount, false, isFavorite);
        }
        testMap.put(testKey, display);
    }
    if (testMap.size() == 0) {
        error = NO_TESTS_ERROR;
    }
    if (showAll) {
        for (Key testKey : testMap.keySet()) {
            displayedTests.add(testMap.get(testKey));
        }
    } else {
        if (testMap.size() > 0) {
            for (Entity favoriteEntity : favoriteIter) {
                UserFavoriteEntity favorite = UserFavoriteEntity.fromEntity(favoriteEntity);
                Key testKey = favorite.testKey;
                if (!testMap.containsKey(testKey)) {
                    continue;
                }
                TestDisplay display = testMap.get(testKey);
                display.setMuteNotifications(favorite.muteNotifications);
                displayedTests.add(display);
            }
        }
    }
    displayedTests.sort(Comparator.naturalOrder());
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("allTestsJson", new Gson().toJson(allTestNames));
    request.setAttribute("subscriptionMapJson", new Gson().toJson(subscriptionMap));
    request.setAttribute("testNames", displayedTests);
    request.setAttribute("showAll", showAll);
    request.setAttribute("error", error);
    request.setAttribute("resultsUrl", referTo.defaultUrl);
    dispatcher = request.getRequestDispatcher(DASHBOARD_MAIN_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#method_after
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    RequestDispatcher dispatcher = null;
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    HttpSession session = request.getSession(true);
    PageType referTo = PageType.TREE;
    if (session.getAttribute("treeDefault") != null) {
        boolean treeDefault = (boolean) session.getAttribute("treeDefault");
        if (!treeDefault) {
            referTo = PageType.TABLE;
        }
    }
    List<TestDisplay> displayedTests = new ArrayList<>();
    List<String> allTestNames = new ArrayList<>();
    List<Key> unprocessedTestKeys = new ArrayList<>();
    // map from table key to TestDisplay
    Map<Key, TestDisplay> testMap = new HashMap<>();
    Map<String, String> subscriptionMap = new HashMap<>();
    boolean showAll = request.getParameter("showAll") != null;
    String error = null;
    Query query = new Query(TestEntity.KIND).setKeysOnly();
    for (Entity test : datastore.prepare(query).asIterable()) {
        allTestNames.add(test.getKey().getName());
    }
    List<Key> favoriteKeyList = new ArrayList<Key>();
    Filter userFilter = new FilterPredicate(UserFavoriteEntity.USER, FilterOperator.EQUAL, currentUser);
    Query filterQuery = new Query(UserFavoriteEntity.KIND).setFilter(userFilter);
    Iterable<Entity> favoriteIter = datastore.prepare(filterQuery).asIterable();
    favoriteIter.forEach(fe -> {
        Key testKey = UserFavoriteEntity.fromEntity(fe).testKey;
        favoriteKeyList.add(testKey);
        subscriptionMap.put(testKey.getName(), KeyFactory.keyToString(fe.getKey()));
    });
    query = new Query(TestStatusEntity.KIND).addProjection(new PropertyProjection(TestStatusEntity.PASS_COUNT, Long.class)).addProjection(new PropertyProjection(TestStatusEntity.FAIL_COUNT, Long.class));
    for (Entity status : datastore.prepare(query).asIterable()) {
        TestStatusEntity statusEntity = TestStatusEntity.fromEntity(status);
        if (statusEntity == null)
            continue;
        Key testKey = KeyFactory.createKey(TestEntity.KIND, statusEntity.testName);
        boolean isFavorite = favoriteKeyList.contains(testKey);
        TestDisplay display = new TestDisplay(testKey, -1, -1, false, isFavorite);
        if (!unprocessedTestKeys.contains(testKey)) {
            display = new TestDisplay(testKey, statusEntity.passCount, statusEntity.failCount, false, isFavorite);
        }
        testMap.put(testKey, display);
    }
    if (testMap.size() == 0) {
        error = NO_TESTS_ERROR;
    }
    if (showAll) {
        for (Key testKey : testMap.keySet()) {
            displayedTests.add(testMap.get(testKey));
        }
    } else {
        if (testMap.size() > 0) {
            for (Entity favoriteEntity : favoriteIter) {
                UserFavoriteEntity favorite = UserFavoriteEntity.fromEntity(favoriteEntity);
                Key testKey = favorite.testKey;
                if (!testMap.containsKey(testKey)) {
                    continue;
                }
                TestDisplay display = testMap.get(testKey);
                display.setMuteNotifications(favorite.muteNotifications);
                displayedTests.add(display);
            }
        }
    }
    displayedTests.sort(Comparator.naturalOrder());
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("allTestsJson", new Gson().toJson(allTestNames));
    request.setAttribute("subscriptionMapJson", new Gson().toJson(subscriptionMap));
    request.setAttribute("testNames", displayedTests);
    request.setAttribute("showAll", showAll);
    request.setAttribute("error", error);
    request.setAttribute("resultsUrl", referTo.defaultUrl);
    dispatcher = request.getRequestDispatcher(DASHBOARD_MAIN_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#end_block

#method_before
public void onError(int error) {
}
#method_after
public void onError(@NetworkScan.ScanErrorCode int error) {
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(radioAccessNetwork);
    dest.writeIntArray(bands);
    dest.writeIntArray(channels);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mRadioAccessNetwork);
    dest.writeIntArray(mBands);
    dest.writeIntArray(mChannels);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    RadioAccessSpecifier ras;
    try {
        ras = (RadioAccessSpecifier) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (radioAccessNetwork == ras.radioAccessNetwork && Arrays.equals(bands, ras.bands) && Arrays.equals(channels, ras.channels));
}
#method_after
@Override
public boolean equals(Object o) {
    RadioAccessSpecifier ras;
    try {
        ras = (RadioAccessSpecifier) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mRadioAccessNetwork == ras.mRadioAccessNetwork && Arrays.equals(mBands, ras.mBands) && Arrays.equals(mChannels, ras.mChannels));
}
#end_block

#method_before
@Override
public int hashCode() {
    return ((radioAccessNetwork * 31) + (Arrays.hashCode(bands) * 37) + (Arrays.hashCode(channels)) * 39);
}
#method_after
@Override
public int hashCode() {
    return ((mRadioAccessNetwork * 31) + (Arrays.hashCode(mBands) * 37) + (Arrays.hashCode(mChannels)) * 39);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(scanType);
    dest.writeParcelableArray(specifiers, flags);
    dest.writeInt(searchPeriodicity);
    dest.writeInt(maxSearchTime);
    dest.writeBoolean(incrementalResults);
    dest.writeInt(incrementalResultsPeriodicity);
    dest.writeStringList(mccMncs);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mScanType);
    dest.writeParcelableArray(mSpecifiers, flags);
    dest.writeInt(mSearchPeriodicity);
    dest.writeInt(mMaxSearchTime);
    dest.writeBoolean(mIncrementalResults);
    dest.writeInt(mIncrementalResultsPeriodicity);
    dest.writeStringList(mMccMncs);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    NetworkScanRequest nsr;
    try {
        nsr = (NetworkScanRequest) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (scanType == nsr.scanType && Arrays.equals(specifiers, nsr.specifiers) && searchPeriodicity == nsr.searchPeriodicity && maxSearchTime == nsr.maxSearchTime && incrementalResults == nsr.incrementalResults && incrementalResultsPeriodicity == nsr.incrementalResultsPeriodicity && (((mccMncs != null) && mccMncs.equals(nsr.mccMncs))));
}
#method_after
@Override
public boolean equals(Object o) {
    NetworkScanRequest nsr;
    try {
        nsr = (NetworkScanRequest) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mScanType == nsr.mScanType && Arrays.equals(mSpecifiers, nsr.mSpecifiers) && mSearchPeriodicity == nsr.mSearchPeriodicity && mMaxSearchTime == nsr.mMaxSearchTime && mIncrementalResults == nsr.mIncrementalResults && mIncrementalResultsPeriodicity == nsr.mIncrementalResultsPeriodicity && (((mMccMncs != null) && mMccMncs.equals(nsr.mMccMncs))));
}
#end_block

#method_before
@Override
public int hashCode() {
    return ((scanType * 31) + (Arrays.hashCode(specifiers)) * 37 + (searchPeriodicity * 41) + (maxSearchTime * 43) + ((incrementalResults == true ? 1 : 0) * 47) + (incrementalResultsPeriodicity * 53) + (mccMncs.hashCode() * 59));
}
#method_after
@Override
public int hashCode() {
    return ((mScanType * 31) + (Arrays.hashCode(mSpecifiers)) * 37 + (mSearchPeriodicity * 41) + (mMaxSearchTime * 43) + ((mIncrementalResults == true ? 1 : 0) * 47) + (mIncrementalResultsPeriodicity * 53) + (mMccMncs.hashCode() * 59));
}
#end_block

#method_before
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        int subId = getSubId(SubscriptionManager.getDefaultDataSubscriptionId());
        if (keyType != KEY_TYPE_EPDDG && keyType != KEY_TYPE_WLAN) {
            throw new IllegalArgumentException("Invalid key type");
        }
        return info.getCarrierInfoForImsiEncryption(subId, keyType, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption RemoteException", ex);
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption NullPointerException", ex);
        return null;
    }
}
#method_after
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null) {
            throw new RuntimeException("IMSI error: Subscriber Info is null");
        }
        int subId = getSubId(SubscriptionManager.getDefaultDataSubscriptionId());
        if (keyType != KEY_TYPE_EPDG && keyType != KEY_TYPE_WLAN) {
            throw new IllegalArgumentException("IMSI error: Invalid key type");
        }
        ImsiEncryptionInfo imsiEncryptionInfo = info.getCarrierInfoForImsiEncryption(subId, keyType, mContext.getOpPackageName());
        if (imsiEncryptionInfo == null && isImsiEncryptionRequired(subId, keyType)) {
            Rlog.e(TAG, "IMSI error: key is required but not found");
            throw new RuntimeException("IMSI error: key is required but not found");
        }
        return imsiEncryptionInfo;
    } catch (RemoteException ex) {
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption RemoteException" + ex);
        throw new RuntimeException("IMSI error: Remote Exception");
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption NullPointerException" + ex);
        throw new RuntimeException("IMSI error: Null Pointer exception");
    }
}
#end_block

#method_before
public void setNetworkSelectionModeAutomatic(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setNetworkSelectionModeAutomatic(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic NPE", ex);
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setNetworkSelectionModeAutomatic() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setNetworkSelectionModeAutomatic(getSubId());
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic NPE", ex);
    }
}
#end_block

#method_before
public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback) {
    synchronized (this) {
        if (mTelephonyScanManager == null) {
            mTelephonyScanManager = new TelephonyScanManager();
        }
    }
    return mTelephonyScanManager.requestNetworkScan(getSubId(), request, callback);
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback) {
    synchronized (this) {
        if (mTelephonyScanManager == null) {
            mTelephonyScanManager = new TelephonyScanManager();
        }
    }
    return mTelephonyScanManager.requestNetworkScan(getSubId(), request, callback);
}
#end_block

#method_before
public boolean setNetworkSelectionModeManual(int subId, String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setNetworkSelectionModeManual(subId, operatorNumeric, persistSelection);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setNetworkSelectionModeManual(getSubId(), operatorNumeric, persistSelection);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#end_block

#method_before
public boolean setPreferredNetworkType(int subId, int networkType) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setPreferredNetworkType(subId, networkType);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setPreferredNetworkType RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setPreferredNetworkType NPE", ex);
    }
    return false;
}
#method_after
public boolean setPreferredNetworkType(int subId, int networkType) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setPreferredNetworkType(subId, networkType);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setPreferredNetworkType RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setPreferredNetworkType NPE", ex);
    }
    return false;
}
#end_block

#method_before
private void closeService() {
    if (VERBOSE) {
        Log.v(TAG, "Pbap Service closeService");
    }
    BluetoothPbapUtils.savePbapParams(this, BluetoothPbapUtils.sPrimaryVersionCounter, BluetoothPbapUtils.sSecondaryVersionCounter, BluetoothPbapUtils.sDbIdentifier.get(), BluetoothPbapUtils.contactsLastUpdated, BluetoothPbapUtils.totalFields, BluetoothPbapUtils.totalSvcFields, BluetoothPbapUtils.totalContacts);
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    clearServerSocket();
    if (mSessionStatusHandler != null) {
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    }
    mRemoteDevice = null;
}
#method_after
private void closeService() {
    if (VERBOSE) {
        Log.v(TAG, "Pbap Service closeService");
    }
    BluetoothPbapUtils.savePbapParams(this, BluetoothPbapUtils.sPrimaryVersionCounter, BluetoothPbapUtils.sSecondaryVersionCounter, BluetoothPbapUtils.sDbIdentifier.get(), BluetoothPbapUtils.contactsLastUpdated, BluetoothPbapUtils.totalFields, BluetoothPbapUtils.totalSvcFields, BluetoothPbapUtils.totalContacts);
    // exit initSocket early
    mInterrupted = true;
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    cleanUpServerSocket();
    if (mSessionStatusHandler != null) {
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    }
    mRemoteDevice = null;
}
#end_block

#method_before
private void cleanUpSdpRecord() {
    if (mSdpHandle < 0) {
        Log.w(TAG, "cleanUpSdpRecord, SDP record never created");
        return;
    }
    int sdpHandle = mSdpHandle;
    mSdpHandle = -1;
    SdpManager sdpManager = SdpManager.getDefaultManager();
    Log.d(TAG, "cleanUpSdpRecord, mSdpHandle=" + sdpHandle);
    if (sdpManager == null || !sdpManager.removeSdpRecord(sdpHandle)) {
        Log.e(TAG, "cleanUpSdpRecord, removeSdpRecord failed, sdpHandle=" + sdpHandle);
    }
}
#method_after
private void cleanUpSdpRecord() {
    if (mSdpHandle < 0) {
        Log.w(TAG, "cleanUpSdpRecord, SDP record never created");
        return;
    }
    int sdpHandle = mSdpHandle;
    mSdpHandle = -1;
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (DEBUG) {
        Log.d(TAG, "cleanUpSdpRecord, mSdpHandle=" + sdpHandle);
    }
    if (sdpManager == null) {
        Log.e(TAG, "sdpManager is null");
    } else if (!sdpManager.removeSdpRecord(sdpHandle)) {
        Log.w(TAG, "cleanUpSdpRecord, removeSdpRecord failed, sdpHandle=" + sdpHandle);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (VERBOSE) {
        Log.v(TAG, "Handler(): got msg=" + msg.what);
    }
    switch(msg.what) {
        case START_LISTENER:
            mServerSockets = ObexServerSockets.create(BluetoothPbapService.this);
            createSdpRecord();
            // fetch Pbap Params to check if significant change has happened to Database
            BluetoothPbapUtils.fetchPbapParams(mContext);
            break;
        case USER_TIMEOUT:
            Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL);
            intent.setPackage(getString(R.string.pairing_ui_package));
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
            intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
            sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
            mIsWaitingAuthorization = false;
            stopObexServerSession();
            break;
        case AUTH_TIMEOUT:
            Intent i = new Intent(USER_CONFIRM_TIMEOUT_ACTION);
            sendBroadcast(i);
            removePbapNotification(NOTIFICATION_ID_AUTH);
            notifyAuthCancelled();
            break;
        case MSG_SERVERSESSION_CLOSE:
            stopObexServerSession();
            break;
        case MSG_SESSION_ESTABLISHED:
            break;
        case MSG_OBEX_AUTH_CHALL:
            createPbapNotification(AUTH_CHALL_ACTION);
            mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(AUTH_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
            break;
        case MSG_ACQUIRE_WAKE_LOCK:
            if (mWakeLock == null) {
                PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
                mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "StartingObexPbapTransaction");
                mWakeLock.setReferenceCounted(false);
                mWakeLock.acquire();
                Log.w(TAG, "Acquire Wake Lock");
            }
            mSessionStatusHandler.removeMessages(MSG_RELEASE_WAKE_LOCK);
            mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(MSG_RELEASE_WAKE_LOCK), RELEASE_WAKE_LOCK_DELAY);
            break;
        case MSG_RELEASE_WAKE_LOCK:
            if (mWakeLock != null) {
                mWakeLock.release();
                mWakeLock = null;
                Log.w(TAG, "Release Wake Lock");
            }
            break;
        case SHUTDOWN:
            closeService();
            break;
        case LOAD_CONTACTS:
            loadAllContacts();
            break;
        case CHECK_SECONDARY_VERSION_COUNTER:
            updateSecondaryVersion();
            break;
        case ROLLOVER_COUNTERS:
            BluetoothPbapUtils.rolloverCounters();
            break;
        default:
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (VERBOSE) {
        Log.v(TAG, "Handler(): got msg=" + msg.what);
    }
    switch(msg.what) {
        case START_LISTENER:
            startSocketListeners();
            break;
        case USER_TIMEOUT:
            Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL);
            intent.setPackage(getString(R.string.pairing_ui_package));
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
            intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
            sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
            mIsWaitingAuthorization = false;
            stopObexServerSession();
            break;
        case AUTH_TIMEOUT:
            Intent i = new Intent(USER_CONFIRM_TIMEOUT_ACTION);
            sendBroadcast(i);
            removePbapNotification(NOTIFICATION_ID_AUTH);
            notifyAuthCancelled();
            break;
        case MSG_SERVERSESSION_CLOSE:
            stopObexServerSession();
            break;
        case MSG_OBEX_AUTH_CHALL:
            createPbapNotification(AUTH_CHALL_ACTION);
            mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(AUTH_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
            break;
        case MSG_ACQUIRE_WAKE_LOCK:
            if (mWakeLock == null) {
                PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
                mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "StartingObexPbapTransaction");
                mWakeLock.setReferenceCounted(false);
                mWakeLock.acquire();
                Log.w(TAG, "Acquire Wake Lock");
            }
            mSessionStatusHandler.removeMessages(MSG_RELEASE_WAKE_LOCK);
            mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(MSG_RELEASE_WAKE_LOCK), RELEASE_WAKE_LOCK_DELAY);
            break;
        case MSG_RELEASE_WAKE_LOCK:
            if (mWakeLock != null) {
                mWakeLock.release();
                mWakeLock = null;
                Log.w(TAG, "Release Wake Lock");
            }
            break;
        case SHUTDOWN:
            closeService();
            break;
        case LOAD_CONTACTS:
            loadAllContacts();
            break;
        case CHECK_SECONDARY_VERSION_COUNTER:
            updateSecondaryVersion();
            break;
        case ROLLOVER_COUNTERS:
            BluetoothPbapUtils.rolloverCounters();
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
protected boolean start() {
    Log.v(TAG, "start()");
    mState = BluetoothProfile.STATE_DISCONNECTED;
    mContext = this;
    mSessionStatusHandler = new PbapHandler();
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
    filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
    filter.addAction(AUTH_RESPONSE_ACTION);
    filter.addAction(AUTH_CANCELLED_ACTION);
    BluetoothPbapConfig.init(this);
    registerReceiver(mPbapReceiver, filter);
    try {
        mContactChangeObserver = new BluetoothPbapContentObserver();
        getContentResolver().registerContentObserver(DevicePolicyUtils.getEnterprisePhoneUri(this), false, mContactChangeObserver);
    } catch (SQLiteException e) {
        Log.e(TAG, "SQLite exception: " + e);
    } catch (IllegalStateException e) {
        Log.e(TAG, "Illegal state exception, content observer is already registered");
    }
    mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(START_LISTENER));
    return true;
}
#method_after
@Override
protected boolean start() {
    Log.v(TAG, "start()");
    mState = BluetoothProfile.STATE_DISCONNECTED;
    mContext = this;
    mSessionStatusHandler = new PbapHandler();
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
    filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
    filter.addAction(AUTH_RESPONSE_ACTION);
    filter.addAction(AUTH_CANCELLED_ACTION);
    mInterrupted = false;
    BluetoothPbapConfig.init(this);
    mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(START_LISTENER));
    registerReceiver(mPbapReceiver, filter);
    try {
        mContactChangeObserver = new BluetoothPbapContentObserver();
        getContentResolver().registerContentObserver(DevicePolicyUtils.getEnterprisePhoneUri(this), false, mContactChangeObserver);
    } catch (SQLiteException e) {
        Log.e(TAG, "SQLite exception: " + e);
    } catch (IllegalStateException e) {
        Log.e(TAG, "Illegal state exception, content observer is already registered");
    }
    return true;
}
#end_block

#method_before
private synchronized void startSocketListeners() {
    if (VERBOSE) {
        Log.v(TAG, "startsocketListener");
    }
    if (mServerSockets != null) {
        mServerSockets.prepareForNewConnect();
    }
}
#method_after
private synchronized void startSocketListeners() {
    if (DEBUG) {
        Log.d(TAG, "startsocketListener");
    }
    if (mServerSession != null) {
        if (DEBUG) {
            Log.d(TAG, "mServerSession exists - shutting it down...");
        }
        mServerSession.close();
        mServerSession = null;
    }
    closeConnectionSocket();
    if (mServerSockets != null) {
        mServerSockets.prepareForNewConnect();
    } else {
        mServerSockets = ObexServerSockets.create(this);
        if (mServerSockets == null) {
            // TODO: Handle - was not handled before
            Log.e(TAG, "Failed to start the listeners");
            return;
        }
        if (mSdpHandle >= 0) {
            Log.e(TAG, "SDP handle was not cleaned up, mSdpHandle=" + mSdpHandle);
            return;
        }
        mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord("OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES);
        // fetch Pbap Params to check if significant change has happened to Database
        BluetoothPbapUtils.fetchPbapParams(mContext);
        if (DEBUG) {
            Log.d(TAG, "PBAP server with handle:" + mSdpHandle);
        }
    }
}
#end_block

#method_before
@Override
public boolean onConnect(BluetoothDevice remoteDevice, BluetoothSocket socket) {
    mRemoteDevice = remoteDevice;
    if (DEBUG) {
        Log.d(TAG, "onConnect(): mRemoteDevice=" + mRemoteDevice + " socket=" + socket);
    }
    if (mRemoteDevice == null || socket == null) {
        return false;
    }
    mConnSocket = socket;
    sRemoteDeviceName = mRemoteDevice.getName();
    // In case getRemoteName failed and return null
    if (TextUtils.isEmpty(sRemoteDeviceName)) {
        sRemoteDeviceName = getString(R.string.defaultname);
    }
    int permission = mRemoteDevice.getPhonebookAccessPermission();
    if (DEBUG) {
        Log.d(TAG, "getPhonebookAccessPermission() = " + permission);
    }
    if (permission == BluetoothDevice.ACCESS_ALLOWED) {
        try {
            startObexServerSession();
        } catch (IOException ex) {
            Log.e(TAG, "Caught exception starting obex server session" + ex.toString());
        }
        if (!BluetoothPbapUtils.contactsLoaded) {
            mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(LOAD_CONTACTS));
        }
    } else if (permission == BluetoothDevice.ACCESS_REJECTED) {
        if (DEBUG) {
            Log.d(TAG, "incoming connection rejected from: " + sRemoteDeviceName + " automatically as already rejected device");
        }
        return false;
    } else {
        // permission == BluetoothDevice.ACCESS_UNKNOWN
        // Send an Intent to Settings app to ask user preference.
        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName());
        mIsWaitingAuthorization = true;
        sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM);
        if (VERBOSE) {
            Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName);
        }
        /* In case car kit time out and try to use HFP for phonebook
             * access, while UI still there waiting for user to confirm */
        mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
    /* We will continue the process when we receive
             * BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. */
    }
    return true;
}
#method_after
@Override
public boolean onConnect(BluetoothDevice remoteDevice, BluetoothSocket socket) {
    mRemoteDevice = remoteDevice;
    if (DEBUG) {
        Log.d(TAG, "onConnect(): mRemoteDevice=" + mRemoteDevice + " socket=" + socket);
    }
    if (mRemoteDevice == null || socket == null) {
        Log.e(TAG, "onConnect(): Unexpected null. mRemoteDevice=" + mRemoteDevice + " socket=" + socket);
        return false;
    }
    mConnSocket = socket;
    sRemoteDeviceName = mRemoteDevice.getName();
    // In case getRemoteName failed and return null
    if (TextUtils.isEmpty(sRemoteDeviceName)) {
        sRemoteDeviceName = getString(R.string.defaultname);
    }
    int permission = mRemoteDevice.getPhonebookAccessPermission();
    if (DEBUG) {
        Log.d(TAG, "getPhonebookAccessPermission() = " + permission);
    }
    if (permission == BluetoothDevice.ACCESS_ALLOWED) {
        try {
            startObexServerSession();
        } catch (IOException ex) {
            Log.e(TAG, "Caught exception starting obex server session" + ex.toString());
        }
        if (!BluetoothPbapUtils.contactsLoaded) {
            mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(LOAD_CONTACTS));
        }
    } else if (permission == BluetoothDevice.ACCESS_REJECTED) {
        if (DEBUG) {
            Log.d(TAG, "incoming connection rejected from: " + sRemoteDeviceName + " automatically as already rejected device");
        }
        return false;
    } else {
        // permission == BluetoothDevice.ACCESS_UNKNOWN
        // Send an Intent to Settings app to ask user preference.
        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName());
        mIsWaitingAuthorization = true;
        sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM);
        if (VERBOSE) {
            Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName);
        }
        /* In case car kit time out and try to use HFP for phonebook
             * access, while UI still there waiting for user to confirm */
        mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
    /* We will continue the process when we receive
             * BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. */
    }
    return true;
}
#end_block

#method_before
@Override
public synchronized void onAcceptFailed() {
    Log.e(TAG, "PBAP server socket accept thread failed. Restarting the server socket");
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    clearServerSocket();
    if (mSessionStatusHandler != null) {
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    }
    mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(START_LISTENER));
}
#method_after
@Override
public synchronized void onAcceptFailed() {
    Log.w(TAG, "PBAP server socket accept thread failed. Restarting the server socket");
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    cleanUpServerSocket();
    if (mSessionStatusHandler != null) {
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    }
    if (!mInterrupted) {
        startSocketListeners();
    }
}
#end_block

#method_before
@SystemApi
@RequiresPermission(android.Manifest.permission.UPDATE_DEVICE_STATS)
public static void clearThreadStatsUid() {
    NetworkManagementSocketTagger.setThreadSocketStatsUid(-1);
}
#method_after
@SystemApi
@SuppressLint("Doclava125")
public static void clearThreadStatsUid() {
    NetworkManagementSocketTagger.setThreadSocketStatsUid(-1);
}
#end_block

#method_before
public void systemReady() {
    mSystemReady = true;
    if (!isBandwidthControlEnabled()) {
        Slog.w(TAG, "bandwidth controls disabled, unable to track stats");
        return;
    }
    // create data recorders along with historical rotators
    mDevRecorder = buildRecorder(PREFIX_DEV, mSettings.getDevConfig(), false);
    mXtRecorder = buildRecorder(PREFIX_XT, mSettings.getXtConfig(), false);
    mUidRecorder = buildRecorder(PREFIX_UID, mSettings.getUidConfig(), false);
    mUidTagRecorder = buildRecorder(PREFIX_UID_TAG, mSettings.getUidTagConfig(), true);
    updatePersistThresholds();
    synchronized (mStatsLock) {
        // upgrade any legacy stats, migrating them to rotated files
        maybeUpgradeLegacyStatsLocked();
        // read historical network stats from disk, since policy service
        // might need them right away.
        mXtStatsCached = mXtRecorder.getOrLoadCompleteLocked();
        // bootstrap initial stats to prevent double-counting later
        bootstrapStatsLocked();
    }
    // watch for tethering changes
    final IntentFilter tetherFilter = new IntentFilter(ACTION_TETHER_STATE_CHANGED);
    mContext.registerReceiver(mTetherReceiver, tetherFilter, null, mHandler);
    // listen for periodic polling events
    final IntentFilter pollFilter = new IntentFilter(ACTION_NETWORK_STATS_POLL);
    mContext.registerReceiver(mPollReceiver, pollFilter, READ_NETWORK_USAGE_HISTORY, mHandler);
    // listen for uid removal to clean stats
    final IntentFilter removedFilter = new IntentFilter(ACTION_UID_REMOVED);
    mContext.registerReceiver(mRemovedReceiver, removedFilter, null, mHandler);
    // listen for user changes to clean stats
    final IntentFilter userFilter = new IntentFilter(ACTION_USER_REMOVED);
    mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler);
    // persist stats during clean shutdown
    final IntentFilter shutdownFilter = new IntentFilter(ACTION_SHUTDOWN);
    mContext.registerReceiver(mShutdownReceiver, shutdownFilter);
    try {
        mNetworkManager.registerObserver(mAlertObserver);
    } catch (RemoteException e) {
    // ignored; service lives in system_server
    }
    registerPollAlarmLocked();
    registerGlobalAlert();
}
#method_after
public void systemReady() {
    mSystemReady = true;
    if (!isBandwidthControlEnabled()) {
        Slog.w(TAG, "bandwidth controls disabled, unable to track stats");
        return;
    }
    synchronized (mStatsLock) {
        // create data recorders along with historical rotators
        mDevRecorder = buildRecorder(PREFIX_DEV, mSettings.getDevConfig(), false);
        mXtRecorder = buildRecorder(PREFIX_XT, mSettings.getXtConfig(), false);
        mUidRecorder = buildRecorder(PREFIX_UID, mSettings.getUidConfig(), false);
        mUidTagRecorder = buildRecorder(PREFIX_UID_TAG, mSettings.getUidTagConfig(), true);
        updatePersistThresholdsLocked();
        // upgrade any legacy stats, migrating them to rotated files
        maybeUpgradeLegacyStatsLocked();
        // read historical network stats from disk, since policy service
        // might need them right away.
        mXtStatsCached = mXtRecorder.getOrLoadCompleteLocked();
        // bootstrap initial stats to prevent double-counting later
        bootstrapStatsLocked();
    }
    // watch for tethering changes
    final IntentFilter tetherFilter = new IntentFilter(ACTION_TETHER_STATE_CHANGED);
    mContext.registerReceiver(mTetherReceiver, tetherFilter, null, mHandler);
    // listen for periodic polling events
    final IntentFilter pollFilter = new IntentFilter(ACTION_NETWORK_STATS_POLL);
    mContext.registerReceiver(mPollReceiver, pollFilter, READ_NETWORK_USAGE_HISTORY, mHandler);
    // listen for uid removal to clean stats
    final IntentFilter removedFilter = new IntentFilter(ACTION_UID_REMOVED);
    mContext.registerReceiver(mRemovedReceiver, removedFilter, null, mHandler);
    // listen for user changes to clean stats
    final IntentFilter userFilter = new IntentFilter(ACTION_USER_REMOVED);
    mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler);
    // persist stats during clean shutdown
    final IntentFilter shutdownFilter = new IntentFilter(ACTION_SHUTDOWN);
    mContext.registerReceiver(mShutdownReceiver, shutdownFilter);
    try {
        mNetworkManager.registerObserver(mAlertObserver);
    } catch (RemoteException e) {
    // ignored; service lives in system_server
    }
    registerPollAlarmLocked();
    registerGlobalAlert();
}
#end_block

#method_before
@Override
public INetworkStatsSession openSession() {
    return createSession(null, /* poll on create */
    false);
}
#method_after
@Override
public INetworkStatsSession openSession() {
    // through the public API
    return openSessionInternal(NetworkStatsManager.FLAG_AUGMENT_WITH_SUBSCRIPTION_PLAN, null);
}
#end_block

#method_before
@Override
public INetworkStatsSession openSessionForUsageStats(final String callingPackage) {
    return createSession(callingPackage, /* poll on create */
    true);
}
#method_after
@Override
public INetworkStatsSession openSessionForUsageStats(int flags, String callingPackage) {
    return openSessionInternal(flags, callingPackage);
}
#end_block

#method_before
private NetworkStats internalGetSummaryForNetwork(NetworkTemplate template, long start, long end, @NetworkStatsAccess.Level int accessLevel) {
    // splice DEV and XT together.
    return mXtStatsCached.getSummary(template, start, end, accessLevel);
}
#method_after
private NetworkStats internalGetSummaryForNetwork(NetworkTemplate template, int flags, long start, long end, @NetworkStatsAccess.Level int accessLevel, int callingUid) {
    // We've been using pure XT stats long enough that we no longer need to
    // splice DEV and XT together.
    final NetworkStatsHistory history = internalGetHistoryForNetwork(template, flags, FIELD_ALL, accessLevel, callingUid);
    final long now = System.currentTimeMillis();
    final NetworkStatsHistory.Entry entry = history.getValues(start, end, now, null);
    final NetworkStats stats = new NetworkStats(end - start, 1);
    stats.addValues(new NetworkStats.Entry(IFACE_ALL, UID_ALL, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, entry.rxBytes, entry.rxPackets, entry.txBytes, entry.txPackets, entry.operations));
    return stats;
}
#end_block

#method_before
private NetworkStatsHistory internalGetHistoryForNetwork(NetworkTemplate template, int fields, @NetworkStatsAccess.Level int accessLevel) {
    // splice DEV and XT together.
    return mXtStatsCached.getHistory(template, UID_ALL, SET_ALL, TAG_NONE, fields, accessLevel);
}
#method_after
private NetworkStatsHistory internalGetHistoryForNetwork(NetworkTemplate template, int flags, int fields, @NetworkStatsAccess.Level int accessLevel, int callingUid) {
    // We've been using pure XT stats long enough that we no longer need to
    // splice DEV and XT together.
    final SubscriptionPlan augmentPlan = resolveSubscriptionPlan(template, flags);
    synchronized (mStatsLock) {
        return mXtStatsCached.getHistory(template, augmentPlan, UID_ALL, SET_ALL, TAG_NONE, fields, Long.MIN_VALUE, Long.MAX_VALUE, accessLevel, callingUid);
    }
}
#end_block

#method_before
@Override
public long getNetworkTotalBytes(NetworkTemplate template, long start, long end) {
    // Special case - since this is for internal use only, don't worry about a full access level
    // check and just require the signature/privileged permission.
    mContext.enforceCallingOrSelfPermission(READ_NETWORK_USAGE_HISTORY, TAG);
    assertBandwidthControlEnabled();
    return internalGetSummaryForNetwork(template, start, end, NetworkStatsAccess.Level.DEVICE).getTotalBytes();
}
#method_after
@Override
public long getNetworkTotalBytes(NetworkTemplate template, long start, long end) {
    // Special case - since this is for internal use only, don't worry about
    // a full access level check and just require the signature/privileged
    // permission.
    mContext.enforceCallingOrSelfPermission(READ_NETWORK_USAGE_HISTORY, TAG);
    assertBandwidthControlEnabled();
    // through the public API
    return internalGetSummaryForNetwork(template, NetworkStatsManager.FLAG_AUGMENT_WITH_SUBSCRIPTION_PLAN, start, end, NetworkStatsAccess.Level.DEVICE, Binder.getCallingUid()).getTotalBytes();
}
#end_block

#method_before
@Override
public void incrementOperationCount(int uid, int tag, int operationCount) {
    if (Binder.getCallingUid() != uid) {
        mContext.enforceCallingOrSelfPermission(MODIFY_NETWORK_ACCOUNTING, TAG);
    }
    if (operationCount < 0) {
        throw new IllegalArgumentException("operation count can only be incremented");
    }
    if (tag == TAG_NONE) {
        throw new IllegalArgumentException("operation count must have specific tag");
    }
    synchronized (mStatsLock) {
        final int set = mActiveUidCounterSet.get(uid, SET_DEFAULT);
        mUidOperations.combineValues(mActiveIface, uid, set, tag, 0L, 0L, 0L, 0L, operationCount);
        mUidOperations.combineValues(mActiveIface, uid, set, TAG_NONE, 0L, 0L, 0L, 0L, operationCount);
    }
}
#method_after
@Override
public void incrementOperationCount(int uid, int tag, int operationCount) {
    if (Binder.getCallingUid() != uid) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.UPDATE_DEVICE_STATS, TAG);
    }
    if (operationCount < 0) {
        throw new IllegalArgumentException("operation count can only be incremented");
    }
    if (tag == TAG_NONE) {
        throw new IllegalArgumentException("operation count must have specific tag");
    }
    synchronized (mStatsLock) {
        final int set = mActiveUidCounterSet.get(uid, SET_DEFAULT);
        mUidOperations.combineValues(mActiveIface, uid, set, tag, 0L, 0L, 0L, 0L, operationCount);
        mUidOperations.combineValues(mActiveIface, uid, set, TAG_NONE, 0L, 0L, 0L, 0L, operationCount);
    }
}
#end_block

#method_before
@Override
public void setUidForeground(int uid, boolean uidForeground) {
    mContext.enforceCallingOrSelfPermission(MODIFY_NETWORK_ACCOUNTING, TAG);
    synchronized (mStatsLock) {
        final int set = uidForeground ? SET_FOREGROUND : SET_DEFAULT;
        final int oldSet = mActiveUidCounterSet.get(uid, SET_DEFAULT);
        if (oldSet != set) {
            mActiveUidCounterSet.put(uid, set);
            setKernelCounterSet(uid, set);
        }
    }
}
#method_after
@Override
public void setUidForeground(int uid, boolean uidForeground) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    synchronized (mStatsLock) {
        final int set = uidForeground ? SET_FOREGROUND : SET_DEFAULT;
        final int oldSet = mActiveUidCounterSet.get(uid, SET_DEFAULT);
        if (oldSet != set) {
            mActiveUidCounterSet.put(uid, set);
            setKernelCounterSet(uid, set);
        }
    }
}
#end_block

#method_before
@Override
public void advisePersistThreshold(long thresholdBytes) {
    mContext.enforceCallingOrSelfPermission(MODIFY_NETWORK_ACCOUNTING, TAG);
    assertBandwidthControlEnabled();
    // clamp threshold into safe range
    mPersistThreshold = MathUtils.constrain(thresholdBytes, 128 * KB_IN_BYTES, 2 * MB_IN_BYTES);
    if (LOGV) {
        Slog.v(TAG, "advisePersistThreshold() given " + thresholdBytes + ", clamped to " + mPersistThreshold);
    }
    // update and persist if beyond new thresholds
    final long currentTime = mTime.hasCache() ? mTime.currentTimeMillis() : System.currentTimeMillis();
    synchronized (mStatsLock) {
        if (!mSystemReady)
            return;
        updatePersistThresholds();
        mDevRecorder.maybePersistLocked(currentTime);
        mXtRecorder.maybePersistLocked(currentTime);
        mUidRecorder.maybePersistLocked(currentTime);
        mUidTagRecorder.maybePersistLocked(currentTime);
    }
    // re-arm global alert
    registerGlobalAlert();
}
#method_after
@Override
public void advisePersistThreshold(long thresholdBytes) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    assertBandwidthControlEnabled();
    // clamp threshold into safe range
    mPersistThreshold = MathUtils.constrain(thresholdBytes, 128 * KB_IN_BYTES, 2 * MB_IN_BYTES);
    if (LOGV) {
        Slog.v(TAG, "advisePersistThreshold() given " + thresholdBytes + ", clamped to " + mPersistThreshold);
    }
    // update and persist if beyond new thresholds
    final long currentTime = mTime.hasCache() ? mTime.currentTimeMillis() : System.currentTimeMillis();
    synchronized (mStatsLock) {
        if (!mSystemReady)
            return;
        updatePersistThresholdsLocked();
        mDevRecorder.maybePersistLocked(currentTime);
        mXtRecorder.maybePersistLocked(currentTime);
        mUidRecorder.maybePersistLocked(currentTime);
        mUidTagRecorder.maybePersistLocked(currentTime);
    }
    // re-arm global alert
    registerGlobalAlert();
}
#end_block

#method_before
@Override
public long getUidStats(int uid, int type) {
    Slog.w(TAG, "calling native method from Stats Service");
    return nativeGetUidStat(uid, type);
}
#method_after
@Override
public long getUidStats(int uid, int type) {
    return nativeGetUidStat(uid, type);
}
#end_block

#method_before
@Override
public long getIfaceStats(String iface, int type) {
    Slog.w(TAG, "calling native method from Stats Service");
    return nativeGetIfaceStat(iface, type);
}
#method_after
@Override
public long getIfaceStats(String iface, int type) {
    return nativeGetIfaceStat(iface, type);
}
#end_block

#method_before
@Override
public long getTotalStats(int type) {
    Slog.w(TAG, "calling native method from Stats Service");
    return nativeGetTotalStat(type);
}
#method_after
@Override
public long getTotalStats(int type) {
    return nativeGetTotalStat(type);
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter rawWriter, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, rawWriter))
        return;
    long duration = DateUtils.DAY_IN_MILLIS;
    final HashSet<String> argSet = new HashSet<String>();
    for (String arg : args) {
        argSet.add(arg);
        if (arg.startsWith("--duration=")) {
            try {
                duration = Long.parseLong(arg.substring(11));
            } catch (NumberFormatException ignored) {
            }
        }
    }
    // usage: dumpsys netstats --full --uid --tag --poll --checkin
    final boolean poll = argSet.contains("--poll") || argSet.contains("poll");
    final boolean checkin = argSet.contains("--checkin");
    final boolean fullHistory = argSet.contains("--full") || argSet.contains("full");
    final boolean includeUid = argSet.contains("--uid") || argSet.contains("detail");
    final boolean includeTag = argSet.contains("--tag") || argSet.contains("detail");
    final IndentingPrintWriter pw = new IndentingPrintWriter(rawWriter, "  ");
    synchronized (mStatsLock) {
        if (args.length > 0 && "--proto".equals(args[0])) {
            // In this case ignore all other arguments.
            dumpProto(fd);
            return;
        }
        if (poll) {
            performPollLocked(FLAG_PERSIST_ALL | FLAG_PERSIST_FORCE);
            pw.println("Forced poll");
            return;
        }
        if (checkin) {
            final long end = System.currentTimeMillis();
            final long start = end - duration;
            pw.print("v1,");
            pw.print(start / SECOND_IN_MILLIS);
            pw.print(',');
            pw.print(end / SECOND_IN_MILLIS);
            pw.println();
            pw.println("xt");
            mXtRecorder.dumpCheckin(rawWriter, start, end);
            if (includeUid) {
                pw.println("uid");
                mUidRecorder.dumpCheckin(rawWriter, start, end);
            }
            if (includeTag) {
                pw.println("tag");
                mUidTagRecorder.dumpCheckin(rawWriter, start, end);
            }
            return;
        }
        pw.println("Active interfaces:");
        pw.increaseIndent();
        for (int i = 0; i < mActiveIfaces.size(); i++) {
            pw.printPair("iface", mActiveIfaces.keyAt(i));
            pw.printPair("ident", mActiveIfaces.valueAt(i));
            pw.println();
        }
        pw.decreaseIndent();
        pw.println("Active UID interfaces:");
        pw.increaseIndent();
        for (int i = 0; i < mActiveUidIfaces.size(); i++) {
            pw.printPair("iface", mActiveUidIfaces.keyAt(i));
            pw.printPair("ident", mActiveUidIfaces.valueAt(i));
            pw.println();
        }
        pw.decreaseIndent();
        pw.println("Dev stats:");
        pw.increaseIndent();
        mDevRecorder.dumpLocked(pw, fullHistory);
        pw.decreaseIndent();
        pw.println("Xt stats:");
        pw.increaseIndent();
        mXtRecorder.dumpLocked(pw, fullHistory);
        pw.decreaseIndent();
        if (includeUid) {
            pw.println("UID stats:");
            pw.increaseIndent();
            mUidRecorder.dumpLocked(pw, fullHistory);
            pw.decreaseIndent();
        }
        if (includeTag) {
            pw.println("UID tag stats:");
            pw.increaseIndent();
            mUidTagRecorder.dumpLocked(pw, fullHistory);
            pw.decreaseIndent();
        }
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter rawWriter, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, rawWriter))
        return;
    long duration = DateUtils.DAY_IN_MILLIS;
    final HashSet<String> argSet = new HashSet<String>();
    for (String arg : args) {
        argSet.add(arg);
        if (arg.startsWith("--duration=")) {
            try {
                duration = Long.parseLong(arg.substring(11));
            } catch (NumberFormatException ignored) {
            }
        }
    }
    // usage: dumpsys netstats --full --uid --tag --poll --checkin
    final boolean poll = argSet.contains("--poll") || argSet.contains("poll");
    final boolean checkin = argSet.contains("--checkin");
    final boolean fullHistory = argSet.contains("--full") || argSet.contains("full");
    final boolean includeUid = argSet.contains("--uid") || argSet.contains("detail");
    final boolean includeTag = argSet.contains("--tag") || argSet.contains("detail");
    final IndentingPrintWriter pw = new IndentingPrintWriter(rawWriter, "  ");
    synchronized (mStatsLock) {
        if (args.length > 0 && "--proto".equals(args[0])) {
            // In this case ignore all other arguments.
            dumpProtoLocked(fd);
            return;
        }
        if (poll) {
            performPollLocked(FLAG_PERSIST_ALL | FLAG_PERSIST_FORCE);
            pw.println("Forced poll");
            return;
        }
        if (checkin) {
            final long end = System.currentTimeMillis();
            final long start = end - duration;
            pw.print("v1,");
            pw.print(start / SECOND_IN_MILLIS);
            pw.print(',');
            pw.print(end / SECOND_IN_MILLIS);
            pw.println();
            pw.println("xt");
            mXtRecorder.dumpCheckin(rawWriter, start, end);
            if (includeUid) {
                pw.println("uid");
                mUidRecorder.dumpCheckin(rawWriter, start, end);
            }
            if (includeTag) {
                pw.println("tag");
                mUidTagRecorder.dumpCheckin(rawWriter, start, end);
            }
            return;
        }
        pw.println("Active interfaces:");
        pw.increaseIndent();
        for (int i = 0; i < mActiveIfaces.size(); i++) {
            pw.printPair("iface", mActiveIfaces.keyAt(i));
            pw.printPair("ident", mActiveIfaces.valueAt(i));
            pw.println();
        }
        pw.decreaseIndent();
        pw.println("Active UID interfaces:");
        pw.increaseIndent();
        for (int i = 0; i < mActiveUidIfaces.size(); i++) {
            pw.printPair("iface", mActiveUidIfaces.keyAt(i));
            pw.printPair("ident", mActiveUidIfaces.valueAt(i));
            pw.println();
        }
        pw.decreaseIndent();
        pw.println("Dev stats:");
        pw.increaseIndent();
        mDevRecorder.dumpLocked(pw, fullHistory);
        pw.decreaseIndent();
        pw.println("Xt stats:");
        pw.increaseIndent();
        mXtRecorder.dumpLocked(pw, fullHistory);
        pw.decreaseIndent();
        if (includeUid) {
            pw.println("UID stats:");
            pw.increaseIndent();
            mUidRecorder.dumpLocked(pw, fullHistory);
            pw.decreaseIndent();
        }
        if (includeTag) {
            pw.println("UID tag stats:");
            pw.increaseIndent();
            mUidTagRecorder.dumpLocked(pw, fullHistory);
            pw.decreaseIndent();
        }
    }
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof BluetoothHidDeviceAppQosSettings) {
        BluetoothHidDeviceAppQosSettings qos = (BluetoothHidDeviceAppQosSettings) o;
        return false;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof BluetoothHidDeviceAppQosSettings) {
        BluetoothHidDeviceAppQosSettings qos = (BluetoothHidDeviceAppQosSettings) o;
        return this.serviceType == qos.serviceType && this.tokenRate == qos.tokenRate && this.tokenBucketSize == qos.tokenBucketSize && this.peakBandwidth == qos.peakBandwidth && this.latency == qos.latency && this.delayVariation == qos.delayVariation;
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof BluetoothHidDeviceAppSdpSettings) {
        BluetoothHidDeviceAppSdpSettings sdp = (BluetoothHidDeviceAppSdpSettings) o;
        return false;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof BluetoothHidDeviceAppSdpSettings) {
        BluetoothHidDeviceAppSdpSettings sdp = (BluetoothHidDeviceAppSdpSettings) o;
        return this.name.equals(sdp.name) && this.description.equals(sdp.description) && this.provider.equals(sdp.provider) && this.subclass == sdp.subclass && Arrays.equals(this.descriptors, sdp.descriptors);
    }
    return false;
}
#end_block

#method_before
public void onAppStatusChanged(BluetoothDevice pluggedDevice, BluetoothHidDeviceAppConfiguration config, boolean registered) {
    Log.d(TAG, "onAppStatusChanged: pluggedDevice=" + pluggedDevice + " registered=" + registered);
}
#method_after
public void onAppStatusChanged(BluetoothDevice pluggedDevice, boolean registered) {
    Log.d(TAG, "onAppStatusChanged: pluggedDevice=" + pluggedDevice + " registered=" + registered);
}
#end_block

#method_before
static AddrTypeTestCase of(MacAddressType expected, int... addr) {
    AddrTypeTestCase t = new AddrTypeTestCase();
    t.expected = expected;
    t.addr = toByteArray(addr);
    return t;
}
#method_after
static AddrTypeTestCase of(int expectedType, int... addr) {
    AddrTypeTestCase t = new AddrTypeTestCase();
    t.expectedType = expectedType;
    t.addr = toByteArray(addr);
    return t;
}
#end_block

#method_before
@Test
public void testMacAddrTypes() {
    AddrTypeTestCase[] testcases = { AddrTypeTestCase.of(null), AddrTypeTestCase.of(null, 0), AddrTypeTestCase.of(null, 1, 2, 3, 4, 5), AddrTypeTestCase.of(null, 1, 2, 3, 4, 5, 6, 7), AddrTypeTestCase.of(MacAddressType.UNICAST, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0), AddrTypeTestCase.of(MacAddressType.BROADCAST, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff), AddrTypeTestCase.of(MacAddressType.MULTICAST, 1, 2, 3, 4, 5, 6), AddrTypeTestCase.of(MacAddressType.MULTICAST, 11, 22, 33, 44, 55, 66), AddrTypeTestCase.of(MacAddressType.MULTICAST, 33, 33, 0xaa, 0xbb, 0xcc, 0xdd) };
    for (AddrTypeTestCase t : testcases) {
        MacAddressType got = MacAddress.macAddressType(t.addr);
        String msg = String.format("expected type of %s to be %s, but got %s", Arrays.toString(t.addr), t.expected, got);
        assertEquals(msg, t.expected, got);
        if (got != null) {
            assertEquals(got, MacAddress.fromBytes(t.addr).addressType());
        }
    }
}
#method_after
@Test
public void testMacAddrTypes() {
    AddrTypeTestCase[] testcases = { AddrTypeTestCase.of(MacAddress.TYPE_UNKNOWN), AddrTypeTestCase.of(MacAddress.TYPE_UNKNOWN, 0), AddrTypeTestCase.of(MacAddress.TYPE_UNKNOWN, 1, 2, 3, 4, 5), AddrTypeTestCase.of(MacAddress.TYPE_UNKNOWN, 1, 2, 3, 4, 5, 6, 7), AddrTypeTestCase.of(MacAddress.TYPE_UNICAST, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0), AddrTypeTestCase.of(MacAddress.TYPE_BROADCAST, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff), AddrTypeTestCase.of(MacAddress.TYPE_MULTICAST, 1, 2, 3, 4, 5, 6), AddrTypeTestCase.of(MacAddress.TYPE_MULTICAST, 11, 22, 33, 44, 55, 66), AddrTypeTestCase.of(MacAddress.TYPE_MULTICAST, 33, 33, 0xaa, 0xbb, 0xcc, 0xdd) };
    for (AddrTypeTestCase t : testcases) {
        int got = MacAddress.macAddressType(t.addr);
        String msg = String.format("expected type of %s to be %s, but got %s", Arrays.toString(t.addr), t.expectedType, got);
        assertEquals(msg, t.expectedType, got);
        if (got != MacAddress.TYPE_UNKNOWN) {
            assertEquals(got, MacAddress.fromBytes(t.addr).addressType());
        }
    }
}
#end_block

#method_before
@Test
public void testMacAddressConversions() {
    final int iterations = 10000;
    for (int i = 0; i < iterations; i++) {
        MacAddress mac = MacAddress.makeRandomAddress();
        String stringRepr = mac.toString();
        byte[] bytesRepr = mac.toByteArray();
        assertEquals(mac, MacAddress.fromString(stringRepr));
        assertEquals(mac, MacAddress.fromBytes(bytesRepr));
    }
}
#method_after
@Test
public void testMacAddressConversions() {
    final int iterations = 10000;
    for (int i = 0; i < iterations; i++) {
        MacAddress mac = MacAddress.createRandomUnicastAddress();
        String stringRepr = mac.toString();
        byte[] bytesRepr = mac.toByteArray();
        assertEquals(mac, MacAddress.fromString(stringRepr));
        assertEquals(mac, MacAddress.fromBytes(bytesRepr));
    }
}
#end_block

#method_before
@Test
public void testMacAddressRandomGeneration() {
    final int iterations = 1000;
    final String expectedAndroidOui = "da:a1:19";
    for (int i = 0; i < iterations; i++) {
        MacAddress mac = MacAddress.makeRandomAddress();
        String stringRepr = mac.toString();
        assertTrue(stringRepr + " expected to be a locally assigned address", mac.isLocallyAssigned());
        assertTrue(stringRepr + " expected to begin with " + expectedAndroidOui, stringRepr.startsWith(expectedAndroidOui));
    }
    final Random r = new Random();
    final String anotherOui = "24:5f:78";
    final String expectedLocalOui = "26:5f:78";
    final MacAddress base = MacAddress.fromString(anotherOui + ":0:0:0");
    for (int i = 0; i < iterations; i++) {
        MacAddress mac = MacAddress.makeRandomAddress(base, r);
        String stringRepr = mac.toString();
        assertTrue(stringRepr + " expected to be a locally assigned address", mac.isLocallyAssigned());
        assertTrue(stringRepr + " expected to begin with " + expectedLocalOui, stringRepr.startsWith(expectedLocalOui));
    }
}
#method_after
@Test
public void testMacAddressRandomGeneration() {
    final int iterations = 1000;
    final String expectedAndroidOui = "da:a1:19";
    for (int i = 0; i < iterations; i++) {
        MacAddress mac = MacAddress.createRandomUnicastAddress();
        String stringRepr = mac.toString();
        assertTrue(stringRepr + " expected to be a locally assigned address", mac.isLocallyAssigned());
        assertTrue(stringRepr + " expected to begin with " + expectedAndroidOui, stringRepr.startsWith(expectedAndroidOui));
    }
    final Random r = new Random();
    final String anotherOui = "24:5f:78";
    final String expectedLocalOui = "26:5f:78";
    final MacAddress base = MacAddress.fromString(anotherOui + ":0:0:0");
    for (int i = 0; i < iterations; i++) {
        MacAddress mac = MacAddress.createRandomUnicastAddress(base, r);
        String stringRepr = mac.toString();
        assertTrue(stringRepr + " expected to be a locally assigned address", mac.isLocallyAssigned());
        assertEquals(MacAddress.TYPE_UNICAST, mac.addressType());
        assertTrue(stringRepr + " expected to begin with " + expectedLocalOui, stringRepr.startsWith(expectedLocalOui));
    }
}
#end_block

#method_before
@Test
public void testConstructorInputValidation() {
    String[] invalidStringAddresses = { null, "", "abcd", "1:2:3:4:5", "1:2:3:4:5:6:7", "10000:2:3:4:5:6" };
    for (String s : invalidStringAddresses) {
        try {
            MacAddress mac = MacAddress.fromString(s);
            fail("MacAddress.fromString(" + s + ") should have failed, but returned " + mac);
        } catch (IllegalArgumentException excepted) {
        }
    }
    byte[][] invalidBytesAddresses = { null, {}, { 1, 2, 3, 4, 5 }, { 1, 2, 3, 4, 5, 6, 7 } };
    for (byte[] b : invalidBytesAddresses) {
        try {
            MacAddress mac = MacAddress.fromBytes(b);
            fail("MacAddress.fromBytes(" + Arrays.toString(b) + ") should have failed, but returned " + mac);
        } catch (IllegalArgumentException excepted) {
        }
    }
}
#method_after
@Test
public void testConstructorInputValidation() {
    String[] invalidStringAddresses = { "", "abcd", "1:2:3:4:5", "1:2:3:4:5:6:7", "10000:2:3:4:5:6" };
    for (String s : invalidStringAddresses) {
        try {
            MacAddress mac = MacAddress.fromString(s);
            fail("MacAddress.fromString(" + s + ") should have failed, but returned " + mac);
        } catch (IllegalArgumentException excepted) {
        }
    }
    try {
        MacAddress mac = MacAddress.fromString(null);
        fail("MacAddress.fromString(null) should have failed, but returned " + mac);
    } catch (NullPointerException excepted) {
    }
    byte[][] invalidBytesAddresses = { {}, { 1, 2, 3, 4, 5 }, { 1, 2, 3, 4, 5, 6, 7 } };
    for (byte[] b : invalidBytesAddresses) {
        try {
            MacAddress mac = MacAddress.fromBytes(b);
            fail("MacAddress.fromBytes(" + Arrays.toString(b) + ") should have failed, but returned " + mac);
        } catch (IllegalArgumentException excepted) {
        }
    }
    try {
        MacAddress mac = MacAddress.fromBytes(null);
        fail("MacAddress.fromBytes(null) should have failed, but returned " + mac);
    } catch (NullPointerException excepted) {
    }
}
#end_block

#method_before
public MacAddressType addressType() {
    if (equals(BROADCAST_ADDRESS)) {
        return MacAddressType.BROADCAST;
    }
    if (isMulticastAddress()) {
        return MacAddressType.MULTICAST;
    }
    return MacAddressType.UNICAST;
}
#method_after
@MacAddressType
public int addressType() {
    if (equals(BROADCAST_ADDRESS)) {
        return TYPE_BROADCAST;
    }
    if (isMulticastAddress()) {
        return TYPE_MULTICAST;
    }
    return TYPE_UNICAST;
}
#end_block

#method_before
@Override
public String toString() {
    return stringAddrFromByteAddr(byteAddrFromLongAddr(mAddr));
}
#method_after
@Override
public String toString() {
    return stringAddrFromLongAddr(mAddr);
}
#end_block

#method_before
public static MacAddressType macAddressType(byte[] addr) {
    if (!isMacAddress(addr)) {
        return null;
    }
    return MacAddress.fromBytes(addr).addressType();
}
#method_after
public static int macAddressType(byte[] addr) {
    if (!isMacAddress(addr)) {
        return TYPE_UNKNOWN;
    }
    return MacAddress.fromBytes(addr).addressType();
}
#end_block

#method_before
public static byte[] byteAddrFromStringAddr(String addr) {
    if (addr == null) {
        throw new IllegalArgumentException("cannot convert the null String");
    }
    String[] parts = addr.split(":");
    if (parts.length != ETHER_ADDR_LEN) {
        throw new IllegalArgumentException(addr + " was not a valid MAC address");
    }
    byte[] bytes = new byte[ETHER_ADDR_LEN];
    for (int i = 0; i < ETHER_ADDR_LEN; i++) {
        int x = Integer.valueOf(parts[i], 16);
        if (x < 0 || 0xff < x) {
            throw new IllegalArgumentException(addr + "was not a valid MAC address");
        }
        bytes[i] = (byte) x;
    }
    return bytes;
}
#method_after
public static byte[] byteAddrFromStringAddr(String addr) {
    Preconditions.checkNotNull(addr);
    String[] parts = addr.split(":");
    if (parts.length != ETHER_ADDR_LEN) {
        throw new IllegalArgumentException(addr + " was not a valid MAC address");
    }
    byte[] bytes = new byte[ETHER_ADDR_LEN];
    for (int i = 0; i < ETHER_ADDR_LEN; i++) {
        int x = Integer.valueOf(parts[i], 16);
        if (x < 0 || 0xff < x) {
            throw new IllegalArgumentException(addr + "was not a valid MAC address");
        }
        bytes[i] = (byte) x;
    }
    return bytes;
}
#end_block

#method_before
public static String stringAddrFromByteAddr(byte[] addr) {
    if (!isMacAddress(addr)) {
        return null;
    }
    StringJoiner j = new StringJoiner(":");
    for (byte b : addr) {
        j.add(Integer.toHexString(BitUtils.uint8(b)));
    }
    return j.toString();
}
#method_after
public static String stringAddrFromByteAddr(byte[] addr) {
    if (!isMacAddress(addr)) {
        return null;
    }
    return String.format("%02x:%02x:%02x:%02x:%02x:%02x", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
}
#end_block

#method_before
private static long longAddrFromByteAddr(byte[] addr) {
    if (!isMacAddress(addr)) {
        throw new IllegalArgumentException(Arrays.toString(addr) + " was not a valid MAC address");
    }
    long longAddr = 0;
    for (byte b : addr) {
        longAddr = (longAddr << 8) + BitUtils.uint8(b);
    }
    return longAddr;
}
#method_after
private static long longAddrFromByteAddr(byte[] addr) {
    Preconditions.checkNotNull(addr);
    if (!isMacAddress(addr)) {
        throw new IllegalArgumentException(Arrays.toString(addr) + " was not a valid MAC address");
    }
    long longAddr = 0;
    for (byte b : addr) {
        longAddr = (longAddr << 8) + BitUtils.uint8(b);
    }
    return longAddr;
}
#end_block

#method_before
private static long longAddrFromStringAddr(String addr) {
    if (addr == null) {
        throw new IllegalArgumentException("cannot convert the null String");
    }
    String[] parts = addr.split(":");
    if (parts.length != ETHER_ADDR_LEN) {
        throw new IllegalArgumentException(addr + " was not a valid MAC address");
    }
    long longAddr = 0;
    int index = ETHER_ADDR_LEN;
    while (index-- > 0) {
        int x = Integer.valueOf(parts[index], 16);
        if (x < 0 || 0xff < x) {
            throw new IllegalArgumentException(addr + "was not a valid MAC address");
        }
        longAddr = x + (longAddr << 8);
    }
    return longAddr;
}
#method_after
// Internal conversion function equivalent to longAddrFromByteAddr(byteAddrFromStringAddr(addr))
private static long longAddrFromStringAddr(String addr) {
    Preconditions.checkNotNull(addr);
    String[] parts = addr.split(":");
    if (parts.length != ETHER_ADDR_LEN) {
        throw new IllegalArgumentException(addr + " was not a valid MAC address");
    }
    long longAddr = 0;
    int index = ETHER_ADDR_LEN;
    while (index-- > 0) {
        int x = Integer.valueOf(parts[index], 16);
        if (x < 0 || 0xff < x) {
            throw new IllegalArgumentException(addr + "was not a valid MAC address");
        }
        longAddr = x + (longAddr << 8);
    }
    return longAddr;
}
#end_block

#method_before
private static String stringAddrFromLongAddr(long addr) {
    addr = Long.reverseBytes(addr) >> 16;
    StringJoiner j = new StringJoiner(":");
    for (int i = 0; i < ETHER_ADDR_LEN; i++) {
        j.add(Integer.toHexString((byte) addr));
        addr = addr >> 8;
    }
    return j.toString();
}
#method_after
// Internal conversion function equivalent to stringAddrFromByteAddr(byteAddrFromLongAddr(addr))
private static String stringAddrFromLongAddr(long addr) {
    return String.format("%02x:%02x:%02x:%02x:%02x:%02x", (addr >> 40) & 0xff, (addr >> 32) & 0xff, (addr >> 24) & 0xff, (addr >> 16) & 0xff, (addr >> 8) & 0xff, addr & 0xff);
}
#end_block

#method_before
public static MacAddress fromString(String addr) {
    return new MacAddress(longAddrFromByteAddr(byteAddrFromStringAddr(addr)));
}
#method_after
public static MacAddress fromString(String addr) {
    return new MacAddress(longAddrFromStringAddr(addr));
}
#end_block

#method_before
@VisibleForTesting
public static String getStringForCarrierTableCreation(String tableName) {
    return "CREATE TABLE " + tableName + "(_id INTEGER PRIMARY KEY," + NAME + " TEXT DEFAULT ''," + NUMERIC + " TEXT DEFAULT ''," + MCC + " TEXT DEFAULT ''," + MNC + " TEXT DEFAULT ''," + APN + " TEXT DEFAULT ''," + USER + " TEXT DEFAULT ''," + SERVER + " TEXT DEFAULT ''," + PASSWORD + " TEXT DEFAULT ''," + PROXY + " TEXT DEFAULT ''," + PORT + " TEXT DEFAULT ''," + MMSPROXY + " TEXT DEFAULT ''," + MMSPORT + " TEXT DEFAULT ''," + MMSC + " TEXT DEFAULT ''," + AUTH_TYPE + " INTEGER DEFAULT -1," + TYPE + " TEXT DEFAULT ''," + CURRENT + " INTEGER," + PROTOCOL + " TEXT DEFAULT 'IP'," + ROAMING_PROTOCOL + " TEXT DEFAULT 'IP'," + CARRIER_ENABLED + " BOOLEAN DEFAULT 1," + BEARER + " INTEGER DEFAULT 0," + BEARER_BITMASK + " INTEGER DEFAULT 0," + MVNO_TYPE + " TEXT DEFAULT ''," + MVNO_MATCH_DATA + " TEXT DEFAULT ''," + SUBSCRIPTION_ID + " INTEGER DEFAULT " + SubscriptionManager.INVALID_SUBSCRIPTION_ID + "," + PROFILE_ID + " INTEGER DEFAULT 0," + MODEM_COGNITIVE + " BOOLEAN DEFAULT 0," + MAX_CONNS + " INTEGER DEFAULT 0," + WAIT_TIME + " INTEGER DEFAULT 0," + MAX_CONNS_TIME + " INTEGER DEFAULT 0," + MTU + " INTEGER DEFAULT 0," + EDITED + " INTEGER DEFAULT " + UNEDITED + "," + USER_VISIBLE + " BOOLEAN DEFAULT 1," + USER_EDITABLE + " BOOLEAN DEFAULT 1," + OWNED_BY + " INTEGER DEFAULT " + OWNED_BY_OTHERS + "," + // wait_time, max_conns_time, mtu, bearer_bitmask, user_visible.
    "UNIQUE (" + TextUtils.join(", ", CARRIERS_UNIQUE_FIELDS) + "));";
}
#method_after
@VisibleForTesting
public static String getStringForCarrierTableCreation(String tableName) {
    return "CREATE TABLE " + tableName + "(_id INTEGER PRIMARY KEY," + NAME + " TEXT DEFAULT ''," + NUMERIC + " TEXT DEFAULT ''," + MCC + " TEXT DEFAULT ''," + MNC + " TEXT DEFAULT ''," + APN + " TEXT DEFAULT ''," + USER + " TEXT DEFAULT ''," + SERVER + " TEXT DEFAULT ''," + PASSWORD + " TEXT DEFAULT ''," + PROXY + " TEXT DEFAULT ''," + PORT + " TEXT DEFAULT ''," + MMSPROXY + " TEXT DEFAULT ''," + MMSPORT + " TEXT DEFAULT ''," + MMSC + " TEXT DEFAULT ''," + AUTH_TYPE + " INTEGER DEFAULT -1," + TYPE + " TEXT DEFAULT ''," + CURRENT + " INTEGER," + PROTOCOL + " TEXT DEFAULT " + DEFAULT_PROTOCOL + "," + ROAMING_PROTOCOL + " TEXT DEFAULT " + DEFAULT_ROAMING_PROTOCOL + "," + CARRIER_ENABLED + " BOOLEAN DEFAULT 1," + BEARER + " INTEGER DEFAULT 0," + BEARER_BITMASK + " INTEGER DEFAULT 0," + MVNO_TYPE + " TEXT DEFAULT ''," + MVNO_MATCH_DATA + " TEXT DEFAULT ''," + SUBSCRIPTION_ID + " INTEGER DEFAULT " + SubscriptionManager.INVALID_SUBSCRIPTION_ID + "," + PROFILE_ID + " INTEGER DEFAULT 0," + MODEM_COGNITIVE + " BOOLEAN DEFAULT 0," + MAX_CONNS + " INTEGER DEFAULT 0," + WAIT_TIME + " INTEGER DEFAULT 0," + MAX_CONNS_TIME + " INTEGER DEFAULT 0," + MTU + " INTEGER DEFAULT 0," + EDITED + " INTEGER DEFAULT " + UNEDITED + "," + USER_VISIBLE + " BOOLEAN DEFAULT 1," + USER_EDITABLE + " BOOLEAN DEFAULT 1," + OWNED_BY + " INTEGER DEFAULT " + OWNED_BY_OTHERS + "," + // wait_time, max_conns_time, mtu, bearer_bitmask, user_visible.
    "UNIQUE (" + TextUtils.join(", ", CARRIERS_UNIQUE_FIELDS) + "));";
}
#end_block

#method_before
private void deleteRow(SQLiteDatabase db, ContentValues values) {
    if (VDBG)
        log("deleteRow");
    String where = queryValFirst(NUMERIC) + queryVal(MNC) + queryVal(MNC) + queryValOrNull(APN) + queryValOrNull(USER) + queryValOrNull(SERVER) + queryValOrNull(PASSWORD) + queryValOrNull(PROXY) + queryValOrNull(PORT) + queryValOrNull(MMSPROXY) + queryValOrNull(MMSPORT) + queryValOrNull(MMSC) + queryValOrNull(AUTH_TYPE) + queryValOrNull(TYPE) + queryValOrNull(PROTOCOL) + queryValOrNull(ROAMING_PROTOCOL) + queryVal2OrNull(CARRIER_ENABLED) + queryValOrNull(BEARER) + queryValOrNull(MVNO_TYPE) + queryValOrNull(MVNO_MATCH_DATA) + queryValOrNull(PROFILE_ID) + queryVal2OrNull(MODEM_COGNITIVE) + queryValOrNull(MAX_CONNS) + queryValOrNull(WAIT_TIME) + queryValOrNull(MAX_CONNS_TIME) + queryValOrNull(MTU);
    String[] whereArgs = new String[29];
    int i = 0;
    whereArgs[i++] = values.getAsString(NUMERIC);
    whereArgs[i++] = values.getAsString(MCC);
    whereArgs[i++] = values.getAsString(MNC);
    whereArgs[i++] = values.getAsString(NAME);
    whereArgs[i++] = values.containsKey(APN) ? values.getAsString(APN) : "";
    whereArgs[i++] = values.containsKey(USER) ? values.getAsString(USER) : "";
    whereArgs[i++] = values.containsKey(SERVER) ? values.getAsString(SERVER) : "";
    whereArgs[i++] = values.containsKey(PASSWORD) ? values.getAsString(PASSWORD) : "";
    whereArgs[i++] = values.containsKey(PROXY) ? values.getAsString(PROXY) : "";
    whereArgs[i++] = values.containsKey(PORT) ? values.getAsString(PORT) : "";
    whereArgs[i++] = values.containsKey(MMSPROXY) ? values.getAsString(MMSPROXY) : "";
    whereArgs[i++] = values.containsKey(MMSPORT) ? values.getAsString(MMSPORT) : "";
    whereArgs[i++] = values.containsKey(MMSC) ? values.getAsString(MMSC) : "";
    whereArgs[i++] = values.containsKey(AUTH_TYPE) ? values.getAsString(AUTH_TYPE) : "-1";
    whereArgs[i++] = values.containsKey(TYPE) ? values.getAsString(TYPE) : "";
    whereArgs[i++] = values.containsKey(PROTOCOL) ? values.getAsString(PROTOCOL) : "IP";
    whereArgs[i++] = values.containsKey(ROAMING_PROTOCOL) ? values.getAsString(ROAMING_PROTOCOL) : "IP";
    if (values.containsKey(CARRIER_ENABLED) && (values.getAsString(CARRIER_ENABLED).equalsIgnoreCase("false") || values.getAsString(CARRIER_ENABLED).equals("0"))) {
        whereArgs[i++] = "false";
        whereArgs[i++] = "0";
    } else {
        whereArgs[i++] = "true";
        whereArgs[i++] = "1";
    }
    whereArgs[i++] = values.containsKey(BEARER) ? values.getAsString(BEARER) : "0";
    whereArgs[i++] = values.containsKey(MVNO_TYPE) ? values.getAsString(MVNO_TYPE) : "";
    whereArgs[i++] = values.containsKey(MVNO_MATCH_DATA) ? values.getAsString(MVNO_MATCH_DATA) : "";
    whereArgs[i++] = values.containsKey(PROFILE_ID) ? values.getAsString(PROFILE_ID) : "0";
    if (values.containsKey(MODEM_COGNITIVE) && (values.getAsString(MODEM_COGNITIVE).equalsIgnoreCase("true") || values.getAsString(MODEM_COGNITIVE).equals("1"))) {
        whereArgs[i++] = "true";
        whereArgs[i++] = "1";
    } else {
        whereArgs[i++] = "false";
        whereArgs[i++] = "0";
    }
    whereArgs[i++] = values.containsKey(MAX_CONNS) ? values.getAsString(MAX_CONNS) : "0";
    whereArgs[i++] = values.containsKey(WAIT_TIME) ? values.getAsString(WAIT_TIME) : "0";
    whereArgs[i++] = values.containsKey(MAX_CONNS_TIME) ? values.getAsString(MAX_CONNS_TIME) : "0";
    whereArgs[i++] = values.containsKey(MTU) ? values.getAsString(MTU) : "0";
    if (VDBG) {
        log("deleteRow: where: " + where);
        StringBuilder builder = new StringBuilder();
        for (String s : whereArgs) {
            builder.append(s + ", ");
        }
        log("deleteRow: whereArgs: " + builder.toString());
    }
    db.delete(CARRIERS_TABLE, where, whereArgs);
}
#method_after
private void deleteRow(SQLiteDatabase db, ContentValues values) {
    if (VDBG)
        log("deleteRow");
    String where = queryValFirst(NUMERIC) + queryVal(MNC) + queryVal(MNC) + queryValOrNull(APN) + queryValOrNull(USER) + queryValOrNull(SERVER) + queryValOrNull(PASSWORD) + queryValOrNull(PROXY) + queryValOrNull(PORT) + queryValOrNull(MMSPROXY) + queryValOrNull(MMSPORT) + queryValOrNull(MMSC) + queryValOrNull(AUTH_TYPE) + queryValOrNull(TYPE) + queryValOrNull(PROTOCOL) + queryValOrNull(ROAMING_PROTOCOL) + queryVal2OrNull(CARRIER_ENABLED) + queryValOrNull(BEARER) + queryValOrNull(MVNO_TYPE) + queryValOrNull(MVNO_MATCH_DATA) + queryValOrNull(PROFILE_ID) + queryVal2OrNull(MODEM_COGNITIVE) + queryValOrNull(MAX_CONNS) + queryValOrNull(WAIT_TIME) + queryValOrNull(MAX_CONNS_TIME) + queryValOrNull(MTU);
    String[] whereArgs = new String[29];
    int i = 0;
    whereArgs[i++] = values.getAsString(NUMERIC);
    whereArgs[i++] = values.getAsString(MCC);
    whereArgs[i++] = values.getAsString(MNC);
    whereArgs[i++] = values.getAsString(NAME);
    whereArgs[i++] = values.containsKey(APN) ? values.getAsString(APN) : "";
    whereArgs[i++] = values.containsKey(USER) ? values.getAsString(USER) : "";
    whereArgs[i++] = values.containsKey(SERVER) ? values.getAsString(SERVER) : "";
    whereArgs[i++] = values.containsKey(PASSWORD) ? values.getAsString(PASSWORD) : "";
    whereArgs[i++] = values.containsKey(PROXY) ? values.getAsString(PROXY) : "";
    whereArgs[i++] = values.containsKey(PORT) ? values.getAsString(PORT) : "";
    whereArgs[i++] = values.containsKey(MMSPROXY) ? values.getAsString(MMSPROXY) : "";
    whereArgs[i++] = values.containsKey(MMSPORT) ? values.getAsString(MMSPORT) : "";
    whereArgs[i++] = values.containsKey(MMSC) ? values.getAsString(MMSC) : "";
    whereArgs[i++] = values.containsKey(AUTH_TYPE) ? values.getAsString(AUTH_TYPE) : "-1";
    whereArgs[i++] = values.containsKey(TYPE) ? values.getAsString(TYPE) : "";
    whereArgs[i++] = values.containsKey(PROTOCOL) ? values.getAsString(PROTOCOL) : DEFAULT_PROTOCOL;
    whereArgs[i++] = values.containsKey(ROAMING_PROTOCOL) ? values.getAsString(ROAMING_PROTOCOL) : DEFAULT_ROAMING_PROTOCOL;
    if (values.containsKey(CARRIER_ENABLED) && (values.getAsString(CARRIER_ENABLED).equalsIgnoreCase("false") || values.getAsString(CARRIER_ENABLED).equals("0"))) {
        whereArgs[i++] = "false";
        whereArgs[i++] = "0";
    } else {
        whereArgs[i++] = "true";
        whereArgs[i++] = "1";
    }
    whereArgs[i++] = values.containsKey(BEARER) ? values.getAsString(BEARER) : "0";
    whereArgs[i++] = values.containsKey(MVNO_TYPE) ? values.getAsString(MVNO_TYPE) : "";
    whereArgs[i++] = values.containsKey(MVNO_MATCH_DATA) ? values.getAsString(MVNO_MATCH_DATA) : "";
    whereArgs[i++] = values.containsKey(PROFILE_ID) ? values.getAsString(PROFILE_ID) : "0";
    if (values.containsKey(MODEM_COGNITIVE) && (values.getAsString(MODEM_COGNITIVE).equalsIgnoreCase("true") || values.getAsString(MODEM_COGNITIVE).equals("1"))) {
        whereArgs[i++] = "true";
        whereArgs[i++] = "1";
    } else {
        whereArgs[i++] = "false";
        whereArgs[i++] = "0";
    }
    whereArgs[i++] = values.containsKey(MAX_CONNS) ? values.getAsString(MAX_CONNS) : "0";
    whereArgs[i++] = values.containsKey(WAIT_TIME) ? values.getAsString(WAIT_TIME) : "0";
    whereArgs[i++] = values.containsKey(MAX_CONNS_TIME) ? values.getAsString(MAX_CONNS_TIME) : "0";
    whereArgs[i++] = values.containsKey(MTU) ? values.getAsString(MTU) : "0";
    if (VDBG) {
        log("deleteRow: where: " + where);
        StringBuilder builder = new StringBuilder();
        for (String s : whereArgs) {
            builder.append(s + ", ");
        }
        log("deleteRow: whereArgs: " + builder.toString());
    }
    db.delete(CARRIERS_TABLE, where, whereArgs);
}
#end_block

#method_before
public static Cursor selectConflictingRow(SQLiteDatabase db, String table, ContentValues row) {
    // are set in the new row
    if (!row.containsKey(NUMERIC) || !row.containsKey(MCC) || !row.containsKey(MNC)) {
        loge("dbh.selectConflictingRow: called for non-conflicting row: " + row);
        return null;
    }
    String[] columns = { "_id", TYPE, EDITED, BEARER_BITMASK, PROFILE_ID };
    String selection = TextUtils.join("=? AND ", CARRIERS_UNIQUE_FIELDS) + "=?";
    int i = 0;
    String[] selectionArgs = new String[18];
    selectionArgs[i++] = row.getAsString(NUMERIC);
    selectionArgs[i++] = row.getAsString(MCC);
    selectionArgs[i++] = row.getAsString(MNC);
    selectionArgs[i++] = row.containsKey(APN) ? row.getAsString(APN) : "";
    selectionArgs[i++] = row.containsKey(PROXY) ? row.getAsString(PROXY) : "";
    selectionArgs[i++] = row.containsKey(PORT) ? row.getAsString(PORT) : "";
    selectionArgs[i++] = row.containsKey(MMSPROXY) ? row.getAsString(MMSPROXY) : "";
    selectionArgs[i++] = row.containsKey(MMSPORT) ? row.getAsString(MMSPORT) : "";
    selectionArgs[i++] = row.containsKey(MMSC) ? row.getAsString(MMSC) : "";
    selectionArgs[i++] = row.containsKey(CARRIER_ENABLED) && (row.getAsString(CARRIER_ENABLED).equals("0") || row.getAsString(CARRIER_ENABLED).equals("false")) ? "0" : "1";
    selectionArgs[i++] = row.containsKey(BEARER) ? row.getAsString(BEARER) : "0";
    selectionArgs[i++] = row.containsKey(MVNO_TYPE) ? row.getAsString(MVNO_TYPE) : "";
    selectionArgs[i++] = row.containsKey(MVNO_MATCH_DATA) ? row.getAsString(MVNO_MATCH_DATA) : "";
    selectionArgs[i++] = row.containsKey(PROFILE_ID) ? row.getAsString(PROFILE_ID) : "0";
    selectionArgs[i++] = row.containsKey(PROTOCOL) ? row.getAsString(PROTOCOL) : "IP";
    selectionArgs[i++] = row.containsKey(ROAMING_PROTOCOL) ? row.getAsString(ROAMING_PROTOCOL) : "IP";
    selectionArgs[i++] = row.containsKey(USER_EDITABLE) ? row.getAsString(USER_EDITABLE) : "1";
    selectionArgs[i++] = row.containsKey(OWNED_BY) ? row.getAsString(OWNED_BY) : Integer.toString(OWNED_BY_OTHERS);
    Cursor c = db.query(table, columns, selection, selectionArgs, null, null, null);
    if (c != null) {
        if (c.getCount() == 1) {
            if (VDBG)
                log("dbh.selectConflictingRow: " + c.getCount() + " conflicting " + "row found");
            if (c.moveToFirst()) {
                return c;
            } else {
                loge("dbh.selectConflictingRow: moveToFirst() failed");
            }
        } else {
            loge("dbh.selectConflictingRow: Expected 1 but found " + c.getCount() + " matching rows found for cv " + row);
        }
        c.close();
    } else {
        loge("dbh.selectConflictingRow: Error - c is null; no matching row found for " + "cv " + row);
    }
    return null;
}
#method_after
public static Cursor selectConflictingRow(SQLiteDatabase db, String table, ContentValues row) {
    // are set in the new row
    if (!row.containsKey(NUMERIC) || !row.containsKey(MCC) || !row.containsKey(MNC)) {
        loge("dbh.selectConflictingRow: called for non-conflicting row: " + row);
        return null;
    }
    String[] columns = { "_id", TYPE, EDITED, BEARER_BITMASK, PROFILE_ID };
    String selection = TextUtils.join("=? AND ", CARRIERS_UNIQUE_FIELDS) + "=?";
    int i = 0;
    String[] selectionArgs = new String[CARRIERS_UNIQUE_FIELDS.size()];
    for (String field : CARRIERS_UNIQUE_FIELDS) {
        if (CARRIER_ENABLED.equals(field)) {
            // for CARRIER_ENABLED we overwrite the value "false" with "0"
            selectionArgs[i++] = row.containsKey(CARRIER_ENABLED) && (row.getAsString(CARRIER_ENABLED).equals("0") || row.getAsString(CARRIER_ENABLED).equals("false")) ? "0" : CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(CARRIER_ENABLED);
        } else {
            selectionArgs[i++] = row.containsKey(field) ? row.getAsString(field) : CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(field);
        }
    }
    Cursor c = db.query(table, columns, selection, selectionArgs, null, null, null);
    if (c != null) {
        if (c.getCount() == 1) {
            if (VDBG)
                log("dbh.selectConflictingRow: " + c.getCount() + " conflicting " + "row found");
            if (c.moveToFirst()) {
                return c;
            } else {
                loge("dbh.selectConflictingRow: moveToFirst() failed");
            }
        } else {
            loge("dbh.selectConflictingRow: Expected 1 but found " + c.getCount() + " matching rows found for cv " + row);
        }
        c.close();
    } else {
        loge("dbh.selectConflictingRow: Error - c is null; no matching row found for " + "cv " + row);
    }
    return null;
}
#end_block

#method_before
@Override
public boolean onCreate() {
    mOpenHelper = new DatabaseHelper(getContext());
    if (!apnSourceServiceExists(getContext())) {
        // Call getReadableDatabase() to make sure onUpgrade is called
        if (VDBG)
            log("onCreate: calling getReadableDatabase to trigger onUpgrade");
        SQLiteDatabase db = getReadableDatabase();
        // Update APN db on build update
        String newBuildId = SystemProperties.get("ro.build.id", null);
        if (!TextUtils.isEmpty(newBuildId)) {
            // Check if build id has changed
            SharedPreferences sp = getContext().getSharedPreferences(BUILD_ID_FILE, Context.MODE_PRIVATE);
            String oldBuildId = sp.getString(RO_BUILD_ID, "");
            if (!newBuildId.equals(oldBuildId)) {
                if (DBG)
                    log("onCreate: build id changed from " + oldBuildId + " to " + newBuildId);
                // Get rid of old preferred apn shared preferences
                SubscriptionManager sm = SubscriptionManager.from(getContext());
                if (sm != null) {
                    List<SubscriptionInfo> subInfoList = sm.getAllSubscriptionInfoList();
                    for (SubscriptionInfo subInfo : subInfoList) {
                        SharedPreferences spPrefFile = getContext().getSharedPreferences(PREF_FILE_APN + subInfo.getSubscriptionId(), Context.MODE_PRIVATE);
                        if (spPrefFile != null) {
                            SharedPreferences.Editor editor = spPrefFile.edit();
                            editor.clear();
                            editor.apply();
                        }
                    }
                }
                // Update APN DB
                updateApnDb();
            } else {
                if (VDBG)
                    log("onCreate: build id did not change: " + oldBuildId);
            }
            sp.edit().putString(RO_BUILD_ID, newBuildId).apply();
        } else {
            if (VDBG)
                log("onCreate: newBuildId is empty");
        }
    }
    if (VDBG)
        log("onCreate:- ret true");
    return true;
}
#method_after
@Override
public boolean onCreate() {
    mOpenHelper = new DatabaseHelper(getContext());
    if (!apnSourceServiceExists(getContext())) {
        // Call getReadableDatabase() to make sure onUpgrade is called
        if (VDBG)
            log("onCreate: calling getReadableDatabase to trigger onUpgrade");
        SQLiteDatabase db = getReadableDatabase();
        // Update APN db on build update
        String newBuildId = SystemProperties.get("ro.build.id", null);
        if (!TextUtils.isEmpty(newBuildId)) {
            // Check if build id has changed
            SharedPreferences sp = getContext().getSharedPreferences(BUILD_ID_FILE, Context.MODE_PRIVATE);
            String oldBuildId = sp.getString(RO_BUILD_ID, "");
            if (!newBuildId.equals(oldBuildId)) {
                if (DBG)
                    log("onCreate: build id changed from " + oldBuildId + " to " + newBuildId);
                // Get rid of old preferred apn shared preferences
                SubscriptionManager sm = SubscriptionManager.from(getContext());
                if (sm != null) {
                    List<SubscriptionInfo> subInfoList = sm.getAllSubscriptionInfoList();
                    for (SubscriptionInfo subInfo : subInfoList) {
                        SharedPreferences spPrefFile = getContext().getSharedPreferences(PREF_FILE_APN + subInfo.getSubscriptionId(), Context.MODE_PRIVATE);
                        if (spPrefFile != null) {
                            SharedPreferences.Editor editor = spPrefFile.edit();
                            editor.clear();
                            editor.apply();
                        }
                    }
                }
                // Update APN DB
                updateApnDb();
            } else {
                if (VDBG)
                    log("onCreate: build id did not change: " + oldBuildId);
            }
            sp.edit().putString(RO_BUILD_ID, newBuildId).apply();
        } else {
            if (VDBG)
                log("onCreate: newBuildId is empty");
        }
    }
    SharedPreferences sp = getContext().getSharedPreferences(ENFORCED_FILE, Context.MODE_PRIVATE);
    mManagedApnEnforced = sp.getBoolean(ENFORCED_KEY, false);
    if (VDBG)
        log("onCreate:- ret true");
    return true;
}
#end_block

#method_before
boolean isCallingFromSystemUid() {
    return UserHandle.getAppId(Binder.getCallingUid()) == Process.SYSTEM_UID;
}
#method_after
boolean isCallingFromSystemUid() {
    return mInjector.binderGetCallingUid() == Process.SYSTEM_UID;
}
#end_block

#method_before
// bool isCallingFromSystemServerProcess() {
// }
@Override
public synchronized Cursor query(Uri url, String[] projectionIn, String selection, String[] selectionArgs, String sort) {
    if (VDBG)
        log("query: url=" + url + ", projectionIn=" + projectionIn + ", selection=" + selection + "selectionArgs=" + selectionArgs + ", sort=" + sort);
    TelephonyManager mTelephonyManager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    String subIdString;
    SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
    // a little protection from injection attacks
    qb.setStrict(true);
    qb.setTables(CARRIERS_TABLE);
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                qb.appendWhere(NUMERIC + " = '" + mTelephonyManager.getSimOperator(subId) + "'");
            // FIXME alter the selection to pass subId
            // selection = selection + "and subId = "
            }
        // do nothing
        case URL_TELEPHONY:
            {
                qb.appendWhere(NOT_OWNED_BY_DPC);
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME alter the selection to pass subId
            // selection = selection + "and subId = "
            }
        // intentional fall through from above case
        case URL_CURRENT:
            {
                qb.appendWhere("current IS NOT NULL");
                qb.appendWhere(NOT_OWNED_BY_DPC);
                // selection = null;
                break;
            }
        case URL_ID:
            {
                qb.appendWhere("_id = " + url.getPathSegments().get(1));
                qb.appendWhere(NOT_OWNED_BY_DPC);
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        // intentional fall through from above case
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                qb.appendWhere("_id = " + getPreferredApnId(subId, true));
                break;
            }
        case URL_DPC:
            {
                // Only allowed to be called from system server process.
                // TO be fixed.
                // DPC query only returns DPC records.
                qb.appendWhere(IS_OWNED_BY_DPC);
                break;
            }
        case URL_ALL:
            {
                // Only allowed to be called from SYSTEM_UID.
                if (!isCallingFromSystemUid()) {
                    Log.d("TelephonyProvider", "URL_ALL called from non SYSTEM_UID.");
                    return null;
                }
                // ALL query returns all records.
                break;
            }
        case URL_PRIORITIZED:
            {
                // Only allowed to be called from system server process.
                // TO be fixed.
                // PRIORITIZED query tries to find if there is matching DPC records first.
                SQLiteDatabase db = getReadableDatabase();
                Cursor ret = qb.query(db, projectionIn, selection + " and " + IS_OWNED_BY_DPC, selectionArgs, null, null, sort);
                if (ret != null && ret.getCount() > 0) {
                    // Matching DPC records found, should return DPC records only.
                    qb.appendWhere(IS_OWNED_BY_DPC);
                }
                // Else fall back to non-dpm records.
                break;
            }
        case URL_SIMINFO:
            {
                qb.setTables(SIMINFO_TABLE);
                break;
            }
        default:
            {
                return null;
            }
    }
    if (match != URL_SIMINFO) {
        if (projectionIn != null) {
            for (String column : projectionIn) {
                if (TYPE.equals(column) || MMSC.equals(column) || MMSPROXY.equals(column) || MMSPORT.equals(column) || APN.equals(column)) {
                // noop
                } else {
                    checkPermission();
                    break;
                }
            }
        } else {
            // null returns all columns, so need permission check
            checkPermission();
        }
    }
    SQLiteDatabase db = getReadableDatabase();
    Cursor ret = null;
    try {
        // Exclude entries marked deleted
        if (CARRIERS_TABLE.equals(qb.getTables())) {
            if (TextUtils.isEmpty(selection)) {
                selection = "";
            } else {
                selection += " and ";
            }
            selection += IS_NOT_USER_DELETED + " and " + IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + " and " + IS_NOT_CARRIER_DELETED + " and " + IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML;
            if (VDBG)
                log("query: selection modified to " + selection);
        }
        ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);
    } catch (SQLException e) {
        loge("got exception when querying: " + e);
    }
    if (ret != null)
        ret.setNotificationUri(getContext().getContentResolver(), url);
    return ret;
}
#method_after
@Override
public synchronized Cursor query(Uri url, String[] projectionIn, String selection, String[] selectionArgs, String sort) {
    if (VDBG)
        log("query: url=" + url + ", projectionIn=" + projectionIn + ", selection=" + selection + "selectionArgs=" + selectionArgs + ", sort=" + sort);
    TelephonyManager mTelephonyManager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    String subIdString;
    SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
    // a little protection from injection attacks
    qb.setStrict(true);
    qb.setTables(CARRIERS_TABLE);
    List<String> constraints = new ArrayList<String>();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(NUMERIC + " = '" + mTelephonyManager.getSimOperator(subId) + "'");
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_TELEPHONY:
            {
                constraints.add(IS_NOT_OWNED_BY_DPC);
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_CURRENT:
            {
                constraints.add("current IS NOT NULL");
                constraints.add(IS_NOT_OWNED_BY_DPC);
                // selection = null;
                break;
            }
        case URL_ID:
            {
                constraints.add("_id = " + url.getPathSegments().get(1));
                constraints.add(IS_NOT_OWNED_BY_DPC);
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                constraints.add("_id = " + getPreferredApnId(subId, true));
                break;
            }
        case URL_DPC:
            {
                ensureCallingFromSystemUid("URL_DPC called from non SYSTEM_UID.");
                // DPC query only returns DPC records.
                constraints.add(IS_OWNED_BY_DPC);
                break;
            }
        case URL_FILTERED:
            {
                if (isManagedApnEnforced()) {
                    // If enforced, return DPC records only.
                    constraints.add(IS_OWNED_BY_DPC);
                } else {
                    // Otherwise return non-DPC records only.
                    constraints.add(IS_NOT_OWNED_BY_DPC);
                }
                break;
            }
        case URL_ENFORCE_MANAGED:
            {
                ensureCallingFromSystemUid("URL_ENFORCE_MANAGED called from non SYSTEM_UID.");
                MatrixCursor cursor = new MatrixCursor(new String[] { ENFORCED_KEY });
                cursor.addRow(new Object[] { isManagedApnEnforced() ? 1 : 0 });
                return cursor;
            }
        case URL_SIMINFO:
            {
                qb.setTables(SIMINFO_TABLE);
                break;
            }
        default:
            {
                return null;
            }
    }
    // appendWhere doesn't add ANDs so we do it ourselves
    if (constraints.size() > 0) {
        qb.appendWhere(TextUtils.join(" AND ", constraints));
    }
    if (match != URL_SIMINFO) {
        if (projectionIn != null) {
            for (String column : projectionIn) {
                if (TYPE.equals(column) || MMSC.equals(column) || MMSPROXY.equals(column) || MMSPORT.equals(column) || APN.equals(column)) {
                // noop
                } else {
                    checkPermission();
                    break;
                }
            }
        } else {
            // null returns all columns, so need permission check
            checkPermission();
        }
    }
    SQLiteDatabase db = getReadableDatabase();
    Cursor ret = null;
    try {
        // Exclude entries marked deleted
        if (CARRIERS_TABLE.equals(qb.getTables())) {
            if (TextUtils.isEmpty(selection)) {
                selection = "";
            } else {
                selection += " and ";
            }
            selection += IS_NOT_USER_DELETED + " and " + IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + " and " + IS_NOT_CARRIER_DELETED + " and " + IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML;
            if (VDBG)
                log("query: selection modified to " + selection);
        }
        ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);
    } catch (SQLException e) {
        loge("got exception when querying: " + e);
    }
    if (ret != null)
        ret.setNotificationUri(getContext().getContentResolver(), url);
    return ret;
}
#end_block

#method_before
private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {
    Uri result = null;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    checkPermission();
    boolean notify = false;
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_TELEPHONY:
            {
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                values = DatabaseHelper.setDefaultValue(values);
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, USER_EDITED);
                }
                // Owned_by should be others if inserted via general uri.
                if (!values.containsKey(OWNED_BY)) {
                    values.put(OWNED_BY, OWNED_BY_OTHERS);
                }
                try {
                    // Replace on conflict so that if same APN is present in db with edited
                    // as UNEDITED or USER/CARRIER_DELETED, it is replaced with
                    // edited USER/CARRIER_EDITED
                    long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values, SQLiteDatabase.CONFLICT_REPLACE);
                    if (rowID >= 0) {
                        result = ContentUris.withAppendedId(CONTENT_URI, rowID);
                        notify = true;
                    }
                    if (VDBG)
                        log("insert: inserted " + values.toString() + " rowID = " + rowID);
                } catch (SQLException e) {
                    log("insert: exception " + e);
                    // Insertion failed which could be due to a conflict. Check if that is the case
                    // and merge the entries
                    Cursor oldRow = DatabaseHelper.selectConflictingRow(db, CARRIERS_TABLE, values);
                    if (oldRow != null) {
                        ContentValues mergedValues = new ContentValues();
                        DatabaseHelper.mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values, mergedValues, false, getContext());
                        oldRow.close();
                        notify = true;
                    }
                }
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_CURRENT:
            {
                // zero out the previous operator
                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + "!=0", null);
                String numeric = initialValues.getAsString(NUMERIC);
                int updated = db.update(CARRIERS_TABLE, s_currentSetMap, NUMERIC + " = '" + numeric + "'", null);
                if (updated > 0) {
                    if (VDBG)
                        log("Setting numeric '" + numeric + "' to be the current operator");
                } else {
                    loge("Failed setting numeric '" + numeric + "' to the current operator");
                }
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                if (initialValues != null) {
                    if (initialValues.containsKey(COLUMN_APN_ID)) {
                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);
                    }
                }
                break;
            }
        case URL_DPC:
            {
                // TO be fixed.
                if (!isCallingFromSystemUid()) {
                    return Pair.create(result, notify);
                }
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                values = DatabaseHelper.setDefaultValue(values);
                // OWNED_BY should be DPC is inserted via URL_DPC.
                values.put(OWNED_BY, OWNED_BY_DPC);
                try {
                    // Replace on conflict.
                    long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values, SQLiteDatabase.CONFLICT_REPLACE);
                    if (rowID >= 0) {
                        result = ContentUris.withAppendedId(CONTENT_URI, rowID);
                        notify = true;
                    }
                    if (VDBG)
                        log("insert: inserted " + values.toString() + " rowID = " + rowID);
                } catch (SQLException e) {
                    log("insert: exception " + e);
                }
                break;
            }
        case URL_SIMINFO:
            {
                long id = db.insert(SIMINFO_TABLE, null, initialValues);
                result = ContentUris.withAppendedId(SubscriptionManager.CONTENT_URI, id);
                break;
            }
    }
    return Pair.create(result, notify);
}
#method_after
private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {
    Uri result = null;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    checkPermission();
    boolean notify = false;
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_TELEPHONY:
            {
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                values.put(SUBSCRIPTION_ID, subId);
                values = DatabaseHelper.setDefaultValue(values);
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, USER_EDITED);
                }
                // Owned_by should be others if inserted via general uri.
                values.put(OWNED_BY, OWNED_BY_OTHERS);
                Pair<Uri, Boolean> ret = insertRowWithValue(values);
                result = ret.first;
                notify = ret.second;
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_CURRENT:
            {
                // zero out the previous operator
                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + "!=0", null);
                String numeric = initialValues.getAsString(NUMERIC);
                int updated = db.update(CARRIERS_TABLE, s_currentSetMap, NUMERIC + " = '" + numeric + "'", null);
                if (updated > 0) {
                    if (VDBG)
                        log("Setting numeric '" + numeric + "' to be the current operator");
                } else {
                    loge("Failed setting numeric '" + numeric + "' to the current operator");
                }
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return Pair.create(result, notify);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                if (initialValues != null) {
                    if (initialValues.containsKey(COLUMN_APN_ID)) {
                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);
                    }
                }
                break;
            }
        case URL_DPC:
            {
                ensureCallingFromSystemUid("URL_DPC called from non SYSTEM_UID.");
                ContentValues values;
                if (initialValues != null) {
                    values = new ContentValues(initialValues);
                } else {
                    values = new ContentValues();
                }
                // Owned_by should be DPC if inserted via URL_DPC.
                values.put(OWNED_BY, OWNED_BY_DPC);
                // DPC records should not be user editable.
                values.put(USER_EDITABLE, false);
                Pair<Uri, Boolean> ret = insertRowWithValue(values);
                result = ret.first;
                notify = ret.second;
                break;
            }
        case URL_SIMINFO:
            {
                long id = db.insert(SIMINFO_TABLE, null, initialValues);
                result = ContentUris.withAppendedId(SubscriptionManager.CONTENT_URI, id);
                break;
            }
    }
    return Pair.create(result, notify);
}
#end_block

#method_before
@Override
public synchronized int delete(Uri url, String where, String[] whereArgs) {
    int count = 0;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    String userOrCarrierEdited = ") and (" + IS_USER_EDITED + " or " + IS_CARRIER_EDITED + ")";
    String notUserOrCarrierEdited = ") and (" + IS_NOT_USER_EDITED + " and " + IS_NOT_CARRIER_EDITED + ")";
    String unedited = ") and " + IS_UNEDITED;
    ContentValues cv = new ContentValues();
    cv.put(EDITED, USER_DELETED);
    checkPermission();
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_DELETE:
            {
                // Delete preferred APN for all subIds
                deletePreferredApnId();
                // Delete unedited entries
                count = db.delete(CARRIERS_TABLE, "(" + where + unedited + " and " + NOT_OWNED_BY_DPC, whereArgs);
                break;
            }
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in query
            }
        case URL_TELEPHONY:
            {
                // Delete user/carrier edited entries
                count = db.delete(CARRIERS_TABLE, "(" + where + userOrCarrierEdited + " and " + NOT_OWNED_BY_DPC, whereArgs);
                // Otherwise mark as user deleted instead of deleting
                count += db.update(CARRIERS_TABLE, cv, "(" + where + notUserOrCarrierEdited + " and " + NOT_OWNED_BY_DPC, whereArgs);
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in query
            }
        case URL_CURRENT:
            {
                // Delete user/carrier edited entries
                count = db.delete(CARRIERS_TABLE, "(" + where + userOrCarrierEdited + " and " + NOT_OWNED_BY_DPC, whereArgs);
                // Otherwise mark as user deleted instead of deleting
                count += db.update(CARRIERS_TABLE, cv, "(" + where + notUserOrCarrierEdited + " and " + NOT_OWNED_BY_DPC, whereArgs);
                break;
            }
        case URL_ID:
            {
                // Delete user/carrier edited entries
                count = db.delete(CARRIERS_TABLE, "(" + _ID + "=?" + userOrCarrierEdited + " and " + NOT_OWNED_BY_DPC, new String[] { url.getLastPathSegment() });
                // Otherwise mark as user deleted instead of deleting
                count += db.update(CARRIERS_TABLE, cv, "(" + _ID + "=?" + notUserOrCarrierEdited + " and " + NOT_OWNED_BY_DPC, new String[] { url.getLastPathSegment() });
                break;
            }
        case URL_RESTOREAPN_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in query
            }
        case URL_RESTOREAPN:
            {
                count = 1;
                restoreDefaultAPN(subId);
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                setPreferredApnId((long) INVALID_APN_ID, subId, true);
                if ((match == URL_PREFERAPN) || (match == URL_PREFERAPN_USING_SUBID))
                    count = 1;
                break;
            }
        case URL_DPC:
            {
                // TO be fixed.
                if (!isCallingFromSystemUid()) {
                    break;
                }
                // Only delete entries that owned by DPC.
                count = db.delete(CARRIERS_TABLE, "(" + where + ")" + " and " + IS_OWNED_BY_DPC, whereArgs);
                break;
            }
        case URL_SIMINFO:
            {
                count = db.delete(SIMINFO_TABLE, where, whereArgs);
                break;
            }
        case URL_UPDATE_DB:
            {
                updateApnDb();
                count = 1;
                break;
            }
        default:
            {
                throw new UnsupportedOperationException("Cannot delete that URL: " + url);
            }
    }
    if (count > 0) {
        getContext().getContentResolver().notifyChange(CONTENT_URI, null, true, UserHandle.USER_ALL);
    }
    return count;
}
#method_after
@Override
public synchronized int delete(Uri url, String where, String[] whereArgs) {
    int count = 0;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    String userOrCarrierEdited = ") and (" + IS_USER_EDITED + " or " + IS_CARRIER_EDITED + ")";
    String notUserOrCarrierEdited = ") and (" + IS_NOT_USER_EDITED + " and " + IS_NOT_CARRIER_EDITED + ")";
    String unedited = ") and " + IS_UNEDITED;
    ContentValues cv = new ContentValues();
    cv.put(EDITED, USER_DELETED);
    checkPermission();
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_DELETE:
            {
                // Delete preferred APN for all subIds
                deletePreferredApnId();
                // Delete unedited entries
                count = db.delete(CARRIERS_TABLE, "(" + where + unedited + " and " + IS_NOT_OWNED_BY_DPC, whereArgs);
                break;
            }
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in query
            }
        case URL_TELEPHONY:
            {
                // Delete user/carrier edited entries
                count = db.delete(CARRIERS_TABLE, "(" + where + userOrCarrierEdited + " and " + IS_NOT_OWNED_BY_DPC, whereArgs);
                // Otherwise mark as user deleted instead of deleting
                count += db.update(CARRIERS_TABLE, cv, "(" + where + notUserOrCarrierEdited + " and " + IS_NOT_OWNED_BY_DPC, whereArgs);
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in query
            }
        case URL_CURRENT:
            {
                // Delete user/carrier edited entries
                count = db.delete(CARRIERS_TABLE, "(" + where + userOrCarrierEdited + " and " + IS_NOT_OWNED_BY_DPC, whereArgs);
                // Otherwise mark as user deleted instead of deleting
                count += db.update(CARRIERS_TABLE, cv, "(" + where + notUserOrCarrierEdited + " and " + IS_NOT_OWNED_BY_DPC, whereArgs);
                break;
            }
        case URL_ID:
            {
                // Delete user/carrier edited entries
                count = db.delete(CARRIERS_TABLE, "(" + _ID + "=?" + userOrCarrierEdited + " and " + IS_NOT_OWNED_BY_DPC, new String[] { url.getLastPathSegment() });
                // Otherwise mark as user deleted instead of deleting
                count += db.update(CARRIERS_TABLE, cv, "(" + _ID + "=?" + notUserOrCarrierEdited + " and " + IS_NOT_OWNED_BY_DPC, new String[] { url.getLastPathSegment() });
                break;
            }
        case URL_RESTOREAPN_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in query
            }
        case URL_RESTOREAPN:
            {
                count = 1;
                restoreDefaultAPN(subId);
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                setPreferredApnId((long) INVALID_APN_ID, subId, true);
                if ((match == URL_PREFERAPN) || (match == URL_PREFERAPN_USING_SUBID))
                    count = 1;
                break;
            }
        case URL_DPC_ID:
            {
                ensureCallingFromSystemUid("URL_DPC_ID called from non SYSTEM_UID.");
                // Only delete if owned by DPC.
                count = db.delete(CARRIERS_TABLE, "(" + _ID + "=?)" + " and " + IS_OWNED_BY_DPC, new String[] { url.getLastPathSegment() });
                break;
            }
        case URL_SIMINFO:
            {
                count = db.delete(SIMINFO_TABLE, where, whereArgs);
                break;
            }
        case URL_UPDATE_DB:
            {
                updateApnDb();
                count = 1;
                break;
            }
        default:
            {
                throw new UnsupportedOperationException("Cannot delete that URL: " + url);
            }
    }
    if (count > 0) {
        getContext().getContentResolver().notifyChange(CONTENT_URI, null, true, UserHandle.USER_ALL);
    }
    return count;
}
#end_block

#method_before
@Override
public synchronized int update(Uri url, ContentValues values, String where, String[] whereArgs) {
    int count = 0;
    int uriType = URL_UNKNOWN;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    checkPermission();
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_TELEPHONY:
            {
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, USER_EDITED);
                }
                // Replace on conflict so that if same APN is present in db with edited
                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with
                // edited USER/CARRIER_EDITED
                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where + " and " + NOT_OWNED_BY_DPC, whereArgs, SQLiteDatabase.CONFLICT_REPLACE);
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_CURRENT:
            {
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, USER_EDITED);
                }
                // Replace on conflict so that if same APN is present in db with edited
                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with
                // edited USER/CARRIER_EDITED
                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where + " and " + NOT_OWNED_BY_DPC, whereArgs, SQLiteDatabase.CONFLICT_REPLACE);
                break;
            }
        case URL_ID:
            {
                if (where != null || whereArgs != null) {
                    throw new UnsupportedOperationException("Cannot update URL " + url + " with a where clause");
                }
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, USER_EDITED);
                }
                // Replace on conflict so that if same APN is present in db with edited
                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with
                // edited USER/CARRIER_EDITED
                count = db.updateWithOnConflict(CARRIERS_TABLE, values, _ID + "=?" + " and " + NOT_OWNED_BY_DPC, new String[] { url.getLastPathSegment() }, SQLiteDatabase.CONFLICT_REPLACE);
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                if (values != null) {
                    if (values.containsKey(COLUMN_APN_ID)) {
                        setPreferredApnId(values.getAsLong(COLUMN_APN_ID), subId, true);
                        if ((match == URL_PREFERAPN) || (match == URL_PREFERAPN_USING_SUBID)) {
                            count = 1;
                        }
                    }
                }
                break;
            }
        case URL_DPC:
            {
                // TO be fixed.
                if (!isCallingFromSystemUid()) {
                    break;
                }
                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where + " and " + IS_OWNED_BY_DPC, whereArgs, SQLiteDatabase.CONFLICT_REPLACE);
                break;
            }
        case URL_SIMINFO:
            {
                count = db.update(SIMINFO_TABLE, values, where, whereArgs);
                uriType = URL_SIMINFO;
                break;
            }
        default:
            {
                throw new UnsupportedOperationException("Cannot update that URL: " + url);
            }
    }
    if (count > 0) {
        switch(uriType) {
            case URL_SIMINFO:
                getContext().getContentResolver().notifyChange(SubscriptionManager.CONTENT_URI, null, true, UserHandle.USER_ALL);
                break;
            default:
                getContext().getContentResolver().notifyChange(CONTENT_URI, null, true, UserHandle.USER_ALL);
        }
    }
    return count;
}
#method_after
@Override
public synchronized int update(Uri url, ContentValues values, String where, String[] whereArgs) {
    int count = 0;
    int uriType = URL_UNKNOWN;
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    checkPermission();
    SQLiteDatabase db = getWritableDatabase();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_TELEPHONY:
            {
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, USER_EDITED);
                }
                // Replace on conflict so that if same APN is present in db with edited
                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with
                // edited USER/CARRIER_EDITED
                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where + " and " + IS_NOT_OWNED_BY_DPC, whereArgs, SQLiteDatabase.CONFLICT_REPLACE);
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            // FIXME use subId in the query
            }
        case URL_CURRENT:
            {
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, USER_EDITED);
                }
                // Replace on conflict so that if same APN is present in db with edited
                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with
                // edited USER/CARRIER_EDITED
                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where + " and " + IS_NOT_OWNED_BY_DPC, whereArgs, SQLiteDatabase.CONFLICT_REPLACE);
                break;
            }
        case URL_ID:
            {
                if (where != null || whereArgs != null) {
                    throw new UnsupportedOperationException("Cannot update URL " + url + " with a where clause");
                }
                if (!values.containsKey(EDITED)) {
                    values.put(EDITED, USER_EDITED);
                }
                try {
                    count = db.updateWithOnConflict(CARRIERS_TABLE, values, _ID + "=?" + " and " + IS_NOT_OWNED_BY_DPC, new String[] { url.getLastPathSegment() }, SQLiteDatabase.CONFLICT_ABORT);
                } catch (SQLException e) {
                    // Update failed which could be due to a conflict. Check if that is
                    // the case and merge the entries
                    Cursor oldRow = DatabaseHelper.selectConflictingRow(db, CARRIERS_TABLE, values);
                    if (oldRow != null) {
                        ContentValues mergedValues = new ContentValues();
                        DatabaseHelper.mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values, mergedValues, false, getContext());
                        oldRow.close();
                    }
                }
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                String subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    throw new IllegalArgumentException("Invalid subId " + url);
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
            }
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                if (values != null) {
                    if (values.containsKey(COLUMN_APN_ID)) {
                        setPreferredApnId(values.getAsLong(COLUMN_APN_ID), subId, true);
                        if ((match == URL_PREFERAPN) || (match == URL_PREFERAPN_USING_SUBID)) {
                            count = 1;
                        }
                    }
                }
                break;
            }
        case URL_DPC_ID:
            {
                ensureCallingFromSystemUid("URL_DPC_ID called from non SYSTEM_UID.");
                if (where != null || whereArgs != null) {
                    throw new UnsupportedOperationException("Cannot update URL " + url + " with a where clause");
                }
                count = db.updateWithOnConflict(CARRIERS_TABLE, values, _ID + "=?" + " and " + IS_OWNED_BY_DPC, new String[] { url.getLastPathSegment() }, SQLiteDatabase.CONFLICT_REPLACE);
                break;
            }
        case URL_ENFORCE_MANAGED:
            {
                ensureCallingFromSystemUid("URL_ENFORCE_MANAGED called from non SYSTEM_UID.");
                if (values != null) {
                    if (values.containsKey(ENFORCED_KEY)) {
                        setManagedApnEnforced(values.getAsBoolean(ENFORCED_KEY));
                        count = 1;
                    }
                }
                break;
            }
        case URL_SIMINFO:
            {
                count = db.update(SIMINFO_TABLE, values, where, whereArgs);
                uriType = URL_SIMINFO;
                break;
            }
        default:
            {
                throw new UnsupportedOperationException("Cannot update that URL: " + url);
            }
    }
    if (count > 0) {
        switch(uriType) {
            case URL_SIMINFO:
                getContext().getContentResolver().notifyChange(SubscriptionManager.CONTENT_URI, null, true, UserHandle.USER_ALL);
                break;
            default:
                getContext().getContentResolver().notifyChange(CONTENT_URI, null, true, UserHandle.USER_ALL);
        }
    }
    return count;
}
#end_block

#method_before
private void restoreDefaultAPN(int subId) {
    SQLiteDatabase db = getWritableDatabase();
    try {
        db.delete(CARRIERS_TABLE, NOT_OWNED_BY_DPC, null);
    } catch (SQLException e) {
        loge("got exception when deleting to restore: " + e);
    }
    // delete preferred apn ids and preferred apns (both stored in diff SharedPref) for all
    // subIds
    SharedPreferences spApnId = getContext().getSharedPreferences(PREF_FILE_APN, Context.MODE_PRIVATE);
    SharedPreferences.Editor editorApnId = spApnId.edit();
    editorApnId.clear();
    editorApnId.apply();
    SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN, Context.MODE_PRIVATE);
    SharedPreferences.Editor editorApn = spApn.edit();
    editorApn.clear();
    editorApn.apply();
    if (apnSourceServiceExists(getContext())) {
        restoreApnsWithService();
    } else {
        initDatabaseWithDatabaseHelper(db);
    }
}
#method_after
private void restoreDefaultAPN(int subId) {
    SQLiteDatabase db = getWritableDatabase();
    try {
        db.delete(CARRIERS_TABLE, IS_NOT_OWNED_BY_DPC, null);
    } catch (SQLException e) {
        loge("got exception when deleting to restore: " + e);
    }
    // delete preferred apn ids and preferred apns (both stored in diff SharedPref) for all
    // subIds
    SharedPreferences spApnId = getContext().getSharedPreferences(PREF_FILE_APN, Context.MODE_PRIVATE);
    SharedPreferences.Editor editorApnId = spApnId.edit();
    editorApnId.clear();
    editorApnId.apply();
    SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN, Context.MODE_PRIVATE);
    SharedPreferences.Editor editorApn = spApn.edit();
    editorApn.clear();
    editorApn.apply();
    if (apnSourceServiceExists(getContext())) {
        restoreApnsWithService();
    } else {
        initDatabaseWithDatabaseHelper(db);
    }
}
#end_block

#method_before
private synchronized void updateApnDb() {
    if (apnSourceServiceExists(getContext())) {
        loge("called updateApnDb when apn source service exists");
        return;
    }
    if (!needApnDbUpdate()) {
        log("Skipping apn db update since apn-conf has not changed.");
        return;
    }
    SQLiteDatabase db = getWritableDatabase();
    // Delete preferred APN for all subIds
    deletePreferredApnId();
    // Delete entries in db
    try {
        if (VDBG)
            log("updateApnDb: deleting edited=UNEDITED entries");
        db.delete(CARRIERS_TABLE, IS_UNEDITED + " and " + NOT_OWNED_BY_DPC, null);
    } catch (SQLException e) {
        loge("got exception when deleting to update: " + e);
    }
    initDatabaseWithDatabaseHelper(db);
    // Notify listereners of DB change since DB has been updated
    getContext().getContentResolver().notifyChange(CONTENT_URI, null, true, UserHandle.USER_ALL);
}
#method_after
private synchronized void updateApnDb() {
    if (apnSourceServiceExists(getContext())) {
        loge("called updateApnDb when apn source service exists");
        return;
    }
    if (!needApnDbUpdate()) {
        log("Skipping apn db update since apn-conf has not changed.");
        return;
    }
    SQLiteDatabase db = getWritableDatabase();
    // Delete preferred APN for all subIds
    deletePreferredApnId();
    // Delete entries in db
    try {
        if (VDBG)
            log("updateApnDb: deleting edited=UNEDITED entries");
        db.delete(CARRIERS_TABLE, IS_UNEDITED + " and " + IS_NOT_OWNED_BY_DPC, null);
    } catch (SQLException e) {
        loge("got exception when deleting to update: " + e);
    }
    initDatabaseWithDatabaseHelper(db);
    // Notify listereners of DB change since DB has been updated
    getContext().getContentResolver().notifyChange(CONTENT_URI, null, true, UserHandle.USER_ALL);
}
#end_block

#method_before
private synchronized void closeService() {
    if (DEBUG) {
        Log.d(TAG, "MAP Service closeService in");
    }
    if (mBluetoothMnsObexClient != null) {
        mBluetoothMnsObexClient.shutdown();
        mBluetoothMnsObexClient = null;
    }
    if (mMasInstances.size() > 0) {
        for (int i = 0, c = mMasInstances.size(); i < c; i++) {
            mMasInstances.valueAt(i).shutdown();
        }
        mMasInstances.clear();
    }
    mIsWaitingAuthorization = false;
    mPermission = BluetoothDevice.ACCESS_UNKNOWN;
    setState(BluetoothMap.STATE_DISCONNECTED);
    if (mWakeLock != null) {
        mWakeLock.release();
        if (VERBOSE) {
            Log.v(TAG, "CloseService(): Release Wake Lock");
        }
        mWakeLock = null;
    }
    /* Only one SHUTDOWN message expected to closeService.
         * Hence, quit looper and Handler on first SHUTDOWN message*/
    if (mSessionStatusHandler != null) {
        // Perform cleanup in Handler running on worker Thread
        mSessionStatusHandler.removeCallbacksAndMessages(null);
        Looper looper = mSessionStatusHandler.getLooper();
        if (looper != null) {
            looper.quit();
            if (VERBOSE) {
                Log.i(TAG, "Quit looper");
            }
        }
        mSessionStatusHandler = null;
        if (VERBOSE) {
            Log.i(TAG, "Remove Handler");
        }
    }
    sRemoteDevice = null;
    if (VERBOSE) {
        Log.v(TAG, "MAP Service closeService out");
    }
}
#method_after
private synchronized void closeService() {
    if (DEBUG) {
        Log.d(TAG, "MAP Service closeService in");
    }
    // Mark MapService Started as false while shutdown ongoing.
    mServiceStarted = false;
    if (mBluetoothMnsObexClient != null) {
        mBluetoothMnsObexClient.shutdown();
        mBluetoothMnsObexClient = null;
    }
    if (mMasInstances.size() > 0) {
        for (int i = 0, c = mMasInstances.size(); i < c; i++) {
            mMasInstances.valueAt(i).shutdown();
        }
        mMasInstances.clear();
    }
    mIsWaitingAuthorization = false;
    mPermission = BluetoothDevice.ACCESS_UNKNOWN;
    setState(BluetoothMap.STATE_DISCONNECTED);
    if (mWakeLock != null) {
        mWakeLock.release();
        if (VERBOSE) {
            Log.v(TAG, "CloseService(): Release Wake Lock");
        }
        mWakeLock = null;
    }
    /* Only one SHUTDOWN message expected to closeService.
         * Hence, quit looper and Handler on first SHUTDOWN message*/
    if (mSessionStatusHandler != null) {
        // Perform cleanup in Handler running on worker Thread
        mSessionStatusHandler.removeCallbacksAndMessages(null);
        Looper looper = mSessionStatusHandler.getLooper();
        if (looper != null) {
            looper.quit();
            if (VERBOSE) {
                Log.i(TAG, "Quit looper");
            }
        }
        mSessionStatusHandler = null;
        if (VERBOSE) {
            Log.i(TAG, "Remove Handler");
        }
    }
    sRemoteDevice = null;
    if (VERBOSE) {
        Log.v(TAG, "MAP Service closeService out");
    }
}
#end_block

#method_before
protected boolean isMapStarted() {
    return !mStartError;
}
#method_after
protected boolean isMapStarted() {
    return mServiceStarted;
}
#end_block

#method_before
@Override
protected boolean start() {
    if (DEBUG) {
        Log.d(TAG, "start()");
    }
    if (isMapStarted()) {
        Log.w(TAG, "start received for already started, ignoring");
        return false;
    }
    HandlerThread thread = new HandlerThread("BluetoothMapHandler");
    thread.start();
    Looper looper = thread.getLooper();
    mSessionStatusHandler = new MapServiceMessageHandler(looper);
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
    filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
    filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
    filter.addAction(BluetoothDevice.ACTION_SDP_RECORD);
    filter.addAction(ACTION_SHOW_MAPS_SETTINGS);
    filter.addAction(USER_CONFIRM_TIMEOUT_ACTION);
    // We need two filters, since Type only applies to the ACTION_MESSAGE_SENT
    IntentFilter filterMessageSent = new IntentFilter();
    filterMessageSent.addAction(BluetoothMapContentObserver.ACTION_MESSAGE_SENT);
    try {
        filterMessageSent.addDataType("message/*");
    } catch (MalformedMimeTypeException e) {
        Log.e(TAG, "Wrong mime type!!!", e);
    }
    if (!mRegisteredMapReceiver) {
        try {
            registerReceiver(mMapReceiver, filter);
            registerReceiver(mMapReceiver, filterMessageSent);
            mRegisteredMapReceiver = true;
        } catch (Exception e) {
            Log.e(TAG, "Unable to register map receiver", e);
        }
    }
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    mAppObserver = new BluetoothMapAppObserver(this, this);
    mEnabledAccounts = mAppObserver.getEnabledAccountItems();
    mSmsCapable = getResources().getBoolean(com.android.internal.R.bool.config_sms_capable);
    // Uses mEnabledAccounts, hence getEnabledAccountItems() must be called before this.
    createMasInstances();
    // start RFCOMM listener
    sendStartListenerMessage(-1);
    mStartError = false;
    return !mStartError;
}
#method_after
@Override
protected boolean start() {
    if (DEBUG) {
        Log.d(TAG, "start()");
    }
    if (isMapStarted()) {
        Log.w(TAG, "start received for already started, ignoring");
        return false;
    }
    HandlerThread thread = new HandlerThread("BluetoothMapHandler");
    thread.start();
    Looper looper = thread.getLooper();
    mSessionStatusHandler = new MapServiceMessageHandler(looper);
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
    filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
    filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
    filter.addAction(BluetoothDevice.ACTION_SDP_RECORD);
    filter.addAction(ACTION_SHOW_MAPS_SETTINGS);
    filter.addAction(USER_CONFIRM_TIMEOUT_ACTION);
    // We need two filters, since Type only applies to the ACTION_MESSAGE_SENT
    IntentFilter filterMessageSent = new IntentFilter();
    filterMessageSent.addAction(BluetoothMapContentObserver.ACTION_MESSAGE_SENT);
    try {
        filterMessageSent.addDataType("message/*");
    } catch (MalformedMimeTypeException e) {
        Log.e(TAG, "Wrong mime type!!!", e);
    }
    if (!mRegisteredMapReceiver) {
        try {
            registerReceiver(mMapReceiver, filter);
            registerReceiver(mMapReceiver, filterMessageSent);
            mRegisteredMapReceiver = true;
        } catch (Exception e) {
            Log.e(TAG, "Unable to register map receiver", e);
        }
    }
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    mAppObserver = new BluetoothMapAppObserver(this, this);
    mEnabledAccounts = mAppObserver.getEnabledAccountItems();
    mSmsCapable = getResources().getBoolean(com.android.internal.R.bool.config_sms_capable);
    // Uses mEnabledAccounts, hence getEnabledAccountItems() must be called before this.
    createMasInstances();
    // start RFCOMM listener
    sendStartListenerMessage(-1);
    mServiceStarted = true;
    return mServiceStarted;
}
#end_block

#method_before
@Override
protected boolean stop() {
    if (DEBUG) {
        Log.d(TAG, "stop()");
    }
    if (mRegisteredMapReceiver) {
        try {
            mRegisteredMapReceiver = false;
            unregisterReceiver(mMapReceiver);
            mAppObserver.shutdown();
        } catch (Exception e) {
            Log.e(TAG, "Unable to unregister map receiver", e);
        }
    }
    // TODO: Check if the profile state can be retreived from ProfileService or AdapterService.
    if (!isMapStarted()) {
        if (DEBUG) {
            Log.d(TAG, "Service Not Available to STOP, ignoring");
        }
        return true;
    } else {
        if (VERBOSE) {
            Log.d(TAG, "Service Stoping()");
        }
    }
    if (mSessionStatusHandler != null) {
        sendShutdownMessage();
    }
    mStartError = true;
    setState(BluetoothMap.STATE_DISCONNECTED, BluetoothMap.RESULT_CANCELED);
    return true;
}
#method_after
@Override
protected boolean stop() {
    if (DEBUG) {
        Log.d(TAG, "stop()");
    }
    if (mRegisteredMapReceiver) {
        try {
            mRegisteredMapReceiver = false;
            unregisterReceiver(mMapReceiver);
            mAppObserver.shutdown();
        } catch (Exception e) {
            Log.e(TAG, "Unable to unregister map receiver", e);
        }
    }
    // TODO: Check if the profile state can be retreived from ProfileService or AdapterService.
    if (!isMapStarted()) {
        if (DEBUG) {
            Log.d(TAG, "Service Not Available to STOP or Shutdown already" + " in progress - Ignoring");
        }
        return true;
    } else {
        if (VERBOSE) {
            Log.d(TAG, "Service Stoping()");
        }
    }
    // setState Disconnect already handled from closeService.
    // Handle it otherwise - Redundant for backup?
    setState(BluetoothMap.STATE_DISCONNECTED, BluetoothMap.RESULT_CANCELED);
    if (mSessionStatusHandler != null) {
        sendShutdownMessage();
    }
    mServiceStarted = false;
    return true;
}
#end_block

#method_before
@Override
public boolean cleanup() {
    if (DEBUG) {
        Log.d(TAG, "cleanup()");
    }
    setState(BluetoothMap.STATE_DISCONNECTED, BluetoothMap.RESULT_CANCELED);
    // Cleanup already handled in Stop().
    // Move this  extra check to Handler.
    sendShutdownMessage();
    return true;
}
#method_after
@Override
public boolean cleanup() {
    if (DEBUG) {
        Log.d(TAG, "cleanup()");
    }
    // TODO: Check if the profile state can be retreived from ProfileService or AdapterService.
    if (!isMapStarted()) {
        if (DEBUG) {
            Log.d(TAG, "Service Not Available to STOP or Shutdown already" + " in progress - Ignoring");
        }
        return true;
    } else {
        if (VERBOSE)
            Log.d(TAG, "Service Stoping()");
    }
    // SetState Disconnect already handled from closeService.
    // Handle it otherwise. Redundant for backup ?
    setState(BluetoothMap.STATE_DISCONNECTED, BluetoothMap.RESULT_CANCELED);
    // Move this  extra check to Handler.
    if (mSessionStatusHandler != null) {
        sendShutdownMessage();
    }
    mServiceStarted = false;
    return true;
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (DEBUG) {
        Log.d(TAG, "onReceive");
    }
    String action = intent.getAction();
    if (DEBUG) {
        Log.d(TAG, "onReceive: " + action);
    }
    if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
        if (state == BluetoothAdapter.STATE_TURNING_OFF) {
            if (DEBUG) {
                Log.d(TAG, "STATE_TURNING_OFF");
            }
            sendShutdownMessage();
        } else if (state == BluetoothAdapter.STATE_ON) {
            if (DEBUG) {
                Log.d(TAG, "STATE_ON");
            }
            // start ServerSocket listener threads
            sendStartListenerMessage(-1);
        }
    } else if (action.equals(USER_CONFIRM_TIMEOUT_ACTION)) {
        if (DEBUG) {
            Log.d(TAG, "USER_CONFIRM_TIMEOUT ACTION Received.");
        }
        // send us self a message about the timeout.
        sendConnectTimeoutMessage();
    } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
        int requestType = intent.getIntExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
        if (DEBUG) {
            Log.d(TAG, "Received ACTION_CONNECTION_ACCESS_REPLY:" + requestType + "isWaitingAuthorization:" + mIsWaitingAuthorization);
        }
        if ((!mIsWaitingAuthorization) || (requestType != BluetoothDevice.REQUEST_TYPE_MESSAGE_ACCESS)) {
            // this reply is not for us
            return;
        }
        mIsWaitingAuthorization = false;
        if (mRemoveTimeoutMsg) {
            mSessionStatusHandler.removeMessages(USER_TIMEOUT);
            cancelUserTimeoutAlarm();
            setState(BluetoothMap.STATE_DISCONNECTED);
        }
        if (intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT, BluetoothDevice.CONNECTION_ACCESS_NO) == BluetoothDevice.CONNECTION_ACCESS_YES) {
            // Bluetooth connection accepted by user
            mPermission = BluetoothDevice.ACCESS_ALLOWED;
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                boolean result = sRemoteDevice.setMessageAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                if (DEBUG) {
                    Log.d(TAG, "setMessageAccessPermission(ACCESS_ALLOWED) result=" + result);
                }
            }
            sRemoteDevice.sdpSearch(BluetoothMnsObexClient.BLUETOOTH_UUID_OBEX_MNS);
            mSdpSearchInitiated = true;
        } else {
            // Auth. declined by user, serverSession should not be running, but
            // call stop anyway to restart listener.
            mPermission = BluetoothDevice.ACCESS_REJECTED;
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                boolean result = sRemoteDevice.setMessageAccessPermission(BluetoothDevice.ACCESS_REJECTED);
                if (DEBUG) {
                    Log.d(TAG, "setMessageAccessPermission(ACCESS_REJECTED) result=" + result);
                }
            }
            sendConnectCancelMessage();
        }
    } else if (action.equals(BluetoothDevice.ACTION_SDP_RECORD)) {
        if (DEBUG) {
            Log.d(TAG, "Received ACTION_SDP_RECORD.");
        }
        ParcelUuid uuid = intent.getParcelableExtra(BluetoothDevice.EXTRA_UUID);
        if (VERBOSE) {
            Log.v(TAG, "Received UUID: " + uuid.toString());
            Log.v(TAG, "expected UUID: " + BluetoothMnsObexClient.BLUETOOTH_UUID_OBEX_MNS.toString());
        }
        if (uuid.equals(BluetoothMnsObexClient.BLUETOOTH_UUID_OBEX_MNS)) {
            mMnsRecord = intent.getParcelableExtra(BluetoothDevice.EXTRA_SDP_RECORD);
            int status = intent.getIntExtra(BluetoothDevice.EXTRA_SDP_SEARCH_STATUS, -1);
            if (VERBOSE) {
                Log.v(TAG, " -> MNS Record:" + mMnsRecord);
                Log.v(TAG, " -> status: " + status);
            }
            if (mBluetoothMnsObexClient != null && !mSdpSearchInitiated) {
                mBluetoothMnsObexClient.setMnsRecord(mMnsRecord);
            }
            if (status != -1 && mMnsRecord != null) {
                for (int i = 0, c = mMasInstances.size(); i < c; i++) {
                    mMasInstances.valueAt(i).setRemoteFeatureMask(mMnsRecord.getSupportedFeatures());
                }
            }
            if (mSdpSearchInitiated) {
                // done searching
                mSdpSearchInitiated = false;
                // -1 indicates all MAS instances
                sendConnectMessage(-1);
            }
        }
    } else if (action.equals(ACTION_SHOW_MAPS_SETTINGS)) {
        if (VERBOSE) {
            Log.v(TAG, "Received ACTION_SHOW_MAPS_SETTINGS.");
        }
        Intent in = new Intent(context, BluetoothMapSettings.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        context.startActivity(in);
    } else if (action.equals(BluetoothMapContentObserver.ACTION_MESSAGE_SENT)) {
        BluetoothMapMasInstance masInst = null;
        int result = getResultCode();
        boolean handled = false;
        if (mSmsCapable && mMasInstances != null && (masInst = mMasInstances.get(MAS_ID_SMS_MMS)) != null) {
            intent.putExtra(BluetoothMapContentObserver.EXTRA_MESSAGE_SENT_RESULT, result);
            if (masInst.handleSmsSendIntent(context, intent)) {
                // The intent was handled by the mas instance it self
                handled = true;
            }
        }
        if (!handled) {
            /* We do not have a connection to a device, hence we need to move
                       the SMS to the correct folder. */
            BluetoothMapContentObserver.actionMessageSentDisconnected(context, intent, result);
        }
    } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED) && mIsWaitingAuthorization) {
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (sRemoteDevice == null || device == null) {
            Log.e(TAG, "Unexpected error!");
            return;
        }
        if (VERBOSE) {
            Log.v(TAG, "ACL disconnected for " + device);
        }
        if (sRemoteDevice.equals(device)) {
            // Send any pending timeout now, since ACL got disconnected
            mSessionStatusHandler.removeMessages(USER_TIMEOUT);
            mSessionStatusHandler.obtainMessage(USER_TIMEOUT).sendToTarget();
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (DEBUG) {
        Log.d(TAG, "onReceive");
    }
    String action = intent.getAction();
    if (DEBUG) {
        Log.d(TAG, "onReceive: " + action);
    }
    if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
        int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
        if (state == BluetoothAdapter.STATE_TURNING_OFF) {
            if (DEBUG)
                Log.d(TAG, "STATE_TURNING_OFF");
            // Stop MapProfile if already started.
            if (!isMapStarted()) {
                if (DEBUG) {
                    Log.d(TAG, "Service Not Available to STOP or Shutdown already" + " in progress - Ignoring");
                }
            } else if (mSessionStatusHandler != null) {
                if (VERBOSE)
                    Log.d(TAG, "Service Stoping()");
                sendShutdownMessage();
            } else {
                if (DEBUG) {
                    Log.d(TAG, "Unable to perform STOP or Shutdown already" + " in progress - Ignoring");
                }
            }
        } else if (state == BluetoothAdapter.STATE_ON) {
            if (DEBUG) {
                Log.d(TAG, "STATE_ON");
            }
            // start ServerSocket listener threads
            sendStartListenerMessage(-1);
        }
    } else if (action.equals(USER_CONFIRM_TIMEOUT_ACTION)) {
        if (DEBUG) {
            Log.d(TAG, "USER_CONFIRM_TIMEOUT ACTION Received.");
        }
        // send us self a message about the timeout.
        sendConnectTimeoutMessage();
    } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
        int requestType = intent.getIntExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
        if (DEBUG) {
            Log.d(TAG, "Received ACTION_CONNECTION_ACCESS_REPLY:" + requestType + "isWaitingAuthorization:" + mIsWaitingAuthorization);
        }
        if ((!mIsWaitingAuthorization) || (requestType != BluetoothDevice.REQUEST_TYPE_MESSAGE_ACCESS)) {
            // this reply is not for us
            return;
        }
        mIsWaitingAuthorization = false;
        if (mRemoveTimeoutMsg) {
            mSessionStatusHandler.removeMessages(USER_TIMEOUT);
            cancelUserTimeoutAlarm();
            setState(BluetoothMap.STATE_DISCONNECTED);
        }
        if (intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT, BluetoothDevice.CONNECTION_ACCESS_NO) == BluetoothDevice.CONNECTION_ACCESS_YES) {
            // Bluetooth connection accepted by user
            mPermission = BluetoothDevice.ACCESS_ALLOWED;
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                boolean result = sRemoteDevice.setMessageAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                if (DEBUG) {
                    Log.d(TAG, "setMessageAccessPermission(ACCESS_ALLOWED) result=" + result);
                }
            }
            sRemoteDevice.sdpSearch(BluetoothMnsObexClient.BLUETOOTH_UUID_OBEX_MNS);
            mSdpSearchInitiated = true;
        } else {
            // Auth. declined by user, serverSession should not be running, but
            // call stop anyway to restart listener.
            mPermission = BluetoothDevice.ACCESS_REJECTED;
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                boolean result = sRemoteDevice.setMessageAccessPermission(BluetoothDevice.ACCESS_REJECTED);
                if (DEBUG) {
                    Log.d(TAG, "setMessageAccessPermission(ACCESS_REJECTED) result=" + result);
                }
            }
            sendConnectCancelMessage();
        }
    } else if (action.equals(BluetoothDevice.ACTION_SDP_RECORD)) {
        if (DEBUG) {
            Log.d(TAG, "Received ACTION_SDP_RECORD.");
        }
        ParcelUuid uuid = intent.getParcelableExtra(BluetoothDevice.EXTRA_UUID);
        if (VERBOSE) {
            Log.v(TAG, "Received UUID: " + uuid.toString());
            Log.v(TAG, "expected UUID: " + BluetoothMnsObexClient.BLUETOOTH_UUID_OBEX_MNS.toString());
        }
        if (uuid.equals(BluetoothMnsObexClient.BLUETOOTH_UUID_OBEX_MNS)) {
            mMnsRecord = intent.getParcelableExtra(BluetoothDevice.EXTRA_SDP_RECORD);
            int status = intent.getIntExtra(BluetoothDevice.EXTRA_SDP_SEARCH_STATUS, -1);
            if (VERBOSE) {
                Log.v(TAG, " -> MNS Record:" + mMnsRecord);
                Log.v(TAG, " -> status: " + status);
            }
            if (mBluetoothMnsObexClient != null && !mSdpSearchInitiated) {
                mBluetoothMnsObexClient.setMnsRecord(mMnsRecord);
            }
            if (status != -1 && mMnsRecord != null) {
                for (int i = 0, c = mMasInstances.size(); i < c; i++) {
                    mMasInstances.valueAt(i).setRemoteFeatureMask(mMnsRecord.getSupportedFeatures());
                }
            }
            if (mSdpSearchInitiated) {
                // done searching
                mSdpSearchInitiated = false;
                // -1 indicates all MAS instances
                sendConnectMessage(-1);
            }
        }
    } else if (action.equals(ACTION_SHOW_MAPS_SETTINGS)) {
        if (VERBOSE) {
            Log.v(TAG, "Received ACTION_SHOW_MAPS_SETTINGS.");
        }
        Intent in = new Intent(context, BluetoothMapSettings.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        context.startActivity(in);
    } else if (action.equals(BluetoothMapContentObserver.ACTION_MESSAGE_SENT)) {
        BluetoothMapMasInstance masInst = null;
        int result = getResultCode();
        boolean handled = false;
        if (mSmsCapable && mMasInstances != null && (masInst = mMasInstances.get(MAS_ID_SMS_MMS)) != null) {
            intent.putExtra(BluetoothMapContentObserver.EXTRA_MESSAGE_SENT_RESULT, result);
            if (masInst.handleSmsSendIntent(context, intent)) {
                // The intent was handled by the mas instance it self
                handled = true;
            }
        }
        if (!handled) {
            /* We do not have a connection to a device, hence we need to move
                       the SMS to the correct folder. */
            BluetoothMapContentObserver.actionMessageSentDisconnected(context, intent, result);
        }
    } else if (action.equals(BluetoothDevice.ACTION_ACL_DISCONNECTED) && mIsWaitingAuthorization) {
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (sRemoteDevice == null || device == null) {
            Log.e(TAG, "Unexpected error!");
            return;
        }
        if (VERBOSE) {
            Log.v(TAG, "ACL disconnected for " + device);
        }
        if (sRemoteDevice.equals(device)) {
            // Send any pending timeout now, since ACL got disconnected
            mSessionStatusHandler.removeMessages(USER_TIMEOUT);
            mSessionStatusHandler.obtainMessage(USER_TIMEOUT).sendToTarget();
        }
    }
}
#end_block

#method_before
protected synchronized void startSocketListeners() {
    if (D) {
        Log.d(mTag, "Map Service startSocketListeners");
    }
    if (mServerSession != null) {
        if (D) {
            Log.d(mTag, "mServerSession exists - shutting it down...");
        }
        mServerSession.close();
        mServerSession = null;
    }
    if (mObserver != null) {
        if (D) {
            Log.d(mTag, "mObserver exists - shutting it down...");
        }
        mObserver.deinit();
        mObserver = null;
    }
    closeConnectionSocket();
    if (mServerSockets != null) {
        mServerSockets.prepareForNewConnect();
    } else {
        mServerSockets = ObexServerSockets.create(this);
        if (mServerSockets == null) {
            // TODO: Handle - was not handled before
            Log.e(mTag, "Failed to start the listeners");
            return;
        }
        removeSdpRecord();
        mSdpHandle = createMasSdpRecord(mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm());
        // Here we might have changed crucial data, hence reset DB identifier
        if (V) {
            Log.d(mTag, "Creating new SDP record for MAS instance: " + mMasInstanceId + " Object reference: " + this + "SDP handle: " + mSdpHandle);
        }
        updateDbIdentifier();
    }
}
#method_after
public synchronized void startSocketListeners() {
    if (D) {
        Log.d(mTag, "Map Service startSocketListeners");
    }
    if (mServerSession != null) {
        if (D) {
            Log.d(mTag, "mServerSession exists - shutting it down...");
        }
        mServerSession.close();
        mServerSession = null;
    }
    if (mObserver != null) {
        if (D) {
            Log.d(mTag, "mObserver exists - shutting it down...");
        }
        mObserver.deinit();
        mObserver = null;
    }
    closeConnectionSocket();
    if (mServerSockets != null) {
        mServerSockets.prepareForNewConnect();
    } else {
        mServerSockets = ObexServerSockets.create(this);
        if (mServerSockets == null) {
            // TODO: Handle - was not handled before
            Log.e(mTag, "Failed to start the listeners");
            return;
        }
        removeSdpRecord();
        mSdpHandle = createMasSdpRecord(mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm());
        // Here we might have changed crucial data, hence reset DB identifier
        if (V) {
            Log.d(mTag, "Creating new SDP record for MAS instance: " + mMasInstanceId + " Object reference: " + this + "SDP handle: " + mSdpHandle);
        }
        updateDbIdentifier();
    }
}
#end_block

#method_before
public void shutdown() {
    if (D) {
        Log.d(mTag, "MAP Service shutdown");
    }
    if (mServerSession != null) {
        mServerSession.close();
        mServerSession = null;
    }
    if (mObserver != null) {
        mObserver.deinit();
        mObserver = null;
    }
    removeSdpRecord();
    closeConnectionSocket();
    closeServerSockets(true);
}
#method_after
public void shutdown() {
    if (D) {
        Log.d(mTag, "MAP Service shutdown");
    }
    if (mServerSession != null) {
        mServerSession.close();
        mServerSession = null;
    }
    if (mObserver != null) {
        mObserver.deinit();
        mObserver = null;
    }
    removeSdpRecord();
    closeConnectionSocket();
    // Do not block for Accept thread cleanup.
    // Fix Handler Thread block during BT Turn OFF.
    closeServerSockets(false);
}
#end_block

#method_before
void onProfileStateChanged(LocalBluetoothProfile profile, int newProfileState) {
    if (Utils.D) {
        Log.d(TAG, "onProfileStateChanged: profile " + profile + " newProfileState " + newProfileState);
    }
    if (mLocalAdapter.getBluetoothState() == BluetoothAdapter.STATE_TURNING_OFF) {
        if (Utils.D)
            Log.d(TAG, " BT Turninig Off...Profile conn state change ignored...");
        return;
    }
    mProfileConnectionState.put(profile, newProfileState);
    if (newProfileState == BluetoothProfile.STATE_CONNECTED) {
        if (profile instanceof MapProfile) {
            profile.setPreferred(mDevice, true);
            mRemovedProfiles.remove(profile);
            mProfiles.add(profile);
        } else if (!mProfiles.contains(profile)) {
            mRemovedProfiles.remove(profile);
            mProfiles.add(profile);
            if (profile instanceof PanProfile && ((PanProfile) profile).isLocalRoleNap(mDevice)) {
                // Device doesn't support NAP, so remove PanProfile on disconnect
                mLocalNapRoleConnected = true;
            }
        }
    } else if (profile instanceof MapProfile && newProfileState == BluetoothProfile.STATE_DISCONNECTED) {
        profile.setPreferred(mDevice, false);
    } else if (mLocalNapRoleConnected && profile instanceof PanProfile && ((PanProfile) profile).isLocalRoleNap(mDevice) && newProfileState == BluetoothProfile.STATE_DISCONNECTED) {
        Log.d(TAG, "Removing PanProfile from device after NAP disconnect");
        mProfiles.remove(profile);
        mRemovedProfiles.add(profile);
        mLocalNapRoleConnected = false;
    }
}
#method_after
void onProfileStateChanged(LocalBluetoothProfile profile, int newProfileState) {
    if (Utils.D) {
        Log.d(TAG, "onProfileStateChanged: profile " + profile + " newProfileState " + newProfileState);
    }
    if (mLocalAdapter.getBluetoothState() == BluetoothAdapter.STATE_TURNING_OFF) {
        if (Utils.D)
            Log.d(TAG, " BT Turninig Off...Profile conn state change ignored...");
        return;
    }
    mProfileConnectionState.put(profile, newProfileState);
    if (newProfileState == BluetoothProfile.STATE_CONNECTED) {
        if (profile instanceof MapProfile) {
            profile.setPreferred(mDevice, true);
        }
        if (!mProfiles.contains(profile)) {
            mRemovedProfiles.remove(profile);
            mProfiles.add(profile);
            if (profile instanceof PanProfile && ((PanProfile) profile).isLocalRoleNap(mDevice)) {
                // Device doesn't support NAP, so remove PanProfile on disconnect
                mLocalNapRoleConnected = true;
            }
        }
    } else if (profile instanceof MapProfile && newProfileState == BluetoothProfile.STATE_DISCONNECTED) {
        profile.setPreferred(mDevice, false);
    } else if (mLocalNapRoleConnected && profile instanceof PanProfile && ((PanProfile) profile).isLocalRoleNap(mDevice) && newProfileState == BluetoothProfile.STATE_DISCONNECTED) {
        Log.d(TAG, "Removing PanProfile from device after NAP disconnect");
        mProfiles.remove(profile);
        mRemovedProfiles.add(profile);
        mLocalNapRoleConnected = false;
    }
}
#end_block

#method_before
public boolean startPairing() {
    // Pairing is unreliable while scanning, so cancel discovery
    if (mLocalAdapter.isDiscovering()) {
        mLocalAdapter.cancelDiscovery();
    }
    if (!mDevice.createBond()) {
        return false;
    }
    // auto-connect after pairing
    mConnectAfterPairing = true;
    return true;
}
#method_after
public boolean startPairing() {
    // Pairing is unreliable while scanning, so cancel discovery
    if (mLocalAdapter.isDiscovering()) {
        mLocalAdapter.cancelDiscovery();
    }
    if (!mDevice.createBond()) {
        return false;
    }
    return true;
}
#end_block

#method_before
boolean isUserInitiatedPairing() {
    return mConnectAfterPairing;
}
#method_after
boolean isUserInitiatedPairing() {
    return mDevice.isBondingInitiatedLocally();
}
#end_block

#method_before
public int getProfileConnectionState(LocalBluetoothProfile profile) {
    if (mProfileConnectionState == null || mProfileConnectionState.get(profile) == null) {
        // If cache is empty make the binder call to get the state
        int state = profile.getConnectionStatus(mDevice);
        mProfileConnectionState.put(profile, state);
    }
    return mProfileConnectionState.get(profile);
}
#method_after
public int getProfileConnectionState(LocalBluetoothProfile profile) {
    if (mProfileConnectionState.get(profile) == null) {
        // If cache is empty make the binder call to get the state
        int state = profile.getConnectionStatus(mDevice);
        mProfileConnectionState.put(profile, state);
    }
    return mProfileConnectionState.get(profile);
}
#end_block

#method_before
void onBondingStateChanged(int bondState) {
    if (bondState == BluetoothDevice.BOND_NONE) {
        mProfiles.clear();
        // cancel auto-connect
        mConnectAfterPairing = false;
        setPhonebookPermissionChoice(ACCESS_UNKNOWN);
        setMessagePermissionChoice(ACCESS_UNKNOWN);
        setSimPermissionChoice(ACCESS_UNKNOWN);
        mMessageRejectionCount = 0;
        saveMessageRejectionCount();
    }
    refresh();
    if (bondState == BluetoothDevice.BOND_BONDED) {
        if (mDevice.isBluetoothDock()) {
            onBondingDockConnect();
        } else if (mConnectAfterPairing) {
            connect(false);
        }
        mConnectAfterPairing = false;
    }
}
#method_after
void onBondingStateChanged(int bondState) {
    if (bondState == BluetoothDevice.BOND_NONE) {
        mProfiles.clear();
        setPhonebookPermissionChoice(ACCESS_UNKNOWN);
        setMessagePermissionChoice(ACCESS_UNKNOWN);
        setSimPermissionChoice(ACCESS_UNKNOWN);
        mMessageRejectionCount = 0;
        saveMessageRejectionCount();
    }
    refresh();
    if (bondState == BluetoothDevice.BOND_BONDED) {
        if (mDevice.isBluetoothDock()) {
            onBondingDockConnect();
        } else if (mDevice.isBondingInitiatedLocally()) {
            connect(false);
        }
    }
}
#end_block

#method_before
private void processPhonebookAccess() {
    if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)
        return;
    ParcelUuid[] uuids = mDevice.getUuids();
    if (BluetoothUuid.containsAnyUuid(uuids, PbapServerProfile.PBAB_CLIENT_UUIDS)) {
        // No separate prompt is displayed after pairing.
        if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
            if (mDevice.getBluetoothClass().getDeviceClass() == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE) {
                setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
            } else {
                setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_REJECTED);
            }
        }
    }
}
#method_after
private void processPhonebookAccess() {
    if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)
        return;
    ParcelUuid[] uuids = mDevice.getUuids();
    if (BluetoothUuid.containsAnyUuid(uuids, PbapServerProfile.PBAB_CLIENT_UUIDS)) {
        // No separate prompt is displayed after pairing.
        if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
            if (mDevice.getBluetoothClass().getDeviceClass() == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE || mDevice.getBluetoothClass().getDeviceClass() == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET) {
                setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
            } else {
                setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_REJECTED);
            }
        }
    }
}
#end_block

#method_before
public int getConnectionSummary() {
    // at least one profile is connected
    boolean profileConnected = false;
    // A2DP is preferred but not connected
    boolean a2dpNotConnected = false;
    // Headset is preferred but not connected
    boolean headsetNotConnected = false;
    for (LocalBluetoothProfile profile : getProfiles()) {
        int connectionStatus = getProfileConnectionState(profile);
        switch(connectionStatus) {
            case BluetoothProfile.STATE_CONNECTING:
            case BluetoothProfile.STATE_DISCONNECTING:
                return Utils.getConnectionStateSummary(connectionStatus);
            case BluetoothProfile.STATE_CONNECTED:
                profileConnected = true;
                break;
            case BluetoothProfile.STATE_DISCONNECTED:
                if (profile.isProfileReady()) {
                    if ((profile instanceof A2dpProfile) || (profile instanceof A2dpSinkProfile)) {
                        a2dpNotConnected = true;
                    } else if (profile instanceof HeadsetProfile) {
                        headsetNotConnected = true;
                    }
                }
                break;
        }
    }
    if (profileConnected) {
        if (a2dpNotConnected && headsetNotConnected) {
            return R.string.bluetooth_connected_no_headset_no_a2dp;
        } else if (a2dpNotConnected) {
            return R.string.bluetooth_connected_no_a2dp;
        } else if (headsetNotConnected) {
            return R.string.bluetooth_connected_no_headset;
        } else {
            return R.string.bluetooth_connected;
        }
    }
    return getBondState() == BluetoothDevice.BOND_BONDING ? R.string.bluetooth_pairing : 0;
}
#method_after
public String getConnectionSummary() {
    // at least one profile is connected
    boolean profileConnected = false;
    // A2DP is preferred but not connected
    boolean a2dpNotConnected = false;
    // HFP is preferred but not connected
    boolean hfpNotConnected = false;
    for (LocalBluetoothProfile profile : getProfiles()) {
        int connectionStatus = getProfileConnectionState(profile);
        switch(connectionStatus) {
            case BluetoothProfile.STATE_CONNECTING:
            case BluetoothProfile.STATE_DISCONNECTING:
                return mContext.getString(Utils.getConnectionStateSummary(connectionStatus));
            case BluetoothProfile.STATE_CONNECTED:
                profileConnected = true;
                break;
            case BluetoothProfile.STATE_DISCONNECTED:
                if (profile.isProfileReady()) {
                    if ((profile instanceof A2dpProfile) || (profile instanceof A2dpSinkProfile)) {
                        a2dpNotConnected = true;
                    } else if ((profile instanceof HeadsetProfile) || (profile instanceof HfpClientProfile)) {
                        hfpNotConnected = true;
                    }
                }
                break;
        }
    }
    String batteryLevelPercentageString = null;
    // Android framework should only set mBatteryLevel to valid range [0-100] or
    // BluetoothDevice.BATTERY_LEVEL_UNKNOWN, any other value should be a framework bug.
    // Thus assume here that if value is not BluetoothDevice.BATTERY_LEVEL_UNKNOWN, it must
    // be valid
    final int batteryLevel = getBatteryLevel();
    if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
        // TODO: name com.android.settingslib.bluetooth.Utils something different
        batteryLevelPercentageString = com.android.settingslib.Utils.formatPercentage(batteryLevel);
    }
    if (profileConnected) {
        if (a2dpNotConnected && hfpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_headset_no_a2dp_battery_level, batteryLevelPercentageString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_headset_no_a2dp);
            }
        } else if (a2dpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_a2dp_battery_level, batteryLevelPercentageString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_a2dp);
            }
        } else if (hfpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_headset_battery_level, batteryLevelPercentageString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_headset);
            }
        } else {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_battery_level, batteryLevelPercentageString);
            } else {
                return mContext.getString(R.string.bluetooth_connected);
            }
        }
    }
    return getBondState() == BluetoothDevice.BOND_BONDING ? mContext.getString(R.string.bluetooth_pairing) : null;
}
#end_block

#method_before
void updateLocalProfiles(ParcelUuid[] uuids) {
    // A2DP SRC
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSource)) {
        if (mA2dpProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local A2DP SRC profile");
            mA2dpProfile = new A2dpProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mA2dpProfile, A2dpProfile.NAME, BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mA2dpProfile != null) {
        Log.w(TAG, "Warning: A2DP profile was previously added but the UUID is now missing.");
    }
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSink)) {
        if (mA2dpSinkProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local A2DP Sink profile");
            mA2dpSinkProfile = new A2dpSinkProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mA2dpSinkProfile, A2dpSinkProfile.NAME, BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mA2dpSinkProfile != null) {
        Log.w(TAG, "Warning: A2DP Sink profile was previously added but the UUID is now missing.");
    }
    // Headset / Handsfree
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree_AG) || BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP_AG)) {
        if (mHeadsetProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local HEADSET profile");
            mHeadsetProfile = new HeadsetProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mHeadsetProfile, HeadsetProfile.NAME, BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mHeadsetProfile != null) {
        Log.w(TAG, "Warning: HEADSET profile was previously added but the UUID is now missing.");
    }
    // OPP
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush)) {
        if (mOppProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local OPP profile");
            mOppProfile = new OppProfile();
            // Note: no event handler for OPP, only name map.
            mProfileNameMap.put(OppProfile.NAME, mOppProfile);
        }
    } else if (mOppProfile != null) {
        Log.w(TAG, "Warning: OPP profile was previously added but the UUID is now missing.");
    }
    mEventManager.registerProfileIntentReceiver();
// There is no local SDP record for HID and Settings app doesn't control PBAP
}
#method_after
void updateLocalProfiles(ParcelUuid[] uuids) {
    // A2DP SRC
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSource)) {
        if (mA2dpProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local A2DP SRC profile");
            mA2dpProfile = new A2dpProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mA2dpProfile, A2dpProfile.NAME, BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mA2dpProfile != null) {
        Log.w(TAG, "Warning: A2DP profile was previously added but the UUID is now missing.");
    }
    // A2DP SINK
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSink)) {
        if (mA2dpSinkProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local A2DP Sink profile");
            mA2dpSinkProfile = new A2dpSinkProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mA2dpSinkProfile, A2dpSinkProfile.NAME, BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mA2dpSinkProfile != null) {
        Log.w(TAG, "Warning: A2DP Sink profile was previously added but the UUID is now missing.");
    }
    // Headset / Handsfree
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree_AG) || BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP_AG)) {
        if (mHeadsetProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local HEADSET profile");
            mHeadsetProfile = new HeadsetProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mHeadsetProfile, HeadsetProfile.NAME, BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mHeadsetProfile != null) {
        Log.w(TAG, "Warning: HEADSET profile was previously added but the UUID is now missing.");
    }
    // Headset HF
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree)) {
        if (mHfpClientProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local HfpClient profile");
            mHfpClientProfile = new HfpClientProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mHfpClientProfile, HfpClientProfile.NAME, BluetoothHeadsetClient.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mHfpClientProfile != null) {
        Log.w(TAG, "Warning: Hfp Client profile was previously added but the UUID is now missing.");
    } else {
        Log.d(TAG, "Handsfree Uuid not found.");
    }
    // Message Access Profile Client
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.MNS)) {
        if (mMapClientProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local Map Client profile");
            mMapClientProfile = new MapClientProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mMapClientProfile, MapClientProfile.NAME, BluetoothMapClient.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mMapClientProfile != null) {
        Log.w(TAG, "Warning: MAP Client profile was previously added but the UUID is now missing.");
    } else {
        Log.d(TAG, "MAP Client Uuid not found.");
    }
    // OPP
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush)) {
        if (mOppProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local OPP profile");
            mOppProfile = new OppProfile();
            // Note: no event handler for OPP, only name map.
            mProfileNameMap.put(OppProfile.NAME, mOppProfile);
        }
    } else if (mOppProfile != null) {
        Log.w(TAG, "Warning: OPP profile was previously added but the UUID is now missing.");
    }
    // PBAP Client
    if (mUsePbapPce) {
        if (mPbapClientProfile == null) {
            if (DEBUG)
                Log.d(TAG, "Adding local PBAP Client profile");
            mPbapClientProfile = new PbapClientProfile(mContext, mLocalAdapter, mDeviceManager, this);
            addProfile(mPbapClientProfile, PbapClientProfile.NAME, BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED);
        }
    } else if (mPbapClientProfile != null) {
        Log.w(TAG, "Warning: PBAP Client profile was previously added but the UUID is now missing.");
    }
    mEventManager.registerProfileIntentReceiver();
// There is no local SDP record for HID and Settings app doesn't control PBAP Server.
}
#end_block

#method_before
A2dpSinkProfile getA2dpSinkProfile() {
    if ((mA2dpSinkProfile != null) && (mA2dpSinkProfile.isProfileReady()))
        return mA2dpSinkProfile;
    else
        return null;
}
#method_after
public A2dpSinkProfile getA2dpSinkProfile() {
    if ((mA2dpSinkProfile != null) && (mA2dpSinkProfile.isProfileReady())) {
        return mA2dpSinkProfile;
    } else {
        return null;
    }
}
#end_block

#method_before
synchronized void updateProfiles(ParcelUuid[] uuids, ParcelUuid[] localUuids, Collection<LocalBluetoothProfile> profiles, Collection<LocalBluetoothProfile> removedProfiles, boolean isPanNapConnected, BluetoothDevice device) {
    // Copy previous profile list into removedProfiles
    removedProfiles.clear();
    removedProfiles.addAll(profiles);
    profiles.clear();
    if (uuids == null) {
        return;
    }
    if (mHeadsetProfile != null) {
        if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) || (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree))) {
            profiles.add(mHeadsetProfile);
            removedProfiles.remove(mHeadsetProfile);
        }
    }
    if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) && mA2dpProfile != null) {
        profiles.add(mA2dpProfile);
        removedProfiles.remove(mA2dpProfile);
    }
    if (BluetoothUuid.containsAnyUuid(uuids, A2dpSinkProfile.SRC_UUIDS) && mA2dpSinkProfile != null) {
        profiles.add(mA2dpSinkProfile);
        removedProfiles.remove(mA2dpSinkProfile);
    }
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush) && mOppProfile != null) {
        profiles.add(mOppProfile);
        removedProfiles.remove(mOppProfile);
    }
    if ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hid) || BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hogp)) && mHidProfile != null) {
        profiles.add(mHidProfile);
        removedProfiles.remove(mHidProfile);
    }
    if (isPanNapConnected)
        if (DEBUG)
            Log.d(TAG, "Valid PAN-NAP connection exists.");
    if ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.NAP) && mPanProfile != null) || isPanNapConnected) {
        profiles.add(mPanProfile);
        removedProfiles.remove(mPanProfile);
    }
    if ((mMapProfile != null) && (mMapProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
        profiles.add(mMapProfile);
        removedProfiles.remove(mMapProfile);
        mMapProfile.setPreferred(device, true);
    }
    if ((mPbapProfile != null) && (mPbapProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
        profiles.add(mPbapProfile);
        removedProfiles.remove(mPbapProfile);
        mPbapProfile.setPreferred(device, true);
    }
    if (DEBUG) {
        Log.d(TAG, "New Profiles" + profiles.toString());
    }
}
#method_after
synchronized void updateProfiles(ParcelUuid[] uuids, ParcelUuid[] localUuids, Collection<LocalBluetoothProfile> profiles, Collection<LocalBluetoothProfile> removedProfiles, boolean isPanNapConnected, BluetoothDevice device) {
    // Copy previous profile list into removedProfiles
    removedProfiles.clear();
    removedProfiles.addAll(profiles);
    if (DEBUG) {
        Log.d(TAG, "Current Profiles" + profiles.toString());
    }
    profiles.clear();
    if (uuids == null) {
        return;
    }
    if (mHeadsetProfile != null) {
        if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) || (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree))) {
            profiles.add(mHeadsetProfile);
            removedProfiles.remove(mHeadsetProfile);
        }
    }
    if ((mHfpClientProfile != null) && BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree_AG) && BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree)) {
        profiles.add(mHfpClientProfile);
        removedProfiles.remove(mHfpClientProfile);
    }
    if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) && mA2dpProfile != null) {
        profiles.add(mA2dpProfile);
        removedProfiles.remove(mA2dpProfile);
    }
    if (BluetoothUuid.containsAnyUuid(uuids, A2dpSinkProfile.SRC_UUIDS) && mA2dpSinkProfile != null) {
        profiles.add(mA2dpSinkProfile);
        removedProfiles.remove(mA2dpSinkProfile);
    }
    if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush) && mOppProfile != null) {
        profiles.add(mOppProfile);
        removedProfiles.remove(mOppProfile);
    }
    if ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hid) || BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Hogp)) && mHidProfile != null) {
        profiles.add(mHidProfile);
        removedProfiles.remove(mHidProfile);
    }
    if (isPanNapConnected)
        if (DEBUG)
            Log.d(TAG, "Valid PAN-NAP connection exists.");
    if ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.NAP) && mPanProfile != null) || isPanNapConnected) {
        profiles.add(mPanProfile);
        removedProfiles.remove(mPanProfile);
    }
    if ((mMapProfile != null) && (mMapProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
        profiles.add(mMapProfile);
        removedProfiles.remove(mMapProfile);
        mMapProfile.setPreferred(device, true);
    }
    if ((mPbapProfile != null) && (mPbapProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
        profiles.add(mPbapProfile);
        removedProfiles.remove(mPbapProfile);
        mPbapProfile.setPreferred(device, true);
    }
    if (mMapClientProfile != null) {
        profiles.add(mMapClientProfile);
        removedProfiles.remove(mMapClientProfile);
    }
    if (mUsePbapPce) {
        profiles.add(mPbapClientProfile);
        removedProfiles.remove(mPbapClientProfile);
    }
    if (DEBUG) {
        Log.d(TAG, "New Profiles" + profiles.toString());
    }
}
#end_block

#method_before
@Override
public List<BluetoothDevice> getConnectedDevices() {
    if (VDBG) {
        log("getConnectedDevices()");
    }
    final IBluetoothPbap service = mService;
    if (service != null) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
#method_after
@Override
public List<BluetoothDevice> getConnectedDevices() {
    log("getConnectedDevices()");
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    }
    try {
        return service.getConnectedDevices();
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return new ArrayList<BluetoothDevice>();
}
#end_block

#method_before
@Override
public int getConnectionState(BluetoothDevice device) {
    if (VDBG) {
        log("getConnectionState: device=" + device);
    }
    final IBluetoothPbap service = mService;
    if (service != null) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
#method_after
@Override
public int getConnectionState(BluetoothDevice device) {
    log("getConnectionState: device=" + device);
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.STATE_DISCONNECTED;
    }
    try {
        return service.getConnectionState(device);
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
#end_block

#method_before
@Override
public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    if (VDBG) {
        log("getDevicesMatchingConnectionStates: states=" + Arrays.toString(states));
    }
    final IBluetoothPbap service = mService;
    if (service != null) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
#method_after
@Override
public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    log("getDevicesMatchingConnectionStates: states=" + Arrays.toString(states));
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    }
    try {
        return service.getDevicesMatchingConnectionStates(states);
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return new ArrayList<BluetoothDevice>();
}
#end_block

#method_before
/**
 * Disconnects the current Pbap client (PCE). Currently this call blocks,
 * it may soon be made asynchronous. Returns false if this proxy object is
 * not currently connected to the Pbap service.
 */
// TODO: This is currently being used by SettingsLib and will be used in the future.
public boolean disconnect(BluetoothDevice device) {
    if (DBG) {
        log("disconnect()");
    }
    final IBluetoothPbap service = mService;
    if (service != null) {
        try {
            service.disconnect(device);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
#method_after
/**
 * Disconnects the current Pbap client (PCE). Currently this call blocks,
 * it may soon be made asynchronous. Returns false if this proxy object is
 * not currently connected to the Pbap service.
 */
// TODO: This is currently being used by SettingsLib and will be used in the future.
public boolean disconnect(BluetoothDevice device) {
    log("disconnect()");
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return false;
    }
    try {
        service.disconnect(device);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return false;
}
#end_block

#method_before
private static void log(String msg) {
    Log.d(TAG, msg);
}
#method_after
private static void log(String msg) {
    if (DBG) {
        Log.d(TAG, msg);
    }
}
#end_block

#method_before
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    boolean replace = false;
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    if (instantApp) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (fullApp) {
        scanFlags |= SCAN_AS_FULL_APP;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (instantApp && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (instantApp ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    pp.setCallback(mPackageParserCallback);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Instant apps must have target SDK >= O and have targetSanboxVersion >= 2
    if (instantApp && pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.N_MR1) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target O");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must target O");
        return;
    }
    if (instantApp && pkg.applicationInfo.targetSandboxVersion != 2) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must use targetSanboxVersion 2");
        return;
    }
    if (pkg.applicationInfo.isStaticSharedLibrary()) {
        // Static shared libraries have synthetic package names
        renameStaticSharedLibraryPackage(pkg);
        // No static shared libs on external storage
        if (onExternal) {
            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Packages declaring static-shared libs cannot be updated");
            return;
        }
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo(this);
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.certificates != null) {
            try {
                PackageParser.populateCertificates(pkg, args.certificates);
            } catch (PackageParserException e) {
                // there was something wrong with the certificates we were given;
                // try to pull them from the APK
                PackageParser.collectCertificates(pkg, parseFlags);
            }
        } else {
            PackageParser.collectCertificates(pkg, parseFlags);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.getRenamedPackageLPr(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent persistent apps from being updated
                if ((oldPackage.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) != 0) {
                    res.setError(PackageManager.INSTALL_FAILED_PERSISTENT_APP_NOT_UPDATEABLE, "Package " + oldPackage.packageName + " is a persistent app. " + "Persistent apps are not updateable.");
                    return;
                }
                // Prevent apps from downgrading their targetSandbox.
                final int oldTargetSandbox = oldPackage.applicationInfo.targetSandboxVersion;
                final int newTargetSandbox = pkg.applicationInfo.targetSandboxVersion;
                if (oldTargetSandbox == 2 && newTargetSandbox != 2) {
                    res.setError(PackageManager.INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Package " + pkg.packageName + " new target sandbox " + newTargetSandbox + " is incompatible with the previous value of" + oldTargetSandbox + ".");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // Static shared libs have same package with different versions where
            // we internally use a synthetic package name to allow multiple versions
            // of the same package, therefore we need to compare signatures against
            // the package setting for the latest library version.
            PackageSetting signatureCheckPs = ps;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                if (libraryEntry != null) {
                    signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);
                }
            }
            // bail early here before tripping over redefined permissions.
            if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
                if (!checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    verifySignaturesLP(signatureCheckPs, pkg);
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            PackageParser.Permission perm = pkg.permissions.get(i);
            BasePermission bp = mSettings.mPermissions.get(perm.info.name);
            // Don't allow anyone but the system to define ephemeral permissions.
            if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_FLAG_EPHEMERAL) != 0 && !systemApp) {
                Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                perm.info.protectionLevel &= ~PermissionInfo.PROTECTION_FLAG_EPHEMERAL;
            }
            // Check whether the newly-scanned package wants to define an already-defined perm
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) {
                    sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                } else {
                    sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!bp.sourcePackage.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                        res.origPermission = perm.info.name;
                        res.origPackage = bp.sourcePackage;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName)) {
                    // it as dangerous leading to the group auto-grant.
                    if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS) {
                        if (bp != null && !bp.isRuntime()) {
                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                            perm.info.protectionLevel = bp.protectionLevel;
                        }
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (instantApp) {
            // Abort update; system app can't be replaced with an instant app
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Cannot update a system app with an instant app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, extractNativeLibs, mAppLib32InstallDir);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPr(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
        // via gservices.
        if (!instantApp || Global.getInt(mContext.getContentResolver(), Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0) {
            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
            // Do not run PackageDexOptimizer through the local performDexOpt
            // method because `pkg` may not be in `mPackages` yet.
            // 
            // Also, don't fail application installs if the dexopt step fails.
            mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, /* instructionSets */
            false, /* checkProfiles */
            getCompilerFilterForReason(REASON_INSTALL), getOrCreateCompilerPackageStats(pkg), mDexManager.isUsedByOtherApps(pkg.packageName), true);
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }
        // Notify BackgroundDexOptService that the package has been changed.
        // If this is an update of a package which used to fail to compile,
        // BDOS will remove it from its blacklist.
        // TODO: Layering violation
        BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                // Static libs have a synthetic package name containing the version
                // and cannot be updated as an update would get a new package name,
                // unless this is the exact same version code which is useful for
                // development.
                PackageParser.Package existingPkg = mPackages.get(pkg.packageName);
                if (existingPkg != null && existingPkg.mVersionCode != pkg.mVersionCode) {
                    res.setError(INSTALL_FAILED_DUPLICATE_PACKAGE, "Packages declaring " + "static-shared libs cannot be updated");
                    return;
                }
            }
            replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res, args.installReason);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res, args.installReason);
        }
    }
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
            ps.setUpdateAvailable(false);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            updateSequenceNumberLP(ps, res.newUsers);
            updateInstantAppInstallerLocked(pkgName);
        }
    }
}
#method_after
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    boolean replace = false;
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    if (instantApp) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (fullApp) {
        scanFlags |= SCAN_AS_FULL_APP;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (instantApp && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (instantApp ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    pp.setCallback(mPackageParserCallback);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Instant apps must have target SDK >= O and have targetSanboxVersion >= 2
    if (instantApp && pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.N_MR1) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target O");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must target O");
        return;
    }
    if (instantApp && pkg.applicationInfo.targetSandboxVersion != 2) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must use targetSanboxVersion 2");
        return;
    }
    if (pkg.applicationInfo.isStaticSharedLibrary()) {
        // Static shared libraries have synthetic package names
        renameStaticSharedLibraryPackage(pkg);
        // No static shared libs on external storage
        if (onExternal) {
            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Packages declaring static-shared libs cannot be updated");
            return;
        }
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo(this);
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.certificates != null) {
            try {
                PackageParser.populateCertificates(pkg, args.certificates);
            } catch (PackageParserException e) {
                // there was something wrong with the certificates we were given;
                // try to pull them from the APK
                PackageParser.collectCertificates(pkg, parseFlags);
            }
        } else {
            PackageParser.collectCertificates(pkg, parseFlags);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.getRenamedPackageLPr(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent persistent apps from being updated
                if ((oldPackage.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) != 0) {
                    res.setError(PackageManager.INSTALL_FAILED_INVALID_APK, "Package " + oldPackage.packageName + " is a persistent app. " + "Persistent apps are not updateable.");
                    return;
                }
                // Prevent apps from downgrading their targetSandbox.
                final int oldTargetSandbox = oldPackage.applicationInfo.targetSandboxVersion;
                final int newTargetSandbox = pkg.applicationInfo.targetSandboxVersion;
                if (oldTargetSandbox == 2 && newTargetSandbox != 2) {
                    res.setError(PackageManager.INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Package " + pkg.packageName + " new target sandbox " + newTargetSandbox + " is incompatible with the previous value of" + oldTargetSandbox + ".");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // Static shared libs have same package with different versions where
            // we internally use a synthetic package name to allow multiple versions
            // of the same package, therefore we need to compare signatures against
            // the package setting for the latest library version.
            PackageSetting signatureCheckPs = ps;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                if (libraryEntry != null) {
                    signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);
                }
            }
            // bail early here before tripping over redefined permissions.
            if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
                if (!checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    verifySignaturesLP(signatureCheckPs, pkg);
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            PackageParser.Permission perm = pkg.permissions.get(i);
            BasePermission bp = mSettings.mPermissions.get(perm.info.name);
            // Don't allow anyone but the system to define ephemeral permissions.
            if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_FLAG_EPHEMERAL) != 0 && !systemApp) {
                Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                perm.info.protectionLevel &= ~PermissionInfo.PROTECTION_FLAG_EPHEMERAL;
            }
            // Check whether the newly-scanned package wants to define an already-defined perm
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) {
                    sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                } else {
                    sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!bp.sourcePackage.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                        res.origPermission = perm.info.name;
                        res.origPackage = bp.sourcePackage;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName)) {
                    // it as dangerous leading to the group auto-grant.
                    if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS) {
                        if (bp != null && !bp.isRuntime()) {
                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                            perm.info.protectionLevel = bp.protectionLevel;
                        }
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (instantApp) {
            // Abort update; system app can't be replaced with an instant app
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Cannot update a system app with an instant app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, extractNativeLibs, mAppLib32InstallDir);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPr(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
        // via gservices.
        if (!instantApp || Global.getInt(mContext.getContentResolver(), Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0) {
            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
            // Do not run PackageDexOptimizer through the local performDexOpt
            // method because `pkg` may not be in `mPackages` yet.
            // 
            // Also, don't fail application installs if the dexopt step fails.
            mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, /* instructionSets */
            false, /* checkProfiles */
            getCompilerFilterForReason(REASON_INSTALL), getOrCreateCompilerPackageStats(pkg), mDexManager.isUsedByOtherApps(pkg.packageName), true);
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }
        // Notify BackgroundDexOptService that the package has been changed.
        // If this is an update of a package which used to fail to compile,
        // BDOS will remove it from its blacklist.
        // TODO: Layering violation
        BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                // Static libs have a synthetic package name containing the version
                // and cannot be updated as an update would get a new package name,
                // unless this is the exact same version code which is useful for
                // development.
                PackageParser.Package existingPkg = mPackages.get(pkg.packageName);
                if (existingPkg != null && existingPkg.mVersionCode != pkg.mVersionCode) {
                    res.setError(INSTALL_FAILED_DUPLICATE_PACKAGE, "Packages declaring " + "static-shared libs cannot be updated");
                    return;
                }
            }
            replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res, args.installReason);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res, args.installReason);
        }
    }
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
            ps.setUpdateAvailable(false);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            updateSequenceNumberLP(ps, res.newUsers);
            updateInstantAppInstallerLocked(pkgName);
        }
    }
}
#end_block

#method_before
@Test
@SmallTest
public void testSmsHandleStateUpdate() throws Exception {
    assertEquals(SmsConstants.FORMAT_UNKNOWN, mImsSmsDispatcher.getImsSmsFormat());
    // Mock ImsNetWorkStateChange with GSM phone type
    switchImsSmsFormat(PhoneConstants.PHONE_TYPE_GSM);
    assertEquals(SmsConstants.FORMAT_3GPP, mImsSmsDispatcher.getImsSmsFormat());
    assertTrue(mImsSmsDispatcher.isIms());
    // Mock ImsNetWorkStateChange with Cdma Phone type
    switchImsSmsFormat(PhoneConstants.PHONE_TYPE_CDMA);
    assertEquals(SmsConstants.FORMAT_3GPP2, mImsSmsDispatcher.getImsSmsFormat());
    assertTrue(mImsSmsDispatcher.isIms());
}
#method_after
@Test
@SmallTest
@FlakyTest
@Ignore
public void testSmsHandleStateUpdate() throws Exception {
    assertEquals(SmsConstants.FORMAT_UNKNOWN, mImsSmsDispatcher.getImsSmsFormat());
    // Mock ImsNetWorkStateChange with GSM phone type
    switchImsSmsFormat(PhoneConstants.PHONE_TYPE_GSM);
    assertEquals(SmsConstants.FORMAT_3GPP, mImsSmsDispatcher.getImsSmsFormat());
    assertTrue(mImsSmsDispatcher.isIms());
    // Mock ImsNetWorkStateChange with Cdma Phone type
    switchImsSmsFormat(PhoneConstants.PHONE_TYPE_CDMA);
    assertEquals(SmsConstants.FORMAT_3GPP2, mImsSmsDispatcher.getImsSmsFormat());
    assertTrue(mImsSmsDispatcher.isIms());
}
#end_block

#method_before
@Test
@SmallTest
public void testSendImsGmsTest() throws Exception {
    switchImsSmsFormat(PhoneConstants.PHONE_TYPE_GSM);
    mImsSmsDispatcher.sendText("111", /* desAddr*/
    "222", /*scAddr*/
    TAG, null, null, null, null, false, -1, false, -1);
    verify(mSimulatedCommandsVerifier).sendImsGsmSms(eq("038122f2"), eq("0100038111f1000014c9f67cda9c12d37378983e4697e5d4f29c0e"), eq(0), eq(0), any(Message.class));
}
#method_after
@Test
@SmallTest
@FlakyTest
@Ignore
public void testSendImsGmsTest() throws Exception {
    switchImsSmsFormat(PhoneConstants.PHONE_TYPE_GSM);
    mImsSmsDispatcher.sendText("111", /* desAddr*/
    "222", /*scAddr*/
    TAG, null, null, null, null, false, -1, false, -1);
    verify(mSimulatedCommandsVerifier).sendImsGsmSms(eq("038122f2"), eq("0100038111f1000014c9f67cda9c12d37378983e4697e5d4f29c0e"), eq(0), eq(0), any(Message.class));
}
#end_block

#method_before
@Test
@SmallTest
public void testInjectNullSmsPdu() throws Exception {
    // unmock ActivityManager to be able to register receiver, create real PendingIntent and
    // receive TEST_INTENT
    restoreInstance(Singleton.class, "mInstance", mIActivityManagerSingleton);
    restoreInstance(ActivityManagerNative.class, "gDefault", null);
    Context realContext = TestApplication.getAppContext();
    realContext.registerReceiver(mTestReceiver, new IntentFilter(TEST_INTENT));
    PendingIntent pendingIntent = PendingIntent.getBroadcast(realContext, 0, new Intent(TEST_INTENT), 0);
    // inject null sms pdu. This should cause intent to be received since pdu is null.
    mImsSmsDispatcher.injectSmsPdu(null, SmsConstants.FORMAT_3GPP, pendingIntent);
    waitForMs(100);
    synchronized (mLock) {
        assertEquals(true, mReceivedTestIntent);
    }
}
#method_after
@Test
@SmallTest
public void testInjectNullSmsPdu() throws Exception {
    // unmock ActivityManager to be able to register receiver, create real PendingIntent and
    // receive TEST_INTENT
    restoreInstance(Singleton.class, "mInstance", mIActivityManagerSingleton);
    restoreInstance(ActivityManager.class, "IActivityManagerSingleton", null);
    Context realContext = TestApplication.getAppContext();
    realContext.registerReceiver(mTestReceiver, new IntentFilter(TEST_INTENT));
    PendingIntent pendingIntent = PendingIntent.getBroadcast(realContext, 0, new Intent(TEST_INTENT), 0);
    // inject null sms pdu. This should cause intent to be received since pdu is null.
    mImsSmsDispatcher.injectSmsPdu(null, SmsConstants.FORMAT_3GPP, pendingIntent);
    waitForMs(100);
    synchronized (mLock) {
        assertEquals(true, mReceivedTestIntent);
    }
}
#end_block

#method_before
@Override
public void sendData(String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddr, destAddr, destPort, data, (deliveryIntent != null));
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destAddr, scAddr, destPort, data, pdu);
        SmsTracker tracker = getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), null, /*messageUri*/
        false, /*isExpectMore*/
        null, /*fullMessageText*/
        false, /*isText*/
        true);
        String carrierPackage = getCarrierAppPackageName();
        if (carrierPackage != null) {
            Rlog.d(TAG, "Found carrier package.");
            DataSmsSender smsSender = new DataSmsSender(tracker);
            smsSender.sendSmsByCarrierApp(carrierPackage, new SmsSenderCallback(smsSender));
        } else {
            Rlog.v(TAG, "No carrier package.");
            sendSubmitPdu(tracker);
        }
    } else {
        Rlog.e(TAG, "CdmaSMSDispatcher.sendData(): getSubmitPdu() returned null");
        if (sentIntent != null) {
            try {
                sentIntent.send(SmsManager.RESULT_ERROR_GENERIC_FAILURE);
            } catch (CanceledException ex) {
                Rlog.e(TAG, "Intent has been canceled!");
            }
        }
    }
}
#method_after
@Override
public void sendData(String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddr, destAddr, destPort, data, (deliveryIntent != null));
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destAddr, scAddr, destPort, data, pdu);
        SmsTracker tracker = getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), null, /*messageUri*/
        false, /*expectMore*/
        null, /*fullMessageText*/
        false, /*isText*/
        true);
        String carrierPackage = getCarrierAppPackageName();
        if (carrierPackage != null) {
            Rlog.d(TAG, "Found carrier package.");
            DataSmsSender smsSender = new DataSmsSender(tracker);
            smsSender.sendSmsByCarrierApp(carrierPackage, new SmsSenderCallback(smsSender));
        } else {
            Rlog.v(TAG, "No carrier package.");
            sendSubmitPdu(tracker);
        }
    } else {
        Rlog.e(TAG, "CdmaSMSDispatcher.sendData(): getSubmitPdu() returned null");
        if (sentIntent != null) {
            try {
                sentIntent.send(SmsManager.RESULT_ERROR_GENERIC_FAILURE);
            } catch (CanceledException ex) {
                Rlog.e(TAG, "Intent has been canceled!");
            }
        }
    }
}
#end_block

#method_before
@Override
public void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean isExpectMore, int validityPeriod) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddr, destAddr, text, (deliveryIntent != null), null, priority);
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destAddr, scAddr, text, pdu);
        SmsTracker tracker = getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), messageUri, isExpectMore, text, true, /*isText*/
        persistMessage, validityPeriod);
        String carrierPackage = getCarrierAppPackageName();
        if (carrierPackage != null) {
            Rlog.d(TAG, "Found carrier package.");
            TextSmsSender smsSender = new TextSmsSender(tracker);
            smsSender.sendSmsByCarrierApp(carrierPackage, new SmsSenderCallback(smsSender));
        } else {
            Rlog.v(TAG, "No carrier package.");
            sendSubmitPdu(tracker);
        }
    } else {
        Rlog.e(TAG, "CdmaSMSDispatcher.sendText(): getSubmitPdu() returned null");
        if (sentIntent != null) {
            try {
                sentIntent.send(SmsManager.RESULT_ERROR_GENERIC_FAILURE);
            } catch (CanceledException ex) {
                Rlog.e(TAG, "Intent has been canceled!");
            }
        }
    }
}
#method_after
@Override
public void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddr, destAddr, text, (deliveryIntent != null), null, priority);
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destAddr, scAddr, text, pdu);
        SmsTracker tracker = getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), messageUri, expectMore, text, true, /*isText*/
        persistMessage, priority, validityPeriod);
        String carrierPackage = getCarrierAppPackageName();
        if (carrierPackage != null) {
            Rlog.d(TAG, "Found carrier package.");
            TextSmsSender smsSender = new TextSmsSender(tracker);
            smsSender.sendSmsByCarrierApp(carrierPackage, new SmsSenderCallback(smsSender));
        } else {
            Rlog.v(TAG, "No carrier package.");
            sendSubmitPdu(tracker);
        }
    } else {
        Rlog.e(TAG, "CdmaSMSDispatcher.sendText(): getSubmitPdu() returned null");
        if (sentIntent != null) {
            try {
                sentIntent.send(SmsManager.RESULT_ERROR_GENERIC_FAILURE);
            } catch (CanceledException ex) {
                Rlog.e(TAG, "Intent has been canceled!");
            }
        }
    }
}
#end_block

#method_before
@Override
protected SmsTracker getNewSubmitPduTracker(String destinationAddress, String scAddress, String message, SmsHeader smsHeader, int encoding, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, String fullMessageText, int priority, boolean isExpectMore, int validityPeriod) {
    UserData uData = new UserData();
    uData.payloadStr = message;
    uData.userDataHeader = smsHeader;
    if (encoding == SmsConstants.ENCODING_7BIT) {
        uData.msgEncoding = UserData.ENCODING_GSM_7BIT_ALPHABET;
    } else {
        // assume UTF-16
        uData.msgEncoding = UserData.ENCODING_UNICODE_16;
    }
    uData.msgEncodingSet = true;
    /* By setting the statusReportRequested bit only for the
         * last message fragment, this will result in only one
         * callback to the sender when that last fragment delivery
         * has been acknowledged. */
    SmsMessage.SubmitPdu submitPdu = SmsMessage.getSubmitPdu(destinationAddress, uData, (deliveryIntent != null) && lastPart, priority);
    HashMap map = getSmsTrackerMap(destinationAddress, scAddress, message, submitPdu);
    return getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), unsentPartCount, anyPartFailed, messageUri, smsHeader, (!lastPart || isExpectMore), fullMessageText, true, /*isText*/
    true, /*persistMessage*/
    validityPeriod);
}
#method_after
@Override
protected SmsTracker getNewSubmitPduTracker(String destinationAddress, String scAddress, String message, SmsHeader smsHeader, int encoding, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, String fullMessageText, int priority, boolean expectMore, int validityPeriod) {
    UserData uData = new UserData();
    uData.payloadStr = message;
    uData.userDataHeader = smsHeader;
    if (encoding == SmsConstants.ENCODING_7BIT) {
        uData.msgEncoding = UserData.ENCODING_GSM_7BIT_ALPHABET;
    } else {
        // assume UTF-16
        uData.msgEncoding = UserData.ENCODING_UNICODE_16;
    }
    uData.msgEncodingSet = true;
    /* By setting the statusReportRequested bit only for the
         * last message fragment, this will result in only one
         * callback to the sender when that last fragment delivery
         * has been acknowledged. */
    SmsMessage.SubmitPdu submitPdu = SmsMessage.getSubmitPdu(destinationAddress, uData, (deliveryIntent != null) && lastPart, priority);
    HashMap map = getSmsTrackerMap(destinationAddress, scAddress, message, submitPdu);
    return getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), unsentPartCount, anyPartFailed, messageUri, smsHeader, (!lastPart || expectMore), fullMessageText, true, /*isText*/
    true, /*persistMessage*/
    priority, validityPeriod);
}
#end_block

#method_before
public void sendText(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    sendTextInternal(callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessageForNonDefaultSmsApp);
}
#method_after
public void sendText(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    sendTextInternal(callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessageForNonDefaultSmsApp, SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, false, /* expectMore */
    SMS_MESSAGE_PERIOD_NOT_SPECIFIED);
}
#end_block

#method_before
public void sendTextWithSelfPermissions(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
    mPhone.getContext().enforceCallingOrSelfPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    sendTextInternal(callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessage);
}
#method_after
public void sendTextWithSelfPermissions(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
    mPhone.getContext().enforceCallingOrSelfPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    sendTextInternal(callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessage, SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, false, /* expectMore */
    SMS_MESSAGE_PERIOD_NOT_SPECIFIED);
}
#end_block

#method_before
/**
 * Send a text based SMS.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *  the current default SMSC
 * @param text the body of the message to send
 * @param sentIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is successfully sent, or failed.
 *  The result code will be <code>Activity.RESULT_OK<code> for success,
 *  or one of these errors:<br>
 *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
 *  <code>RESULT_ERROR_RADIO_OFF</code><br>
 *  <code>RESULT_ERROR_NULL_PDU</code><br>
 *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
 *  the extra "errorCode" containing a radio technology specific value,
 *  generally only useful for troubleshooting.<br>
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is delivered to the recipient.  The
 *  raw pdu of the status report is in the extended data ("pdu").
 */
private void sendTextInternal(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) {
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        log("sendText: destAddr=" + destAddr + " scAddr=" + scAddr + " text='" + text + "' sentIntent=" + sentIntent + " deliveryIntent=" + deliveryIntent);
    }
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (!persistMessageForNonDefaultSmsApp) {
        enforcePrivilegedAppPermissions();
    }
    destAddr = filterDestAddress(destAddr);
    mDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, null, /*messageUri*/
    callingPackage, persistMessageForNonDefaultSmsApp, -1, false, -1);
}
#method_after
/**
 * Send a text based SMS.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *  the current default SMSC
 * @param text the body of the message to send
 * @param sentIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is successfully sent, or failed.
 *  The result code will be <code>Activity.RESULT_OK<code> for success,
 *  or one of these errors:<br>
 *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
 *  <code>RESULT_ERROR_RADIO_OFF</code><br>
 *  <code>RESULT_ERROR_NULL_PDU</code><br>
 *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
 *  the extra "errorCode" containing a radio technology specific value,
 *  generally only useful for troubleshooting.<br>
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is delivered to the recipient.  The
 *  raw pdu of the status report is in the extended data ("pdu").
 * @param persistMessageForNonDefaultSmsApp whether the sent message should
 *  be automatically persisted in the SMS db. It only affects messages sent
 *  by a non-default SMS app. Currently only the carrier app can set this
 *  parameter to false to skip auto message persistence.
 * @param priority Priority level of the message
 *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
 *  ---------------------------------
 *  PRIORITY      | Level of Priority
 *  ---------------------------------
 *      '00'      |     Normal
 *      '01'      |     Interactive
 *      '10'      |     Urgent
 *      '11'      |     Emergency
 *  ----------------------------------
 *  Any Other values including negative considered as Invalid Priority Indicator of the message.
 * @param expectMore is a boolean to indicate the sending messages through same link or not.
 * @param validityPeriod Validity Period of the message in mins.
 *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
 *  Validity Period(Minimum) -> 5 mins
 *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
 *  Any Other values including negative considered as Invalid Validity Period of the message.
 */
private void sendTextInternal(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore, int validityPeriod) {
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        log("sendText: destAddr=" + destAddr + " scAddr=" + scAddr + " text='" + text + "' sentIntent=" + sentIntent + " deliveryIntent=" + deliveryIntent + " priority=" + priority + " expectMore=" + expectMore + " validityPeriod=" + validityPeriod);
    }
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (!persistMessageForNonDefaultSmsApp) {
        enforcePrivilegedAppPermissions();
    }
    destAddr = filterDestAddress(destAddr);
    mDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, null, /*messageUri*/
    callingPackage, persistMessageForNonDefaultSmsApp, priority, expectMore, validityPeriod);
}
#end_block

#method_before
/**
 * Send a text based SMS with Messaging Options.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *  the current default SMSC
 * @param text the body of the message to send
 * @param sentIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is successfully sent, or failed.
 *  The result code will be <code>Activity.RESULT_OK<code> for success,
 *  or one of these errors:<br>
 *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
 *  <code>RESULT_ERROR_RADIO_OFF</code><br>
 *  <code>RESULT_ERROR_NULL_PDU</code><br>
 *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
 *  the extra "errorCode" containing a radio technology specific value,
 *  generally only useful for troubleshooting.<br>
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is delivered to the recipient.  The
 *  raw pdu of the status report is in the extended data ("pdu").
 * @param persistMessageForNonDefaultSmsApp whether the sent message should
 *  be automatically persisted in the SMS db. It only affects messages sent
 *  by a non-default SMS app. Currently only the carrier app can set this
 *  parameter to false to skip auto message persistence.
 * @param priority Priority level of the message
 *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
 *  ---------------------------------
 *  PRIORITY      | Level of Priority
 *  ---------------------------------
 *      '00'      |     Normal
 *      '01'      |     Interactive
 *      '10'      |     Urgent
 *      '11'      |     Emergency
 *  ----------------------------------
 *  Any Other values included Negative considered as Invalid Priority Indicator of the message.
 * @param isExpectMore is a boolean to indicate the sending message is multi segmented or not.
 * @param validityPeriod Validity Period of the message in mins.
 *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
 *  Validity Period(Minimum) -> 5 mins
 *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
 *  Any Other values included Negative considered as Invalid Validity Period of the message.
 */
public void sendTextWithOptions(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp, int priority, boolean isExpectMore, int validityPeriod) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        log("sendText: destAddr=" + destAddr + " scAddr=" + scAddr + " text='" + text + "' sentIntent=" + sentIntent + " deliveryIntent=" + deliveryIntent + "validityPeriod" + validityPeriod);
    }
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    mDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, null, /*messageUri*/
    callingPackage, persistMessageForNonDefaultSmsApp, priority, isExpectMore, validityPeriod);
}
#method_after
/**
 * Send a text based SMS with Messaging Options.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *  the current default SMSC
 * @param text the body of the message to send
 * @param sentIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is successfully sent, or failed.
 *  The result code will be <code>Activity.RESULT_OK<code> for success,
 *  or one of these errors:<br>
 *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
 *  <code>RESULT_ERROR_RADIO_OFF</code><br>
 *  <code>RESULT_ERROR_NULL_PDU</code><br>
 *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
 *  the extra "errorCode" containing a radio technology specific value,
 *  generally only useful for troubleshooting.<br>
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is delivered to the recipient.  The
 *  raw pdu of the status report is in the extended data ("pdu").
 * @param persistMessageForNonDefaultSmsApp whether the sent message should
 *  be automatically persisted in the SMS db. It only affects messages sent
 *  by a non-default SMS app. Currently only the carrier app can set this
 *  parameter to false to skip auto message persistence.
 * @param priority Priority level of the message
 *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
 *  ---------------------------------
 *  PRIORITY      | Level of Priority
 *  ---------------------------------
 *      '00'      |     Normal
 *      '01'      |     Interactive
 *      '10'      |     Urgent
 *      '11'      |     Emergency
 *  ----------------------------------
 *  Any Other values including negative considered as Invalid Priority Indicator of the message.
 * @param expectMore is a boolean to indicate the sending messages through same link or not.
 * @param validityPeriod Validity Period of the message in mins.
 *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
 *  Validity Period(Minimum) -> 5 mins
 *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
 *  Any Other values including negative considered as Invalid Validity Period of the message.
 */
public void sendTextWithOptions(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore, int validityPeriod) {
    mPhone.getContext().enforceCallingOrSelfPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    sendTextInternal(callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessageForNonDefaultSmsApp, priority, expectMore, validityPeriod);
}
#end_block

#method_before
/**
 * Send a multi-part text based SMS.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *   the current default SMSC
 * @param parts an <code>ArrayList</code> of strings that, in order,
 *   comprise the original message
 * @param sentIntents if not null, an <code>ArrayList</code> of
 *   <code>PendingIntent</code>s (one for each message part) that is
 *   broadcast when the corresponding message part has been sent.
 *   The result code will be <code>Activity.RESULT_OK<code> for success,
 *   or one of these errors:
 *   <code>RESULT_ERROR_GENERIC_FAILURE</code>
 *   <code>RESULT_ERROR_RADIO_OFF</code>
 *   <code>RESULT_ERROR_NULL_PDU</code>.
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntents if not null, an <code>ArrayList</code> of
 *   <code>PendingIntent</code>s (one for each message part) that is
 *   broadcast when the corresponding message part has been delivered
 *   to the recipient.  The raw pdu of the status report is in the
 *   extended data ("pdu").
 */
public void sendMultipartText(String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    if (!persistMessageForNonDefaultSmsApp) {
        // Only allow carrier app or carrier ims to skip auto message persistence.
        enforcePrivilegedAppPermissions();
    }
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        int i = 0;
        for (String part : parts) {
            log("sendMultipartText: destAddr=" + destAddr + ", srAddr=" + scAddr + ", part[" + (i++) + "]=" + part);
        }
    }
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    destAddr = filterDestAddress(destAddr);
    if (parts.size() > 1 && parts.size() < 10 && !SmsMessage.hasEmsSupport()) {
        for (int i = 0; i < parts.size(); i++) {
            // If EMS is not supported, we have to break down EMS into single segment SMS
            // and add page info " x/y".
            String singlePart = parts.get(i);
            if (SmsMessage.shouldAppendPageNumberAsPrefix()) {
                singlePart = String.valueOf(i + 1) + '/' + parts.size() + ' ' + singlePart;
            } else {
                singlePart = singlePart.concat(' ' + String.valueOf(i + 1) + '/' + parts.size());
            }
            PendingIntent singleSentIntent = null;
            if (sentIntents != null && sentIntents.size() > i) {
                singleSentIntent = sentIntents.get(i);
            }
            PendingIntent singleDeliveryIntent = null;
            if (deliveryIntents != null && deliveryIntents.size() > i) {
                singleDeliveryIntent = deliveryIntents.get(i);
            }
            mDispatcher.sendText(destAddr, scAddr, singlePart, singleSentIntent, singleDeliveryIntent, null, /*messageUri*/
            callingPackage, persistMessageForNonDefaultSmsApp, -1, false, -1);
        }
        return;
    }
    mDispatcher.sendMultipartText(destAddr, scAddr, (ArrayList<String>) parts, (ArrayList<PendingIntent>) sentIntents, (ArrayList<PendingIntent>) deliveryIntents, null, /*messageUri*/
    callingPackage, persistMessageForNonDefaultSmsApp, -1, false, -1);
}
#method_after
/**
 * Send a multi-part text based SMS.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *   the current default SMSC
 * @param parts an <code>ArrayList</code> of strings that, in order,
 *   comprise the original message
 * @param sentIntents if not null, an <code>ArrayList</code> of
 *   <code>PendingIntent</code>s (one for each message part) that is
 *   broadcast when the corresponding message part has been sent.
 *   The result code will be <code>Activity.RESULT_OK<code> for success,
 *   or one of these errors:
 *   <code>RESULT_ERROR_GENERIC_FAILURE</code>
 *   <code>RESULT_ERROR_RADIO_OFF</code>
 *   <code>RESULT_ERROR_NULL_PDU</code>.
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntents if not null, an <code>ArrayList</code> of
 *   <code>PendingIntent</code>s (one for each message part) that is
 *   broadcast when the corresponding message part has been delivered
 *   to the recipient.  The raw pdu of the status report is in the
 *   extended data ("pdu").
 */
public void sendMultipartText(String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp) {
    sendMultipartTextWithOptions(callingPackage, destAddr, destAddr, parts, sentIntents, deliveryIntents, persistMessageForNonDefaultSmsApp, SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, false, /* expectMore */
    SMS_MESSAGE_PERIOD_NOT_SPECIFIED);
}
#end_block

#method_before
/**
 * Send a multi-part text based SMS with Messaging Options.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *   the current default SMSC
 * @param parts an <code>ArrayList</code> of strings that, in order,
 *   comprise the original message
 * @param sentIntents if not null, an <code>ArrayList</code> of
 *   <code>PendingIntent</code>s (one for each message part) that is
 *   broadcast when the corresponding message part has been sent.
 *   The result code will be <code>Activity.RESULT_OK<code> for success,
 *   or one of these errors:
 *   <code>RESULT_ERROR_GENERIC_FAILURE</code>
 *   <code>RESULT_ERROR_RADIO_OFF</code>
 *   <code>RESULT_ERROR_NULL_PDU</code>.
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntents if not null, an <code>ArrayList</code> of
 *   <code>PendingIntent</code>s (one for each message part) that is
 *   broadcast when the corresponding message part has been delivered
 *   to the recipient.  The raw pdu of the status report is in the
 *   extended data ("pdu").
 * @param persistMessageForNonDefaultSmsApp whether the sent message should
 *   be automatically persisted in the SMS db. It only affects messages sent
 *   by a non-default SMS app. Currently only the carrier app can set this
 *   parameter to false to skip auto message persistence.
 * @param priority Priority level of the message
 *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
 *  ---------------------------------
 *  PRIORITY      | Level of Priority
 *  ---------------------------------
 *      '00'      |     Normal
 *      '01'      |     Interactive
 *      '10'      |     Urgent
 *      '11'      |     Emergency
 *  ----------------------------------
 *  Any Other values included Negative considered as Invalid Priority Indicator of the message.
 * @param isExpectMore is a boolean to indicate the sending message is multi segmented or not.
 * @param validityPeriod Validity Period of the message in mins.
 *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
 *  Validity Period(Minimum) -> 5 mins
 *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
 *  Any Other values included Negative considered as Invalid Validity Period of the message.
 */
public void sendMultipartTextWithOptions(String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp, int priority, boolean isExpectMore, int validityPeriod) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        int i = 0;
        for (String part : parts) {
            log("sendMultipartTextWithOptions: destAddr=" + destAddr + ", srAddr=" + scAddr + ", part[" + (i++) + "]=" + part);
        }
    }
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    destAddr = filterDestAddress(destAddr);
    if (parts.size() > 1 && parts.size() < 10 && !SmsMessage.hasEmsSupport()) {
        for (int i = 0; i < parts.size(); i++) {
            // If EMS is not supported, we have to break down EMS into single segment SMS
            // and add page info " x/y".
            String singlePart = parts.get(i);
            if (SmsMessage.shouldAppendPageNumberAsPrefix()) {
                singlePart = String.valueOf(i + 1) + '/' + parts.size() + ' ' + singlePart;
            } else {
                singlePart = singlePart.concat(' ' + String.valueOf(i + 1) + '/' + parts.size());
            }
            PendingIntent singleSentIntent = null;
            if (sentIntents != null && sentIntents.size() > i) {
                singleSentIntent = sentIntents.get(i);
            }
            PendingIntent singleDeliveryIntent = null;
            if (deliveryIntents != null && deliveryIntents.size() > i) {
                singleDeliveryIntent = deliveryIntents.get(i);
            }
            mDispatcher.sendText(destAddr, scAddr, singlePart, singleSentIntent, singleDeliveryIntent, null, /*messageUri*/
            callingPackage, persistMessageForNonDefaultSmsApp, priority, isExpectMore, validityPeriod);
        }
        return;
    }
    mDispatcher.sendMultipartText(destAddr, scAddr, (ArrayList<String>) parts, (ArrayList<PendingIntent>) sentIntents, (ArrayList<PendingIntent>) deliveryIntents, null, callingPackage, persistMessageForNonDefaultSmsApp, priority, isExpectMore, validityPeriod);
}
#method_after
/**
 * Send a multi-part text based SMS with Messaging Options.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *   the current default SMSC
 * @param parts an <code>ArrayList</code> of strings that, in order,
 *   comprise the original message
 * @param sentIntents if not null, an <code>ArrayList</code> of
 *   <code>PendingIntent</code>s (one for each message part) that is
 *   broadcast when the corresponding message part has been sent.
 *   The result code will be <code>Activity.RESULT_OK<code> for success,
 *   or one of these errors:
 *   <code>RESULT_ERROR_GENERIC_FAILURE</code>
 *   <code>RESULT_ERROR_RADIO_OFF</code>
 *   <code>RESULT_ERROR_NULL_PDU</code>.
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntents if not null, an <code>ArrayList</code> of
 *   <code>PendingIntent</code>s (one for each message part) that is
 *   broadcast when the corresponding message part has been delivered
 *   to the recipient.  The raw pdu of the status report is in the
 *   extended data ("pdu").
 * @param persistMessageForNonDefaultSmsApp whether the sent message should
 *   be automatically persisted in the SMS db. It only affects messages sent
 *   by a non-default SMS app. Currently only the carrier app can set this
 *   parameter to false to skip auto message persistence.
 * @param priority Priority level of the message
 *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
 *  ---------------------------------
 *  PRIORITY      | Level of Priority
 *  ---------------------------------
 *      '00'      |     Normal
 *      '01'      |     Interactive
 *      '10'      |     Urgent
 *      '11'      |     Emergency
 *  ----------------------------------
 *  Any Other values including negative considered as Invalid Priority Indicator of the message.
 * @param expectMore is a boolean to indicate the sending messages through same link or not.
 * @param validityPeriod Validity Period of the message in mins.
 *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
 *  Validity Period(Minimum) -> 5 mins
 *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
 *  Any Other values including negative considered as Invalid Validity Period of the message.
 */
public void sendMultipartTextWithOptions(String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore, int validityPeriod) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    if (!persistMessageForNonDefaultSmsApp) {
        // Only allow carrier app or carrier ims to skip auto message persistence.
        enforcePrivilegedAppPermissions();
    }
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        int i = 0;
        for (String part : parts) {
            log("sendMultipartTextWithOptions: destAddr=" + destAddr + ", srAddr=" + scAddr + ", part[" + (i++) + "]=" + part);
        }
    }
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    destAddr = filterDestAddress(destAddr);
    if (parts.size() > 1 && parts.size() < 10 && !SmsMessage.hasEmsSupport()) {
        for (int i = 0; i < parts.size(); i++) {
            // If EMS is not supported, we have to break down EMS into single segment SMS
            // and add page info " x/y".
            String singlePart = parts.get(i);
            if (SmsMessage.shouldAppendPageNumberAsPrefix()) {
                singlePart = String.valueOf(i + 1) + '/' + parts.size() + ' ' + singlePart;
            } else {
                singlePart = singlePart.concat(' ' + String.valueOf(i + 1) + '/' + parts.size());
            }
            PendingIntent singleSentIntent = null;
            if (sentIntents != null && sentIntents.size() > i) {
                singleSentIntent = sentIntents.get(i);
            }
            PendingIntent singleDeliveryIntent = null;
            if (deliveryIntents != null && deliveryIntents.size() > i) {
                singleDeliveryIntent = deliveryIntents.get(i);
            }
            mDispatcher.sendText(destAddr, scAddr, singlePart, singleSentIntent, singleDeliveryIntent, null, /*messageUri*/
            callingPackage, persistMessageForNonDefaultSmsApp, priority, expectMore, validityPeriod);
        }
        return;
    }
    mDispatcher.sendMultipartText(destAddr, scAddr, (ArrayList<String>) parts, (ArrayList<PendingIntent>) sentIntents, (ArrayList<PendingIntent>) deliveryIntents, null, callingPackage, persistMessageForNonDefaultSmsApp, priority, expectMore, validityPeriod);
}
#end_block

#method_before
public void sendStoredText(String callingPkg, Uri messageUri, String scAddress, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        log("sendStoredText: scAddr=" + scAddress + " messageUri=" + messageUri + " sentIntent=" + sentIntent + " deliveryIntent=" + deliveryIntent);
    }
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPkg) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    final ContentResolver resolver = mPhone.getContext().getContentResolver();
    if (!isFailedOrDraft(resolver, messageUri)) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredText: not FAILED or DRAFT message");
        returnUnspecifiedFailure(sentIntent);
        return;
    }
    final String[] textAndAddress = loadTextAndAddress(resolver, messageUri);
    if (textAndAddress == null) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredText: can not load text");
        returnUnspecifiedFailure(sentIntent);
        return;
    }
    textAndAddress[1] = filterDestAddress(textAndAddress[1]);
    mDispatcher.sendText(textAndAddress[1], scAddress, textAndAddress[0], sentIntent, deliveryIntent, messageUri, callingPkg, true, /* persistMessageForNonDefaultSmsApp */
    -1, false, -1);
}
#method_after
public void sendStoredText(String callingPkg, Uri messageUri, String scAddress, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        log("sendStoredText: scAddr=" + scAddress + " messageUri=" + messageUri + " sentIntent=" + sentIntent + " deliveryIntent=" + deliveryIntent);
    }
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPkg) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    final ContentResolver resolver = mPhone.getContext().getContentResolver();
    if (!isFailedOrDraft(resolver, messageUri)) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredText: not FAILED or DRAFT message");
        returnUnspecifiedFailure(sentIntent);
        return;
    }
    final String[] textAndAddress = loadTextAndAddress(resolver, messageUri);
    if (textAndAddress == null) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredText: can not load text");
        returnUnspecifiedFailure(sentIntent);
        return;
    }
    textAndAddress[1] = filterDestAddress(textAndAddress[1]);
    mDispatcher.sendText(textAndAddress[1], scAddress, textAndAddress[0], sentIntent, deliveryIntent, messageUri, callingPkg, true, /* persistMessageForNonDefaultSmsApp */
    SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, false, /* expectMore */
    SMS_MESSAGE_PERIOD_NOT_SPECIFIED);
}
#end_block

#method_before
public void sendStoredMultipartText(String callingPkg, Uri messageUri, String scAddress, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPkg) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    final ContentResolver resolver = mPhone.getContext().getContentResolver();
    if (!isFailedOrDraft(resolver, messageUri)) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredMultipartText: " + "not FAILED or DRAFT message");
        returnUnspecifiedFailure(sentIntents);
        return;
    }
    final String[] textAndAddress = loadTextAndAddress(resolver, messageUri);
    if (textAndAddress == null) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredMultipartText: can not load text");
        returnUnspecifiedFailure(sentIntents);
        return;
    }
    final ArrayList<String> parts = SmsManager.getDefault().divideMessage(textAndAddress[0]);
    if (parts == null || parts.size() < 1) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredMultipartText: can not divide text");
        returnUnspecifiedFailure(sentIntents);
        return;
    }
    textAndAddress[1] = filterDestAddress(textAndAddress[1]);
    if (parts.size() > 1 && parts.size() < 10 && !SmsMessage.hasEmsSupport()) {
        for (int i = 0; i < parts.size(); i++) {
            // If EMS is not supported, we have to break down EMS into single segment SMS
            // and add page info " x/y".
            String singlePart = parts.get(i);
            if (SmsMessage.shouldAppendPageNumberAsPrefix()) {
                singlePart = String.valueOf(i + 1) + '/' + parts.size() + ' ' + singlePart;
            } else {
                singlePart = singlePart.concat(' ' + String.valueOf(i + 1) + '/' + parts.size());
            }
            PendingIntent singleSentIntent = null;
            if (sentIntents != null && sentIntents.size() > i) {
                singleSentIntent = sentIntents.get(i);
            }
            PendingIntent singleDeliveryIntent = null;
            if (deliveryIntents != null && deliveryIntents.size() > i) {
                singleDeliveryIntent = deliveryIntents.get(i);
            }
            mDispatcher.sendText(textAndAddress[1], scAddress, singlePart, singleSentIntent, singleDeliveryIntent, messageUri, callingPkg, true, /* persistMessageForNonDefaultSmsApp */
            -1, false, -1);
        }
        return;
    }
    mDispatcher.sendMultipartText(// destAddress
    textAndAddress[1], scAddress, parts, (ArrayList<PendingIntent>) sentIntents, (ArrayList<PendingIntent>) deliveryIntents, messageUri, callingPkg, true, /* persistMessageForNonDefaultSmsApp */
    -1, false, -1);
}
#method_after
public void sendStoredMultipartText(String callingPkg, Uri messageUri, String scAddress, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) {
    mPhone.getContext().enforceCallingPermission(Manifest.permission.SEND_SMS, "Sending SMS message");
    if (mAppOps.noteOp(AppOpsManager.OP_SEND_SMS, Binder.getCallingUid(), callingPkg) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    final ContentResolver resolver = mPhone.getContext().getContentResolver();
    if (!isFailedOrDraft(resolver, messageUri)) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredMultipartText: " + "not FAILED or DRAFT message");
        returnUnspecifiedFailure(sentIntents);
        return;
    }
    final String[] textAndAddress = loadTextAndAddress(resolver, messageUri);
    if (textAndAddress == null) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredMultipartText: can not load text");
        returnUnspecifiedFailure(sentIntents);
        return;
    }
    final ArrayList<String> parts = SmsManager.getDefault().divideMessage(textAndAddress[0]);
    if (parts == null || parts.size() < 1) {
        Log.e(LOG_TAG, "[IccSmsInterfaceManager]sendStoredMultipartText: can not divide text");
        returnUnspecifiedFailure(sentIntents);
        return;
    }
    textAndAddress[1] = filterDestAddress(textAndAddress[1]);
    if (parts.size() > 1 && parts.size() < 10 && !SmsMessage.hasEmsSupport()) {
        for (int i = 0; i < parts.size(); i++) {
            // If EMS is not supported, we have to break down EMS into single segment SMS
            // and add page info " x/y".
            String singlePart = parts.get(i);
            if (SmsMessage.shouldAppendPageNumberAsPrefix()) {
                singlePart = String.valueOf(i + 1) + '/' + parts.size() + ' ' + singlePart;
            } else {
                singlePart = singlePart.concat(' ' + String.valueOf(i + 1) + '/' + parts.size());
            }
            PendingIntent singleSentIntent = null;
            if (sentIntents != null && sentIntents.size() > i) {
                singleSentIntent = sentIntents.get(i);
            }
            PendingIntent singleDeliveryIntent = null;
            if (deliveryIntents != null && deliveryIntents.size() > i) {
                singleDeliveryIntent = deliveryIntents.get(i);
            }
            mDispatcher.sendText(textAndAddress[1], scAddress, singlePart, singleSentIntent, singleDeliveryIntent, messageUri, callingPkg, true, /* persistMessageForNonDefaultSmsApp */
            SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, false, /* expectMore */
            SMS_MESSAGE_PERIOD_NOT_SPECIFIED);
        }
        return;
    }
    mDispatcher.sendMultipartText(// destAddress
    textAndAddress[1], scAddress, parts, (ArrayList<PendingIntent>) sentIntents, (ArrayList<PendingIntent>) deliveryIntents, messageUri, callingPkg, true, /* persistMessageForNonDefaultSmsApp */
    SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, false, /* expectMore */
    SMS_MESSAGE_PERIOD_NOT_SPECIFIED);
}
#end_block

#method_before
@Override
public void sendMultipartText(String destAddr, String scAddr, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean isExpectMore, int validityPeriod) {
    if (isCdmaMo()) {
        mCdmaDispatcher.sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, messageUri, callingPkg, persistMessage, priority, isExpectMore, validityPeriod);
    } else {
        mGsmDispatcher.sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, messageUri, callingPkg, persistMessage, priority, isExpectMore, validityPeriod);
    }
}
#method_after
@Override
public void sendMultipartText(String destAddr, String scAddr, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    if (isCdmaMo()) {
        mCdmaDispatcher.sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, messageUri, callingPkg, persistMessage, priority, expectMore, validityPeriod);
    } else {
        mGsmDispatcher.sendMultipartText(destAddr, scAddr, parts, sentIntents, deliveryIntents, messageUri, callingPkg, persistMessage, priority, expectMore, validityPeriod);
    }
}
#end_block

#method_before
@Override
public void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean isExpectMore, int validityPeriod) {
    Rlog.d(TAG, "sendText");
    if (isCdmaMo()) {
        mCdmaDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, messageUri, callingPkg, persistMessage, priority, isExpectMore, validityPeriod);
    } else {
        mGsmDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, messageUri, callingPkg, persistMessage, priority, isExpectMore, validityPeriod);
    }
}
#method_after
@Override
public void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    Rlog.d(TAG, "sendText");
    if (isCdmaMo()) {
        mCdmaDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, messageUri, callingPkg, persistMessage, priority, expectMore, validityPeriod);
    } else {
        mGsmDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent, messageUri, callingPkg, persistMessage, priority, expectMore, validityPeriod);
    }
}
#end_block

#method_before
@Override
protected SmsTracker getNewSubmitPduTracker(String destinationAddress, String scAddress, String message, SmsHeader smsHeader, int format, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, String fullMessageText, int priority, boolean isExpectMore, int validityPeriod) {
    Rlog.e(TAG, "Error! Not implemented for IMS.");
    return null;
}
#method_after
@Override
protected SmsTracker getNewSubmitPduTracker(String destinationAddress, String scAddress, String message, SmsHeader smsHeader, int format, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, String fullMessageText, int priority, boolean expectMore, int validityPeriod) {
    Rlog.e(TAG, "Error! Not implemented for IMS.");
    return null;
}
#end_block

#method_before
public void sendTextForSubscriberWithOptions(int subId, String callingPackage, String destAddr, String scAddr, String parts, PendingIntent sentIntents, PendingIntent deliveryIntents, boolean persistMessage, int priority, boolean isExpectMore, int validityPeriod) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessage, priority, isExpectMore, validityPeriod);
    } else {
        Rlog.e(LOG_TAG, "sendTextWithOptions iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
}
#method_after
@Override
public void sendTextForSubscriberWithOptions(int subId, String callingPackage, String destAddr, String scAddr, String parts, PendingIntent sentIntents, PendingIntent deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessage, priority, expectMore, validityPeriod);
    } else {
        Rlog.e(LOG_TAG, "sendTextWithOptions iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
}
#end_block

#method_before
public void sendMultipartTextForSubscriberWithOptions(int subId, String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, int priority, boolean isExpectMore, int validityPeriod) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendMultipartTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessage, priority, isExpectMore, validityPeriod);
    } else {
        Rlog.e(LOG_TAG, "sendMultipartTextWithOptions iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
}
#method_after
@Override
public void sendMultipartTextForSubscriberWithOptions(int subId, String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendMultipartTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessage, priority, expectMore, validityPeriod);
    } else {
        Rlog.e(LOG_TAG, "sendMultipartTextWithOptions iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
}
#end_block

#method_before
@Nullable
private IccSmsInterfaceManager getIccSmsInterfaceManager(int subId) {
    if (!isActiveSubId(subId)) {
        Rlog.e(LOG_TAG, "Subscription " + subId + " is inactive.");
        return null;
    }
    int phoneId = SubscriptionController.getInstance().getPhoneId(subId);
    // Fixme: for multi-subscription case
    if (!SubscriptionManager.isValidPhoneId(phoneId) || phoneId == SubscriptionManager.DEFAULT_PHONE_INDEX) {
        phoneId = 0;
    }
    try {
        return (IccSmsInterfaceManager) ((Phone) mPhone[(int) phoneId]).getIccSmsInterfaceManager();
    } catch (NullPointerException e) {
        Rlog.e(LOG_TAG, "Exception is :" + e.toString() + " For subscription :" + subId);
        e.printStackTrace();
        return null;
    } catch (ArrayIndexOutOfBoundsException e) {
        Rlog.e(LOG_TAG, "Exception is :" + e.toString() + " For subscription :" + subId);
        e.printStackTrace();
        return null;
    }
}
#method_after
@Nullable
private IccSmsInterfaceManager getIccSmsInterfaceManager(int subId) {
    return getPhone(subId).getIccSmsInterfaceManager();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_SEND_SMS_COMPLETE:
            // An outbound SMS has been successfully transferred, or failed.
            handleSendComplete((AsyncResult) msg.obj);
            break;
        case EVENT_SEND_RETRY:
            Rlog.d(TAG, "SMS retry..");
            sendRetrySms((SmsTracker) msg.obj);
            break;
        case EVENT_SEND_LIMIT_REACHED_CONFIRMATION:
            handleReachSentLimit((SmsTracker) (msg.obj));
            break;
        case EVENT_CONFIRM_SEND_TO_POSSIBLE_PREMIUM_SHORT_CODE:
            handleConfirmShortCode(false, (SmsTracker) (msg.obj));
            break;
        case EVENT_CONFIRM_SEND_TO_PREMIUM_SHORT_CODE:
            handleConfirmShortCode(true, (SmsTracker) (msg.obj));
            break;
        case EVENT_SEND_CONFIRMED_SMS:
            {
                SmsTracker tracker = (SmsTracker) msg.obj;
                if (tracker.isMultipart()) {
                    sendMultipartSms(tracker);
                } else {
                    if (mPendingTrackerCount > 1) {
                        tracker.mExpectMore = true;
                    } else {
                        tracker.mExpectMore = false;
                    }
                    sendSms(tracker);
                }
                mPendingTrackerCount--;
                break;
            }
        case EVENT_STOP_SENDING:
            {
                SmsTracker tracker = (SmsTracker) msg.obj;
                tracker.onFailed(mContext, RESULT_ERROR_LIMIT_EXCEEDED, 0);
                mPendingTrackerCount--;
                break;
            }
        case EVENT_HANDLE_STATUS_REPORT:
            handleStatusReport(msg.obj);
            break;
        default:
            Rlog.e(TAG, "handleMessage() ignoring message of unexpected type " + msg.what);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_SEND_SMS_COMPLETE:
            // An outbound SMS has been successfully transferred, or failed.
            handleSendComplete((AsyncResult) msg.obj);
            break;
        case EVENT_SEND_RETRY:
            Rlog.d(TAG, "SMS retry..");
            sendRetrySms((SmsTracker) msg.obj);
            break;
        case EVENT_SEND_LIMIT_REACHED_CONFIRMATION:
            handleReachSentLimit((SmsTracker) (msg.obj));
            break;
        case EVENT_CONFIRM_SEND_TO_POSSIBLE_PREMIUM_SHORT_CODE:
            handleConfirmShortCode(false, (SmsTracker) (msg.obj));
            break;
        case EVENT_CONFIRM_SEND_TO_PREMIUM_SHORT_CODE:
            handleConfirmShortCode(true, (SmsTracker) (msg.obj));
            break;
        case EVENT_SEND_CONFIRMED_SMS:
            {
                SmsTracker tracker = (SmsTracker) msg.obj;
                if (tracker.isMultipart()) {
                    sendMultipartSms(tracker);
                } else {
                    if (mPendingTrackerCount > 1) {
                        tracker.mExpectMore = true;
                    } else {
                        tracker.mExpectMore = false;
                    }
                    sendSms(tracker);
                }
                mPendingTrackerCount--;
                break;
            }
        case EVENT_STOP_SENDING:
            {
                SmsTracker tracker = (SmsTracker) msg.obj;
                if (msg.arg1 == ConfirmDialogListener.SHORT_CODE_MSG) {
                    if (msg.arg2 == ConfirmDialogListener.NEVER_ALLOW) {
                        tracker.onFailed(mContext, RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED, 0);
                        Rlog.d(TAG, "SMSDispatcher: EVENT_STOP_SENDING - " + "sending SHORT_CODE_NEVER_ALLOWED error code.");
                    } else {
                        tracker.onFailed(mContext, RESULT_ERROR_SHORT_CODE_NOT_ALLOWED, 0);
                        Rlog.d(TAG, "SMSDispatcher: EVENT_STOP_SENDING - " + "sending SHORT_CODE_NOT_ALLOWED error code.");
                    }
                } else if (msg.arg1 == ConfirmDialogListener.RATE_LIMIT) {
                    tracker.onFailed(mContext, RESULT_ERROR_LIMIT_EXCEEDED, 0);
                    Rlog.d(TAG, "SMSDispatcher: EVENT_STOP_SENDING - " + "sending LIMIT_EXCEEDED error code.");
                } else {
                    Rlog.e(TAG, "SMSDispatcher: EVENT_STOP_SENDING - unexpected cases.");
                }
                mPendingTrackerCount--;
                break;
            }
        case EVENT_HANDLE_STATUS_REPORT:
            handleStatusReport(msg.obj);
            break;
        default:
            Rlog.e(TAG, "handleMessage() ignoring message of unexpected type " + msg.what);
    }
}
#end_block

#method_before
protected void sendMultipartText(String destAddr, String scAddr, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean isExpectMore, int validityPeriod) {
    final String fullMessageText = getMultipartMessageText(parts);
    int refNumber = getNextConcatenatedRef() & 0x00FF;
    int msgCount = parts.size();
    int encoding = SmsConstants.ENCODING_UNKNOWN;
    TextEncodingDetails[] encodingForParts = new TextEncodingDetails[msgCount];
    for (int i = 0; i < msgCount; i++) {
        TextEncodingDetails details = calculateLength(parts.get(i), false);
        if (encoding != details.codeUnitSize && (encoding == SmsConstants.ENCODING_UNKNOWN || encoding == SmsConstants.ENCODING_7BIT)) {
            encoding = details.codeUnitSize;
        }
        encodingForParts[i] = details;
    }
    SmsTracker[] trackers = new SmsTracker[msgCount];
    // States to track at the message level (for all parts)
    final AtomicInteger unsentPartCount = new AtomicInteger(msgCount);
    final AtomicBoolean anyPartFailed = new AtomicBoolean(false);
    for (int i = 0; i < msgCount; i++) {
        SmsHeader.ConcatRef concatRef = new SmsHeader.ConcatRef();
        concatRef.refNumber = refNumber;
        // 1-based sequence
        concatRef.seqNumber = i + 1;
        concatRef.msgCount = msgCount;
        // TODO: We currently set this to true since our messaging app will never
        // send more than 255 parts (it converts the message to MMS well before that).
        // However, we should support 3rd party messaging apps that might need 16-bit
        // references
        // Note:  It's not sufficient to just flip this bit to true; it will have
        // ripple effects (several calculations assume 8-bit ref).
        concatRef.isEightBits = true;
        SmsHeader smsHeader = new SmsHeader();
        smsHeader.concatRef = concatRef;
        // Set the national language tables for 3GPP 7-bit encoding, if enabled.
        if (encoding == SmsConstants.ENCODING_7BIT) {
            smsHeader.languageTable = encodingForParts[i].languageTable;
            smsHeader.languageShiftTable = encodingForParts[i].languageShiftTable;
        }
        PendingIntent sentIntent = null;
        if (sentIntents != null && sentIntents.size() > i) {
            sentIntent = sentIntents.get(i);
        }
        PendingIntent deliveryIntent = null;
        if (deliveryIntents != null && deliveryIntents.size() > i) {
            deliveryIntent = deliveryIntents.get(i);
        }
        trackers[i] = getNewSubmitPduTracker(destAddr, scAddr, parts.get(i), smsHeader, encoding, sentIntent, deliveryIntent, (i == (msgCount - 1)), unsentPartCount, anyPartFailed, messageUri, fullMessageText, priority, isExpectMore, validityPeriod);
        trackers[i].mPersistMessage = persistMessage;
    }
    if (parts == null || trackers == null || trackers.length == 0 || trackers[0] == null) {
        Rlog.e(TAG, "Cannot send multipart text. parts=" + parts + " trackers=" + trackers);
        return;
    }
    String carrierPackage = getCarrierAppPackageName();
    if (carrierPackage != null) {
        Rlog.d(TAG, "Found carrier package.");
        MultipartSmsSender smsSender = new MultipartSmsSender(parts, trackers);
        smsSender.sendSmsByCarrierApp(carrierPackage, new MultipartSmsSenderCallback(smsSender));
    } else {
        Rlog.v(TAG, "No carrier package.");
        for (SmsTracker tracker : trackers) {
            if (tracker != null) {
                sendSubmitPdu(tracker);
            } else {
                Rlog.e(TAG, "Null tracker.");
            }
        }
    }
}
#method_after
protected void sendMultipartText(String destAddr, String scAddr, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    final String fullMessageText = getMultipartMessageText(parts);
    int refNumber = getNextConcatenatedRef() & 0x00FF;
    int msgCount = parts.size();
    int encoding = SmsConstants.ENCODING_UNKNOWN;
    TextEncodingDetails[] encodingForParts = new TextEncodingDetails[msgCount];
    for (int i = 0; i < msgCount; i++) {
        TextEncodingDetails details = calculateLength(parts.get(i), false);
        if (encoding != details.codeUnitSize && (encoding == SmsConstants.ENCODING_UNKNOWN || encoding == SmsConstants.ENCODING_7BIT)) {
            encoding = details.codeUnitSize;
        }
        encodingForParts[i] = details;
    }
    SmsTracker[] trackers = new SmsTracker[msgCount];
    // States to track at the message level (for all parts)
    final AtomicInteger unsentPartCount = new AtomicInteger(msgCount);
    final AtomicBoolean anyPartFailed = new AtomicBoolean(false);
    for (int i = 0; i < msgCount; i++) {
        SmsHeader.ConcatRef concatRef = new SmsHeader.ConcatRef();
        concatRef.refNumber = refNumber;
        // 1-based sequence
        concatRef.seqNumber = i + 1;
        concatRef.msgCount = msgCount;
        // TODO: We currently set this to true since our messaging app will never
        // send more than 255 parts (it converts the message to MMS well before that).
        // However, we should support 3rd party messaging apps that might need 16-bit
        // references
        // Note:  It's not sufficient to just flip this bit to true; it will have
        // ripple effects (several calculations assume 8-bit ref).
        concatRef.isEightBits = true;
        SmsHeader smsHeader = new SmsHeader();
        smsHeader.concatRef = concatRef;
        // Set the national language tables for 3GPP 7-bit encoding, if enabled.
        if (encoding == SmsConstants.ENCODING_7BIT) {
            smsHeader.languageTable = encodingForParts[i].languageTable;
            smsHeader.languageShiftTable = encodingForParts[i].languageShiftTable;
        }
        PendingIntent sentIntent = null;
        if (sentIntents != null && sentIntents.size() > i) {
            sentIntent = sentIntents.get(i);
        }
        PendingIntent deliveryIntent = null;
        if (deliveryIntents != null && deliveryIntents.size() > i) {
            deliveryIntent = deliveryIntents.get(i);
        }
        trackers[i] = getNewSubmitPduTracker(destAddr, scAddr, parts.get(i), smsHeader, encoding, sentIntent, deliveryIntent, (i == (msgCount - 1)), unsentPartCount, anyPartFailed, messageUri, fullMessageText, priority, expectMore, validityPeriod);
        trackers[i].mPersistMessage = persistMessage;
    }
    if (parts == null || trackers == null || trackers.length == 0 || trackers[0] == null) {
        Rlog.e(TAG, "Cannot send multipart text. parts=" + parts + " trackers=" + trackers);
        return;
    }
    String carrierPackage = getCarrierAppPackageName();
    if (carrierPackage != null) {
        Rlog.d(TAG, "Found carrier package.");
        MultipartSmsSender smsSender = new MultipartSmsSender(parts, trackers);
        smsSender.sendSmsByCarrierApp(carrierPackage, new MultipartSmsSenderCallback(smsSender));
    } else {
        Rlog.v(TAG, "No carrier package.");
        for (SmsTracker tracker : trackers) {
            if (tracker != null) {
                sendSubmitPdu(tracker);
            } else {
                Rlog.e(TAG, "Null tracker.");
            }
        }
    }
}
#end_block

#method_before
protected void sendRawPdu(SmsTracker tracker) {
    HashMap map = tracker.getData();
    byte[] pdu = (byte[]) map.get("pdu");
    if (mSmsSendDisabled) {
        Rlog.e(TAG, "Device does not support sending sms.");
        tracker.onFailed(mContext, RESULT_ERROR_NO_SERVICE, 0);
        return;
    }
    if (pdu == null) {
        Rlog.e(TAG, "Empty PDU");
        tracker.onFailed(mContext, RESULT_ERROR_NULL_PDU, 0);
        return;
    }
    // Get calling app package name via UID from Binder call
    PackageManager pm = mContext.getPackageManager();
    String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
    if (packageNames == null || packageNames.length == 0) {
        // Refuse to send SMS if we can't get the calling package name.
        Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS");
        tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0);
        return;
    }
    // Get package info via packagemanager
    PackageInfo appInfo;
    try {
        // XXX this is lossy- apps can share a UID
        appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, tracker.mUserId);
    } catch (PackageManager.NameNotFoundException e) {
        Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS");
        tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0);
        return;
    }
    // handler with the SmsTracker to request user confirmation before sending.
    if (checkDestination(tracker)) {
        // check for excessive outgoing SMS usage by this app
        if (!mUsageMonitor.check(appInfo.packageName, SINGLE_PART_SMS)) {
            sendMessage(obtainMessage(EVENT_SEND_LIMIT_REACHED_CONFIRMATION, tracker));
            return;
        }
        sendSms(tracker);
    }
    if (PhoneNumberUtils.isLocalEmergencyNumber(mContext, tracker.mDestAddress)) {
        new AsyncEmergencyContactNotifier(mContext).execute();
    }
}
#method_after
@VisibleForTesting
public void sendRawPdu(SmsTracker tracker) {
    HashMap map = tracker.getData();
    byte[] pdu = (byte[]) map.get("pdu");
    if (mSmsSendDisabled) {
        Rlog.e(TAG, "Device does not support sending sms.");
        tracker.onFailed(mContext, RESULT_ERROR_NO_SERVICE, 0);
        return;
    }
    if (pdu == null) {
        Rlog.e(TAG, "Empty PDU");
        tracker.onFailed(mContext, RESULT_ERROR_NULL_PDU, 0);
        return;
    }
    // Get calling app package name via UID from Binder call
    PackageManager pm = mContext.getPackageManager();
    String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
    if (packageNames == null || packageNames.length == 0) {
        // Refuse to send SMS if we can't get the calling package name.
        Rlog.e(TAG, "Can't get calling app package name: refusing to send SMS");
        tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0);
        return;
    }
    // Get package info via packagemanager
    PackageInfo appInfo;
    try {
        // XXX this is lossy- apps can share a UID
        appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, tracker.mUserId);
    } catch (PackageManager.NameNotFoundException e) {
        Rlog.e(TAG, "Can't get calling app package info: refusing to send SMS");
        tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0);
        return;
    }
    // handler with the SmsTracker to request user confirmation before sending.
    if (checkDestination(tracker)) {
        // check for excessive outgoing SMS usage by this app
        if (!mUsageMonitor.check(appInfo.packageName, SINGLE_PART_SMS)) {
            sendMessage(obtainMessage(EVENT_SEND_LIMIT_REACHED_CONFIRMATION, tracker));
            return;
        }
        sendSms(tracker);
    }
    if (PhoneNumberUtils.isLocalEmergencyNumber(mContext, tracker.mDestAddress)) {
        new AsyncEmergencyContactNotifier(mContext).execute();
    }
}
#end_block

#method_before
boolean checkDestination(SmsTracker tracker) {
    if (mContext.checkCallingOrSelfPermission(SEND_SMS_NO_CONFIRMATION) == PackageManager.PERMISSION_GRANTED) {
        // app is pre-approved to send to short codes
        return true;
    } else {
        int rule = mPremiumSmsRule.get();
        int smsCategory = SmsUsageMonitor.CATEGORY_NOT_SHORT_CODE;
        if (rule == PREMIUM_RULE_USE_SIM || rule == PREMIUM_RULE_USE_BOTH) {
            String simCountryIso = mTelephonyManager.getSimCountryIso();
            if (simCountryIso == null || simCountryIso.length() != 2) {
                Rlog.e(TAG, "Can't get SIM country Iso: trying network country Iso");
                simCountryIso = mTelephonyManager.getNetworkCountryIso();
            }
            smsCategory = mUsageMonitor.checkDestination(tracker.mDestAddress, simCountryIso);
        }
        if (rule == PREMIUM_RULE_USE_NETWORK || rule == PREMIUM_RULE_USE_BOTH) {
            String networkCountryIso = mTelephonyManager.getNetworkCountryIso();
            if (networkCountryIso == null || networkCountryIso.length() != 2) {
                Rlog.e(TAG, "Can't get Network country Iso: trying SIM country Iso");
                networkCountryIso = mTelephonyManager.getSimCountryIso();
            }
            smsCategory = SmsUsageMonitor.mergeShortCodeCategories(smsCategory, mUsageMonitor.checkDestination(tracker.mDestAddress, networkCountryIso));
        }
        if (smsCategory == SmsUsageMonitor.CATEGORY_NOT_SHORT_CODE || smsCategory == SmsUsageMonitor.CATEGORY_FREE_SHORT_CODE || smsCategory == SmsUsageMonitor.CATEGORY_STANDARD_SHORT_CODE) {
            // not a premium short code
            return true;
        }
        // Do not allow any premium sms during SuW
        if (Settings.Global.getInt(mResolver, Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
            Rlog.e(TAG, "Can't send premium sms during Setup Wizard");
            return false;
        }
        // Wait for user confirmation unless the user has set permission to always allow/deny
        int premiumSmsPermission = mUsageMonitor.getPremiumSmsPermission(tracker.mAppInfo.packageName);
        if (premiumSmsPermission == SmsUsageMonitor.PREMIUM_SMS_PERMISSION_UNKNOWN) {
            // First time trying to send to premium SMS.
            premiumSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ASK_USER;
        }
        switch(premiumSmsPermission) {
            case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ALWAYS_ALLOW:
                Rlog.d(TAG, "User approved this app to send to premium SMS");
                return true;
            case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_NEVER_ALLOW:
                Rlog.w(TAG, "User denied this app from sending to premium SMS");
                sendMessage(obtainMessage(EVENT_STOP_SENDING, tracker));
                // reject this message
                return false;
            case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ASK_USER:
            default:
                int event;
                if (smsCategory == SmsUsageMonitor.CATEGORY_POSSIBLE_PREMIUM_SHORT_CODE) {
                    event = EVENT_CONFIRM_SEND_TO_POSSIBLE_PREMIUM_SHORT_CODE;
                } else {
                    event = EVENT_CONFIRM_SEND_TO_PREMIUM_SHORT_CODE;
                }
                sendMessage(obtainMessage(event, tracker));
                // wait for user confirmation
                return false;
        }
    }
}
#method_after
boolean checkDestination(SmsTracker tracker) {
    if (mContext.checkCallingOrSelfPermission(SEND_SMS_NO_CONFIRMATION) == PackageManager.PERMISSION_GRANTED) {
        // app is pre-approved to send to short codes
        return true;
    } else {
        int rule = mPremiumSmsRule.get();
        int smsCategory = SmsUsageMonitor.CATEGORY_NOT_SHORT_CODE;
        if (rule == PREMIUM_RULE_USE_SIM || rule == PREMIUM_RULE_USE_BOTH) {
            String simCountryIso = mTelephonyManager.getSimCountryIso();
            if (simCountryIso == null || simCountryIso.length() != 2) {
                Rlog.e(TAG, "Can't get SIM country Iso: trying network country Iso");
                simCountryIso = mTelephonyManager.getNetworkCountryIso();
            }
            smsCategory = mUsageMonitor.checkDestination(tracker.mDestAddress, simCountryIso);
        }
        if (rule == PREMIUM_RULE_USE_NETWORK || rule == PREMIUM_RULE_USE_BOTH) {
            String networkCountryIso = mTelephonyManager.getNetworkCountryIso();
            if (networkCountryIso == null || networkCountryIso.length() != 2) {
                Rlog.e(TAG, "Can't get Network country Iso: trying SIM country Iso");
                networkCountryIso = mTelephonyManager.getSimCountryIso();
            }
            smsCategory = SmsUsageMonitor.mergeShortCodeCategories(smsCategory, mUsageMonitor.checkDestination(tracker.mDestAddress, networkCountryIso));
        }
        if (smsCategory == SmsUsageMonitor.CATEGORY_NOT_SHORT_CODE || smsCategory == SmsUsageMonitor.CATEGORY_FREE_SHORT_CODE || smsCategory == SmsUsageMonitor.CATEGORY_STANDARD_SHORT_CODE) {
            // not a premium short code
            return true;
        }
        // Do not allow any premium sms during SuW
        if (Settings.Global.getInt(mResolver, Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
            Rlog.e(TAG, "Can't send premium sms during Setup Wizard");
            return false;
        }
        // Wait for user confirmation unless the user has set permission to always allow/deny
        int premiumSmsPermission = mUsageMonitor.getPremiumSmsPermission(tracker.getAppPackageName());
        if (premiumSmsPermission == SmsUsageMonitor.PREMIUM_SMS_PERMISSION_UNKNOWN) {
            // First time trying to send to premium SMS.
            premiumSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ASK_USER;
        }
        switch(premiumSmsPermission) {
            case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ALWAYS_ALLOW:
                Rlog.d(TAG, "User approved this app to send to premium SMS");
                return true;
            case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_NEVER_ALLOW:
                Rlog.w(TAG, "User denied this app from sending to premium SMS");
                Message msg = obtainMessage(EVENT_STOP_SENDING, tracker);
                msg.arg1 = ConfirmDialogListener.SHORT_CODE_MSG;
                msg.arg2 = ConfirmDialogListener.NEVER_ALLOW;
                sendMessage(msg);
                // reject this message
                return false;
            case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ASK_USER:
            default:
                int event;
                if (smsCategory == SmsUsageMonitor.CATEGORY_POSSIBLE_PREMIUM_SHORT_CODE) {
                    event = EVENT_CONFIRM_SEND_TO_POSSIBLE_PREMIUM_SHORT_CODE;
                } else {
                    event = EVENT_CONFIRM_SEND_TO_PREMIUM_SHORT_CODE;
                }
                sendMessage(obtainMessage(event, tracker));
                // wait for user confirmation
                return false;
        }
    }
}
#end_block

#method_before
protected void handleReachSentLimit(SmsTracker tracker) {
    if (denyIfQueueLimitReached(tracker)) {
        // queue limit reached; error was returned to caller
        return;
    }
    CharSequence appLabel = getAppLabel(tracker.mAppInfo.packageName, tracker.mUserId);
    Resources r = Resources.getSystem();
    Spanned messageText = Html.fromHtml(r.getString(R.string.sms_control_message, appLabel));
    ConfirmDialogListener listener = new ConfirmDialogListener(tracker, null);
    AlertDialog d = new AlertDialog.Builder(mContext).setTitle(R.string.sms_control_title).setIcon(R.drawable.stat_sys_warning).setMessage(messageText).setPositiveButton(r.getString(R.string.sms_control_yes), listener).setNegativeButton(r.getString(R.string.sms_control_no), listener).setOnCancelListener(listener).create();
    d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    d.show();
}
#method_after
protected void handleReachSentLimit(SmsTracker tracker) {
    if (denyIfQueueLimitReached(tracker)) {
        // queue limit reached; error was returned to caller
        return;
    }
    CharSequence appLabel = getAppLabel(tracker.getAppPackageName(), tracker.mUserId);
    Resources r = Resources.getSystem();
    Spanned messageText = Html.fromHtml(r.getString(R.string.sms_control_message, appLabel));
    // Construct ConfirmDialogListenter for Rate Limit handling
    ConfirmDialogListener listener = new ConfirmDialogListener(tracker, null, ConfirmDialogListener.RATE_LIMIT);
    AlertDialog d = new AlertDialog.Builder(mContext).setTitle(R.string.sms_control_title).setIcon(R.drawable.stat_sys_warning).setMessage(messageText).setPositiveButton(r.getString(R.string.sms_control_yes), listener).setNegativeButton(r.getString(R.string.sms_control_no), listener).setOnCancelListener(listener).create();
    d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    d.show();
}
#end_block

#method_before
protected void handleConfirmShortCode(boolean isPremium, SmsTracker tracker) {
    if (denyIfQueueLimitReached(tracker)) {
        // queue limit reached; error was returned to caller
        return;
    }
    int detailsId;
    if (isPremium) {
        detailsId = R.string.sms_premium_short_code_details;
    } else {
        detailsId = R.string.sms_short_code_details;
    }
    CharSequence appLabel = getAppLabel(tracker.mAppInfo.packageName, tracker.mUserId);
    Resources r = Resources.getSystem();
    Spanned messageText = Html.fromHtml(r.getString(R.string.sms_short_code_confirm_message, appLabel, tracker.mDestAddress));
    LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View layout = inflater.inflate(R.layout.sms_short_code_confirmation_dialog, null);
    ConfirmDialogListener listener = new ConfirmDialogListener(tracker, (TextView) layout.findViewById(R.id.sms_short_code_remember_undo_instruction));
    TextView messageView = (TextView) layout.findViewById(R.id.sms_short_code_confirm_message);
    messageView.setText(messageText);
    ViewGroup detailsLayout = (ViewGroup) layout.findViewById(R.id.sms_short_code_detail_layout);
    TextView detailsView = (TextView) detailsLayout.findViewById(R.id.sms_short_code_detail_message);
    detailsView.setText(detailsId);
    CheckBox rememberChoice = (CheckBox) layout.findViewById(R.id.sms_short_code_remember_choice_checkbox);
    rememberChoice.setOnCheckedChangeListener(listener);
    AlertDialog d = new AlertDialog.Builder(mContext).setView(layout).setPositiveButton(r.getString(R.string.sms_short_code_confirm_allow), listener).setNegativeButton(r.getString(R.string.sms_short_code_confirm_deny), listener).setOnCancelListener(listener).create();
    d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    d.show();
    listener.setPositiveButton(d.getButton(DialogInterface.BUTTON_POSITIVE));
    listener.setNegativeButton(d.getButton(DialogInterface.BUTTON_NEGATIVE));
}
#method_after
protected void handleConfirmShortCode(boolean isPremium, SmsTracker tracker) {
    if (denyIfQueueLimitReached(tracker)) {
        // queue limit reached; error was returned to caller
        return;
    }
    int detailsId;
    if (isPremium) {
        detailsId = R.string.sms_premium_short_code_details;
    } else {
        detailsId = R.string.sms_short_code_details;
    }
    CharSequence appLabel = getAppLabel(tracker.getAppPackageName(), tracker.mUserId);
    Resources r = Resources.getSystem();
    Spanned messageText = Html.fromHtml(r.getString(R.string.sms_short_code_confirm_message, appLabel, tracker.mDestAddress));
    LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View layout = inflater.inflate(R.layout.sms_short_code_confirmation_dialog, null);
    // Construct ConfirmDialogListenter for short code message sending
    ConfirmDialogListener listener = new ConfirmDialogListener(tracker, (TextView) layout.findViewById(R.id.sms_short_code_remember_undo_instruction), ConfirmDialogListener.SHORT_CODE_MSG);
    TextView messageView = (TextView) layout.findViewById(R.id.sms_short_code_confirm_message);
    messageView.setText(messageText);
    ViewGroup detailsLayout = (ViewGroup) layout.findViewById(R.id.sms_short_code_detail_layout);
    TextView detailsView = (TextView) detailsLayout.findViewById(R.id.sms_short_code_detail_message);
    detailsView.setText(detailsId);
    CheckBox rememberChoice = (CheckBox) layout.findViewById(R.id.sms_short_code_remember_choice_checkbox);
    rememberChoice.setOnCheckedChangeListener(listener);
    AlertDialog d = new AlertDialog.Builder(mContext).setView(layout).setPositiveButton(r.getString(R.string.sms_short_code_confirm_allow), listener).setNegativeButton(r.getString(R.string.sms_short_code_confirm_deny), listener).setOnCancelListener(listener).create();
    d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    d.show();
    listener.setPositiveButton(d.getButton(DialogInterface.BUTTON_POSITIVE));
    listener.setNegativeButton(d.getButton(DialogInterface.BUTTON_NEGATIVE));
}
#end_block

#method_before
private void sendMultipartSms(SmsTracker tracker) {
    ArrayList<String> parts;
    ArrayList<PendingIntent> sentIntents;
    ArrayList<PendingIntent> deliveryIntents;
    HashMap<String, Object> map = tracker.getData();
    String destinationAddress = (String) map.get("destination");
    String scAddress = (String) map.get("scaddress");
    parts = (ArrayList<String>) map.get("parts");
    sentIntents = (ArrayList<PendingIntent>) map.get("sentIntents");
    deliveryIntents = (ArrayList<PendingIntent>) map.get("deliveryIntents");
    // check if in service
    int ss = mPhone.getServiceState().getState();
    // if sms over IMS is not supported on data and voice is not available...
    if (!isIms() && ss != ServiceState.STATE_IN_SERVICE) {
        for (int i = 0, count = parts.size(); i < count; i++) {
            PendingIntent sentIntent = null;
            if (sentIntents != null && sentIntents.size() > i) {
                sentIntent = sentIntents.get(i);
            }
            handleNotInService(ss, sentIntent);
        }
        return;
    }
    sendMultipartText(destinationAddress, scAddress, parts, sentIntents, deliveryIntents, null, /*messageUri*/
    null, /*callingPkg*/
    tracker.mPersistMessage, -1, tracker.mExpectMore, tracker.mvalidityPeriod);
}
#method_after
private void sendMultipartSms(SmsTracker tracker) {
    ArrayList<String> parts;
    ArrayList<PendingIntent> sentIntents;
    ArrayList<PendingIntent> deliveryIntents;
    HashMap<String, Object> map = tracker.getData();
    String destinationAddress = (String) map.get("destination");
    String scAddress = (String) map.get("scaddress");
    parts = (ArrayList<String>) map.get("parts");
    sentIntents = (ArrayList<PendingIntent>) map.get("sentIntents");
    deliveryIntents = (ArrayList<PendingIntent>) map.get("deliveryIntents");
    // check if in service
    int ss = mPhone.getServiceState().getState();
    // if sms over IMS is not supported on data and voice is not available...
    if (!isIms() && ss != ServiceState.STATE_IN_SERVICE) {
        for (int i = 0, count = parts.size(); i < count; i++) {
            PendingIntent sentIntent = null;
            if (sentIntents != null && sentIntents.size() > i) {
                sentIntent = sentIntents.get(i);
            }
            handleNotInService(ss, sentIntent);
        }
        return;
    }
    sendMultipartText(destinationAddress, scAddress, parts, sentIntents, deliveryIntents, null, /*messageUri*/
    null, /*callingPkg*/
    tracker.mPersistMessage, tracker.mPriority, tracker.mExpectMore, tracker.mValidityPeriod);
}
#end_block

#method_before
protected SmsTracker getSmsTracker(HashMap<String, Object> data, PendingIntent sentIntent, PendingIntent deliveryIntent, String format, Uri messageUri, boolean isExpectMore, String fullMessageText, boolean isText, boolean persistMessage, int validityPeriod) {
    return getSmsTracker(data, sentIntent, deliveryIntent, format, null, /*unsentPartCount*/
    null, /*anyPartFailed*/
    messageUri, null, /*smsHeader*/
    isExpectMore, fullMessageText, isText, persistMessage, validityPeriod);
}
#method_after
protected SmsTracker getSmsTracker(HashMap<String, Object> data, PendingIntent sentIntent, PendingIntent deliveryIntent, String format, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, SmsHeader smsHeader, boolean expectMore, String fullMessageText, boolean isText, boolean persistMessage, int priority, int validityPeriod) {
    // Get calling app package name via UID from Binder call
    PackageManager pm = mContext.getPackageManager();
    String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
    // Get package info via packagemanager
    final int userId = UserHandle.getCallingUserId();
    PackageInfo appInfo = null;
    if (packageNames != null && packageNames.length > 0) {
        try {
            // XXX this is lossy- apps can share a UID
            appInfo = pm.getPackageInfoAsUser(packageNames[0], PackageManager.GET_SIGNATURES, userId);
        } catch (PackageManager.NameNotFoundException e) {
        // error will be logged in sendRawPdu
        }
    }
    // Strip non-digits from destination phone number before checking for short codes
    // and before displaying the number to the user if confirmation is required.
    String destAddr = PhoneNumberUtils.extractNetworkPortion((String) data.get("destAddr"));
    return new SmsTracker(data, sentIntent, deliveryIntent, appInfo, destAddr, format, unsentPartCount, anyPartFailed, messageUri, smsHeader, expectMore, fullMessageText, getSubId(), isText, persistMessage, userId, priority, validityPeriod);
}
#end_block

#method_before
protected SmsTracker getSmsTracker(HashMap<String, Object> data, PendingIntent sentIntent, PendingIntent deliveryIntent, String format, Uri messageUri, boolean isExpectMore, String fullMessageText, boolean isText, boolean persistMessage) {
    return getSmsTracker(data, sentIntent, deliveryIntent, format, null, /*unsentPartCount*/
    null, /*anyPartFailed*/
    messageUri, null, /*smsHeader*/
    isExpectMore, fullMessageText, isText, persistMessage, -1);
}
#method_after
protected SmsTracker getSmsTracker(HashMap<String, Object> data, PendingIntent sentIntent, PendingIntent deliveryIntent, String format, Uri messageUri, boolean expectMore, String fullMessageText, boolean isText, boolean persistMessage) {
    return getSmsTracker(data, sentIntent, deliveryIntent, format, null, /*unsentPartCount*/
    null, /*anyPartFailed*/
    messageUri, null, /*smsHeader*/
    expectMore, fullMessageText, isText, persistMessage, SMS_MESSAGE_PRIORITY_NOT_SPECIFIED, SMS_MESSAGE_PERIOD_NOT_SPECIFIED);
}
#end_block

#method_before
@Override
public void onClick(DialogInterface dialog, int which) {
    // Always set the SMS permission so that Settings will show a permission setting
    // for the app (it won't be shown until after the app tries to send to a short code).
    int newSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ASK_USER;
    if (which == DialogInterface.BUTTON_POSITIVE) {
        Rlog.d(TAG, "CONFIRM sending SMS");
        // XXX this is lossy- apps can have more than one signature
        EventLog.writeEvent(EventLogTags.EXP_DET_SMS_SENT_BY_USER, mTracker.mAppInfo.applicationInfo == null ? -1 : mTracker.mAppInfo.applicationInfo.uid);
        sendMessage(obtainMessage(EVENT_SEND_CONFIRMED_SMS, mTracker));
        if (mRememberChoice) {
            newSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ALWAYS_ALLOW;
        }
    } else if (which == DialogInterface.BUTTON_NEGATIVE) {
        Rlog.d(TAG, "DENY sending SMS");
        // XXX this is lossy- apps can have more than one signature
        EventLog.writeEvent(EventLogTags.EXP_DET_SMS_DENIED_BY_USER, mTracker.mAppInfo.applicationInfo == null ? -1 : mTracker.mAppInfo.applicationInfo.uid);
        sendMessage(obtainMessage(EVENT_STOP_SENDING, mTracker));
        if (mRememberChoice) {
            newSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_NEVER_ALLOW;
        }
    }
    setPremiumSmsPermission(mTracker.mAppInfo.packageName, newSmsPermission);
}
#method_after
@Override
public void onClick(DialogInterface dialog, int which) {
    // Always set the SMS permission so that Settings will show a permission setting
    // for the app (it won't be shown until after the app tries to send to a short code).
    int newSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ASK_USER;
    if (which == DialogInterface.BUTTON_POSITIVE) {
        Rlog.d(TAG, "CONFIRM sending SMS");
        // XXX this is lossy- apps can have more than one signature
        EventLog.writeEvent(EventLogTags.EXP_DET_SMS_SENT_BY_USER, mTracker.mAppInfo.applicationInfo == null ? -1 : mTracker.mAppInfo.applicationInfo.uid);
        sendMessage(obtainMessage(EVENT_SEND_CONFIRMED_SMS, mTracker));
        if (mRememberChoice) {
            newSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ALWAYS_ALLOW;
        }
    } else if (which == DialogInterface.BUTTON_NEGATIVE) {
        Rlog.d(TAG, "DENY sending SMS");
        // XXX this is lossy- apps can have more than one signature
        EventLog.writeEvent(EventLogTags.EXP_DET_SMS_DENIED_BY_USER, mTracker.mAppInfo.applicationInfo == null ? -1 : mTracker.mAppInfo.applicationInfo.uid);
        Message msg = obtainMessage(EVENT_STOP_SENDING, mTracker);
        msg.arg1 = mConfirmationType;
        if (mRememberChoice) {
            newSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_NEVER_ALLOW;
            msg.arg2 = ConfirmDialogListener.NEVER_ALLOW;
        }
        sendMessage(msg);
    }
    setPremiumSmsPermission(mTracker.getAppPackageName(), newSmsPermission);
}
#end_block

#method_before
@Override
public void onCancel(DialogInterface dialog) {
    Rlog.d(TAG, "dialog dismissed: don't send SMS");
    sendMessage(obtainMessage(EVENT_STOP_SENDING, mTracker));
}
#method_after
@Override
public void onCancel(DialogInterface dialog) {
    Rlog.d(TAG, "dialog dismissed: don't send SMS");
    Message msg = obtainMessage(EVENT_STOP_SENDING, mTracker);
    msg.arg1 = mConfirmationType;
    sendMessage(msg);
}
#end_block

#method_before
@Override
protected void sendData(String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddr, destAddr, destPort, data, (deliveryIntent != null));
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destAddr, scAddr, destPort, data, pdu);
        SmsTracker tracker = getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), null, /*messageUri*/
        false, /*isExpectMore*/
        null, /*fullMessageText*/
        false, /*isText*/
        true);
        String carrierPackage = getCarrierAppPackageName();
        if (carrierPackage != null) {
            Rlog.d(TAG, "Found carrier package.");
            DataSmsSender smsSender = new DataSmsSender(tracker);
            smsSender.sendSmsByCarrierApp(carrierPackage, new SmsSenderCallback(smsSender));
        } else {
            Rlog.v(TAG, "No carrier package.");
            sendRawPdu(tracker);
        }
    } else {
        Rlog.e(TAG, "GsmSMSDispatcher.sendData(): getSubmitPdu() returned null");
    }
}
#method_after
@Override
protected void sendData(String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddr, destAddr, destPort, data, (deliveryIntent != null));
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destAddr, scAddr, destPort, data, pdu);
        SmsTracker tracker = getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), null, /*messageUri*/
        false, /*expectMore*/
        null, /*fullMessageText*/
        false, /*isText*/
        true);
        String carrierPackage = getCarrierAppPackageName();
        if (carrierPackage != null) {
            Rlog.d(TAG, "Found carrier package.");
            DataSmsSender smsSender = new DataSmsSender(tracker);
            smsSender.sendSmsByCarrierApp(carrierPackage, new SmsSenderCallback(smsSender));
        } else {
            Rlog.v(TAG, "No carrier package.");
            sendRawPdu(tracker);
        }
    } else {
        Rlog.e(TAG, "GsmSMSDispatcher.sendData(): getSubmitPdu() returned null");
    }
}
#end_block

#method_before
@VisibleForTesting
@Override
public void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean isExpectMore, int validityPeriod) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddr, destAddr, text, (deliveryIntent != null), validityPeriod);
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destAddr, scAddr, text, pdu);
        SmsTracker tracker = getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), messageUri, false, /*isExpectMore*/
        text, /*fullMessageText*/
        true, /*isText*/
        persistMessage, validityPeriod);
        String carrierPackage = getCarrierAppPackageName();
        if (carrierPackage != null) {
            Rlog.d(TAG, "Found carrier package.");
            TextSmsSender smsSender = new TextSmsSender(tracker);
            smsSender.sendSmsByCarrierApp(carrierPackage, new SmsSenderCallback(smsSender));
        } else {
            Rlog.v(TAG, "No carrier package.");
            sendRawPdu(tracker);
        }
    } else {
        Rlog.e(TAG, "GsmSMSDispatcher.sendText(): getSubmitPdu() returned null");
    }
}
#method_after
@VisibleForTesting
@Override
public void sendText(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri, String callingPkg, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddr, destAddr, text, (deliveryIntent != null), validityPeriod);
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destAddr, scAddr, text, pdu);
        SmsTracker tracker = getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), messageUri, false, /*expectMore*/
        text, /*fullMessageText*/
        true, /*isText*/
        persistMessage, priority, validityPeriod);
        String carrierPackage = getCarrierAppPackageName();
        if (carrierPackage != null) {
            Rlog.d(TAG, "Found carrier package.");
            TextSmsSender smsSender = new TextSmsSender(tracker);
            smsSender.sendSmsByCarrierApp(carrierPackage, new SmsSenderCallback(smsSender));
        } else {
            Rlog.v(TAG, "No carrier package.");
            sendRawPdu(tracker);
        }
    } else {
        Rlog.e(TAG, "GsmSMSDispatcher.sendText(): getSubmitPdu() returned null");
    }
}
#end_block

#method_before
@Override
protected SmsTracker getNewSubmitPduTracker(String destinationAddress, String scAddress, String message, SmsHeader smsHeader, int encoding, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, String fullMessageText, int priority, boolean isExpectMore, int validityPeriod) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddress, destinationAddress, message, deliveryIntent != null, SmsHeader.toByteArray(smsHeader), encoding, smsHeader.languageTable, smsHeader.languageShiftTable, validityPeriod);
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destinationAddress, scAddress, message, pdu);
        return getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), unsentPartCount, anyPartFailed, messageUri, smsHeader, (!lastPart || isExpectMore), fullMessageText, true, /*isText*/
        false, /*persistMessage*/
        validityPeriod);
    } else {
        Rlog.e(TAG, "GsmSMSDispatcher.sendNewSubmitPdu(): getSubmitPdu() returned null");
        return null;
    }
}
#method_after
@Override
protected SmsTracker getNewSubmitPduTracker(String destinationAddress, String scAddress, String message, SmsHeader smsHeader, int encoding, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean lastPart, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, String fullMessageText, int priority, boolean expectMore, int validityPeriod) {
    SmsMessage.SubmitPdu pdu = SmsMessage.getSubmitPdu(scAddress, destinationAddress, message, deliveryIntent != null, SmsHeader.toByteArray(smsHeader), encoding, smsHeader.languageTable, smsHeader.languageShiftTable, validityPeriod);
    if (pdu != null) {
        HashMap map = getSmsTrackerMap(destinationAddress, scAddress, message, pdu);
        return getSmsTracker(map, sentIntent, deliveryIntent, getFormat(), unsentPartCount, anyPartFailed, messageUri, smsHeader, (!lastPart || expectMore), fullMessageText, true, /*isText*/
        false, /*persistMessage*/
        priority, validityPeriod);
    } else {
        Rlog.e(TAG, "GsmSMSDispatcher.sendNewSubmitPdu(): getSubmitPdu() returned null");
        return null;
    }
}
#end_block

#method_before
String getSCAddress() {
    int len;
    String ret;
    // length of SC Address
    len = getByte();
    if (len == 0) {
        // no SC address
        ret = null;
    } else {
        // SC address
        try {
            ret = PhoneNumberUtils.calledPartyBCDToString(mPdu, mCur, len);
        } catch (RuntimeException tr) {
            Rlog.d(LOG_TAG, "invalid SC address: ", tr);
            ret = null;
        }
    }
    mCur += len;
    return ret;
}
#method_after
String getSCAddress() {
    int len;
    String ret;
    // length of SC Address
    len = getByte();
    if (len == 0) {
        // no SC address
        ret = null;
    } else {
        // SC address
        try {
            ret = PhoneNumberUtils.calledPartyBCDToString(mPdu, mCur, len, PhoneNumberUtils.BCD_EXTENDED_TYPE_CALLED_PARTY);
        } catch (RuntimeException tr) {
            Rlog.d(LOG_TAG, "invalid SC address: ", tr);
            ret = null;
        }
    }
    mCur += len;
    return ret;
}
#end_block

#method_before
public static SmsMessage createFromEfRecord(int index, byte[] data) {
    try {
        SmsMessage msg = new SmsMessage();
        msg.mIndexOnIcc = index;
        // See 3GPP2 C.S0023 3.4.27
        if ((data[0] & 1) == 0) {
            Rlog.w(LOG_TAG, "SMS parsing failed: Trying to parse a free record");
            return null;
        } else {
            msg.mStatusOnIcc = data[0] & 0x07;
        }
        // Second byte is the MSG_LEN, length of the message
        // See 3GPP2 C.S0023 3.4.27
        int size = data[1];
        // Note: Data may include trailing FF's.  That's OK; message
        // should still parse correctly.
        byte[] pdu = new byte[size];
        System.arraycopy(data, 2, pdu, 0, size);
        // the message has to be parsed before it can be displayed
        // see gsm.SmsMessage
        msg.parsePduFromEfRecord(pdu);
        return msg;
    } catch (RuntimeException ex) {
        Rlog.e(LOG_TAG, "SMS PDU parsing failed: ", ex);
        return null;
    }
}
#method_after
public static SmsMessage createFromEfRecord(int index, byte[] data) {
    try {
        SmsMessage msg = new SmsMessage();
        msg.mIndexOnIcc = index;
        // See 3GPP2 C.S0023 3.4.27
        if ((data[0] & 1) == 0) {
            Rlog.w(LOG_TAG, "SMS parsing failed: Trying to parse a free record");
            return null;
        } else {
            msg.mStatusOnIcc = data[0] & 0x07;
        }
        // Second byte is the MSG_LEN, length of the message
        // See 3GPP2 C.S0023 3.4.27
        int size = data[1] & 0xFF;
        // Note: Data may include trailing FF's.  That's OK; message
        // should still parse correctly.
        byte[] pdu = new byte[size];
        System.arraycopy(data, 2, pdu, 0, size);
        // the message has to be parsed before it can be displayed
        // see gsm.SmsMessage
        msg.parsePduFromEfRecord(pdu);
        return msg;
    } catch (RuntimeException ex) {
        Rlog.e(LOG_TAG, "SMS PDU parsing failed: ", ex);
        return null;
    }
}
#end_block

#method_before
public void sendTextMessageInternal(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    if (TextUtils.isEmpty(destinationAddress)) {
        throw new IllegalArgumentException("Invalid destinationAddress");
    }
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException("Invalid message body");
    }
    try {
        ISms iccISms = getISmsServiceOrThrow();
        if (iccISms != null) {
            iccISms.sendTextForSubscriberWithOptions(getSubscriptionId(), ActivityThread.currentPackageName(), destinationAddress, scAddress, text, sentIntent, deliveryIntent, persistMessage, priority, expectMore, validityPeriod);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
#method_after
private void sendTextMessageInternal(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    if (TextUtils.isEmpty(destinationAddress)) {
        throw new IllegalArgumentException("Invalid destinationAddress");
    }
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException("Invalid message body");
    }
    if (priority < 0x00 || priority > 0x03) {
        throw new IllegalArgumentException("Invalid priority");
    }
    if (validityPeriod < 0x05 || validityPeriod > 0x09b0a0) {
        throw new IllegalArgumentException("Invalid validity period");
    }
    try {
        ISms iccISms = getISmsServiceOrThrow();
        if (iccISms != null) {
            iccISms.sendTextForSubscriberWithOptions(getSubscriptionId(), ActivityThread.currentPackageName(), destinationAddress, scAddress, text, sentIntent, deliveryIntent, persistMessage, priority, expectMore, validityPeriod);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
#end_block

#method_before
@SystemApi
public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, int priority, boolean expectMore, int validityPeriod) {
    sendTextMessageInternal(destinationAddress, scAddress, text, sentIntent, deliveryIntent, false, /* persistMessage */
    priority, expectMore, validityPeriod);
}
#method_after
public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, int priority, boolean expectMore, int validityPeriod) {
    sendTextMessageInternal(destinationAddress, scAddress, text, sentIntent, deliveryIntent, false, /* persistMessage */
    priority, expectMore, validityPeriod);
}
#end_block

#method_before
public void sendMultipartTextMessageInternal(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    if (TextUtils.isEmpty(destinationAddress)) {
        throw new IllegalArgumentException("Invalid destinationAddress");
    }
    if (parts == null || parts.size() < 1) {
        throw new IllegalArgumentException("Invalid message body");
    }
    if (parts.size() > 1) {
        try {
            ISms iccISms = getISmsServiceOrThrow();
            if (iccISms != null) {
                iccISms.sendMultipartTextForSubscriberWithOptions(getSubscriptionId(), ActivityThread.currentPackageName(), destinationAddress, scAddress, parts, sentIntents, deliveryIntents, persistMessage, priority, expectMore, validityPeriod);
            }
        } catch (RemoteException ex) {
        // ignore it
        }
    } else {
        PendingIntent sentIntent = null;
        PendingIntent deliveryIntent = null;
        if (sentIntents != null && sentIntents.size() > 0) {
            sentIntent = sentIntents.get(0);
        }
        if (deliveryIntents != null && deliveryIntents.size() > 0) {
            deliveryIntent = deliveryIntents.get(0);
        }
        sendTextMessageInternal(destinationAddress, scAddress, parts.get(0), sentIntent, deliveryIntent, persistMessage, priority, expectMore, validityPeriod);
    }
}
#method_after
private void sendMultipartTextMessageInternal(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    if (TextUtils.isEmpty(destinationAddress)) {
        throw new IllegalArgumentException("Invalid destinationAddress");
    }
    if (parts == null || parts.size() < 1) {
        throw new IllegalArgumentException("Invalid message body");
    }
    if (priority < 0x00 || priority > 0x03) {
        throw new IllegalArgumentException("Invalid priority");
    }
    if (validityPeriod < 0x05 || validityPeriod > 0x09b0a0) {
        throw new IllegalArgumentException("Invalid validity period");
    }
    if (parts.size() > 1) {
        try {
            ISms iccISms = getISmsServiceOrThrow();
            if (iccISms != null) {
                iccISms.sendMultipartTextForSubscriberWithOptions(getSubscriptionId(), ActivityThread.currentPackageName(), destinationAddress, scAddress, parts, sentIntents, deliveryIntents, persistMessage, priority, expectMore, validityPeriod);
            }
        } catch (RemoteException ex) {
        // ignore it
        }
    } else {
        PendingIntent sentIntent = null;
        PendingIntent deliveryIntent = null;
        if (sentIntents != null && sentIntents.size() > 0) {
            sentIntent = sentIntents.get(0);
        }
        if (deliveryIntents != null && deliveryIntents.size() > 0) {
            deliveryIntent = deliveryIntents.get(0);
        }
        sendTextMessageInternal(destinationAddress, scAddress, parts.get(0), sentIntent, deliveryIntent, persistMessage, priority, expectMore, validityPeriod);
    }
}
#end_block

#method_before
@SystemApi
public void sendMultipartTextMessageWithoutPersisting(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, int priority, boolean expectMore, int validityPeriod) {
    sendMultipartTextMessageInternal(destinationAddress, scAddress, parts, sentIntents, deliveryIntents, false, /* persistMessage*/
    priority, expectMore, validityPeriod);
}
#method_after
public void sendMultipartTextMessageWithoutPersisting(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, int priority, boolean expectMore, int validityPeriod) {
    sendMultipartTextMessageInternal(destinationAddress, scAddress, parts, sentIntents, deliveryIntents, false, /* persistMessage*/
    priority, expectMore, validityPeriod);
}
#end_block

#method_before
public int read() throws IOException {
    // Android-changed: Delegate to read(byte[], int, int) so that IoBridge can be used.
    byte[] b = new byte[1];
    return (read(b, 0, 1) != -1) ? b[0] & 0xff : -1;
}
#method_after
public int read() throws IOException {
    // Android-changed: Read methods delegate to read(byte[], int, int) to share Android logic.
    byte[] b = new byte[1];
    return (read(b, 0, 1) != -1) ? b[0] & 0xff : -1;
}
#end_block

#method_before
// Android-removed: readBytes(byte[], int, int), use IoBridge instead.
/*
    /**
     * Reads a subarray as a sequence of bytes.
     * @param b the data to be written
     * @param off the start offset in the data
     * @param len the number of bytes that are written
     * @exception IOException If an I/O error has occurred.
     *
    private native int readBytes(byte b[], int off, int len) throws IOException;
    */
public int read(byte[] b) throws IOException {
    // Android-changed: Use read(byte[], int, int) for close() check / IO tracking.
    return read(b, 0, b.length);
}
#method_after
// Android-removed: Read methods delegate to read(byte[], int, int) to share Android logic.
// private native int read0() throws IOException;
// Android-removed: Read methods delegate to read(byte[], int, int) to share Android logic.
/*
    /**
     * Reads a subarray as a sequence of bytes.
     * @param b the data to be written
     * @param off the start offset in the data
     * @param len the number of bytes that are written
     * @exception IOException If an I/O error has occurred.
     *
    private native int readBytes(byte b[], int off, int len) throws IOException;
    */
public int read(byte[] b) throws IOException {
    // Android-changed: Read methods delegate to read(byte[], int, int) to share Android logic.
    return read(b, 0, b.length);
}
#end_block

#method_before
public int read(byte[] b, int off, int len) throws IOException {
    // Android-added: Added close() check before reading.
    if (closed && len > 0) {
        throw new IOException("Stream Closed");
    }
    // Android-added: IO tracking.
    tracker.trackIo(len);
    // Android-changed: Switch to IoBridge instead of native method.
    return IoBridge.read(fd, b, off, len);
}
#method_after
public int read(byte[] b, int off, int len) throws IOException {
    // Android-added: close() check before I/O.
    if (closed && len > 0) {
        throw new IOException("Stream Closed");
    }
    // Android-added: Tracking of unbuffered I/O.
    tracker.trackIo(len);
    // Android-changed: Use IoBridge instead of calling native method.
    return IoBridge.read(fd, b, off, len);
}
#end_block

#method_before
/**
 * Skips over and discards <code>n</code> bytes of data from the
 * input stream.
 *
 * <p>The <code>skip</code> method may, for a variety of
 * reasons, end up skipping over some smaller number of bytes,
 * possibly <code>0</code>. If <code>n</code> is negative, the method
 * will try to skip backwards. In case the backing file does not support
 * backward skip at its current position, an <code>IOException</code> is
 * thrown. The actual number of bytes skipped is returned. If it skips
 * forwards, it returns a positive value. If it skips backwards, it
 * returns a negative value.
 *
 * <p>This method may skip more bytes than what are remaining in the
 * backing file. This produces no exception and the number of bytes skipped
 * may include some number of bytes that were beyond the EOF of the
 * backing file. Attempting to read from the stream after skipping past
 * the end will result in -1 indicating the end of the file.
 *
 * @param      n   the number of bytes to be skipped.
 * @return     the actual number of bytes skipped.
 * @exception  IOException  if n is negative, if the stream does not
 *             support seek, or if an I/O error occurs.
 */
public long skip(long n) throws IOException {
    // Android-added: Added close() check before skip.
    if (closed) {
        throw new IOException("Stream Closed");
    }
    try {
        // Android-changed: Added BlockGuard checks.
        BlockGuard.getThreadPolicy().onReadFromDisk();
        return skip0(n);
    } catch (UseManualSkipException e) {
        return super.skip(n);
    }
}
#method_after
/**
 * Skips over and discards <code>n</code> bytes of data from the
 * input stream.
 *
 * <p>The <code>skip</code> method may, for a variety of
 * reasons, end up skipping over some smaller number of bytes,
 * possibly <code>0</code>. If <code>n</code> is negative, the method
 * will try to skip backwards. In case the backing file does not support
 * backward skip at its current position, an <code>IOException</code> is
 * thrown. The actual number of bytes skipped is returned. If it skips
 * forwards, it returns a positive value. If it skips backwards, it
 * returns a negative value.
 *
 * <p>This method may skip more bytes than what are remaining in the
 * backing file. This produces no exception and the number of bytes skipped
 * may include some number of bytes that were beyond the EOF of the
 * backing file. Attempting to read from the stream after skipping past
 * the end will result in -1 indicating the end of the file.
 *
 * @param      n   the number of bytes to be skipped.
 * @return     the actual number of bytes skipped.
 * @exception  IOException  if n is negative, if the stream does not
 *             support seek, or if an I/O error occurs.
 */
public long skip(long n) throws IOException {
    // Android-added: close() check before I/O.
    if (closed) {
        throw new IOException("Stream Closed");
    }
    try {
        // Android-added: BlockGuard support.
        BlockGuard.getThreadPolicy().onReadFromDisk();
        return skip0(n);
    } catch (UseManualSkipException e) {
        return super.skip(n);
    }
}
#end_block

#method_before
// END Android-changed: skip(long) implementation changed from bare native.
/**
 * Returns an estimate of the number of remaining bytes that can be read (or
 * skipped over) from this input stream without blocking by the next
 * invocation of a method for this input stream. Returns 0 when the file
 * position is beyond EOF. The next invocation might be the same thread
 * or another thread. A single read or skip of this many bytes will not
 * block, but may read or skip fewer bytes.
 *
 * <p> In some cases, a non-blocking read (or skip) may appear to be
 * blocked when it is merely slow, for example when reading large
 * files over slow networks.
 *
 * @return     an estimate of the number of remaining bytes that can be read
 *             (or skipped over) from this input stream without blocking.
 * @exception  IOException  if this file input stream has been closed by calling
 *             {@code close} or an I/O error occurs.
 */
public int available() throws IOException {
    // Android-added: Added close() check before available().
    if (closed) {
        throw new IOException("Stream Closed");
    }
    return available0();
}
#method_after
// END Android-changed: skip(long) implementation changed from bare native.
/**
 * Returns an estimate of the number of remaining bytes that can be read (or
 * skipped over) from this input stream without blocking by the next
 * invocation of a method for this input stream. Returns 0 when the file
 * position is beyond EOF. The next invocation might be the same thread
 * or another thread. A single read or skip of this many bytes will not
 * block, but may read or skip fewer bytes.
 *
 * <p> In some cases, a non-blocking read (or skip) may appear to be
 * blocked when it is merely slow, for example when reading large
 * files over slow networks.
 *
 * @return     an estimate of the number of remaining bytes that can be read
 *             (or skipped over) from this input stream without blocking.
 * @exception  IOException  if this file input stream has been closed by calling
 *             {@code close} or an I/O error occurs.
 */
public int available() throws IOException {
    // Android-added: close() check before I/O.
    if (closed) {
        throw new IOException("Stream Closed");
    }
    return available0();
}
#end_block

#method_before
// END Android-changed: available() implementation changed from bare native.
public void close() throws IOException {
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    // Android-added: CloseGuard support.
    guard.close();
    // BEGIN Android-changed: Close handling / notification of blocked threads.
    if (channel != null) {
        /*
             * Decrement the FD use count associated with the channel
             * The use count is incremented whenever a new channel
             * is obtained from this stream.
             */
        channel.close();
    }
    if (isFdOwner) {
        IoBridge.closeAndSignalBlockedThreads(fd);
    }
// END Android-changed: Close handling / notification of blocked threads.
}
#method_after
// END Android-changed: available() implementation changed from bare native.
public void close() throws IOException {
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    // Android-added: CloseGuard support.
    guard.close();
    if (channel != null) {
        channel.close();
    }
    // BEGIN Android-changed: Close handling / notification of blocked threads.
    if (isFdOwner) {
        IoBridge.closeAndSignalBlockedThreads(fd);
    }
// END Android-changed: Close handling / notification of blocked threads.
}
#end_block

#method_before
// BEGIN Android-removed: Unused code.
/*
    private static native void initIDs();

    private native void close0() throws IOException;

    static {
        initIDs();
    }
    */
// END Android-changed: Unused code.
protected void finalize() throws IOException {
    // Android-added: CloseGuard warning.
    if (guard != null) {
        guard.warnIfOpen();
    }
    if ((fd != null) && (fd != FileDescriptor.in)) {
        // Android-removed: Obsoleted comment about shared FileDescriptor handling.
        close();
    }
}
#method_after
// BEGIN Android-removed: Unused code.
/*
    private static native void initIDs();

    private native void close0() throws IOException;

    static {
        initIDs();
    }
    */
// END Android-changed: Unused code.
protected void finalize() throws IOException {
    // Android-added: CloseGuard support.
    if (guard != null) {
        guard.warnIfOpen();
    }
    if ((fd != null) && (fd != FileDescriptor.in)) {
        // Android-removed: Obsoleted comment about shared FileDescriptor handling.
        close();
    }
}
#end_block

#method_before
// Android-removed: write(int, boolean), use IoBridge instead.
/*
    /**
     * Writes the specified byte to this file output stream.
     *
     * @param   b   the byte to be written.
     * @param   append   {@code true} if the write operation first
     *     advances the position to the end of file
     *
    private native void write(int b, boolean append) throws IOException;
    */
public void write(int b) throws IOException {
    // Android-changed: Delegate to write(byte[], int, int) so that IoBridge can be used.
    write(new byte[] { (byte) b }, 0, 1);
}
#method_after
// Android-removed: write(int, boolean), use IoBridge instead.
/*
    /**
     * Writes the specified byte to this file output stream.
     *
     * @param   b   the byte to be written.
     * @param   append   {@code true} if the write operation first
     *     advances the position to the end of file
     *
    private native void write(int b, boolean append) throws IOException;
    */
public void write(int b) throws IOException {
    // Android-changed: Write methods delegate to write(byte[],int,int) to share Android logic.
    write(new byte[] { (byte) b }, 0, 1);
}
#end_block

#method_before
// Android-removed: writeBytes(byte[], int, int, boolean), use IoBridge instead.
/*
    /**
     * Writes a sub array as a sequence of bytes.
     * @param b the data to be written
     * @param off the start offset in the data
     * @param len the number of bytes that are written
     * @param append {@code true} to first advance the position to the
     *     end of file
     * @exception IOException If an I/O error has occurred.
     *
    private native void writeBytes(byte b[], int off, int len, boolean append)
        throws IOException;
    */
public void write(byte[] b) throws IOException {
    // Android-changed: Use write(byte[], int, int) for close() check / IO tracking.
    write(b, 0, b.length);
}
#method_after
// Android-removed: Write methods delegate to write(byte[],int,int) to share Android logic.
/*
    /**
     * Writes a sub array as a sequence of bytes.
     * @param b the data to be written
     * @param off the start offset in the data
     * @param len the number of bytes that are written
     * @param append {@code true} to first advance the position to the
     *     end of file
     * @exception IOException If an I/O error has occurred.
     *
    private native void writeBytes(byte b[], int off, int len, boolean append)
        throws IOException;
    */
public void write(byte[] b) throws IOException {
    // Android-changed: Write methods delegate to write(byte[],int,int) to share Android logic.
    write(b, 0, b.length);
}
#end_block

#method_before
public void write(byte[] b, int off, int len) throws IOException {
    // Android-added: Added close() check before writing.
    if (closed && len > 0) {
        throw new IOException("Stream Closed");
    }
    // Android-added: IO tracking.
    tracker.trackIo(len);
    // Android-changed: Switch to IoBridge instead of native method.
    IoBridge.write(fd, b, off, len);
}
#method_after
public void write(byte[] b, int off, int len) throws IOException {
    // Android-added: close() check before I/O.
    if (closed && len > 0) {
        throw new IOException("Stream Closed");
    }
    // Android-added: Tracking of unbuffered I/O.
    tracker.trackIo(len);
    // Android-changed: Use IoBridge instead of calling native method.
    IoBridge.write(fd, b, off, len);
}
#end_block

#method_before
public void close() throws IOException {
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    // Android-added: CloseGuard support.
    guard.close();
    // BEGIN Android-changed: Close handling / notification of blocked threads.
    if (channel != null) {
        /*
             * Decrement FD use count associated with the channel
             * The use count is incremented whenever a new channel
             * is obtained from this stream.
             */
        channel.close();
    }
    if (isFdOwner) {
        IoBridge.closeAndSignalBlockedThreads(fd);
    }
// END Android-changed: Close handling / notification of blocked threads.
}
#method_after
public void close() throws IOException {
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    // Android-added: CloseGuard support.
    guard.close();
    if (channel != null) {
        channel.close();
    }
    // BEGIN Android-changed: Close handling / notification of blocked threads.
    if (isFdOwner) {
        IoBridge.closeAndSignalBlockedThreads(fd);
    }
// END Android-changed: Close handling / notification of blocked threads.
}
#end_block

#method_before
protected void finalize() throws IOException {
    // Android-added: CloseGuard warning.
    if (guard != null) {
        guard.warnIfOpen();
    }
    if (fd != null) {
        if (fd == FileDescriptor.out || fd == FileDescriptor.err) {
            flush();
        } else {
            // Android-removed: Obsoleted comment about shared FileDescriptor handling.
            close();
        }
    }
}
#method_after
protected void finalize() throws IOException {
    // Android-added: CloseGuard support.
    if (guard != null) {
        guard.warnIfOpen();
    }
    if (fd != null) {
        if (fd == FileDescriptor.out || fd == FileDescriptor.err) {
            flush();
        } else {
            // Android-removed: Obsoleted comment about shared FileDescriptor handling.
            close();
        }
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    CatLog.d(LOG_TAG, "onCreate");
    // Remove the default title, customized one is used.
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    // Set the layout for this activity.
    setContentView(R.layout.stk_menu_list);
    mInstance = this;
    mTitleTextView = (TextView) findViewById(R.id.title_text);
    mTitleIconView = (ImageView) findViewById(R.id.title_icon);
    mProgressView = (ProgressBar) findViewById(R.id.progress_bar);
    mContext = getBaseContext();
    mAcceptUsersInput = true;
    getListView().setOnCreateContextMenuListener(this);
    // with the saved instance state right after the phone process is killed.
    if (appService == null) {
        CatLog.d(LOG_TAG, "onCreate - appService is null");
        finish();
        return;
    }
    initFromIntent(getIntent());
}
#method_after
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    CatLog.d(LOG_TAG, "onCreate");
    ActionBar actionBar = getActionBar();
    actionBar.setCustomView(R.layout.stk_title);
    actionBar.setDisplayShowCustomEnabled(true);
    // Set the layout for this activity.
    setContentView(R.layout.stk_menu_list);
    mInstance = this;
    mTitleTextView = (TextView) findViewById(R.id.title_text);
    mTitleIconView = (ImageView) findViewById(R.id.title_icon);
    mProgressView = (ProgressBar) findViewById(R.id.progress_bar);
    mContext = getBaseContext();
    getListView().setOnCreateContextMenuListener(this);
    // with the saved instance state right after the phone process is killed.
    if (appService == null) {
        CatLog.d(LOG_TAG, "onCreate - appService is null");
        finish();
        return;
    }
    LocalBroadcastManager.getInstance(this).registerReceiver(mLocalBroadcastReceiver, new IntentFilter(StkAppService.SESSION_ENDED));
    initFromIntent(getIntent());
    if (!SubscriptionManager.isValidSlotIndex(mSlotId)) {
        finish();
        return;
    }
}
#end_block

#method_before
@Override
protected void onListItemClick(ListView l, View v, int position, long id) {
    super.onListItemClick(l, v, position, id);
    if (!mAcceptUsersInput) {
        CatLog.d(LOG_TAG, "mAcceptUsersInput:false");
        return;
    }
    Item item = getSelectedItem(position);
    if (item == null) {
        CatLog.d(LOG_TAG, "Item is null");
        return;
    }
    CatLog.d(LOG_TAG, "onListItemClick Id: " + item.id + ", mState: " + mState);
    // ONLY set SECONDARY menu. It will be finished when the following command is comming.
    if (mState == STATE_SECONDARY) {
        appService.getStkContext(mSlotId).setPendingActivityInstance(this);
    }
    cancelTimeOut();
    sendResponse(StkAppService.RES_ID_MENU_SELECTION, item.id, false);
    mAcceptUsersInput = false;
    mProgressView.setVisibility(View.VISIBLE);
    mProgressView.setIndeterminate(true);
}
#method_after
@Override
protected void onListItemClick(ListView l, View v, int position, long id) {
    super.onListItemClick(l, v, position, id);
    if (!mAcceptUsersInput) {
        CatLog.d(LOG_TAG, "mAcceptUsersInput:false");
        return;
    }
    Item item = getSelectedItem(position);
    if (item == null) {
        CatLog.d(LOG_TAG, "Item is null");
        return;
    }
    CatLog.d(LOG_TAG, "onListItemClick Id: " + item.id + ", mState: " + mState);
    // ONLY set SECONDARY menu. It will be finished when the following command is comming.
    if (mState == STATE_SECONDARY) {
        appService.getStkContext(mSlotId).setPendingActivityInstance(this);
    }
    cancelTimeOut();
    sendResponse(StkAppService.RES_ID_MENU_SELECTION, item.id, false);
    invalidateOptionsMenu();
}
#end_block

#method_before
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    CatLog.d(LOG_TAG, "mAcceptUsersInput: " + mAcceptUsersInput);
    if (!mAcceptUsersInput) {
        return true;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            CatLog.d(LOG_TAG, "KEYCODE_BACK - mState[" + mState + "]");
            switch(mState) {
                case STATE_SECONDARY:
                    CatLog.d(LOG_TAG, "STATE_SECONDARY");
                    cancelTimeOut();
                    mAcceptUsersInput = false;
                    appService.getStkContext(mSlotId).setPendingActivityInstance(this);
                    sendResponse(StkAppService.RES_ID_BACKWARD);
                    return true;
                case STATE_MAIN:
                    CatLog.d(LOG_TAG, "STATE_MAIN");
                    cancelTimeOut();
                    finish();
                    return true;
            }
            break;
    }
    return super.onKeyDown(keyCode, event);
}
#method_after
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    CatLog.d(LOG_TAG, "mAcceptUsersInput: " + mAcceptUsersInput);
    if (!mAcceptUsersInput) {
        return true;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            CatLog.d(LOG_TAG, "KEYCODE_BACK - mState[" + mState + "]");
            switch(mState) {
                case STATE_SECONDARY:
                    CatLog.d(LOG_TAG, "STATE_SECONDARY");
                    cancelTimeOut();
                    appService.getStkContext(mSlotId).setPendingActivityInstance(this);
                    sendResponse(StkAppService.RES_ID_BACKWARD);
                    return true;
                case STATE_MAIN:
                    CatLog.d(LOG_TAG, "STATE_MAIN");
                    cancelTimeOut();
                    finish();
                    return true;
            }
            break;
    }
    return super.onKeyDown(keyCode, event);
}
#end_block

#method_before
@Override
public void onResume() {
    super.onResume();
    CatLog.d(LOG_TAG, "onResume, slot id: " + mSlotId + "," + mState);
    appService.indicateMenuVisibility(true, mSlotId);
    if (mState == STATE_MAIN) {
        mStkMenu = appService.getMainMenu(mSlotId);
    } else {
        mStkMenu = appService.getMenu(mSlotId);
    }
    if (mStkMenu == null) {
        CatLog.d(LOG_TAG, "menu is null");
        cancelTimeOut();
        finish();
        return;
    }
    displayMenu();
    startTimeOut();
    // user's input;
    if (!mAcceptUsersInput) {
        // Remove set mState to STATE_MAIN. This is for single instance flow.
        mAcceptUsersInput = true;
    }
    invalidateOptionsMenu();
    // make sure the progress bar is not shown.
    mProgressView.setIndeterminate(false);
    mProgressView.setVisibility(View.GONE);
}
#method_after
@Override
public void onResume() {
    super.onResume();
    CatLog.d(LOG_TAG, "onResume, slot id: " + mSlotId + "," + mState);
    appService.indicateMenuVisibility(true, mSlotId);
    if (mState == STATE_MAIN) {
        mStkMenu = appService.getMainMenu(mSlotId);
    } else {
        mStkMenu = appService.getMenu(mSlotId);
    }
    if (mStkMenu == null) {
        CatLog.d(LOG_TAG, "menu is null");
        cancelTimeOut();
        finish();
        return;
    }
    displayMenu();
    startTimeOut();
    invalidateOptionsMenu();
}
#end_block

#method_before
@Override
public void onDestroy() {
    getListView().setOnCreateContextMenuListener(null);
    super.onDestroy();
    CatLog.d(LOG_TAG, "onDestroy" + "," + mState);
    if (appService == null) {
        return;
    }
    // we can not send TR here, since the input cmd is waiting user to process.
    if (mState == STATE_SECONDARY && !mIsResponseSent && !appService.isMenuPending(mSlotId)) {
        CatLog.d(LOG_TAG, "handleDestroy - Send End Session");
        sendResponse(StkAppService.RES_ID_END_SESSION);
    }
}
#method_after
@Override
public void onDestroy() {
    getListView().setOnCreateContextMenuListener(null);
    super.onDestroy();
    CatLog.d(LOG_TAG, "onDestroy" + ", " + mState);
    if (appService == null || !SubscriptionManager.isValidSlotIndex(mSlotId)) {
        return;
    }
    // we can not send TR here, since the input cmd is waiting user to process.
    if (mState == STATE_SECONDARY && !mIsResponseSent && !appService.isMenuPending(mSlotId)) {
        CatLog.d(LOG_TAG, "handleDestroy - Send End Session");
        sendResponse(StkAppService.RES_ID_END_SESSION);
    }
    LocalBroadcastManager.getInstance(this).unregisterReceiver(mLocalBroadcastReceiver);
}
#end_block

#method_before
@Override
public boolean onCreateOptionsMenu(android.view.Menu menu) {
    super.onCreateOptionsMenu(menu);
    menu.add(0, StkApp.MENU_ID_END_SESSION, 1, R.string.menu_end_session);
    menu.add(0, StkApp.MENU_ID_HELP, 2, R.string.help);
    return true;
}
#method_after
@Override
public boolean onCreateOptionsMenu(android.view.Menu menu) {
    super.onCreateOptionsMenu(menu);
    menu.add(0, StkApp.MENU_ID_END_SESSION, 1, R.string.menu_end_session);
    return true;
}
#end_block

#method_before
@Override
public boolean onPrepareOptionsMenu(android.view.Menu menu) {
    super.onPrepareOptionsMenu(menu);
    boolean helpVisible = false;
    boolean mainVisible = false;
    if (mState == STATE_SECONDARY) {
        mainVisible = true;
    }
    if (mStkMenu != null) {
        helpVisible = mStkMenu.helpAvailable;
    }
    menu.findItem(StkApp.MENU_ID_END_SESSION).setVisible(mainVisible);
    menu.findItem(StkApp.MENU_ID_HELP).setVisible(helpVisible);
    return true;
}
#method_after
@Override
public boolean onPrepareOptionsMenu(android.view.Menu menu) {
    super.onPrepareOptionsMenu(menu);
    boolean mainVisible = false;
    if (mState == STATE_SECONDARY && mAcceptUsersInput) {
        mainVisible = true;
    }
    menu.findItem(StkApp.MENU_ID_END_SESSION).setVisible(mainVisible);
    return mainVisible;
}
#end_block

#method_before
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    if (!mAcceptUsersInput) {
        return true;
    }
    switch(item.getItemId()) {
        case StkApp.MENU_ID_END_SESSION:
            cancelTimeOut();
            mAcceptUsersInput = false;
            // send session end response.
            sendResponse(StkAppService.RES_ID_END_SESSION);
            cancelTimeOut();
            finish();
            return true;
        case StkApp.MENU_ID_HELP:
            cancelTimeOut();
            mAcceptUsersInput = false;
            int position = getSelectedItemPosition();
            Item stkItem = getSelectedItem(position);
            if (stkItem == null) {
                break;
            }
            // send help needed response.
            sendResponse(StkAppService.RES_ID_MENU_SELECTION, stkItem.id, true);
            return true;
    }
    return super.onOptionsItemSelected(item);
}
#method_after
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    if (!mAcceptUsersInput) {
        return true;
    }
    switch(item.getItemId()) {
        case StkApp.MENU_ID_END_SESSION:
            cancelTimeOut();
            // send session end response.
            sendResponse(StkAppService.RES_ID_END_SESSION);
            cancelTimeOut();
            finish();
            return true;
        default:
            break;
    }
    return super.onOptionsItemSelected(item);
}
#end_block

#method_before
@Override
public boolean onContextItemSelected(MenuItem item) {
    AdapterView.AdapterContextMenuInfo info;
    try {
        info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
    } catch (ClassCastException e) {
        return false;
    }
    switch(item.getItemId()) {
        case CONTEXT_MENU_HELP:
            cancelTimeOut();
            mAcceptUsersInput = false;
            int position = info.position;
            CatLog.d(this, "Position:" + position);
            Item stkItem = getSelectedItem(position);
            if (stkItem != null) {
                CatLog.d(this, "item id:" + stkItem.id);
                sendResponse(StkAppService.RES_ID_MENU_SELECTION, stkItem.id, true);
            }
            return true;
        default:
            return super.onContextItemSelected(item);
    }
}
#method_after
@Override
public boolean onContextItemSelected(MenuItem item) {
    AdapterView.AdapterContextMenuInfo info;
    try {
        info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
    } catch (ClassCastException e) {
        return false;
    }
    switch(item.getItemId()) {
        case CONTEXT_MENU_HELP:
            cancelTimeOut();
            int position = info.position;
            CatLog.d(this, "Position:" + position);
            Item stkItem = getSelectedItem(position);
            if (stkItem != null) {
                CatLog.d(this, "item id:" + stkItem.id);
                sendResponse(StkAppService.RES_ID_MENU_SELECTION, stkItem.id, true);
            }
            return true;
        default:
            return super.onContextItemSelected(item);
    }
}
#end_block

#method_before
@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    CatLog.d(LOG_TAG, "onRestoreInstanceState: " + mSlotId);
    mState = savedInstanceState.getInt("STATE");
    mStkMenu = savedInstanceState.getParcelable("MENU");
    mAcceptUsersInput = savedInstanceState.getBoolean("ACCEPT_USERS_INPUT");
}
#method_after
@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    CatLog.d(LOG_TAG, "onRestoreInstanceState: " + mSlotId);
    mState = savedInstanceState.getInt("STATE");
    mStkMenu = savedInstanceState.getParcelable("MENU");
    mAcceptUsersInput = savedInstanceState.getBoolean("ACCEPT_USERS_INPUT");
    if (!mAcceptUsersInput) {
        // Check the latest information as the saved instance state can be outdated.
        if ((mState == STATE_MAIN) && appService.isMainMenuAvailable(mSlotId)) {
            mAcceptUsersInput = true;
        } else {
            showProgressBar(true);
        }
    }
}
#end_block

#method_before
private void sendResponse(int resId, int itemId, boolean help) {
    CatLog.d(LOG_TAG, "sendResponse resID[" + resId + "] itemId[" + itemId + "] help[" + help + "]");
    mIsResponseSent = true;
    Bundle args = new Bundle();
    args.putInt(StkAppService.OPCODE, StkAppService.OP_RESPONSE);
    args.putInt(StkAppService.SLOT_ID, mSlotId);
    args.putInt(StkAppService.RES_ID, resId);
    args.putInt(StkAppService.MENU_SELECTION, itemId);
    args.putBoolean(StkAppService.HELP, help);
    mContext.startService(new Intent(mContext, StkAppService.class).putExtras(args));
}
#method_after
private void sendResponse(int resId, int itemId, boolean help) {
    CatLog.d(LOG_TAG, "sendResponse resID[" + resId + "] itemId[" + itemId + "] help[" + help + "]");
    // Disallow user operation temporarily until receiving the result of the response.
    mAcceptUsersInput = false;
    if (resId == StkAppService.RES_ID_MENU_SELECTION) {
        showProgressBar(true);
    }
    mIsResponseSent = true;
    Bundle args = new Bundle();
    args.putInt(StkAppService.OPCODE, StkAppService.OP_RESPONSE);
    args.putInt(StkAppService.SLOT_ID, mSlotId);
    args.putInt(StkAppService.RES_ID, resId);
    args.putInt(StkAppService.MENU_SELECTION, itemId);
    args.putBoolean(StkAppService.HELP, help);
    mContext.startService(new Intent(mContext, StkAppService.class).putExtras(args));
}
#end_block

#method_before
@Override
public void onCreate() {
    CatLog.d(LOG_TAG, "onCreate()+");
    // Initialize members
    int i = 0;
    mContext = getBaseContext();
    mSimCount = TelephonyManager.from(mContext).getSimCount();
    CatLog.d(LOG_TAG, "simCount: " + mSimCount);
    mStkService = new AppInterface[mSimCount];
    mStkContext = new StkContext[mSimCount];
    mPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
    mStkCmdReceiver = new StkCmdReceiver();
    registerReceiver(mStkCmdReceiver, new IntentFilter(Intent.ACTION_SCREEN_OFF));
    for (i = 0; i < mSimCount; i++) {
        CatLog.d(LOG_TAG, "slotId: " + i);
        mStkService[i] = CatService.getInstance(i);
        mStkContext[i] = new StkContext();
        mStkContext[i].mSlotId = i;
        mStkContext[i].mCmdsQ = new LinkedList<DelayedCmd>();
    }
    Thread serviceThread = new Thread(null, this, "Stk App Service");
    serviceThread.start();
    mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    sInstance = this;
}
#method_after
@Override
public void onCreate() {
    CatLog.d(LOG_TAG, "onCreate()+");
    // Initialize members
    int i = 0;
    mContext = getBaseContext();
    mSimCount = TelephonyManager.from(mContext).getSimCount();
    CatLog.d(LOG_TAG, "simCount: " + mSimCount);
    mStkService = new AppInterface[mSimCount];
    mStkContext = new StkContext[mSimCount];
    for (i = 0; i < mSimCount; i++) {
        CatLog.d(LOG_TAG, "slotId: " + i);
        mStkService[i] = CatService.getInstance(i);
        mStkContext[i] = new StkContext();
        mStkContext[i].mSlotId = i;
        mStkContext[i].mCmdsQ = new LinkedList<DelayedCmd>();
    }
    Thread serviceThread = new Thread(null, this, "Stk App Service");
    serviceThread.start();
    mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    sInstance = this;
}
#end_block

#method_before
@Override
public void onStart(Intent intent, int startId) {
    if (intent == null) {
        CatLog.d(LOG_TAG, "StkAppService onStart intent is null so return");
        return;
    }
    Bundle args = intent.getExtras();
    if (args == null) {
        CatLog.d(LOG_TAG, "StkAppService onStart args is null so return");
        return;
    }
    int op = args.getInt(OPCODE);
    int slotId = 0;
    int i = 0;
    if (op != OP_BOOT_COMPLETED) {
        slotId = args.getInt(SLOT_ID);
    }
    CatLog.d(LOG_TAG, "onStart sim id: " + slotId + ", op: " + op + ", *****");
    if ((slotId >= 0 && slotId < mSimCount) && mStkService[slotId] == null) {
        mStkService[slotId] = CatService.getInstance(slotId);
        if (mStkService[slotId] == null) {
            CatLog.d(LOG_TAG, "mStkService is: " + mStkContext[slotId].mStkServiceState);
            mStkContext[slotId].mStkServiceState = STATE_NOT_EXIST;
            // If all StkServices are not available, stop itself and uninstall apk.
            for (i = PhoneConstants.SIM_ID_1; i < mSimCount; i++) {
                if (i != slotId && (mStkService[i] != null) && (mStkContext[i].mStkServiceState == STATE_UNKNOWN || mStkContext[i].mStkServiceState == STATE_EXIST)) {
                    break;
                }
            }
        } else {
            mStkContext[slotId].mStkServiceState = STATE_EXIST;
        }
        if (i == mSimCount) {
            stopSelf();
            StkAppInstaller.unInstall(mContext);
            return;
        }
    }
    waitForLooper();
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = op;
    msg.arg2 = slotId;
    switch(msg.arg1) {
        case OP_CMD:
            msg.obj = args.getParcelable(CMD_MSG);
            break;
        case OP_RESPONSE:
        case OP_CARD_STATUS_CHANGED:
        case OP_LOCALE_CHANGED:
        case OP_ALPHA_NOTIFY:
        case OP_IDLE_SCREEN:
            msg.obj = args;
        /* falls through */
        case OP_LAUNCH_APP:
        case OP_END_SESSION:
        case OP_BOOT_COMPLETED:
            break;
        default:
            return;
    }
    mServiceHandler.sendMessage(msg);
}
#method_after
@Override
public void onStart(Intent intent, int startId) {
    if (intent == null) {
        CatLog.d(LOG_TAG, "StkAppService onStart intent is null so return");
        return;
    }
    Bundle args = intent.getExtras();
    if (args == null) {
        CatLog.d(LOG_TAG, "StkAppService onStart args is null so return");
        return;
    }
    int op = args.getInt(OPCODE);
    int slotId = 0;
    int i = 0;
    if (op != OP_BOOT_COMPLETED) {
        slotId = args.getInt(SLOT_ID);
    }
    CatLog.d(LOG_TAG, "onStart sim id: " + slotId + ", op: " + op + ", *****");
    if ((slotId >= 0 && slotId < mSimCount) && mStkService[slotId] == null) {
        mStkService[slotId] = CatService.getInstance(slotId);
        if (mStkService[slotId] == null) {
            CatLog.d(LOG_TAG, "mStkService is: " + mStkContext[slotId].mStkServiceState);
            mStkContext[slotId].mStkServiceState = STATE_NOT_EXIST;
            // If all StkServices are not available, stop itself and uninstall apk.
            for (i = PhoneConstants.SIM_ID_1; i < mSimCount; i++) {
                if (i != slotId && (mStkService[i] != null) && (mStkContext[i].mStkServiceState == STATE_UNKNOWN || mStkContext[i].mStkServiceState == STATE_EXIST)) {
                    break;
                }
            }
        } else {
            mStkContext[slotId].mStkServiceState = STATE_EXIST;
        }
        if (i == mSimCount) {
            stopSelf();
            StkAppInstaller.unInstall(mContext);
            return;
        }
    }
    waitForLooper();
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = op;
    msg.arg2 = slotId;
    switch(msg.arg1) {
        case OP_CMD:
            msg.obj = args.getParcelable(CMD_MSG);
            break;
        case OP_RESPONSE:
        case OP_CARD_STATUS_CHANGED:
        case OP_LOCALE_CHANGED:
        case OP_ALPHA_NOTIFY:
        case OP_IDLE_SCREEN:
            msg.obj = args;
        /* falls through */
        case OP_LAUNCH_APP:
        case OP_END_SESSION:
        case OP_BOOT_COMPLETED:
            break;
        case OP_STOP_TONE_USER:
            msg.obj = args;
            msg.what = STOP_TONE_WHAT;
            break;
        default:
            return;
    }
    mServiceHandler.sendMessage(msg);
}
#end_block

#method_before
@Override
public void onDestroy() {
    CatLog.d(LOG_TAG, "onDestroy()");
    if (mStkCmdReceiver != null) {
        unregisterReceiver(mStkCmdReceiver);
        mStkCmdReceiver = null;
    }
    mPowerManager = null;
    waitForLooper();
    mServiceLooper.quit();
}
#method_after
@Override
public void onDestroy() {
    CatLog.d(LOG_TAG, "onDestroy()");
    unregisterProcessObserver();
    sInstance = null;
    waitForLooper();
    mServiceLooper.quit();
}
#end_block

#method_before
Menu getMainMenu(int slotId) {
    CatLog.d(LOG_TAG, "StkAppService, getMainMenu, sim id: " + slotId);
    if (slotId >= 0 && slotId < mSimCount && (mStkContext[slotId].mMainCmd != null)) {
        return mStkContext[slotId].mMainCmd.getMenu();
    } else {
        return null;
    }
}
#method_after
Menu getMainMenu(int slotId) {
    CatLog.d(LOG_TAG, "StkAppService, getMainMenu, sim id: " + slotId);
    if (slotId >= 0 && slotId < mSimCount && (mStkContext[slotId].mMainCmd != null)) {
        Menu menu = mStkContext[slotId].mMainCmd.getMenu();
        if (menu != null && mSimCount > PhoneConstants.MAX_PHONE_COUNT_SINGLE_SIM) {
            // specified in SET-UP MENU command, it should be more prioritized than preset ones.
            if (menu.title == null && (menu.titleIcon == null || !menu.titleIconSelfExplanatory)) {
                StkMenuConfig config = StkMenuConfig.getInstance(getApplicationContext());
                String label = config.getLabel(slotId);
                Bitmap icon = config.getIcon(slotId);
                if (label != null || icon != null) {
                    Parcel parcel = Parcel.obtain();
                    menu.writeToParcel(parcel, 0);
                    parcel.setDataPosition(0);
                    menu = Menu.CREATOR.createFromParcel(parcel);
                    parcel.recycle();
                    menu.title = label;
                    menu.titleIcon = icon;
                    menu.titleIconSelfExplanatory = false;
                }
            }
        }
        return menu;
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (null == msg) {
        CatLog.d(LOG_TAG, "ServiceHandler handleMessage msg is null");
        return;
    }
    int opcode = msg.arg1;
    int slotId = msg.arg2;
    CatLog.d(LOG_TAG, "handleMessage opcode[" + opcode + "], sim id[" + slotId + "]");
    if (opcode == OP_CMD && msg.obj != null && ((CatCmdMessage) msg.obj).getCmdType() != null) {
        CatLog.d(LOG_TAG, "cmdName[" + ((CatCmdMessage) msg.obj).getCmdType().name() + "]");
    }
    mStkContext[slotId].mOpCode = opcode;
    switch(opcode) {
        case OP_LAUNCH_APP:
            if (mStkContext[slotId].mMainCmd == null) {
                CatLog.d(LOG_TAG, "mMainCmd is null");
                // nothing todo when no SET UP MENU command didn't arrive.
                return;
            }
            CatLog.d(LOG_TAG, "handleMessage OP_LAUNCH_APP - mCmdInProgress[" + mStkContext[slotId].mCmdInProgress + "]");
            // If there is a pending activity for the slot id,
            // just finish it and create a new one to handle the pending command.
            cleanUpInstanceStackBySlot(slotId);
            CatLog.d(LOG_TAG, "Current cmd type: " + mStkContext[slotId].mCurrentCmd.getCmdType());
            // Restore the last command from stack by slot id.
            restoreInstanceFromStackBySlot(slotId);
            break;
        case OP_CMD:
            CatLog.d(LOG_TAG, "[OP_CMD]");
            CatCmdMessage cmdMsg = (CatCmdMessage) msg.obj;
            // the user has responded or a timeout expired.
            if (!isCmdInteractive(cmdMsg)) {
                handleCmd(cmdMsg, slotId);
            } else {
                if (!mStkContext[slotId].mCmdInProgress) {
                    mStkContext[slotId].mCmdInProgress = true;
                    handleCmd((CatCmdMessage) msg.obj, slotId);
                } else {
                    CatLog.d(LOG_TAG, "[Interactive][in progress]");
                    mStkContext[slotId].mCmdsQ.addLast(new DelayedCmd(OP_CMD, (CatCmdMessage) msg.obj, slotId));
                }
            }
            break;
        case OP_RESPONSE:
            handleCmdResponse((Bundle) msg.obj, slotId);
            // call delayed commands if needed.
            if (mStkContext[slotId].mCmdsQ.size() != 0) {
                callDelayedMsg(slotId);
            } else {
                mStkContext[slotId].mCmdInProgress = false;
            }
            break;
        case OP_END_SESSION:
            if (!mStkContext[slotId].mCmdInProgress) {
                mStkContext[slotId].mCmdInProgress = true;
                handleSessionEnd(slotId);
            } else {
                mStkContext[slotId].mCmdsQ.addLast(new DelayedCmd(OP_END_SESSION, null, slotId));
            }
            break;
        case OP_BOOT_COMPLETED:
            CatLog.d(LOG_TAG, " OP_BOOT_COMPLETED");
            int i = 0;
            for (i = PhoneConstants.SIM_ID_1; i < mSimCount; i++) {
                if (mStkContext[i].mMainCmd != null) {
                    break;
                }
            }
            if (i == mSimCount) {
                StkAppInstaller.unInstall(mContext);
            }
            break;
        case OP_DELAYED_MSG:
            handleDelayedCmd(slotId);
            break;
        case OP_CARD_STATUS_CHANGED:
            CatLog.d(LOG_TAG, "Card/Icc Status change received");
            handleCardStatusChangeAndIccRefresh((Bundle) msg.obj, slotId);
            break;
        case OP_SET_ACT_INST:
            Activity act = new Activity();
            act = (Activity) msg.obj;
            CatLog.d(LOG_TAG, "Set activity instance. " + act);
            mStkContext[slotId].mActivityInstance = act;
            break;
        case OP_SET_DAL_INST:
            Activity dal = new Activity();
            CatLog.d(LOG_TAG, "Set dialog instance. " + dal);
            dal = (Activity) msg.obj;
            mStkContext[slotId].mDialogInstance = dal;
            break;
        case OP_LOCALE_CHANGED:
            CatLog.d(this, "Locale Changed");
            for (int slot = PhoneConstants.SIM_ID_1; slot < mSimCount; slot++) {
                checkForSetupEvent(LANGUAGE_SELECTION_EVENT, (Bundle) msg.obj, slot);
            }
            break;
        case OP_ALPHA_NOTIFY:
            handleAlphaNotify((Bundle) msg.obj);
            break;
        case OP_IDLE_SCREEN:
            for (int slot = 0; slot < mSimCount; slot++) {
                if (mStkContext[slot] != null) {
                    handleIdleScreen(slot);
                }
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (null == msg) {
        CatLog.d(LOG_TAG, "ServiceHandler handleMessage msg is null");
        return;
    }
    int opcode = msg.arg1;
    int slotId = msg.arg2;
    CatLog.d(LOG_TAG, "handleMessage opcode[" + opcode + "], sim id[" + slotId + "]");
    if (opcode == OP_CMD && msg.obj != null && ((CatCmdMessage) msg.obj).getCmdType() != null) {
        CatLog.d(LOG_TAG, "cmdName[" + ((CatCmdMessage) msg.obj).getCmdType().name() + "]");
    }
    mStkContext[slotId].mOpCode = opcode;
    switch(opcode) {
        case OP_LAUNCH_APP:
            if (mStkContext[slotId].mMainCmd == null) {
                CatLog.d(LOG_TAG, "mMainCmd is null");
                // nothing todo when no SET UP MENU command didn't arrive.
                return;
            }
            CatLog.d(LOG_TAG, "handleMessage OP_LAUNCH_APP - mCmdInProgress[" + mStkContext[slotId].mCmdInProgress + "]");
            // If there is a pending activity for the slot id,
            // just finish it and create a new one to handle the pending command.
            cleanUpInstanceStackBySlot(slotId);
            CatLog.d(LOG_TAG, "Current cmd type: " + mStkContext[slotId].mCurrentCmd.getCmdType());
            // Restore the last command from stack by slot id.
            restoreInstanceFromStackBySlot(slotId);
            break;
        case OP_CMD:
            CatLog.d(LOG_TAG, "[OP_CMD]");
            CatCmdMessage cmdMsg = (CatCmdMessage) msg.obj;
            // the user has responded or a timeout expired.
            if (!isCmdInteractive(cmdMsg)) {
                handleCmd(cmdMsg, slotId);
            } else {
                if (!mStkContext[slotId].mCmdInProgress) {
                    mStkContext[slotId].mCmdInProgress = true;
                    handleCmd((CatCmdMessage) msg.obj, slotId);
                } else {
                    CatLog.d(LOG_TAG, "[Interactive][in progress]");
                    mStkContext[slotId].mCmdsQ.addLast(new DelayedCmd(OP_CMD, (CatCmdMessage) msg.obj, slotId));
                }
            }
            break;
        case OP_RESPONSE:
            handleCmdResponse((Bundle) msg.obj, slotId);
            // call delayed commands if needed.
            if (mStkContext[slotId].mCmdsQ.size() != 0) {
                callDelayedMsg(slotId);
            } else {
                mStkContext[slotId].mCmdInProgress = false;
            }
            break;
        case OP_END_SESSION:
            if (!mStkContext[slotId].mCmdInProgress) {
                mStkContext[slotId].mCmdInProgress = true;
                handleSessionEnd(slotId);
            } else {
                mStkContext[slotId].mCmdsQ.addLast(new DelayedCmd(OP_END_SESSION, null, slotId));
            }
            break;
        case OP_BOOT_COMPLETED:
            CatLog.d(LOG_TAG, " OP_BOOT_COMPLETED");
            int i = 0;
            for (i = PhoneConstants.SIM_ID_1; i < mSimCount; i++) {
                if (mStkContext[i].mMainCmd != null) {
                    break;
                }
            }
            if (i == mSimCount) {
                StkAppInstaller.unInstall(mContext);
            }
            break;
        case OP_DELAYED_MSG:
            handleDelayedCmd(slotId);
            break;
        case OP_CARD_STATUS_CHANGED:
            CatLog.d(LOG_TAG, "Card/Icc Status change received");
            handleCardStatusChangeAndIccRefresh((Bundle) msg.obj, slotId);
            break;
        case OP_SET_ACT_INST:
            Activity act = (Activity) msg.obj;
            if (mStkContext[slotId].mActivityInstance != act) {
                CatLog.d(LOG_TAG, "Set activity instance - " + act);
                Activity previous = mStkContext[slotId].mActivityInstance;
                mStkContext[slotId].mActivityInstance = act;
                // Finish the previous one if it has not been finished yet somehow.
                if (previous != null && !previous.isDestroyed() && !previous.isFinishing()) {
                    CatLog.d(LOG_TAG, "Finish the previous pending activity - " + previous);
                    previous.finish();
                }
            }
            break;
        case OP_SET_DAL_INST:
            Activity dal = new Activity();
            CatLog.d(LOG_TAG, "Set dialog instance. " + dal);
            dal = (Activity) msg.obj;
            mStkContext[slotId].mDialogInstance = dal;
            break;
        case OP_LOCALE_CHANGED:
            CatLog.d(this, "Locale Changed");
            for (int slot = PhoneConstants.SIM_ID_1; slot < mSimCount; slot++) {
                checkForSetupEvent(LANGUAGE_SELECTION_EVENT, (Bundle) msg.obj, slot);
            }
            // rename all registered notification channels on locale change
            createAllChannels();
            break;
        case OP_ALPHA_NOTIFY:
            handleAlphaNotify((Bundle) msg.obj);
            break;
        case OP_IDLE_SCREEN:
            for (int slot = 0; slot < mSimCount; slot++) {
                if (mStkContext[slot] != null) {
                    handleIdleScreen(slot);
                }
            }
            break;
        case OP_STOP_TONE_USER:
        case OP_STOP_TONE:
            CatLog.d(this, "Stop tone");
            handleStopTone(msg, slotId);
            break;
    }
}
#end_block

#method_before
private void handleCardStatusChangeAndIccRefresh(Bundle args, int slotId) {
    boolean cardStatus = args.getBoolean(AppInterface.CARD_STATUS);
    CatLog.d(LOG_TAG, "CardStatus: " + cardStatus);
    if (cardStatus == false) {
        CatLog.d(LOG_TAG, "CARD is ABSENT");
        // Uninstall STKAPP, Clear Idle text, Stop StkAppService
        mNotificationManager.cancel(getNotificationId(slotId));
        if (isAllOtherCardsAbsent(slotId)) {
            CatLog.d(LOG_TAG, "All CARDs are ABSENT");
            StkAppInstaller.unInstall(mContext);
            stopSelf();
        }
    } else {
        IccRefreshResponse state = new IccRefreshResponse();
        state.refreshResult = args.getInt(AppInterface.REFRESH_RESULT);
        CatLog.d(LOG_TAG, "Icc Refresh Result: " + state.refreshResult);
        if ((state.refreshResult == IccRefreshResponse.REFRESH_RESULT_INIT) || (state.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET)) {
            // Clear Idle Text
            mNotificationManager.cancel(getNotificationId(slotId));
        }
        if (state.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET) {
            // Uninstall STkmenu
            if (isAllOtherCardsAbsent(slotId)) {
                StkAppInstaller.unInstall(mContext);
            }
            mStkContext[slotId].mCurrentMenu = null;
            mStkContext[slotId].mMainCmd = null;
        }
    }
}
#method_after
private void handleCardStatusChangeAndIccRefresh(Bundle args, int slotId) {
    boolean cardStatus = args.getBoolean(AppInterface.CARD_STATUS);
    CatLog.d(LOG_TAG, "CardStatus: " + cardStatus);
    if (cardStatus == false) {
        CatLog.d(LOG_TAG, "CARD is ABSENT");
        // Uninstall STKAPP, Clear Idle text, Stop StkAppService
        cancelIdleText(slotId);
        mStkContext[slotId].mCurrentMenu = null;
        mStkContext[slotId].mMainCmd = null;
        if (isAllOtherCardsAbsent(slotId)) {
            CatLog.d(LOG_TAG, "All CARDs are ABSENT");
            StkAppInstaller.unInstall(mContext);
            stopSelf();
        }
    } else {
        IccRefreshResponse state = new IccRefreshResponse();
        state.refreshResult = args.getInt(AppInterface.REFRESH_RESULT);
        CatLog.d(LOG_TAG, "Icc Refresh Result: " + state.refreshResult);
        if ((state.refreshResult == IccRefreshResponse.REFRESH_RESULT_INIT) || (state.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET)) {
            // Clear Idle Text
            cancelIdleText(slotId);
        }
        if (state.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET) {
            // Uninstall STkmenu
            if (isAllOtherCardsAbsent(slotId)) {
                StkAppInstaller.unInstall(mContext);
            }
            mStkContext[slotId].mCurrentMenu = null;
            mStkContext[slotId].mMainCmd = null;
        }
    }
}
#end_block

#method_before
private boolean isScreenIdle() {
    return (!mPowerManager.isInteractive());
}
#method_after
boolean isScreenIdle() {
    ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    List<RunningTaskInfo> tasks = am.getRunningTasks(1);
    if (tasks == null || tasks.isEmpty()) {
        return false;
    }
    String top = tasks.get(0).topActivity.getPackageName();
    if (top == null) {
        return false;
    }
    // We can assume that the screen is idle if the home application is in the foreground.
    final Intent intent = new Intent(Intent.ACTION_MAIN, null);
    intent.addCategory(Intent.CATEGORY_HOME);
    ResolveInfo info = getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null) {
        if (top.equals(info.activityInfo.packageName)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void handleIdleScreen(int slotId) {
    // If the idle screen event is present in the list need to send the
    // response to SIM.
    CatLog.d(this, "Need to send IDLE SCREEN Available event to SIM");
    checkForSetupEvent(IDLE_SCREEN_AVAILABLE_EVENT, null, slotId);
    if (mStkContext[slotId].mIdleModeTextCmd != null) {
        launchIdleText(slotId);
    }
}
#method_after
private void handleIdleScreen(int slotId) {
    // If the idle screen event is present in the list need to send the
    // response to SIM.
    CatLog.d(this, "Need to send IDLE SCREEN Available event to SIM");
    checkForSetupEvent(IDLE_SCREEN_AVAILABLE_EVENT, null, slotId);
    if (mStkContext[slotId].mIdleModeTextCmd != null && !mStkContext[slotId].mIdleModeTextVisible) {
        launchIdleText(slotId);
    }
}
#end_block

#method_before
private void handleSessionEnd(int slotId) {
    // We should finish all pending activity if receiving END SESSION command.
    cleanUpInstanceStackBySlot(slotId);
    mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
    CatLog.d(LOG_TAG, "[handleSessionEnd] - mCurrentCmd changed to mMainCmd!.");
    mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mMainCmd;
    CatLog.d(LOG_TAG, "slotId: " + slotId + ", mMenuState: " + mStkContext[slotId].mMenuState);
    mStkContext[slotId].mIsInputPending = false;
    mStkContext[slotId].mIsMenuPending = false;
    mStkContext[slotId].mIsDialogPending = false;
    if (mStkContext[slotId].mMainCmd == null) {
        CatLog.d(LOG_TAG, "[handleSessionEnd][mMainCmd is null!]");
    }
    mStkContext[slotId].lastSelectedItem = null;
    // update the current menu member.
    if (mStkContext[slotId].mCurrentMenu != null && mStkContext[slotId].mMainCmd != null) {
        mStkContext[slotId].mCurrentMenu = mStkContext[slotId].mMainCmd.getMenu();
    }
    CatLog.d(LOG_TAG, "[handleSessionEnd][mMenuState]" + mStkContext[slotId].mMenuIsVisible);
    if (StkMenuActivity.STATE_SECONDARY == mStkContext[slotId].mMenuState) {
        mStkContext[slotId].mMenuState = StkMenuActivity.STATE_MAIN;
    }
    if (mStkContext[slotId].mCmdsQ.size() != 0) {
        callDelayedMsg(slotId);
    } else {
        mStkContext[slotId].mCmdInProgress = false;
    }
    // In case a launch browser command was just confirmed, launch that url.
    if (mStkContext[slotId].launchBrowser) {
        mStkContext[slotId].launchBrowser = false;
        launchBrowser(mStkContext[slotId].mBrowserSettings);
    }
}
#method_after
private void handleSessionEnd(int slotId) {
    // We should finish all pending activity if receiving END SESSION command.
    cleanUpInstanceStackBySlot(slotId);
    mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
    CatLog.d(LOG_TAG, "[handleSessionEnd] - mCurrentCmd changed to mMainCmd!.");
    mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mMainCmd;
    CatLog.d(LOG_TAG, "slotId: " + slotId + ", mMenuState: " + mStkContext[slotId].mMenuState);
    mStkContext[slotId].mIsInputPending = false;
    mStkContext[slotId].mIsMenuPending = false;
    mStkContext[slotId].mIsDialogPending = false;
    if (mStkContext[slotId].mMainCmd == null) {
        CatLog.d(LOG_TAG, "[handleSessionEnd][mMainCmd is null!]");
    }
    mStkContext[slotId].lastSelectedItem = null;
    // update the current menu member.
    if (mStkContext[slotId].mCurrentMenu != null && mStkContext[slotId].mMainCmd != null) {
        mStkContext[slotId].mCurrentMenu = mStkContext[slotId].mMainCmd.getMenu();
    }
    CatLog.d(LOG_TAG, "[handleSessionEnd][mMenuState]" + mStkContext[slotId].mMenuIsVisible);
    if (StkMenuActivity.STATE_SECONDARY == mStkContext[slotId].mMenuState) {
        mStkContext[slotId].mMenuState = StkMenuActivity.STATE_MAIN;
    }
    // Send a local broadcast as a notice that this service handled the session end event.
    Intent intent = new Intent(SESSION_ENDED);
    intent.putExtra(SLOT_ID, slotId);
    LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    if (mStkContext[slotId].mCmdsQ.size() != 0) {
        callDelayedMsg(slotId);
    } else {
        mStkContext[slotId].mCmdInProgress = false;
    }
    // In case a launch browser command was just confirmed, launch that url.
    if (mStkContext[slotId].launchBrowser) {
        mStkContext[slotId].launchBrowser = false;
        launchBrowser(mStkContext[slotId].mBrowserSettings);
    }
}
#end_block

#method_before
private boolean isTopOfStack() {
    ActivityManager mActivityManager = (ActivityManager) mContext.getSystemService(ACTIVITY_SERVICE);
    String currentPackageName = null;
    List<RunningTaskInfo> tasks = mActivityManager.getRunningTasks(1);
    if (tasks == null || tasks.get(0).topActivity == null) {
        return false;
    }
    currentPackageName = tasks.get(0).topActivity.getPackageName();
    if (null != currentPackageName) {
        return currentPackageName.equals(PACKAGE_NAME);
    }
    return false;
}
#method_after
boolean isTopOfStack() {
    ActivityManager mActivityManager = (ActivityManager) mContext.getSystemService(ACTIVITY_SERVICE);
    String currentPackageName = null;
    List<RunningTaskInfo> tasks = mActivityManager.getRunningTasks(1);
    if (tasks == null || tasks.get(0).topActivity == null) {
        return false;
    }
    currentPackageName = tasks.get(0).topActivity.getPackageName();
    if (null != currentPackageName) {
        return currentPackageName.equals(PACKAGE_NAME);
    }
    return false;
}
#end_block

#method_before
private void handleCmd(CatCmdMessage cmdMsg, int slotId) {
    if (cmdMsg == null) {
        return;
    }
    // save local reference for state tracking.
    mStkContext[slotId].mCurrentCmd = cmdMsg;
    boolean waitForUsersResponse = true;
    mStkContext[slotId].mIsInputPending = false;
    mStkContext[slotId].mIsMenuPending = false;
    mStkContext[slotId].mIsDialogPending = false;
    CatLog.d(LOG_TAG, "[handleCmd]" + cmdMsg.getCmdType().name());
    switch(cmdMsg.getCmdType()) {
        case DISPLAY_TEXT:
            TextMessage msg = cmdMsg.geTextMessage();
            waitForUsersResponse = msg.responseNeeded;
            if (mStkContext[slotId].lastSelectedItem != null) {
                msg.title = mStkContext[slotId].lastSelectedItem;
            } else if (mStkContext[slotId].mMainCmd != null) {
                msg.title = mStkContext[slotId].mMainCmd.getMenu().title;
            } else {
                // TODO: get the carrier name from the SIM
                msg.title = "";
            }
            // proactive command (Refer to ETSI TS 102 384 section 27.22.4.1.4.4.2).
            if (!(msg.isHighPriority || mStkContext[slotId].mMenuIsVisible || mStkContext[slotId].mDisplayTextDlgIsVisibile || isTopOfStack())) {
                if (!isScreenIdle()) {
                    CatLog.d(LOG_TAG, "Screen is not idle");
                    sendScreenBusyResponse(slotId);
                } else {
                    launchTextDialog(slotId);
                }
            } else {
                launchTextDialog(slotId);
            }
            break;
        case SELECT_ITEM:
            CatLog.d(LOG_TAG, "SELECT_ITEM +");
            mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenu = cmdMsg.getMenu();
            launchMenuActivity(cmdMsg.getMenu(), slotId);
            break;
        case SET_UP_MENU:
            mStkContext[slotId].mCmdInProgress = false;
            mStkContext[slotId].mMainCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenu = cmdMsg.getMenu();
            CatLog.d(LOG_TAG, "SET_UP_MENU [" + removeMenu(slotId) + "]");
            if (removeMenu(slotId)) {
                int i = 0;
                CatLog.d(LOG_TAG, "removeMenu() - Uninstall App");
                mStkContext[slotId].mCurrentMenu = null;
                mStkContext[slotId].mMainCmd = null;
                // Check other setup menu state. If all setup menu are removed, uninstall apk.
                for (i = PhoneConstants.SIM_ID_1; i < mSimCount; i++) {
                    if (i != slotId && (mStkContext[slotId].mSetupMenuState == STATE_UNKNOWN || mStkContext[slotId].mSetupMenuState == STATE_EXIST)) {
                        CatLog.d(LOG_TAG, "Not Uninstall App:" + i + "," + mStkContext[slotId].mSetupMenuState);
                        break;
                    }
                }
                if (i == mSimCount) {
                    StkAppInstaller.unInstall(mContext);
                }
            } else {
                CatLog.d(LOG_TAG, "install App");
                StkAppInstaller.install(mContext);
            }
            if (mStkContext[slotId].mMenuIsVisible) {
                launchMenuActivity(null, slotId);
            }
            break;
        case GET_INPUT:
        case GET_INKEY:
            launchInputActivity(slotId);
            break;
        case SET_UP_IDLE_MODE_TEXT:
            waitForUsersResponse = false;
            mStkContext[slotId].mIdleModeTextCmd = mStkContext[slotId].mCurrentCmd;
            TextMessage idleModeText = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if (idleModeText == null) {
                launchIdleText(slotId);
                mStkContext[slotId].mIdleModeTextCmd = null;
            }
            mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
            if ((mStkContext[slotId].mIdleModeTextCmd != null) && isScreenIdle()) {
                CatLog.d(this, "set up idle mode");
                launchIdleText(slotId);
            }
            break;
        case SEND_DTMF:
        case SEND_SMS:
        case SEND_SS:
        case SEND_USSD:
        case GET_CHANNEL_STATUS:
            waitForUsersResponse = false;
            launchEventMessage(slotId);
            break;
        case LAUNCH_BROWSER:
            // The device setup process should not be interrupted by launching browser.
            if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
                CatLog.d(this, "The command is not performed if the setup has not been completed.");
                sendScreenBusyResponse(slotId);
                break;
            }
            /* Check if Carrier would not want to launch browser */
            if (getBooleanCarrierConfig(mContext, CarrierConfigManager.KEY_STK_DISABLE_LAUNCH_BROWSER_BOOL)) {
                CatLog.d(this, "Browser is not launched as per carrier.");
                sendResponse(RES_ID_DONE, slotId, true);
                break;
            }
            TextMessage alphaId = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if ((mStkContext[slotId].mCurrentCmd.getBrowserSettings().mode == LaunchBrowserMode.LAUNCH_IF_NOT_ALREADY_LAUNCHED) && ((alphaId == null) || TextUtils.isEmpty(alphaId.text))) {
                // don't need user confirmation in this case
                // just launch the browser or spawn a new tab
                CatLog.d(this, "Browser mode is: launch if not already launched " + "and user confirmation is not currently needed.\n" + "supressing confirmation dialogue and confirming silently...");
                mStkContext[slotId].launchBrowser = true;
                mStkContext[slotId].mBrowserSettings = mStkContext[slotId].mCurrentCmd.getBrowserSettings();
                sendResponse(RES_ID_CONFIRM, slotId, true);
            } else {
                launchConfirmationDialog(alphaId, slotId);
            }
            break;
        case SET_UP_CALL:
            TextMessage mesg = mStkContext[slotId].mCurrentCmd.getCallSettings().confirmMsg;
            if ((mesg != null) && (mesg.text == null || mesg.text.length() == 0)) {
                mesg.text = getResources().getString(R.string.default_setup_call_msg);
            }
            CatLog.d(this, "SET_UP_CALL mesg.text " + mesg.text);
            launchConfirmationDialog(mesg, slotId);
            break;
        case PLAY_TONE:
            launchToneDialog(slotId);
            break;
        case OPEN_CHANNEL:
            launchOpenChannelDialog(slotId);
            break;
        case CLOSE_CHANNEL:
        case RECEIVE_DATA:
        case SEND_DATA:
            TextMessage m = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if ((m != null) && (m.text == null)) {
                switch(cmdMsg.getCmdType()) {
                    case CLOSE_CHANNEL:
                        m.text = getResources().getString(R.string.default_close_channel_msg);
                        break;
                    case RECEIVE_DATA:
                        m.text = getResources().getString(R.string.default_receive_data_msg);
                        break;
                    case SEND_DATA:
                        m.text = getResources().getString(R.string.default_send_data_msg);
                        break;
                }
            }
            /*
             * Display indication in the form of a toast to the user if required.
             */
            launchEventMessage(slotId);
            break;
        case SET_UP_EVENT_LIST:
            mStkContext[slotId].mSetupEventListSettings = mStkContext[slotId].mCurrentCmd.getSetEventList();
            mStkContext[slotId].mCurrentSetupEventCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
            if (isScreenIdle()) {
                CatLog.d(this, " Check if IDLE_SCREEN_AVAILABLE_EVENT is present in List");
                checkForSetupEvent(IDLE_SCREEN_AVAILABLE_EVENT, null, slotId);
            }
            break;
    }
    if (!waitForUsersResponse) {
        if (mStkContext[slotId].mCmdsQ.size() != 0) {
            callDelayedMsg(slotId);
        } else {
            mStkContext[slotId].mCmdInProgress = false;
        }
    }
}
#method_after
private void handleCmd(CatCmdMessage cmdMsg, int slotId) {
    if (cmdMsg == null) {
        return;
    }
    // save local reference for state tracking.
    mStkContext[slotId].mCurrentCmd = cmdMsg;
    boolean waitForUsersResponse = true;
    mStkContext[slotId].mIsInputPending = false;
    mStkContext[slotId].mIsMenuPending = false;
    mStkContext[slotId].mIsDialogPending = false;
    CatLog.d(LOG_TAG, "[handleCmd]" + cmdMsg.getCmdType().name());
    switch(cmdMsg.getCmdType()) {
        case DISPLAY_TEXT:
            TextMessage msg = cmdMsg.geTextMessage();
            waitForUsersResponse = msg.responseNeeded;
            if (mStkContext[slotId].lastSelectedItem != null) {
                msg.title = mStkContext[slotId].lastSelectedItem;
            } else if (mStkContext[slotId].mMainCmd != null) {
                if (!getResources().getBoolean(R.bool.show_menu_title_only_on_menu)) {
                    msg.title = mStkContext[slotId].mMainCmd.getMenu().title;
                }
            }
            // proactive command (Refer to ETSI TS 102 384 section 27.22.4.1.4.4.2).
            if (!(msg.isHighPriority || mStkContext[slotId].mMenuIsVisible || mStkContext[slotId].mDisplayTextDlgIsVisibile || isTopOfStack())) {
                if (!isScreenIdle()) {
                    CatLog.d(LOG_TAG, "Screen is not idle");
                    sendScreenBusyResponse(slotId);
                } else {
                    launchTextDialog(slotId);
                }
            } else {
                launchTextDialog(slotId);
            }
            break;
        case SELECT_ITEM:
            CatLog.d(LOG_TAG, "SELECT_ITEM +");
            mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenu = cmdMsg.getMenu();
            launchMenuActivity(cmdMsg.getMenu(), slotId);
            break;
        case SET_UP_MENU:
            mStkContext[slotId].mCmdInProgress = false;
            mStkContext[slotId].mMainCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenu = cmdMsg.getMenu();
            CatLog.d(LOG_TAG, "SET_UP_MENU [" + removeMenu(slotId) + "]");
            if (removeMenu(slotId)) {
                int i = 0;
                CatLog.d(LOG_TAG, "removeMenu() - Uninstall App");
                mStkContext[slotId].mCurrentMenu = null;
                mStkContext[slotId].mMainCmd = null;
                // Check other setup menu state. If all setup menu are removed, uninstall apk.
                for (i = PhoneConstants.SIM_ID_1; i < mSimCount; i++) {
                    if (i != slotId && (mStkContext[i].mSetupMenuState == STATE_UNKNOWN || mStkContext[i].mSetupMenuState == STATE_EXIST)) {
                        CatLog.d(LOG_TAG, "Not Uninstall App:" + i + "," + mStkContext[i].mSetupMenuState);
                        break;
                    }
                }
                if (i == mSimCount) {
                    StkAppInstaller.unInstall(mContext);
                }
            } else {
                CatLog.d(LOG_TAG, "install App");
                StkAppInstaller.install(mContext);
            }
            if (mStkContext[slotId].mMenuIsVisible) {
                launchMenuActivity(null, slotId);
            }
            break;
        case GET_INPUT:
        case GET_INKEY:
            launchInputActivity(slotId);
            break;
        case SET_UP_IDLE_MODE_TEXT:
            waitForUsersResponse = false;
            mStkContext[slotId].mIdleModeTextCmd = mStkContext[slotId].mCurrentCmd;
            TextMessage idleModeText = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if (idleModeText == null || TextUtils.isEmpty(idleModeText.text)) {
                cancelIdleText(slotId);
            }
            mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
            if (mStkContext[slotId].mIdleModeTextCmd != null) {
                if (mStkContext[slotId].mIdleModeTextVisible || isScreenIdle()) {
                    CatLog.d(this, "set up idle mode");
                    launchIdleText(slotId);
                } else {
                    registerProcessObserver();
                }
            }
            break;
        case SEND_DTMF:
        case SEND_SMS:
        case SEND_SS:
        case SEND_USSD:
        case GET_CHANNEL_STATUS:
            waitForUsersResponse = false;
            launchEventMessage(slotId);
            break;
        case LAUNCH_BROWSER:
            // The device setup process should not be interrupted by launching browser.
            if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
                CatLog.d(this, "The command is not performed if the setup has not been completed.");
                sendScreenBusyResponse(slotId);
                break;
            }
            /* Check if Carrier would not want to launch browser */
            if (getBooleanCarrierConfig(mContext, CarrierConfigManager.KEY_STK_DISABLE_LAUNCH_BROWSER_BOOL)) {
                CatLog.d(this, "Browser is not launched as per carrier.");
                sendResponse(RES_ID_DONE, slotId, true);
                break;
            }
            mStkContext[slotId].mBrowserSettings = mStkContext[slotId].mCurrentCmd.getBrowserSettings();
            if (!isUrlAvailableToLaunchBrowser(mStkContext[slotId].mBrowserSettings)) {
                CatLog.d(this, "Browser url property is not set - send error");
                sendResponse(RES_ID_ERROR, slotId, true);
            } else {
                TextMessage alphaId = mStkContext[slotId].mCurrentCmd.geTextMessage();
                if ((alphaId == null) || TextUtils.isEmpty(alphaId.text)) {
                    // don't need user confirmation in this case
                    // just launch the browser or spawn a new tab
                    CatLog.d(this, "user confirmation is not currently needed.\n" + "supressing confirmation dialogue and confirming silently...");
                    mStkContext[slotId].launchBrowser = true;
                    sendResponse(RES_ID_CONFIRM, slotId, true);
                } else {
                    launchConfirmationDialog(alphaId, slotId);
                }
            }
            break;
        case SET_UP_CALL:
            TextMessage mesg = mStkContext[slotId].mCurrentCmd.getCallSettings().confirmMsg;
            if ((mesg != null) && (mesg.text == null || mesg.text.length() == 0)) {
                mesg.text = getResources().getString(R.string.default_setup_call_msg);
            }
            CatLog.d(this, "SET_UP_CALL mesg.text " + mesg.text);
            launchConfirmationDialog(mesg, slotId);
            break;
        case PLAY_TONE:
            handlePlayTone(slotId);
            break;
        case OPEN_CHANNEL:
            launchOpenChannelDialog(slotId);
            break;
        case CLOSE_CHANNEL:
        case RECEIVE_DATA:
        case SEND_DATA:
            TextMessage m = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if ((m != null) && (m.text == null)) {
                switch(cmdMsg.getCmdType()) {
                    case CLOSE_CHANNEL:
                        m.text = getResources().getString(R.string.default_close_channel_msg);
                        break;
                    case RECEIVE_DATA:
                        m.text = getResources().getString(R.string.default_receive_data_msg);
                        break;
                    case SEND_DATA:
                        m.text = getResources().getString(R.string.default_send_data_msg);
                        break;
                }
            }
            /*
             * Display indication in the form of a toast to the user if required.
             */
            launchEventMessage(slotId);
            break;
        case SET_UP_EVENT_LIST:
            replaceEventList(slotId);
            if (isScreenIdle()) {
                CatLog.d(this, " Check if IDLE_SCREEN_AVAILABLE_EVENT is present in List");
                checkForSetupEvent(IDLE_SCREEN_AVAILABLE_EVENT, null, slotId);
            }
            break;
    }
    if (!waitForUsersResponse) {
        if (mStkContext[slotId].mCmdsQ.size() != 0) {
            callDelayedMsg(slotId);
        } else {
            mStkContext[slotId].mCmdInProgress = false;
        }
    }
}
#end_block

#method_before
private void handleCmdResponse(Bundle args, int slotId) {
    CatLog.d(LOG_TAG, "handleCmdResponse, sim id: " + slotId);
    if (mStkContext[slotId].mCurrentCmd == null) {
        return;
    }
    if (mStkService[slotId] == null) {
        mStkService[slotId] = CatService.getInstance(slotId);
        if (mStkService[slotId] == null) {
            // This should never happen (we should be responding only to a message
            // that arrived from StkService). It has to exist by this time
            CatLog.d(LOG_TAG, "Exception! mStkService is null when we need to send response.");
            throw new RuntimeException("mStkService is null when we need to send response");
        }
    }
    CatResponseMessage resMsg = new CatResponseMessage(mStkContext[slotId].mCurrentCmd);
    // set result code
    boolean helpRequired = args.getBoolean(HELP, false);
    boolean confirmed = false;
    switch(args.getInt(RES_ID)) {
        case RES_ID_MENU_SELECTION:
            CatLog.d(LOG_TAG, "MENU_SELECTION=" + mStkContext[slotId].mCurrentMenuCmd.getCmdType());
            int menuSelection = args.getInt(MENU_SELECTION);
            switch(mStkContext[slotId].mCurrentMenuCmd.getCmdType()) {
                case SET_UP_MENU:
                case SELECT_ITEM:
                    mStkContext[slotId].lastSelectedItem = getItemName(menuSelection, slotId);
                    if (helpRequired) {
                        resMsg.setResultCode(ResultCode.HELP_INFO_REQUIRED);
                    } else {
                        resMsg.setResultCode(mStkContext[slotId].mCurrentCmd.hasIconLoadFailed() ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK);
                    }
                    resMsg.setMenuSelection(menuSelection);
                    break;
            }
            break;
        case RES_ID_INPUT:
            CatLog.d(LOG_TAG, "RES_ID_INPUT");
            String input = args.getString(INPUT);
            if (input != null && (null != mStkContext[slotId].mCurrentCmd.geInput()) && (mStkContext[slotId].mCurrentCmd.geInput().yesNo)) {
                boolean yesNoSelection = input.equals(StkInputActivity.YES_STR_RESPONSE);
                resMsg.setYesNo(yesNoSelection);
            } else {
                if (helpRequired) {
                    resMsg.setResultCode(ResultCode.HELP_INFO_REQUIRED);
                } else {
                    resMsg.setResultCode(mStkContext[slotId].mCurrentCmd.hasIconLoadFailed() ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK);
                    resMsg.setInput(input);
                }
            }
            break;
        case RES_ID_CONFIRM:
            CatLog.d(this, "RES_ID_CONFIRM");
            confirmed = args.getBoolean(CONFIRMATION);
            switch(mStkContext[slotId].mCurrentCmd.getCmdType()) {
                case DISPLAY_TEXT:
                    if (confirmed) {
                        resMsg.setResultCode(mStkContext[slotId].mCurrentCmd.hasIconLoadFailed() ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK);
                    } else {
                        resMsg.setResultCode(ResultCode.UICC_SESSION_TERM_BY_USER);
                    }
                    break;
                case LAUNCH_BROWSER:
                    resMsg.setResultCode(confirmed ? ResultCode.OK : ResultCode.UICC_SESSION_TERM_BY_USER);
                    if (confirmed) {
                        mStkContext[slotId].launchBrowser = true;
                        mStkContext[slotId].mBrowserSettings = mStkContext[slotId].mCurrentCmd.getBrowserSettings();
                    }
                    break;
                case SET_UP_CALL:
                    resMsg.setResultCode(ResultCode.OK);
                    resMsg.setConfirmation(confirmed);
                    if (confirmed) {
                        launchEventMessage(slotId, mStkContext[slotId].mCurrentCmd.getCallSettings().callMsg);
                    }
                    break;
            }
            break;
        case RES_ID_DONE:
            resMsg.setResultCode(ResultCode.OK);
            break;
        case RES_ID_BACKWARD:
            CatLog.d(LOG_TAG, "RES_ID_BACKWARD");
            resMsg.setResultCode(ResultCode.BACKWARD_MOVE_BY_USER);
            break;
        case RES_ID_END_SESSION:
            CatLog.d(LOG_TAG, "RES_ID_END_SESSION");
            resMsg.setResultCode(ResultCode.UICC_SESSION_TERM_BY_USER);
            break;
        case RES_ID_TIMEOUT:
            CatLog.d(LOG_TAG, "RES_ID_TIMEOUT");
            // then send OK instead of NO_RESPONSE_FROM_USER
            if ((mStkContext[slotId].mCurrentCmd.getCmdType().value() == AppInterface.CommandType.DISPLAY_TEXT.value()) && (mStkContext[slotId].mCurrentCmd.geTextMessage().userClear == false)) {
                resMsg.setResultCode(ResultCode.OK);
            } else {
                resMsg.setResultCode(ResultCode.NO_RESPONSE_FROM_USER);
            }
            break;
        case RES_ID_CHOICE:
            int choice = args.getInt(CHOICE);
            CatLog.d(this, "User Choice=" + choice);
            switch(choice) {
                case YES:
                    resMsg.setResultCode(ResultCode.OK);
                    confirmed = true;
                    break;
                case NO:
                    resMsg.setResultCode(ResultCode.USER_NOT_ACCEPT);
                    break;
            }
            if (mStkContext[slotId].mCurrentCmd.getCmdType().value() == AppInterface.CommandType.OPEN_CHANNEL.value()) {
                resMsg.setConfirmation(confirmed);
            }
            break;
        default:
            CatLog.d(LOG_TAG, "Unknown result id");
            return;
    }
    if (null != mStkContext[slotId].mCurrentCmd && null != mStkContext[slotId].mCurrentCmd.getCmdType()) {
        CatLog.d(LOG_TAG, "handleCmdResponse- cmdName[" + mStkContext[slotId].mCurrentCmd.getCmdType().name() + "]");
    }
    mStkService[slotId].onCmdResponse(resMsg);
}
#method_after
private void handleCmdResponse(Bundle args, int slotId) {
    CatLog.d(LOG_TAG, "handleCmdResponse, sim id: " + slotId);
    if (mStkContext[slotId].mCurrentCmd == null) {
        return;
    }
    if (mStkService[slotId] == null) {
        mStkService[slotId] = CatService.getInstance(slotId);
        if (mStkService[slotId] == null) {
            // This should never happen (we should be responding only to a message
            // that arrived from StkService). It has to exist by this time
            CatLog.d(LOG_TAG, "Exception! mStkService is null when we need to send response.");
            throw new RuntimeException("mStkService is null when we need to send response");
        }
    }
    CatResponseMessage resMsg = new CatResponseMessage(mStkContext[slotId].mCurrentCmd);
    // set result code
    boolean helpRequired = args.getBoolean(HELP, false);
    boolean confirmed = false;
    switch(args.getInt(RES_ID)) {
        case RES_ID_MENU_SELECTION:
            CatLog.d(LOG_TAG, "MENU_SELECTION=" + mStkContext[slotId].mCurrentMenuCmd.getCmdType());
            int menuSelection = args.getInt(MENU_SELECTION);
            switch(mStkContext[slotId].mCurrentMenuCmd.getCmdType()) {
                case SET_UP_MENU:
                case SELECT_ITEM:
                    mStkContext[slotId].lastSelectedItem = getItemName(menuSelection, slotId);
                    if (helpRequired) {
                        resMsg.setResultCode(ResultCode.HELP_INFO_REQUIRED);
                    } else {
                        resMsg.setResultCode(mStkContext[slotId].mCurrentCmd.hasIconLoadFailed() ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK);
                    }
                    resMsg.setMenuSelection(menuSelection);
                    break;
            }
            break;
        case RES_ID_INPUT:
            CatLog.d(LOG_TAG, "RES_ID_INPUT");
            String input = args.getString(INPUT);
            if (input != null && (null != mStkContext[slotId].mCurrentCmd.geInput()) && (mStkContext[slotId].mCurrentCmd.geInput().yesNo)) {
                boolean yesNoSelection = input.equals(StkInputActivity.YES_STR_RESPONSE);
                resMsg.setYesNo(yesNoSelection);
            } else {
                if (helpRequired) {
                    resMsg.setResultCode(ResultCode.HELP_INFO_REQUIRED);
                } else {
                    resMsg.setResultCode(mStkContext[slotId].mCurrentCmd.hasIconLoadFailed() ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK);
                    resMsg.setInput(input);
                }
            }
            break;
        case RES_ID_CONFIRM:
            CatLog.d(this, "RES_ID_CONFIRM");
            confirmed = args.getBoolean(CONFIRMATION);
            switch(mStkContext[slotId].mCurrentCmd.getCmdType()) {
                case DISPLAY_TEXT:
                    if (confirmed) {
                        resMsg.setResultCode(mStkContext[slotId].mCurrentCmd.hasIconLoadFailed() ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK);
                    } else {
                        resMsg.setResultCode(ResultCode.UICC_SESSION_TERM_BY_USER);
                    }
                    break;
                case LAUNCH_BROWSER:
                    resMsg.setResultCode(confirmed ? ResultCode.OK : ResultCode.UICC_SESSION_TERM_BY_USER);
                    if (confirmed) {
                        mStkContext[slotId].launchBrowser = true;
                        mStkContext[slotId].mBrowserSettings = mStkContext[slotId].mCurrentCmd.getBrowserSettings();
                    }
                    break;
                case SET_UP_CALL:
                    resMsg.setResultCode(ResultCode.OK);
                    resMsg.setConfirmation(confirmed);
                    if (confirmed) {
                        launchEventMessage(slotId, mStkContext[slotId].mCurrentCmd.getCallSettings().callMsg);
                    }
                    break;
            }
            break;
        case RES_ID_DONE:
            resMsg.setResultCode(ResultCode.OK);
            break;
        case RES_ID_BACKWARD:
            CatLog.d(LOG_TAG, "RES_ID_BACKWARD");
            resMsg.setResultCode(ResultCode.BACKWARD_MOVE_BY_USER);
            break;
        case RES_ID_END_SESSION:
            CatLog.d(LOG_TAG, "RES_ID_END_SESSION");
            resMsg.setResultCode(ResultCode.UICC_SESSION_TERM_BY_USER);
            break;
        case RES_ID_TIMEOUT:
            CatLog.d(LOG_TAG, "RES_ID_TIMEOUT");
            // then send OK instead of NO_RESPONSE_FROM_USER
            if ((mStkContext[slotId].mCurrentCmd.getCmdType().value() == AppInterface.CommandType.DISPLAY_TEXT.value()) && (mStkContext[slotId].mCurrentCmd.geTextMessage().userClear == false)) {
                resMsg.setResultCode(ResultCode.OK);
            } else {
                resMsg.setResultCode(ResultCode.NO_RESPONSE_FROM_USER);
            }
            break;
        case RES_ID_CHOICE:
            int choice = args.getInt(CHOICE);
            CatLog.d(this, "User Choice=" + choice);
            switch(choice) {
                case YES:
                    resMsg.setResultCode(ResultCode.OK);
                    confirmed = true;
                    break;
                case NO:
                    resMsg.setResultCode(ResultCode.USER_NOT_ACCEPT);
                    break;
            }
            if (mStkContext[slotId].mCurrentCmd.getCmdType().value() == AppInterface.CommandType.OPEN_CHANNEL.value()) {
                resMsg.setConfirmation(confirmed);
            }
            break;
        case RES_ID_ERROR:
            CatLog.d(LOG_TAG, "RES_ID_ERROR");
            switch(mStkContext[slotId].mCurrentCmd.getCmdType()) {
                case LAUNCH_BROWSER:
                    resMsg.setResultCode(ResultCode.LAUNCH_BROWSER_ERROR);
                    break;
            }
            break;
        default:
            CatLog.d(LOG_TAG, "Unknown result id");
            return;
    }
    if (null != mStkContext[slotId].mCurrentCmd && null != mStkContext[slotId].mCurrentCmd.getCmdType()) {
        CatLog.d(LOG_TAG, "handleCmdResponse- cmdName[" + mStkContext[slotId].mCurrentCmd.getCmdType().name() + "]");
    }
    mStkService[slotId].onCmdResponse(resMsg);
}
#end_block

#method_before
private void removeSetUpEvent(int event, int slotId) {
    CatLog.d(this, "Remove Event :" + event);
    if (mStkContext[slotId].mSetupEventListSettings != null) {
        /*
             * Make new  Eventlist without the event
             */
        for (int i = 0; i < mStkContext[slotId].mSetupEventListSettings.eventList.length; i++) {
            if (event == mStkContext[slotId].mSetupEventListSettings.eventList[i]) {
                mStkContext[slotId].mSetupEventListSettings.eventList[i] = INVALID_SETUP_EVENT;
                break;
            }
        }
    }
}
#method_after
private void removeSetUpEvent(int event, int slotId) {
    CatLog.d(this, "Remove Event :" + event);
    if (mStkContext[slotId].mSetupEventListSettings != null) {
        /*
             * Make new  Eventlist without the event
             */
        for (int i = 0; i < mStkContext[slotId].mSetupEventListSettings.eventList.length; i++) {
            if (event == mStkContext[slotId].mSetupEventListSettings.eventList[i]) {
                mStkContext[slotId].mSetupEventListSettings.eventList[i] = INVALID_SETUP_EVENT;
                switch(event) {
                    case IDLE_SCREEN_AVAILABLE_EVENT:
                        // The process observer can be unregistered
                        // as the idle screen has already been available.
                        unregisterProcessObserver();
                        break;
                    default:
                        break;
                }
                break;
            }
        }
    }
}
#end_block

#method_before
private void launchEventMessage(int slotId, TextMessage msg) {
    if (msg == null || (msg.text != null && msg.text.length() == 0)) {
        CatLog.d(LOG_TAG, "launchEventMessage return");
        return;
    }
    Toast toast = new Toast(mContext.getApplicationContext());
    LayoutInflater inflate = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View v = inflate.inflate(R.layout.stk_event_msg, null);
    TextView tv = (TextView) v.findViewById(com.android.internal.R.id.message);
    ImageView iv = (ImageView) v.findViewById(com.android.internal.R.id.icon);
    if (msg.icon != null) {
        iv.setImageBitmap(msg.icon);
    } else {
        iv.setVisibility(View.GONE);
    }
    /* In case of 'self explanatory' stkapp should display the specified
         * icon in proactive command (but not the alpha string).
         * If icon is non-self explanatory and if the icon could not be displayed
         * then alpha string or text data should be displayed
         * Ref: ETSI 102.223,section 6.5.4
         */
    if (mStkContext[slotId].mCurrentCmd.hasIconLoadFailed() || msg.icon == null || !msg.iconSelfExplanatory) {
        tv.setText(msg.text);
    }
    toast.setView(v);
    toast.setDuration(Toast.LENGTH_LONG);
    toast.setGravity(Gravity.BOTTOM, 0, 0);
    toast.show();
}
#method_after
private void launchEventMessage(int slotId, TextMessage msg) {
    if (msg == null || msg.text == null || (msg.text != null && msg.text.length() == 0)) {
        CatLog.d(LOG_TAG, "launchEventMessage return");
        return;
    }
    Toast toast = new Toast(mContext.getApplicationContext());
    LayoutInflater inflate = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View v = inflate.inflate(R.layout.stk_event_msg, null);
    TextView tv = (TextView) v.findViewById(com.android.internal.R.id.message);
    ImageView iv = (ImageView) v.findViewById(com.android.internal.R.id.icon);
    if (msg.icon != null) {
        iv.setImageBitmap(msg.icon);
    } else {
        iv.setVisibility(View.GONE);
    }
    /* In case of 'self explanatory' stkapp should display the specified
         * icon in proactive command (but not the alpha string).
         * If icon is non-self explanatory and if the icon could not be displayed
         * then alpha string or text data should be displayed
         * Ref: ETSI 102.223,section 6.5.4
         */
    if (mStkContext[slotId].mCurrentCmd.hasIconLoadFailed() || msg.icon == null || !msg.iconSelfExplanatory) {
        tv.setText(msg.text);
    }
    toast.setView(v);
    toast.setDuration(Toast.LENGTH_LONG);
    toast.setGravity(Gravity.BOTTOM, 0, 0);
    toast.show();
}
#end_block

#method_before
private void launchIdleText(int slotId) {
    TextMessage msg = mStkContext[slotId].mIdleModeTextCmd.geTextMessage();
    if (msg == null || msg.text == null) {
        CatLog.d(LOG_TAG, msg == null ? "mCurrent.getTextMessage is NULL" : "mCurrent.getTextMessage.text is NULL");
        mNotificationManager.cancel(getNotificationId(slotId));
        return;
    } else {
        CatLog.d(LOG_TAG, "launchIdleText - text[" + msg.text + "] iconSelfExplanatory[" + msg.iconSelfExplanatory + "] icon[" + msg.icon + "], sim id: " + slotId);
        CatLog.d(LOG_TAG, "Add IdleMode text");
        PendingIntent pendingIntent = PendingIntent.getService(mContext, 0, new Intent(mContext, StkAppService.class), 0);
        final Notification.Builder notificationBuilder = new Notification.Builder(StkAppService.this);
        if (mStkContext[slotId].mMainCmd != null && mStkContext[slotId].mMainCmd.getMenu() != null) {
            notificationBuilder.setContentTitle(mStkContext[slotId].mMainCmd.getMenu().title);
        } else {
            notificationBuilder.setContentTitle("");
        }
        notificationBuilder.setSmallIcon(com.android.internal.R.drawable.stat_notify_sim_toolkit);
        notificationBuilder.setContentIntent(pendingIntent);
        notificationBuilder.setOngoing(true);
        // Set text and icon for the status bar and notification body.
        if (mStkContext[slotId].mIdleModeTextCmd.hasIconLoadFailed() || !msg.iconSelfExplanatory) {
            notificationBuilder.setContentText(msg.text);
            notificationBuilder.setTicker(msg.text);
        }
        if (msg.icon != null) {
            notificationBuilder.setLargeIcon(msg.icon);
        } else {
            Bitmap bitmapIcon = BitmapFactory.decodeResource(StkAppService.this.getResources().getSystem(), com.android.internal.R.drawable.stat_notify_sim_toolkit);
            notificationBuilder.setLargeIcon(bitmapIcon);
        }
        notificationBuilder.setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color));
        mNotificationManager.notify(getNotificationId(slotId), notificationBuilder.build());
    }
}
#method_after
private void launchIdleText(int slotId) {
    TextMessage msg = mStkContext[slotId].mIdleModeTextCmd.geTextMessage();
    if (msg != null && !TextUtils.isEmpty(msg.text)) {
        CatLog.d(LOG_TAG, "launchIdleText - text[" + msg.text + "] iconSelfExplanatory[" + msg.iconSelfExplanatory + "] icon[" + msg.icon + "], sim id: " + slotId);
        CatLog.d(LOG_TAG, "Add IdleMode text");
        PendingIntent pendingIntent = PendingIntent.getService(mContext, 0, new Intent(mContext, StkAppService.class), 0);
        createAllChannels();
        final Notification.Builder notificationBuilder = new Notification.Builder(StkAppService.this, STK_NOTIFICATION_CHANNEL_ID);
        if (mStkContext[slotId].mMainCmd != null && mStkContext[slotId].mMainCmd.getMenu() != null) {
            notificationBuilder.setContentTitle(mStkContext[slotId].mMainCmd.getMenu().title);
        } else {
            notificationBuilder.setContentTitle("");
        }
        notificationBuilder.setSmallIcon(com.android.internal.R.drawable.stat_notify_sim_toolkit);
        notificationBuilder.setContentIntent(pendingIntent);
        notificationBuilder.setOngoing(true);
        // Set text and icon for the status bar and notification body.
        if (mStkContext[slotId].mIdleModeTextCmd.hasIconLoadFailed() || !msg.iconSelfExplanatory) {
            notificationBuilder.setContentText(msg.text);
            notificationBuilder.setTicker(msg.text);
        }
        if (msg.icon != null) {
            notificationBuilder.setLargeIcon(msg.icon);
        } else {
            Bitmap bitmapIcon = BitmapFactory.decodeResource(StkAppService.this.getResources().getSystem(), com.android.internal.R.drawable.stat_notify_sim_toolkit);
            notificationBuilder.setLargeIcon(bitmapIcon);
        }
        notificationBuilder.setColor(mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color));
        mNotificationManager.notify(getNotificationId(slotId), notificationBuilder.build());
        mStkContext[slotId].mIdleModeTextVisible = true;
    }
}
#end_block

#method_before
@Override
public PackageCleanItem nextPackageToClean(PackageCleanItem lastPackage) {
    if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
        return null;
    }
    // writer
    if (!isExternalMediaAvailable()) {
        // packages files and can not delete any more.  Bail.
        return null;
    }
    synchronized (mPackages) {
        final ArrayList<PackageCleanItem> pkgs = mSettings.mPackagesToBeCleaned;
        if (lastPackage != null) {
            pkgs.remove(lastPackage);
        }
        if (pkgs.size() > 0) {
            return pkgs.get(0);
        }
    }
    return null;
}
#method_after
@Override
public PackageCleanItem nextPackageToClean(PackageCleanItem lastPackage) {
    if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
        return null;
    }
    if (!isExternalMediaAvailable()) {
        // packages files and can not delete any more.  Bail.
        return null;
    }
    synchronized (mPackages) {
        final ArrayList<PackageCleanItem> pkgs = mSettings.mPackagesToBeCleaned;
        if (lastPackage != null) {
            pkgs.remove(lastPackage);
        }
        if (pkgs.size() > 0) {
            return pkgs.get(0);
        }
    }
    return null;
}
#end_block

#method_before
@DataProvider(name = "format_data")
Object[][] formatData() {
    return new Object[][] { // Chronology, Format Locale, Numbering Locale, ChronoLocalDate, expected string
    { JAPANESE, Locale.JAPANESE, Locale.JAPANESE, JAPANESE.date(IsoDate), // Japanese Heisei 25-02-11
    "\u5e73\u621025\u5e742\u670811\u65e5\u6708\u66dc\u65e5" }, // new CLDR patterns include the era. Test Arabic locale with ASCII digits below.
    { HIJRAH, ARABIC, ARABIC, HIJRAH.date(IsoDate), "\u0627\u0644\u0627\u062b\u0646\u064a\u0646\u060c 1 \u0631\u0628\u064a\u0639 " + // Hijrah AH 1434-04-01 (Mon)
    "\u0627\u0644\u0622\u062e\u0631 1434 \u0647\u0640" }, { HIJRAH, ARABIC, Locale.ENGLISH, HIJRAH.date(IsoDate), "\u0627\u0644\u0627\u062b\u0646\u064a\u0646\u060c 1 \u0631\u0628\u064a\u0639 " + // Hijrah AH 1434-04-01 (Mon)
    "\u0627\u0644\u0622\u062e\u0631\u060c 1434 \u0647\u0640" }, { MINGUO, Locale.TAIWAN, Locale.TAIWAN, MINGUO.date(IsoDate), // Minguo ROC 102-02-11 (Mon)
    "\u6c11\u570b102\u5e742\u670811\u65e5 \u661f\u671f\u4e00" }, { BUDDHIST, thTH, thTH, BUDDHIST.date(IsoDate), "\u0e27\u0e31\u0e19\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c\u0e17\u0e35\u0e48 " + "11 \u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c " + // ThaiBuddhist BE 2556-02-11
    "\u0e1e.\u0e28. 2556" }, { BUDDHIST, thTH, thTHTH, BUDDHIST.date(IsoDate), "\u0e27\u0e31\u0e19\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c\u0e17\u0e35\u0e48 \u0e51\u0e51 " + "\u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c " + // ThaiBuddhist BE 2556-02-11 (with Thai digits)
    "\u0e1e.\u0e28. \u0e52\u0e55\u0e55\u0e56" } };
}
#method_after
@DataProvider(name = "format_data")
Object[][] formatData() {
    return new Object[][] { // Chronology, Format Locale, Numbering Locale, ChronoLocalDate, expected string
    { JAPANESE, Locale.JAPANESE, Locale.JAPANESE, JAPANESE.date(IsoDate), // Japanese Heisei 25-02-11
    "\u5e73\u621025\u5e742\u670811\u65e5\u6708\u66dc\u65e5" }, // new CLDR patterns include the era. Test Arabic locale with ASCII digits below.
    { HIJRAH, ARABIC, ARABIC, HIJRAH.date(IsoDate), "\u0627\u0644\u0627\u062b\u0646\u064a\u0646\u060c \u0661 \u0631\u0628\u064a\u0639 " + // Hijrah AH 1434-04-01 (Mon)
    "\u0627\u0644\u0622\u062e\u0631 \u0661\u0664\u0663\u0664 \u0647\u0640" }, { HIJRAH, ARABIC, Locale.ENGLISH, HIJRAH.date(IsoDate), "\u0627\u0644\u0627\u062b\u0646\u064a\u0646\u060c 1 \u0631\u0628\u064a\u0639 " + // Hijrah AH 1434-04-01 (Mon)
    "\u0627\u0644\u0622\u062e\u0631 1434 \u0647\u0640" }, { MINGUO, Locale.TAIWAN, Locale.TAIWAN, MINGUO.date(IsoDate), // Minguo ROC 102-02-11 (Mon)
    "\u6c11\u570b102\u5e742\u670811\u65e5 \u661f\u671f\u4e00" }, { BUDDHIST, thTH, thTH, BUDDHIST.date(IsoDate), "\u0e27\u0e31\u0e19\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c\u0e17\u0e35\u0e48 " + "11 \u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c " + // ThaiBuddhist BE 2556-02-11
    "\u0e1e.\u0e28. 2556" }, { BUDDHIST, thTH, thTHTH, BUDDHIST.date(IsoDate), "\u0e27\u0e31\u0e19\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c\u0e17\u0e35\u0e48 \u0e51\u0e51 " + "\u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c " + // ThaiBuddhist BE 2556-02-11 (with Thai digits)
    "\u0e1e.\u0e28. \u0e52\u0e55\u0e55\u0e56" } };
}
#end_block

#method_before
private void logBootEvents(Context ctx) throws IOException {
    final DropBoxManager db = (DropBoxManager) ctx.getSystemService(Context.DROPBOX_SERVICE);
    final String headers = getBootHeadersToLogAndUpdate();
    final String bootReason = SystemProperties.get("ro.boot.bootreason", null);
    String recovery = RecoverySystem.handleAftermath(ctx);
    if (recovery != null && db != null) {
        db.addText("SYSTEM_RECOVERY_LOG", headers + recovery);
    }
    String lastKmsgFooter = "";
    if (bootReason != null) {
        lastKmsgFooter = new StringBuilder(512).append("\n").append("Boot info:\n").append("Last boot reason: ").append(bootReason).append("\n").toString();
    }
    HashMap<String, Long> timestamps = readTimestamps();
    if (SystemProperties.getLong("ro.runtime.firstboot", 0) == 0) {
        if (StorageManager.inCryptKeeperBounce()) {
        // Encrypted, first boot to get PIN/pattern/password so data is tmpfs
        // Don't set ro.runtime.firstboot so that we will do this again
        // when data is properly mounted
        } else {
            String now = Long.toString(System.currentTimeMillis());
            SystemProperties.set("ro.runtime.firstboot", now);
        }
        if (db != null)
            db.addText("SYSTEM_BOOT", headers);
        // Negative sizes mean to take the *tail* of the file (see FileUtils.readTextFile())
        addFileWithFootersToDropBox(db, timestamps, headers, lastKmsgFooter, "/proc/last_kmsg", -LOG_SIZE, "SYSTEM_LAST_KMSG");
        addFileWithFootersToDropBox(db, timestamps, headers, lastKmsgFooter, "/sys/fs/pstore/console-ramoops", -LOG_SIZE, "SYSTEM_LAST_KMSG");
        addFileWithFootersToDropBox(db, timestamps, headers, lastKmsgFooter, "/sys/fs/pstore/console-ramoops-0", -LOG_SIZE, "SYSTEM_LAST_KMSG");
        addFileToDropBox(db, timestamps, headers, "/cache/recovery/log", -LOG_SIZE, "SYSTEM_RECOVERY_LOG");
        addFileToDropBox(db, timestamps, headers, "/cache/recovery/last_kmsg", -LOG_SIZE, "SYSTEM_RECOVERY_KMSG");
        addAuditErrorsToDropBox(db, timestamps, headers, -LOG_SIZE, "SYSTEM_AUDIT");
    } else {
        if (db != null)
            db.addText("SYSTEM_RESTART", headers);
    }
    // log always available fs_stat last so that logcat collecting tools can wait until
    // fs_stat to get all file system metrics.
    logFsShutdownTime();
    logFsMountTime();
    addFsckErrorsToDropBoxAndLogFsStat(db, timestamps, headers, -LOG_SIZE, "SYSTEM_FSCK");
    // Scan existing tombstones (in case any new ones appeared)
    File[] tombstoneFiles = TOMBSTONE_DIR.listFiles();
    for (int i = 0; tombstoneFiles != null && i < tombstoneFiles.length; i++) {
        if (tombstoneFiles[i].isFile()) {
            addFileToDropBox(db, timestamps, headers, tombstoneFiles[i].getPath(), LOG_SIZE, "SYSTEM_TOMBSTONE");
        }
    }
    writeTimestamps(timestamps);
    // Start watching for new tombstone files; will record them as they occur.
    // This gets registered with the singleton file observer thread.
    sTombstoneObserver = new FileObserver(TOMBSTONE_DIR.getPath(), FileObserver.CLOSE_WRITE) {

        @Override
        public void onEvent(int event, String path) {
            HashMap<String, Long> timestamps = readTimestamps();
            try {
                File file = new File(TOMBSTONE_DIR, path);
                if (file.isFile()) {
                    addFileToDropBox(db, timestamps, headers, file.getPath(), LOG_SIZE, "SYSTEM_TOMBSTONE");
                }
            } catch (IOException e) {
                Slog.e(TAG, "Can't log tombstone", e);
            }
            writeTimestamps(timestamps);
        }
    };
    sTombstoneObserver.startWatching();
}
#method_after
private void logBootEvents(Context ctx) throws IOException {
    final DropBoxManager db = (DropBoxManager) ctx.getSystemService(Context.DROPBOX_SERVICE);
    final String headers = getBootHeadersToLogAndUpdate();
    final String bootReason = SystemProperties.get("ro.boot.bootreason", null);
    String recovery = RecoverySystem.handleAftermath(ctx);
    if (recovery != null && db != null) {
        db.addText("SYSTEM_RECOVERY_LOG", headers + recovery);
    }
    String lastKmsgFooter = "";
    if (bootReason != null) {
        lastKmsgFooter = new StringBuilder(512).append("\n").append("Boot info:\n").append("Last boot reason: ").append(bootReason).append("\n").toString();
    }
    HashMap<String, Long> timestamps = readTimestamps();
    if (SystemProperties.getLong("ro.runtime.firstboot", 0) == 0) {
        if (StorageManager.inCryptKeeperBounce()) {
        // Encrypted, first boot to get PIN/pattern/password so data is tmpfs
        // Don't set ro.runtime.firstboot so that we will do this again
        // when data is properly mounted
        } else {
            String now = Long.toString(System.currentTimeMillis());
            SystemProperties.set("ro.runtime.firstboot", now);
        }
        if (db != null)
            db.addText("SYSTEM_BOOT", headers);
        // Negative sizes mean to take the *tail* of the file (see FileUtils.readTextFile())
        addFileWithFootersToDropBox(db, timestamps, headers, lastKmsgFooter, "/proc/last_kmsg", -LOG_SIZE, "SYSTEM_LAST_KMSG");
        addFileWithFootersToDropBox(db, timestamps, headers, lastKmsgFooter, "/sys/fs/pstore/console-ramoops", -LOG_SIZE, "SYSTEM_LAST_KMSG");
        addFileWithFootersToDropBox(db, timestamps, headers, lastKmsgFooter, "/sys/fs/pstore/console-ramoops-0", -LOG_SIZE, "SYSTEM_LAST_KMSG");
        addFileToDropBox(db, timestamps, headers, "/cache/recovery/log", -LOG_SIZE, "SYSTEM_RECOVERY_LOG");
        addFileToDropBox(db, timestamps, headers, "/cache/recovery/last_kmsg", -LOG_SIZE, "SYSTEM_RECOVERY_KMSG");
        addAuditErrorsToDropBox(db, timestamps, headers, -LOG_SIZE, "SYSTEM_AUDIT");
    } else {
        if (db != null)
            db.addText("SYSTEM_RESTART", headers);
    }
    // log always available fs_stat last so that logcat collecting tools can wait until
    // fs_stat to get all file system metrics.
    logFsShutdownTime();
    logFsMountTime();
    addFsckErrorsToDropBoxAndLogFsStat(db, timestamps, headers, -LOG_SIZE, "SYSTEM_FSCK");
    logSystemServerShutdownTimeMetrics();
    // Scan existing tombstones (in case any new ones appeared)
    File[] tombstoneFiles = TOMBSTONE_DIR.listFiles();
    for (int i = 0; tombstoneFiles != null && i < tombstoneFiles.length; i++) {
        if (tombstoneFiles[i].isFile()) {
            addFileToDropBox(db, timestamps, headers, tombstoneFiles[i].getPath(), LOG_SIZE, "SYSTEM_TOMBSTONE");
        }
    }
    writeTimestamps(timestamps);
    // Start watching for new tombstone files; will record them as they occur.
    // This gets registered with the singleton file observer thread.
    sTombstoneObserver = new FileObserver(TOMBSTONE_DIR.getPath(), FileObserver.CLOSE_WRITE) {

        @Override
        public void onEvent(int event, String path) {
            HashMap<String, Long> timestamps = readTimestamps();
            try {
                File file = new File(TOMBSTONE_DIR, path);
                if (file.isFile()) {
                    addFileToDropBox(db, timestamps, headers, file.getPath(), LOG_SIZE, "SYSTEM_TOMBSTONE");
                }
            } catch (IOException e) {
                Slog.e(TAG, "Can't log tombstone", e);
            }
            writeTimestamps(timestamps);
        }
    };
    sTombstoneObserver.startWatching();
}
#end_block

#method_before
private static void addFileWithFootersToDropBox(DropBoxManager db, HashMap<String, Long> timestamps, String headers, String footers, String filename, int maxSize, String tag) throws IOException {
    // Logging disabled
    if (db == null || !db.isTagEnabled(tag))
        return;
    File file = new File(filename);
    long fileTime = file.lastModified();
    // File does not exist
    if (fileTime <= 0)
        return;
    if (timestamps.containsKey(filename) && timestamps.get(filename) == fileTime) {
        // Already logged this particular file
        return;
    }
    timestamps.put(filename, fileTime);
    Slog.i(TAG, "Copying " + filename + " to DropBox (" + tag + ")");
    db.addText(tag, headers + FileUtils.readTextFile(file, maxSize, "[[TRUNCATED]]\n") + footers);
    Slog.i(TAG, String.format("Copied to Dropbox: filename=%s, maxSize=%d, tag=%s", filename, maxSize, tag));
}
#method_after
private static void addFileWithFootersToDropBox(DropBoxManager db, HashMap<String, Long> timestamps, String headers, String footers, String filename, int maxSize, String tag) throws IOException {
    // Logging disabled
    if (db == null || !db.isTagEnabled(tag))
        return;
    File file = new File(filename);
    long fileTime = file.lastModified();
    // File does not exist
    if (fileTime <= 0)
        return;
    if (timestamps.containsKey(filename) && timestamps.get(filename) == fileTime) {
        // Already logged this particular file
        return;
    }
    timestamps.put(filename, fileTime);
    Slog.i(TAG, "Copying " + filename + " to DropBox (" + tag + ")");
    db.addText(tag, headers + FileUtils.readTextFile(file, maxSize, "[[TRUNCATED]]\n") + footers);
    EventLog.writeEvent(DropboxLogTags.DROPBOX_FILE_COPY, filename, maxSize, tag);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    mTargetContext = InstrumentationRegistry.getTargetContext();
    // Set up mocks and test assets
    MockitoAnnotations.initMocks(this);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("10:11:12:13:14:15");
    IBinder binder = mServiceRule.bindService(new Intent(mTargetContext, HidDeviceService.class));
    mHidDeviceService = ((HidDeviceService.BluetoothHidDeviceBinder) binder).getServiceForTesting();
    Assert.assertNotNull(mHidDeviceService);
    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            mHidDeviceService.start();
        }
    });
    // Force unregister app first
    mHidDeviceService.unregisterApp();
    Field field = HidDeviceService.class.getDeclaredField("mHidDeviceNativeInterface");
    field.setAccessible(true);
    HidDeviceNativeInterface nativeInterface = (HidDeviceNativeInterface) field.get(mHidDeviceService);
    Assert.assertEquals(nativeInterface, sHidDeviceNativeInterface);
    // Dummy SDP settings
    mSettings = new BluetoothHidDeviceAppSdpSettings("Unit test", "test", "Android", BluetoothHidDevice.SUBCLASS1_COMBO, new byte[] {});
    // Set up the Connection State Changed receiver
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothHidDevice.ACTION_CONNECTION_STATE_CHANGED);
    mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
    mTargetContext.registerReceiver(mConnectionStateChangedReceiver, filter);
}
#method_after
@Before
public void setUp() throws Exception {
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    mTargetContext = InstrumentationRegistry.getTargetContext();
    // Set up mocks and test assets
    MockitoAnnotations.initMocks(this);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("10:11:12:13:14:15");
    IBinder binder = mServiceRule.bindService(new Intent(mTargetContext, HidDeviceService.class));
    mHidDeviceService = ((HidDeviceService.BluetoothHidDeviceBinder) binder).getServiceForTesting();
    Assert.assertNotNull(mHidDeviceService);
    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            mHidDeviceService.start();
        }
    });
    // Force unregister app first
    mHidDeviceService.unregisterApp();
    Field field = HidDeviceService.class.getDeclaredField("mHidDeviceNativeInterface");
    field.setAccessible(true);
    HidDeviceNativeInterface nativeInterface = (HidDeviceNativeInterface) field.get(mHidDeviceService);
    Assert.assertEquals(nativeInterface, sHidDeviceNativeInterface);
    // Dummy SDP settings
    mSettings = new BluetoothHidDeviceAppSdpSettings("Unit test", "test", "Android", BluetoothHidDevice.SUBCLASS1_COMBO, new byte[] {});
    // Set up the Connection State Changed receiver
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothHidDevice.ACTION_CONNECTION_STATE_CHANGED);
    mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
    mTargetContext.registerReceiver(mConnectionStateChangedReceiver, filter);
    reset(sHidDeviceNativeInterface);
}
#end_block

#method_before
@After
public void tearDown() {
    mHidDeviceService.stop();
    mHidDeviceService.cleanup();
    mHidDeviceService = null;
    reset(sHidDeviceNativeInterface);
    mTargetContext.unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedQueue.clear();
}
#method_after
@After
public void tearDown() {
    mHidDeviceService.stop();
    mHidDeviceService.cleanup();
    mHidDeviceService = null;
    mTargetContext.unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedQueue.clear();
    mCallbackQueue.clear();
}
#end_block

#method_before
@Test
public void testSendReport() throws Exception {
    doReturn(true).when(sHidDeviceNativeInterface).sendReport(anyInt(), any(byte[].class));
    // sendReport() should fail without app registered
    Assert.assertEquals(false, mHidDeviceService.sendReport(mTestDevice, SAMPLE_REPORT_ID, SAMPLE_OUTGOING_HID_REPORT));
    // register app
    doReturn(true).when(sHidDeviceNativeInterface).registerApp(anyString(), anyString(), anyString(), anyByte(), any(byte[].class), isNull(), isNull());
    mHidDeviceService.registerApp(mSettings, null, null, null);
    // app registered
    mHidDeviceService.onApplicationStateChangedFromNative(mTestDevice, true);
    // wait for the app registration callback to complete
    Thread.sleep(TIMEOUT_MS);
    // sendReport() should work when app is registered
    Assert.assertEquals(true, mHidDeviceService.sendReport(mTestDevice, SAMPLE_REPORT_ID, SAMPLE_OUTGOING_HID_REPORT));
    verify(sHidDeviceNativeInterface).sendReport(eq((int) SAMPLE_REPORT_ID), eq(SAMPLE_OUTGOING_HID_REPORT));
    // unregister app
    doReturn(true).when(sHidDeviceNativeInterface).unregisterApp();
    Assert.assertEquals(true, mHidDeviceService.unregisterApp());
}
#method_after
@Test
public void testSendReport() throws Exception {
    doReturn(true).when(sHidDeviceNativeInterface).sendReport(anyInt(), any(byte[].class));
    // sendReport() should fail without app registered
    Assert.assertEquals(false, mHidDeviceService.sendReport(mTestDevice, SAMPLE_REPORT_ID, SAMPLE_HID_REPORT));
    // Register app
    doReturn(true).when(sHidDeviceNativeInterface).registerApp(anyString(), anyString(), anyString(), anyByte(), any(byte[].class), isNull(), isNull());
    BluetoothHidDeviceCallbackTestHelper helper = new BluetoothHidDeviceCallbackTestHelper();
    Assert.assertTrue(mHidDeviceService.registerApp(mSettings, null, null, helper));
    // App registered
    mHidDeviceService.onApplicationStateChangedFromNative(mTestDevice, true);
    // Wait for the app registration callback to complete and verify it
    verifyCallback(TIMEOUT_MS, CALLBACK_APP_REGISTERED, mCallbackQueue);
    // sendReport() should work when app is registered
    Assert.assertEquals(true, mHidDeviceService.sendReport(mTestDevice, SAMPLE_REPORT_ID, SAMPLE_HID_REPORT));
    verify(sHidDeviceNativeInterface).sendReport(eq((int) SAMPLE_REPORT_ID), eq(SAMPLE_HID_REPORT));
    // Unregister app
    doReturn(true).when(sHidDeviceNativeInterface).unregisterApp();
    Assert.assertEquals(true, mHidDeviceService.unregisterApp());
}
#end_block

#method_before
@Test
public void testReplyReport() throws Exception {
    doReturn(true).when(sHidDeviceNativeInterface).replyReport(anyByte(), anyByte(), any(byte[].class));
    // replyReport() should fail without app registered
    Assert.assertEquals(false, mHidDeviceService.replyReport(mTestDevice, SAMPLE_REPORT_TYPE, SAMPLE_REPORT_ID, SAMPLE_OUTGOING_HID_REPORT));
    // register app
    doReturn(true).when(sHidDeviceNativeInterface).registerApp(anyString(), anyString(), anyString(), anyByte(), any(byte[].class), isNull(), isNull());
    mHidDeviceService.registerApp(mSettings, null, null, null);
    // app registered
    mHidDeviceService.onApplicationStateChangedFromNative(mTestDevice, true);
    // wait for the app registration callback to complete
    Thread.sleep(TIMEOUT_MS);
    // replyReport() should work when app is registered
    Assert.assertEquals(true, mHidDeviceService.replyReport(mTestDevice, SAMPLE_REPORT_TYPE, SAMPLE_REPORT_ID, SAMPLE_OUTGOING_HID_REPORT));
    verify(sHidDeviceNativeInterface).replyReport(eq(SAMPLE_REPORT_TYPE), eq(SAMPLE_REPORT_ID), eq(SAMPLE_OUTGOING_HID_REPORT));
    // unregister app
    doReturn(true).when(sHidDeviceNativeInterface).unregisterApp();
    Assert.assertEquals(true, mHidDeviceService.unregisterApp());
}
#method_after
@Test
public void testReplyReport() throws Exception {
    doReturn(true).when(sHidDeviceNativeInterface).replyReport(anyByte(), anyByte(), any(byte[].class));
    // replyReport() should fail without app registered
    Assert.assertEquals(false, mHidDeviceService.replyReport(mTestDevice, SAMPLE_REPORT_TYPE, SAMPLE_REPORT_ID, SAMPLE_HID_REPORT));
    // Register app
    doReturn(true).when(sHidDeviceNativeInterface).registerApp(anyString(), anyString(), anyString(), anyByte(), any(byte[].class), isNull(), isNull());
    BluetoothHidDeviceCallbackTestHelper helper = new BluetoothHidDeviceCallbackTestHelper();
    Assert.assertTrue(mHidDeviceService.registerApp(mSettings, null, null, helper));
    // App registered
    mHidDeviceService.onApplicationStateChangedFromNative(mTestDevice, true);
    // Wait for the app registration callback to complete and verify it
    verifyCallback(TIMEOUT_MS, CALLBACK_APP_REGISTERED, mCallbackQueue);
    // replyReport() should work when app is registered
    Assert.assertEquals(true, mHidDeviceService.replyReport(mTestDevice, SAMPLE_REPORT_TYPE, SAMPLE_REPORT_ID, SAMPLE_HID_REPORT));
    verify(sHidDeviceNativeInterface).replyReport(eq(SAMPLE_REPORT_TYPE), eq(SAMPLE_REPORT_ID), eq(SAMPLE_HID_REPORT));
    // Unregister app
    doReturn(true).when(sHidDeviceNativeInterface).unregisterApp();
    Assert.assertEquals(true, mHidDeviceService.unregisterApp());
}
#end_block

#method_before
@Test
public void testReportError() throws Exception {
    doReturn(true).when(sHidDeviceNativeInterface).reportError(anyByte());
    // reportError() should fail without app registered
    Assert.assertEquals(false, mHidDeviceService.reportError(mTestDevice, SAMPLE_REPORT_ERROR));
    // register app
    doReturn(true).when(sHidDeviceNativeInterface).registerApp(anyString(), anyString(), anyString(), anyByte(), any(byte[].class), isNull(), isNull());
    mHidDeviceService.registerApp(mSettings, null, null, null);
    // app registered
    mHidDeviceService.onApplicationStateChangedFromNative(mTestDevice, true);
    // wait for the app registration callback to complete
    Thread.sleep(TIMEOUT_MS);
    // reportError() should work when app is registered
    Assert.assertEquals(true, mHidDeviceService.reportError(mTestDevice, SAMPLE_REPORT_ERROR));
    verify(sHidDeviceNativeInterface).reportError(eq(SAMPLE_REPORT_ERROR));
    // unregister app
    doReturn(true).when(sHidDeviceNativeInterface).unregisterApp();
    Assert.assertEquals(true, mHidDeviceService.unregisterApp());
}
#method_after
@Test
public void testReportError() throws Exception {
    doReturn(true).when(sHidDeviceNativeInterface).reportError(anyByte());
    // reportError() should fail without app registered
    Assert.assertEquals(false, mHidDeviceService.reportError(mTestDevice, SAMPLE_REPORT_ERROR));
    // Register app
    doReturn(true).when(sHidDeviceNativeInterface).registerApp(anyString(), anyString(), anyString(), anyByte(), any(byte[].class), isNull(), isNull());
    BluetoothHidDeviceCallbackTestHelper helper = new BluetoothHidDeviceCallbackTestHelper();
    Assert.assertTrue(mHidDeviceService.registerApp(mSettings, null, null, helper));
    // App registered
    mHidDeviceService.onApplicationStateChangedFromNative(mTestDevice, true);
    // Wait for the app registration callback to complete and verify it
    verifyCallback(TIMEOUT_MS, CALLBACK_APP_REGISTERED, mCallbackQueue);
    // reportError() should work when app is registered
    Assert.assertEquals(true, mHidDeviceService.reportError(mTestDevice, SAMPLE_REPORT_ERROR));
    verify(sHidDeviceNativeInterface).reportError(eq(SAMPLE_REPORT_ERROR));
    // Unregister app
    doReturn(true).when(sHidDeviceNativeInterface).unregisterApp();
    Assert.assertEquals(true, mHidDeviceService.unregisterApp());
}
#end_block

#method_before
@Test
public void testOutgoingConnectDisconnectSuccess() {
    doReturn(true).when(sHidDeviceNativeInterface).connect(any(BluetoothDevice.class));
    doReturn(true).when(sHidDeviceNativeInterface).disconnect();
    // register app
    doReturn(true).when(sHidDeviceNativeInterface).registerApp(anyString(), anyString(), anyString(), anyByte(), any(byte[].class), isNull(), isNull());
    mHidDeviceService.registerApp(mSettings, null, null, null);
    // app registered
    mHidDeviceService.onApplicationStateChangedFromNative(mTestDevice, true);
    // send a connect request
    Assert.assertTrue("Connect failed", mHidDeviceService.connect(mTestDevice));
    mHidDeviceService.onConnectStateChangedFromNative(mTestDevice, HAL_CONN_STATE_CONNECTING);
    // verify the connection state broadcast
    verifyConnectionStateIntent(TIMEOUT_MS, mTestDevice, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTING, mHidDeviceService.getConnectionState(mTestDevice));
    mHidDeviceService.onConnectStateChangedFromNative(mTestDevice, HAL_CONN_STATE_CONNECTED);
    // verify the connection state broadcast
    verifyConnectionStateIntent(TIMEOUT_MS, mTestDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHidDeviceService.getConnectionState(mTestDevice));
    // Verify the list of connected devices
    Assert.assertTrue(mHidDeviceService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED }).contains(mTestDevice));
    // send a disconnect request
    Assert.assertTrue("Disconnect failed", mHidDeviceService.disconnect(mTestDevice));
    mHidDeviceService.onConnectStateChangedFromNative(mTestDevice, HAL_CONN_STATE_DISCONNECTING);
    // verify the connection state broadcast
    verifyConnectionStateIntent(TIMEOUT_MS, mTestDevice, BluetoothProfile.STATE_DISCONNECTING, BluetoothProfile.STATE_CONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTING, mHidDeviceService.getConnectionState(mTestDevice));
    mHidDeviceService.onConnectStateChangedFromNative(mTestDevice, HAL_CONN_STATE_DISCONNECTED);
    // verify the connection state broadcast
    verifyConnectionStateIntent(TIMEOUT_MS, mTestDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTING);
    Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTED, mHidDeviceService.getConnectionState(mTestDevice));
    // Verify the list of connected devices
    Assert.assertFalse(mHidDeviceService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED }).contains(mTestDevice));
}
#method_after
@Test
public void testOutgoingConnectDisconnectSuccess() {
    doReturn(true).when(sHidDeviceNativeInterface).connect(any(BluetoothDevice.class));
    doReturn(true).when(sHidDeviceNativeInterface).disconnect();
    // Register app
    doReturn(true).when(sHidDeviceNativeInterface).registerApp(anyString(), anyString(), anyString(), anyByte(), any(byte[].class), isNull(), isNull());
    mHidDeviceService.registerApp(mSettings, null, null, null);
    // App registered
    mHidDeviceService.onApplicationStateChangedFromNative(mTestDevice, true);
    // Send a connect request
    Assert.assertTrue("Connect failed", mHidDeviceService.connect(mTestDevice));
    mHidDeviceService.onConnectStateChangedFromNative(mTestDevice, HidDeviceService.HAL_CONN_STATE_CONNECTING);
    // Verify the connection state broadcast
    verifyConnectionStateIntent(TIMEOUT_MS, mTestDevice, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTING, mHidDeviceService.getConnectionState(mTestDevice));
    mHidDeviceService.onConnectStateChangedFromNative(mTestDevice, HidDeviceService.HAL_CONN_STATE_CONNECTED);
    // Verify the connection state broadcast
    verifyConnectionStateIntent(TIMEOUT_MS, mTestDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHidDeviceService.getConnectionState(mTestDevice));
    // Verify the list of connected devices
    Assert.assertTrue(mHidDeviceService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED }).contains(mTestDevice));
    // Send a disconnect request
    Assert.assertTrue("Disconnect failed", mHidDeviceService.disconnect(mTestDevice));
    mHidDeviceService.onConnectStateChangedFromNative(mTestDevice, HidDeviceService.HAL_CONN_STATE_DISCONNECTING);
    // Verify the connection state broadcast
    verifyConnectionStateIntent(TIMEOUT_MS, mTestDevice, BluetoothProfile.STATE_DISCONNECTING, BluetoothProfile.STATE_CONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTING, mHidDeviceService.getConnectionState(mTestDevice));
    mHidDeviceService.onConnectStateChangedFromNative(mTestDevice, HidDeviceService.HAL_CONN_STATE_DISCONNECTED);
    // Verify the connection state broadcast
    verifyConnectionStateIntent(TIMEOUT_MS, mTestDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTING);
    Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTED, mHidDeviceService.getConnectionState(mTestDevice));
    // Verify the list of connected devices
    Assert.assertFalse(mHidDeviceService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED }).contains(mTestDevice));
    // Unregister app
    doReturn(true).when(sHidDeviceNativeInterface).unregisterApp();
    Assert.assertEquals(true, mHidDeviceService.unregisterApp());
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, writer)) {
        return;
    }
    String errorMsg = null;
    boolean protoOut = (args.length > 0) && args[0].startsWith("--proto");
    if (!protoOut) {
        writer.println("Bluetooth Status");
        writer.println("  enabled: " + isEnabled());
        writer.println("  state: " + BluetoothAdapter.nameForState(mState));
        writer.println("  address: " + mAddress);
        writer.println("  name: " + mName);
        if (mEnable) {
            long onDuration = SystemClock.elapsedRealtime() - mLastEnabledTime;
            String onDurationString = String.format("%02d:%02d:%02d.%03d", (int) (onDuration / (1000 * 60 * 60)), (int) ((onDuration / (1000 * 60)) % 60), (int) ((onDuration / 1000) % 60), (int) (onDuration % 1000));
            writer.println("  time since enabled: " + onDurationString + "\n");
        }
        if (mActiveLogs.size() == 0) {
            writer.println("Bluetooth never enabled!");
        } else {
            writer.println("Enable log:");
            for (ActiveLog log : mActiveLogs) {
                writer.println("  " + log);
            }
        }
        writer.println("Bluetooth crashed " + mCrashes + " time" + (mCrashes == 1 ? "" : "s"));
        if (mCrashes == CRASH_LOG_MAX_SIZE) {
            writer.println("(last " + CRASH_LOG_MAX_SIZE + ")");
        }
        for (Long time : mCrashTimestamps) {
            writer.println("  " + timeToLog(time.longValue()));
        }
        String bleAppString = "No BLE Apps registered.";
        if (mBleApps.size() == 1) {
            bleAppString = "1 BLE App registered:";
        } else if (mBleApps.size() > 1) {
            bleAppString = mBleApps.size() + " BLE Apps registered:";
        }
        writer.println("\n" + bleAppString);
        for (ClientDeathRecipient app : mBleApps.values()) {
            writer.println("  " + app.getPackageName());
        }
        writer.println("");
        writer.flush();
        if (args.length == 0) {
            // Add arg to produce output
            args = new String[1];
            args[0] = "--print";
        }
    }
    if (mBluetoothBinder == null) {
        errorMsg = "Bluetooth Service not connected";
    } else {
        try {
            mBluetoothBinder.dump(fd, args);
        } catch (RemoteException re) {
            errorMsg = "RemoteException while dumping Bluetooth Service";
        }
    }
    if (errorMsg != null) {
        // Silently return if we are extracting metrics in Protobuf format
        if (protoOut) {
            return;
        }
        writer.println(errorMsg);
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, writer)) {
        return;
    }
    String errorMsg = null;
    boolean protoOut = (args.length > 0) && args[0].startsWith("--proto");
    if (!protoOut) {
        writer.println("Bluetooth Status");
        writer.println("  enabled: " + isEnabled());
        writer.println("  state: " + BluetoothAdapter.nameForState(mState));
        writer.println("  address: " + mAddress);
        writer.println("  name: " + mName);
        if (mEnable) {
            long onDuration = SystemClock.elapsedRealtime() - mLastEnabledTime;
            String onDurationString = String.format(Locale.US, "%02d:%02d:%02d.%03d", (int) (onDuration / (1000 * 60 * 60)), (int) ((onDuration / (1000 * 60)) % 60), (int) ((onDuration / 1000) % 60), (int) (onDuration % 1000));
            writer.println("  time since enabled: " + onDurationString);
        }
        if (mActiveLogs.size() == 0) {
            writer.println("\nBluetooth never enabled!");
        } else {
            writer.println("\nEnable log:");
            for (ActiveLog log : mActiveLogs) {
                writer.println("  " + log);
            }
        }
        writer.println("\nBluetooth crashed " + mCrashes + " time" + (mCrashes == 1 ? "" : "s"));
        if (mCrashes == CRASH_LOG_MAX_SIZE) {
            writer.println("(last " + CRASH_LOG_MAX_SIZE + ")");
        }
        for (Long time : mCrashTimestamps) {
            writer.println("  " + timeToLog(time));
        }
        writer.println("\n" + mBleApps.size() + " BLE app" + (mBleApps.size() == 1 ? "" : "s") + "registered");
        for (ClientDeathRecipient app : mBleApps.values()) {
            writer.println("  " + app.getPackageName());
        }
        writer.println("");
        writer.flush();
        if (args.length == 0) {
            // Add arg to produce output
            args = new String[1];
            args[0] = "--print";
        }
    }
    if (mBluetoothBinder == null) {
        errorMsg = "Bluetooth Service not connected";
    } else {
        try {
            mBluetoothBinder.dump(fd, args);
        } catch (RemoteException re) {
            errorMsg = "RemoteException while dumping Bluetooth Service";
        }
    }
    if (errorMsg != null) {
        // Silently return if we are extracting metrics in Protobuf format
        if (protoOut) {
            return;
        }
        writer.println(errorMsg);
    }
}
#end_block

#method_before
public void stop() {
    synchronized (mLock) {
        mRunning = false;
    }
    clearLinkProperties();
    mNetlinkSocketObserver.clearNetlinkSocket();
}
#method_after
public void stop() {
    mIpNeighborMonitor.stop();
    clearLinkProperties();
}
#end_block

#method_before
// TODO: add a public dump() method that can be called during a bug report.
private String describeWatchList() {
    final String delimiter = ", ";
    StringBuilder sb = new StringBuilder();
    synchronized (mLock) {
        sb.append("iface{" + mInterfaceName + "/" + mInterfaceIndex + "}, ");
        sb.append("v{" + mIpWatchListVersion + "}, ");
        sb.append("ntable=[");
        boolean firstTime = true;
        for (Map.Entry<InetAddress, Short> entry : mIpWatchList.entrySet()) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(delimiter);
            }
            sb.append(entry.getKey().getHostAddress() + "/" + StructNdMsg.stringForNudState(entry.getValue()));
        }
        sb.append("]");
    }
    return sb.toString();
}
#method_after
private String describeWatchList() {
    return describeWatchList(" ");
}
#end_block

#method_before
// TODO: add a public dump() method that can be called during a bug report.
private String describeWatchList() {
    final String delimiter = ", ";
    StringBuilder sb = new StringBuilder();
    synchronized (mLock) {
        sb.append("iface{" + mInterfaceName + "/" + mInterfaceIndex + "}, ");
        sb.append("v{" + mIpWatchListVersion + "}, ");
        sb.append("ntable=[");
        boolean firstTime = true;
        for (Map.Entry<InetAddress, Short> entry : mIpWatchList.entrySet()) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(delimiter);
            }
            sb.append(entry.getKey().getHostAddress() + "/" + StructNdMsg.stringForNudState(entry.getValue()));
        }
        sb.append("]");
    }
    return sb.toString();
}
#method_after
private String describeWatchList(String sep) {
    final StringBuilder sb = new StringBuilder();
    sb.append("iface{" + mInterfaceName + "/" + mInterfaceIndex + "}," + sep);
    sb.append("ntable=[" + sep);
    String delimiter = "";
    for (Map.Entry<InetAddress, NeighborEvent> entry : mNeighborWatchList.entrySet()) {
        sb.append(delimiter).append(entry.getKey().getHostAddress() + "/" + entry.getValue());
        delimiter = "," + sep;
    }
    sb.append("]");
    return sb.toString();
}
#end_block

#method_before
public void updateLinkProperties(LinkProperties lp) {
    if (!mInterfaceName.equals(lp.getInterfaceName())) {
        // TODO: figure out whether / how to cope with interface changes.
        Log.wtf(TAG, "requested LinkProperties interface '" + lp.getInterfaceName() + "' does not match: " + mInterfaceName);
        return;
    }
    synchronized (mLock) {
        mLinkProperties = new LinkProperties(lp);
        Map<InetAddress, Short> newIpWatchList = new HashMap<>();
        final List<RouteInfo> routes = mLinkProperties.getRoutes();
        for (RouteInfo route : routes) {
            if (route.hasGateway()) {
                InetAddress gw = route.getGateway();
                if (isOnLink(routes, gw)) {
                    newIpWatchList.put(gw, getNeighborStateLocked(gw));
                }
            }
        }
        for (InetAddress nameserver : lp.getDnsServers()) {
            if (isOnLink(routes, nameserver)) {
                newIpWatchList.put(nameserver, getNeighborStateLocked(nameserver));
            }
        }
        mIpWatchList = newIpWatchList;
        mIpWatchListVersion++;
    }
    if (DBG) {
        Log.d(TAG, "watch: " + describeWatchList());
    }
}
#method_after
public void updateLinkProperties(LinkProperties lp) {
    if (!mInterfaceName.equals(lp.getInterfaceName())) {
        // TODO: figure out whether / how to cope with interface changes.
        Log.wtf(TAG, "requested LinkProperties interface '" + lp.getInterfaceName() + "' does not match: " + mInterfaceName);
        return;
    }
    mLinkProperties = new LinkProperties(lp);
    Map<InetAddress, NeighborEvent> newNeighborWatchList = new HashMap<>();
    final List<RouteInfo> routes = mLinkProperties.getRoutes();
    for (RouteInfo route : routes) {
        if (route.hasGateway()) {
            InetAddress gw = route.getGateway();
            if (isOnLink(routes, gw)) {
                newNeighborWatchList.put(gw, mNeighborWatchList.getOrDefault(gw, null));
            }
        }
    }
    for (InetAddress dns : lp.getDnsServers()) {
        if (isOnLink(routes, dns)) {
            newNeighborWatchList.put(dns, mNeighborWatchList.getOrDefault(dns, null));
        }
    }
    mNeighborWatchList = newNeighborWatchList;
    if (DBG) {
        Log.d(TAG, "watch: " + describeWatchList());
    }
}
#end_block

#method_before
public void clearLinkProperties() {
    synchronized (mLock) {
        mLinkProperties.clear();
        mIpWatchList.clear();
        mIpWatchListVersion++;
    }
    if (DBG) {
        Log.d(TAG, "clear: " + describeWatchList());
    }
}
#method_after
public void clearLinkProperties() {
    mLinkProperties.clear();
    mNeighborWatchList.clear();
    if (DBG) {
        Log.d(TAG, "clear: " + describeWatchList());
    }
}
#end_block

#method_before
private void handleNeighborLost(String msg) {
    InetAddress ip = null;
    final ProvisioningChange delta;
    synchronized (mLock) {
        LinkProperties whatIfLp = new LinkProperties(mLinkProperties);
        for (Map.Entry<InetAddress, Short> entry : mIpWatchList.entrySet()) {
            if (entry.getValue() != StructNdMsg.NUD_FAILED) {
                continue;
            }
            ip = entry.getKey();
            for (RouteInfo route : mLinkProperties.getRoutes()) {
                if (ip.equals(route.getGateway())) {
                    whatIfLp.removeRoute(route);
                }
            }
            if (avoidingBadLinks() || !(ip instanceof Inet6Address)) {
                // We should do this unconditionally, but alas we cannot: b/31827713.
                whatIfLp.removeDnsServer(ip);
            }
        }
        delta = LinkProperties.compareProvisioning(mLinkProperties, whatIfLp);
    }
    if (delta == ProvisioningChange.LOST_PROVISIONING) {
        final String logMsg = "FAILURE: LOST_PROVISIONING, " + msg;
        Log.w(TAG, logMsg);
        if (mCallback != null) {
            // TODO: remove |ip| when the callback signature no longer has
            // an InetAddress argument.
            mCallback.notifyLost(ip, logMsg);
        }
    }
    logNudFailed(delta);
}
#method_after
private void handleNeighborLost(NeighborEvent event) {
    final LinkProperties whatIfLp = new LinkProperties(mLinkProperties);
    InetAddress ip = null;
    for (Map.Entry<InetAddress, NeighborEvent> entry : mNeighborWatchList.entrySet()) {
        // NUD_INCOMPLETE (say, during network attach).
        if (entry.getValue().nudState != StructNdMsg.NUD_FAILED)
            continue;
        ip = entry.getKey();
        for (RouteInfo route : mLinkProperties.getRoutes()) {
            if (ip.equals(route.getGateway())) {
                whatIfLp.removeRoute(route);
            }
        }
        if (avoidingBadLinks() || !(ip instanceof Inet6Address)) {
            // We should do this unconditionally, but alas we cannot: b/31827713.
            whatIfLp.removeDnsServer(ip);
        }
    }
    final ProvisioningChange delta = LinkProperties.compareProvisioning(mLinkProperties, whatIfLp);
    if (delta == ProvisioningChange.LOST_PROVISIONING) {
        final String logMsg = "FAILURE: LOST_PROVISIONING, " + event;
        Log.w(TAG, logMsg);
        if (mCallback != null) {
            // TODO: remove |ip| when the callback signature no longer has
            // an InetAddress argument.
            mCallback.notifyLost(ip, logMsg);
        }
    }
    logNudFailed(delta);
}
#end_block

#method_before
public void probeAll() {
    Set<InetAddress> ipProbeList = new HashSet<InetAddress>();
    synchronized (mLock) {
        ipProbeList.addAll(mIpWatchList.keySet());
    }
    if (!ipProbeList.isEmpty() && stillRunning()) {
        // Keep the CPU awake long enough to allow all ARP/ND
        // probes a reasonable chance at success. See b/23197666.
        // 
        // The wakelock we use is (by default) refcounted, and this version
        // of acquire(timeout) queues a release message to keep acquisitions
        // and releases balanced.
        mWakeLock.acquire(getProbeWakeLockDuration());
    }
    for (InetAddress target : ipProbeList) {
        if (!stillRunning()) {
            break;
        }
        final int returnValue = probeNeighbor(mInterfaceIndex, target);
        mLog.log(String.format("put neighbor %s into NUD_PROBE state (rval=%d)", target.getHostAddress(), returnValue));
        logEvent(IpReachabilityEvent.PROBE, returnValue);
    }
    mLastProbeTimeMs = SystemClock.elapsedRealtime();
}
#method_after
public void probeAll() {
    final List<InetAddress> ipProbeList = new ArrayList<>(mNeighborWatchList.keySet());
    if (!ipProbeList.isEmpty()) {
        // Keep the CPU awake long enough to allow all ARP/ND
        // probes a reasonable chance at success. See b/23197666.
        // 
        // The wakelock we use is (by default) refcounted, and this version
        // of acquire(timeout) queues a release message to keep acquisitions
        // and releases balanced.
        mDependencies.acquireWakeLock(getProbeWakeLockDuration());
    }
    for (InetAddress target : ipProbeList) {
        final int rval = IpNeighborMonitor.startKernelNeighborProbe(mInterfaceIndex, target);
        mLog.log(String.format("put neighbor %s into NUD_PROBE state (rval=%d)", target.getHostAddress(), rval));
        logEvent(IpReachabilityEvent.PROBE, rval);
    }
    mLastProbeTimeMs = SystemClock.elapsedRealtime();
}
#end_block

#method_before
private void logEvent(int probeType, int errorCode) {
    int eventType = probeType | (errorCode & 0xff);
    mMetricsLog.log(new IpReachabilityEvent(mInterfaceName, eventType));
}
#method_after
private void logEvent(int probeType, int errorCode) {
    int eventType = probeType | (errorCode & 0xff);
    mMetricsLog.log(mInterfaceName, new IpReachabilityEvent(eventType));
}
#end_block

#method_before
private void logNudFailed(ProvisioningChange delta) {
    long duration = SystemClock.elapsedRealtime() - mLastProbeTimeMs;
    boolean isFromProbe = (duration < getProbeWakeLockDuration());
    boolean isProvisioningLost = (delta == ProvisioningChange.LOST_PROVISIONING);
    int eventType = IpReachabilityEvent.nudFailureEventType(isFromProbe, isProvisioningLost);
    mMetricsLog.log(new IpReachabilityEvent(mInterfaceName, eventType));
}
#method_after
private void logNudFailed(ProvisioningChange delta) {
    long duration = SystemClock.elapsedRealtime() - mLastProbeTimeMs;
    boolean isFromProbe = (duration < getProbeWakeLockDuration());
    boolean isProvisioningLost = (delta == ProvisioningChange.LOST_PROVISIONING);
    int eventType = IpReachabilityEvent.nudFailureEventType(isFromProbe, isProvisioningLost);
    mMetricsLog.log(mInterfaceName, new IpReachabilityEvent(eventType));
}
#end_block

#method_before
public void connectToKernel() throws ErrnoException, SocketException {
    connectTo(new NetlinkSocketAddress(0, 0));
}
#method_after
public static void connectToKernel(FileDescriptor fd) throws ErrnoException, SocketException {
    Os.connect(fd, (SocketAddress) (new NetlinkSocketAddress(0, 0)));
}
#end_block

#method_before
private void checkTimeout(long timeoutMs) {
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Negative timeouts not permitted");
    }
}
#method_after
private static void checkTimeout(long timeoutMs) {
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Negative timeouts not permitted");
    }
}
#end_block

#method_before
public ByteBuffer recvMessage(int bufsize, long timeoutMs) throws ErrnoException, IllegalArgumentException, InterruptedIOException {
    checkTimeout(timeoutMs);
    synchronized (mDescriptor) {
        if (mLastRecvTimeoutMs != timeoutMs) {
            Os.setsockoptTimeval(mDescriptor, OsConstants.SOL_SOCKET, OsConstants.SO_RCVTIMEO, StructTimeval.fromMillis(timeoutMs));
            mLastRecvTimeoutMs = timeoutMs;
        }
    }
    ByteBuffer byteBuffer = ByteBuffer.allocate(bufsize);
    int length = Os.read(mDescriptor, byteBuffer);
    if (length == bufsize) {
        Log.w(TAG, "maximum read");
    }
    byteBuffer.position(0);
    byteBuffer.limit(length);
    byteBuffer.order(ByteOrder.nativeOrder());
    return byteBuffer;
}
#method_after
public static ByteBuffer recvMessage(FileDescriptor fd, int bufsize, long timeoutMs) throws ErrnoException, IllegalArgumentException, InterruptedIOException {
    checkTimeout(timeoutMs);
    Os.setsockoptTimeval(fd, SOL_SOCKET, SO_RCVTIMEO, StructTimeval.fromMillis(timeoutMs));
    ByteBuffer byteBuffer = ByteBuffer.allocate(bufsize);
    int length = Os.read(fd, byteBuffer);
    if (length == bufsize) {
        Log.w(TAG, "maximum read");
    }
    byteBuffer.position(0);
    byteBuffer.limit(length);
    byteBuffer.order(ByteOrder.nativeOrder());
    return byteBuffer;
}
#end_block

#method_before
public boolean sendMessage(byte[] bytes, int offset, int count, long timeoutMs) throws ErrnoException, IllegalArgumentException, InterruptedIOException {
    checkTimeout(timeoutMs);
    synchronized (mDescriptor) {
        if (mLastSendTimeoutMs != timeoutMs) {
            Os.setsockoptTimeval(mDescriptor, OsConstants.SOL_SOCKET, OsConstants.SO_SNDTIMEO, StructTimeval.fromMillis(timeoutMs));
            mLastSendTimeoutMs = timeoutMs;
        }
    }
    return (count == Os.write(mDescriptor, bytes, offset, count));
}
#method_after
public static int sendMessage(FileDescriptor fd, byte[] bytes, int offset, int count, long timeoutMs) throws ErrnoException, IllegalArgumentException, InterruptedIOException {
    checkTimeout(timeoutMs);
    Os.setsockoptTimeval(fd, SOL_SOCKET, SO_SNDTIMEO, StructTimeval.fromMillis(timeoutMs));
    return Os.write(fd, bytes, offset, count);
}
#end_block

#method_before
static ImsPhoneMmiCode newFromDialString(String dialString, ImsPhone phone, ResultReceiver wrappedCallback) {
    Matcher m;
    ImsPhoneMmiCode ret = null;
    m = sPatternSuppService.matcher(dialString);
    // Is this formatted like a standard supplementary service code?
    if (m.matches()) {
        ret = new ImsPhoneMmiCode(phone);
        ret.mPoundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));
        ret.mAction = makeEmptyNull(m.group(MATCH_GROUP_ACTION));
        ret.mSc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));
        ret.mSia = makeEmptyNull(m.group(MATCH_GROUP_SIA));
        ret.mSib = makeEmptyNull(m.group(MATCH_GROUP_SIB));
        ret.mSic = makeEmptyNull(m.group(MATCH_GROUP_SIC));
        ret.mPwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));
        ret.mDialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));
        ret.mCallbackReceiver = wrappedCallback;
        // in India operator(Mumbai MTNL)
        if (ret.mDialingNumber != null && ret.mDialingNumber.endsWith("#") && dialString.endsWith("#")) {
            ret = new ImsPhoneMmiCode(phone);
            ret.mPoundString = dialString;
        }
    } else if (dialString.endsWith("#")) {
        // TS 22.030 sec 6.5.3.2
        // "Entry of any characters defined in the 3GPP TS 23.038 [8] Default Alphabet
        // (up to the maximum defined in 3GPP TS 24.080 [10]), followed by #SEND".
        ret = new ImsPhoneMmiCode(phone);
        ret.mPoundString = dialString;
    } else if (isTwoDigitShortCode(phone.getContext(), dialString)) {
        // Is a country-specific exception to short codes as defined in TS 22.030, 6.5.3.2
        ret = null;
    } else if (isShortCode(dialString, phone)) {
        // this may be a short code, as defined in TS 22.030, 6.5.3.2
        ret = new ImsPhoneMmiCode(phone);
        ret.mDialingNumber = dialString;
    }
    return ret;
}
#method_after
static ImsPhoneMmiCode newFromDialString(String dialString, ImsPhone phone, ResultReceiver wrappedCallback) {
    Matcher m;
    ImsPhoneMmiCode ret = null;
    if (phone.getDefaultPhone().getServiceState().getVoiceRoaming() && phone.getDefaultPhone().supportsConversionOfCdmaCallerIdMmiCodesWhileRoaming()) {
        /* The CDMA MMI coded dialString will be converted to a 3GPP MMI Coded dialString
               so that it can be processed by the matcher and code below
             */
        dialString = convertCdmaMmiCodesTo3gppMmiCodes(dialString);
    }
    m = sPatternSuppService.matcher(dialString);
    // Is this formatted like a standard supplementary service code?
    if (m.matches()) {
        ret = new ImsPhoneMmiCode(phone);
        ret.mPoundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));
        ret.mAction = makeEmptyNull(m.group(MATCH_GROUP_ACTION));
        ret.mSc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));
        ret.mSia = makeEmptyNull(m.group(MATCH_GROUP_SIA));
        ret.mSib = makeEmptyNull(m.group(MATCH_GROUP_SIB));
        ret.mSic = makeEmptyNull(m.group(MATCH_GROUP_SIC));
        ret.mPwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));
        ret.mDialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));
        ret.mCallbackReceiver = wrappedCallback;
        // in India operator(Mumbai MTNL)
        if (ret.mDialingNumber != null && ret.mDialingNumber.endsWith("#") && dialString.endsWith("#")) {
            ret = new ImsPhoneMmiCode(phone);
            ret.mPoundString = dialString;
        }
    } else if (dialString.endsWith("#")) {
        // TS 22.030 sec 6.5.3.2
        // "Entry of any characters defined in the 3GPP TS 23.038 [8] Default Alphabet
        // (up to the maximum defined in 3GPP TS 24.080 [10]), followed by #SEND".
        ret = new ImsPhoneMmiCode(phone);
        ret.mPoundString = dialString;
    } else if (isTwoDigitShortCode(phone.getContext(), dialString)) {
        // Is a country-specific exception to short codes as defined in TS 22.030, 6.5.3.2
        ret = null;
    } else if (isShortCode(dialString, phone)) {
        // this may be a short code, as defined in TS 22.030, 6.5.3.2
        ret = new ImsPhoneMmiCode(phone);
        ret.mDialingNumber = dialString;
    }
    return ret;
}
#end_block

#method_before
boolean isSupportedOverImsPhone() {
    if (isShortCode())
        return true;
    else if (mDialingNumber != null)
        return false;
    else if (isServiceCodeCallForwarding(mSc) || isServiceCodeCallBarring(mSc) || (mSc != null && mSc.equals(SC_WAIT)) || (mSc != null && mSc.equals(SC_CLIR)) || (mSc != null && mSc.equals(SC_CLIP)) || (mSc != null && mSc.equals(SC_COLR)) || (mSc != null && mSc.equals(SC_COLP)) || (mSc != null && mSc.equals(SC_BS_MT)) || (mSc != null && mSc.equals(SC_BAICa))) {
        try {
            int serviceClass = siToServiceClass(mSib);
            if (serviceClass != SERVICE_CLASS_NONE && serviceClass != SERVICE_CLASS_VOICE) {
                return false;
            }
            return true;
        } catch (RuntimeException exc) {
            Rlog.d(LOG_TAG, "Invalid service class " + exc);
        }
    } else if (isPinPukCommand() || (mSc != null && (mSc.equals(SC_PWD) || mSc.equals(SC_CLIP) || mSc.equals(SC_CLIR)))) {
        return false;
    } else if (mPoundString != null)
        return true;
    return false;
}
#method_after
boolean isSupportedOverImsPhone() {
    if (isShortCode())
        return true;
    else if (isServiceCodeCallForwarding(mSc) || isServiceCodeCallBarring(mSc) || (mSc != null && mSc.equals(SC_WAIT)) || (mSc != null && mSc.equals(SC_CLIR)) || (mSc != null && mSc.equals(SC_CLIP)) || (mSc != null && mSc.equals(SC_COLR)) || (mSc != null && mSc.equals(SC_COLP)) || (mSc != null && mSc.equals(SC_BS_MT)) || (mSc != null && mSc.equals(SC_BAICa))) {
        try {
            int serviceClass = siToServiceClass(mSib);
            if (serviceClass != SERVICE_CLASS_NONE && serviceClass != SERVICE_CLASS_VOICE && serviceClass != (SERVICE_CLASS_PACKET + SERVICE_CLASS_DATA_SYNC)) {
                return false;
            }
            return true;
        } catch (RuntimeException exc) {
            Rlog.d(LOG_TAG, "Invalid service class " + exc);
        }
    } else if (isPinPukCommand() || (mSc != null && (mSc.equals(SC_PWD) || mSc.equals(SC_CLIP) || mSc.equals(SC_CLIR)))) {
        return false;
    } else if (mPoundString != null)
        return true;
    return false;
}
#end_block

#method_before
public void processCode() throws CallStateException {
    try {
        if (isShortCode()) {
            Rlog.d(LOG_TAG, "processCode: isShortCode");
            // These just get treated as USSD.
            Rlog.d(LOG_TAG, "processCode: Sending short code '" + mDialingNumber + "' over CS pipe.");
            throw new CallStateException(Phone.CS_FALLBACK);
        } else if (isServiceCodeCallForwarding(mSc)) {
            Rlog.d(LOG_TAG, "processCode: is CF");
            String dialingNumber = mSia;
            int reason = scToCallForwardReason(mSc);
            int serviceClass = siToServiceClass(mSib);
            int time = siToTime(mSic);
            if (isInterrogate()) {
                mPhone.getCallForwardingOption(reason, obtainMessage(EVENT_QUERY_CF_COMPLETE, this));
            } else {
                int cfAction;
                if (isActivate()) {
                    // number, or an activation if not
                    if (isEmptyOrNull(dialingNumber)) {
                        cfAction = CommandsInterface.CF_ACTION_ENABLE;
                        mIsCallFwdReg = false;
                    } else {
                        cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                        mIsCallFwdReg = true;
                    }
                } else if (isDeactivate()) {
                    cfAction = CommandsInterface.CF_ACTION_DISABLE;
                } else if (isRegister()) {
                    cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                } else if (isErasure()) {
                    cfAction = CommandsInterface.CF_ACTION_ERASURE;
                } else {
                    throw new RuntimeException("invalid action");
                }
                int isSettingUnconditional = ((reason == CommandsInterface.CF_REASON_UNCONDITIONAL) || (reason == CommandsInterface.CF_REASON_ALL)) ? 1 : 0;
                int isEnableDesired = ((cfAction == CommandsInterface.CF_ACTION_ENABLE) || (cfAction == CommandsInterface.CF_ACTION_REGISTRATION)) ? 1 : 0;
                Rlog.d(LOG_TAG, "processCode: is CF setCallForward");
                mPhone.setCallForwardingOption(cfAction, reason, dialingNumber, serviceClass, time, obtainMessage(EVENT_SET_CFF_COMPLETE, isSettingUnconditional, isEnableDesired, this));
            }
        } else if (isServiceCodeCallBarring(mSc)) {
            // sia = password
            // sib = basic service group
            // service group is not supported
            String password = mSia;
            String facility = scToBarringFacility(mSc);
            if (isInterrogate()) {
                mPhone.getCallBarring(facility, obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
            } else if (isActivate() || isDeactivate()) {
                mPhone.setCallBarring(facility, isActivate(), password, obtainMessage(EVENT_SET_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIR)) {
            // Only the UT interface handle is used.
            if (isActivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIR(CommandsInterface.CLIR_INVOCATION, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIR.");
                }
            } else if (isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIR(CommandsInterface.CLIR_SUPPRESSION, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIR.");
                }
            } else if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCLIR(obtainMessage(EVENT_GET_CLIR_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCLIR.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIP)) {
            // NOTE: Refer to the note above.
            if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCLIP(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCLIP.");
                }
            } else if (isActivate() || isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIP(isActivate(), obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIP.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_COLP)) {
            // NOTE: Refer to the note above.
            if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCOLP(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCOLP.");
                }
            } else if (isActivate() || isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLP(isActivate(), obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLP.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_COLR)) {
            // NOTE: Refer to the note above.
            if (isActivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLR(NUM_PRESENTATION_RESTRICTED, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLR.");
                }
            } else if (isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLR(NUM_PRESENTATION_ALLOWED, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLR.");
                }
            } else if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCOLR(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCOLR.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && (mSc.equals(SC_BS_MT))) {
            try {
                if (isInterrogate()) {
                    mPhone.mCT.getUtInterface().queryCallBarring(ImsUtInterface.CB_BS_MT, obtainMessage(EVENT_QUERY_ICB_COMPLETE, this));
                } else {
                    processIcbMmiCodeForUpdate();
                }
            // TODO: isRegister() case needs to be handled.
            } catch (ImsException e) {
                Rlog.d(LOG_TAG, "processCode: Could not get UT handle for ICB.");
            }
        } else if (mSc != null && mSc.equals(SC_BAICa)) {
            int callAction = 0;
            // TODO: Should we route through queryCallBarring() here?
            try {
                if (isInterrogate()) {
                    mPhone.mCT.getUtInterface().queryCallBarring(ImsUtInterface.CB_BIC_ACR, obtainMessage(EVENT_QUERY_ICB_COMPLETE, this));
                } else {
                    if (isActivate()) {
                        callAction = CommandsInterface.CF_ACTION_ENABLE;
                    } else if (isDeactivate()) {
                        callAction = CommandsInterface.CF_ACTION_DISABLE;
                    }
                    mPhone.mCT.getUtInterface().updateCallBarring(ImsUtInterface.CB_BIC_ACR, callAction, obtainMessage(EVENT_SET_COMPLETE, this), null);
                }
            } catch (ImsException e) {
                Rlog.d(LOG_TAG, "processCode: Could not get UT handle for ICBa.");
            }
        } else if (mSc != null && mSc.equals(SC_WAIT)) {
            // sia = basic service group
            int serviceClass = siToServiceClass(mSib);
            if (isActivate() || isDeactivate()) {
                mPhone.setCallWaiting(isActivate(), serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.getCallWaiting(obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mPoundString != null) {
            Rlog.d(LOG_TAG, "processCode: Sending pound string '" + mDialingNumber + "' over CS pipe.");
            throw new CallStateException(Phone.CS_FALLBACK);
        } else {
            Rlog.d(LOG_TAG, "processCode: invalid or unsupported MMI");
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        }
    } catch (RuntimeException exc) {
        mState = State.FAILED;
        mMessage = mContext.getText(com.android.internal.R.string.mmiError);
        Rlog.d(LOG_TAG, "processCode: RuntimeException = " + exc);
        mPhone.onMMIDone(this);
    }
}
#method_after
public void processCode() throws CallStateException {
    try {
        if (isShortCode()) {
            Rlog.d(LOG_TAG, "processCode: isShortCode");
            // These just get treated as USSD.
            Rlog.d(LOG_TAG, "processCode: Sending short code '" + mDialingNumber + "' over CS pipe.");
            throw new CallStateException(Phone.CS_FALLBACK);
        } else if (isServiceCodeCallForwarding(mSc)) {
            Rlog.d(LOG_TAG, "processCode: is CF");
            String dialingNumber = mSia;
            int reason = scToCallForwardReason(mSc);
            int serviceClass = siToServiceClass(mSib);
            int time = siToTime(mSic);
            if (isInterrogate()) {
                mPhone.getCallForwardingOption(reason, obtainMessage(EVENT_QUERY_CF_COMPLETE, this));
            } else {
                int cfAction;
                if (isActivate()) {
                    // number, or an activation if not
                    if (isEmptyOrNull(dialingNumber)) {
                        cfAction = CommandsInterface.CF_ACTION_ENABLE;
                        mIsCallFwdReg = false;
                    } else {
                        cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                        mIsCallFwdReg = true;
                    }
                } else if (isDeactivate()) {
                    cfAction = CommandsInterface.CF_ACTION_DISABLE;
                } else if (isRegister()) {
                    cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                } else if (isErasure()) {
                    cfAction = CommandsInterface.CF_ACTION_ERASURE;
                } else {
                    throw new RuntimeException("invalid action");
                }
                int isSettingUnconditional = ((reason == CommandsInterface.CF_REASON_UNCONDITIONAL) || (reason == CommandsInterface.CF_REASON_ALL)) ? 1 : 0;
                int isEnableDesired = ((cfAction == CommandsInterface.CF_ACTION_ENABLE) || (cfAction == CommandsInterface.CF_ACTION_REGISTRATION)) ? 1 : 0;
                Rlog.d(LOG_TAG, "processCode: is CF setCallForward");
                mPhone.setCallForwardingOption(cfAction, reason, dialingNumber, serviceClass, time, obtainMessage(EVENT_SET_CFF_COMPLETE, isSettingUnconditional, isEnableDesired, this));
            }
        } else if (isServiceCodeCallBarring(mSc)) {
            // sia = password
            // sib = basic service group
            // service group is not supported
            String password = mSia;
            String facility = scToBarringFacility(mSc);
            int serviceClass = siToServiceClass(mSib);
            if (isInterrogate()) {
                mPhone.getCallBarring(facility, obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this), serviceClass);
            } else if (isActivate() || isDeactivate()) {
                mPhone.setCallBarring(facility, isActivate(), password, obtainMessage(EVENT_SET_COMPLETE, this), serviceClass);
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIR)) {
            // Only the UT interface handle is used.
            if (isActivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIR(CommandsInterface.CLIR_INVOCATION, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIR.");
                }
            } else if (isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIR(CommandsInterface.CLIR_SUPPRESSION, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIR.");
                }
            } else if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCLIR(obtainMessage(EVENT_GET_CLIR_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCLIR.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIP)) {
            // NOTE: Refer to the note above.
            if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCLIP(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCLIP.");
                }
            } else if (isActivate() || isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIP(isActivate(), obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIP.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_COLP)) {
            // NOTE: Refer to the note above.
            if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCOLP(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCOLP.");
                }
            } else if (isActivate() || isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLP(isActivate(), obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLP.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_COLR)) {
            // NOTE: Refer to the note above.
            if (isActivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLR(NUM_PRESENTATION_RESTRICTED, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLR.");
                }
            } else if (isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLR(NUM_PRESENTATION_ALLOWED, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLR.");
                }
            } else if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCOLR(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCOLR.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && (mSc.equals(SC_BS_MT))) {
            try {
                if (isInterrogate()) {
                    mPhone.mCT.getUtInterface().queryCallBarring(ImsUtInterface.CB_BS_MT, obtainMessage(EVENT_QUERY_ICB_COMPLETE, this));
                } else {
                    processIcbMmiCodeForUpdate();
                }
            // TODO: isRegister() case needs to be handled.
            } catch (ImsException e) {
                Rlog.d(LOG_TAG, "processCode: Could not get UT handle for ICB.");
            }
        } else if (mSc != null && mSc.equals(SC_BAICa)) {
            int callAction = 0;
            // TODO: Should we route through queryCallBarring() here?
            try {
                if (isInterrogate()) {
                    mPhone.mCT.getUtInterface().queryCallBarring(ImsUtInterface.CB_BIC_ACR, obtainMessage(EVENT_QUERY_ICB_COMPLETE, this));
                } else {
                    if (isActivate()) {
                        callAction = CommandsInterface.CF_ACTION_ENABLE;
                    } else if (isDeactivate()) {
                        callAction = CommandsInterface.CF_ACTION_DISABLE;
                    }
                    mPhone.mCT.getUtInterface().updateCallBarring(ImsUtInterface.CB_BIC_ACR, callAction, obtainMessage(EVENT_SET_COMPLETE, this), null);
                }
            } catch (ImsException e) {
                Rlog.d(LOG_TAG, "processCode: Could not get UT handle for ICBa.");
            }
        } else if (mSc != null && mSc.equals(SC_WAIT)) {
            // sia = basic service group
            int serviceClass = siToServiceClass(mSib);
            if (isActivate() || isDeactivate()) {
                mPhone.setCallWaiting(isActivate(), serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.getCallWaiting(obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mPoundString != null) {
            Rlog.d(LOG_TAG, "processCode: Sending pound string '" + mDialingNumber + "' over CS pipe.");
            throw new CallStateException(Phone.CS_FALLBACK);
        } else {
            Rlog.d(LOG_TAG, "processCode: invalid or unsupported MMI");
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        }
    } catch (RuntimeException exc) {
        mState = State.FAILED;
        mMessage = mContext.getText(com.android.internal.R.string.mmiError);
        Rlog.d(LOG_TAG, "processCode: RuntimeException = " + exc);
        mPhone.onMMIDone(this);
    }
}
#end_block

#method_before
private void onQueryCfComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            sb.append(getImsErrorMessage(ar));
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        CallForwardInfo[] infos;
        infos = (CallForwardInfo[]) ar.result;
        if (infos.length == 0) {
            // Assume the default is not active
            sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
            // Set unconditional CFF in SIM to false
            if (mIccRecords != null) {
                mPhone.setVoiceCallForwardingFlag(1, false, null);
            }
        } else {
            SpannableStringBuilder tb = new SpannableStringBuilder();
            for (int serviceClassMask = 1; serviceClassMask <= SERVICE_CLASS_MAX; serviceClassMask <<= 1) {
                for (int i = 0, s = infos.length; i < s; i++) {
                    if ((serviceClassMask & infos[i].serviceClass) != 0) {
                        tb.append(makeCFQueryResultMessage(infos[i], serviceClassMask));
                        tb.append("\n");
                    }
                }
            }
            sb.append(tb);
        }
        mState = State.COMPLETE;
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onQueryCfComplete: mmi=" + this);
    mPhone.onMMIDone(this);
}
#method_after
private void onQueryCfComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            sb.append(getImsErrorMessage(ar));
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        CallForwardInfo[] infos;
        infos = (CallForwardInfo[]) ar.result;
        if (infos == null || infos.length == 0) {
            // Assume the default is not active
            sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
            // Set unconditional CFF in SIM to false
            if (mIccRecords != null) {
                mPhone.setVoiceCallForwardingFlag(1, false, null);
            }
        } else {
            SpannableStringBuilder tb = new SpannableStringBuilder();
            for (int serviceClassMask = 1; serviceClassMask <= SERVICE_CLASS_MAX; serviceClassMask <<= 1) {
                for (int i = 0, s = infos.length; i < s; i++) {
                    if ((serviceClassMask & infos[i].serviceClass) != 0) {
                        tb.append(makeCFQueryResultMessage(infos[i], serviceClassMask));
                        tb.append("\n");
                    }
                }
            }
            sb.append(tb);
        }
        mState = State.COMPLETE;
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onQueryCfComplete: mmi=" + this);
    mPhone.onMMIDone(this);
}
#end_block

#method_before
public void processImsSsData(AsyncResult data) {
    mIsSsInfo = true;
    try {
        ImsSsData ssData = (ImsSsData) data.result;
        parseSsData(ssData);
    } catch (ClassCastException ex) {
        Rlog.e(LOG_TAG, "Class Cast Exception in parsing SS Data : " + ex);
    } catch (NullPointerException ex) {
        Rlog.e(LOG_TAG, "Null Pointer Exception in parsing SS Data : " + ex);
    }
}
#method_after
public void processImsSsData(AsyncResult data) throws ImsException {
    try {
        ImsSsData ssData = (ImsSsData) data.result;
        parseSsData(ssData);
    } catch (ClassCastException | NullPointerException ex) {
        throw new ImsException("Exception in parsing SS Data", 0);
    }
}
#end_block

#method_before
void parseSsData(ImsSsData ssData) {
    ImsException ex = (ssData.mResult != RILConstants.SUCCESS) ? new ImsException(null, ssData.mResult) : null;
    mSc = getScStringFromScType(ssData.mServiceType);
    mAction = getActionStringFromReqType(ssData.mRequestType);
    Rlog.d(LOG_TAG, "parseSsData msc = " + mSc + ", action = " + mAction + ", ex = " + ex);
    switch(ssData.mRequestType) {
        case ImsSsData.SS_ACTIVATION:
        case ImsSsData.SS_DEACTIVATION:
        case ImsSsData.SS_REGISTRATION:
        case ImsSsData.SS_ERASURE:
            if ((ssData.mResult == RILConstants.SUCCESS) && ssData.isTypeUnConditional()) {
                /*
                     * When ServiceType is SS_CFU/SS_CF_ALL and RequestType is activate/register and
                     * ServiceClass is Voice/Video/None, set IccRecords.setVoiceCallForwardingFlag.
                     * Only CF status can be set here since number is not available.
                     */
                boolean cffEnabled = ((ssData.mRequestType == ImsSsData.SS_ACTIVATION || ssData.mRequestType == ImsSsData.SS_REGISTRATION) && isServiceClassVoiceVideoOrNone(ssData.mServiceClass));
                Rlog.d(LOG_TAG, "setCallForwardingFlag cffEnabled: " + cffEnabled);
                if (mIccRecords != null) {
                    Rlog.d(LOG_TAG, "setVoiceCallForwardingFlag done from SS Info.");
                    mPhone.setVoiceCallForwardingFlag(1, cffEnabled, null);
                } else {
                    Rlog.e(LOG_TAG, "setCallForwardingFlag aborted. sim records is null.");
                }
            }
            onSetComplete(null, new AsyncResult(null, ssData.mCfInfo, ex));
            break;
        case ImsSsData.SS_INTERROGATION:
            if (ssData.isTypeClir()) {
                Rlog.d(LOG_TAG, "CLIR INTERROGATION");
                Bundle clirInfo = new Bundle();
                clirInfo.putIntArray(UT_BUNDLE_KEY_CLIR, ssData.mSsInfo);
                onQueryClirComplete(new AsyncResult(null, clirInfo, ex));
            } else if (ssData.isTypeCF()) {
                Rlog.d(LOG_TAG, "CALL FORWARD INTERROGATION");
                onQueryCfComplete(new AsyncResult(null, mPhone.handleCfQueryResult(ssData.mCfInfo), ex));
            } else if (ssData.isTypeBarring()) {
                onSuppSvcQueryComplete(new AsyncResult(null, ssData.mSsInfo, ex));
            } else if (ssData.isTypeColr() || ssData.isTypeClip() || ssData.isTypeColp()) {
                ImsSsInfo ssInfo = new ImsSsInfo();
                ssInfo.mStatus = ssData.mSsInfo[0];
                Bundle clInfo = new Bundle();
                clInfo.putParcelable(UT_BUNDLE_KEY_SSINFO, ssInfo);
                onSuppSvcQueryComplete(new AsyncResult(null, clInfo, ex));
            } else if (ssData.isTypeIcb()) {
                onIcbQueryComplete(new AsyncResult(null, ssData.mImsSsInfo, ex));
            } else {
                onQueryComplete(new AsyncResult(null, ssData.mSsInfo, ex));
            }
            break;
        default:
            Rlog.e(LOG_TAG, "Invaid requestType in SSData : " + ssData.mRequestType);
            break;
    }
}
#method_after
void parseSsData(ImsSsData ssData) {
    ImsException ex = (ssData.result != RILConstants.SUCCESS) ? new ImsException(null, ssData.result) : null;
    mSc = getScStringFromScType(ssData.serviceType);
    mAction = getActionStringFromReqType(ssData.requestType);
    Rlog.d(LOG_TAG, "parseSsData msc = " + mSc + ", action = " + mAction + ", ex = " + ex);
    switch(ssData.requestType) {
        case ImsSsData.SS_ACTIVATION:
        case ImsSsData.SS_DEACTIVATION:
        case ImsSsData.SS_REGISTRATION:
        case ImsSsData.SS_ERASURE:
            if ((ssData.result == RILConstants.SUCCESS) && ssData.isTypeUnConditional()) {
                /*
                     * When ssData.serviceType is unconditional (SS_CFU or SS_CF_ALL) and
                     * ssData.requestType is activate/register and
                     * ServiceClass is Voice/Video/None, turn on voice call forwarding.
                     */
                boolean cffEnabled = ((ssData.requestType == ImsSsData.SS_ACTIVATION || ssData.requestType == ImsSsData.SS_REGISTRATION) && isServiceClassVoiceVideoOrNone(ssData.serviceClass));
                Rlog.d(LOG_TAG, "setCallForwardingFlag cffEnabled: " + cffEnabled);
                if (mIccRecords != null) {
                    Rlog.d(LOG_TAG, "setVoiceCallForwardingFlag done from SS Info.");
                    // Only CF status is set here as part of activation/registration,
                    // number is not available until interrogation.
                    mPhone.setVoiceCallForwardingFlag(1, cffEnabled, null);
                } else {
                    Rlog.e(LOG_TAG, "setCallForwardingFlag aborted. sim records is null.");
                }
            }
            onSetComplete(null, new AsyncResult(null, ssData.cfInfo, ex));
            break;
        case ImsSsData.SS_INTERROGATION:
            if (ssData.isTypeClir()) {
                Rlog.d(LOG_TAG, "CLIR INTERROGATION");
                Bundle clirInfo = new Bundle();
                clirInfo.putIntArray(UT_BUNDLE_KEY_CLIR, ssData.ssInfo);
                onQueryClirComplete(new AsyncResult(null, clirInfo, ex));
            } else if (ssData.isTypeCF()) {
                Rlog.d(LOG_TAG, "CALL FORWARD INTERROGATION");
                onQueryCfComplete(new AsyncResult(null, mPhone.handleCfQueryResult(ssData.cfInfo), ex));
            } else if (ssData.isTypeBarring()) {
                onSuppSvcQueryComplete(new AsyncResult(null, ssData.ssInfo, ex));
            } else if (ssData.isTypeColr() || ssData.isTypeClip() || ssData.isTypeColp()) {
                ImsSsInfo ssInfo = new ImsSsInfo();
                ssInfo.mStatus = ssData.ssInfo[0];
                Bundle clInfo = new Bundle();
                clInfo.putParcelable(UT_BUNDLE_KEY_SSINFO, ssInfo);
                onSuppSvcQueryComplete(new AsyncResult(null, clInfo, ex));
            } else if (ssData.isTypeIcb()) {
                onIcbQueryComplete(new AsyncResult(null, ssData.imsSsInfo, ex));
            } else {
                onQueryComplete(new AsyncResult(null, ssData.ssInfo, ex));
            }
            break;
        default:
            Rlog.e(LOG_TAG, "Invaid requestType in SSData : " + ssData.requestType);
            break;
    }
}
#end_block

#method_before
void setServiceState(int state) {
    mSS.setVoiceRegState(state);
    updateDataServiceState();
}
#method_after
@VisibleForTesting
public void setServiceState(int state) {
    boolean isVoiceRegStateChanged = false;
    synchronized (this) {
        isVoiceRegStateChanged = mSS.getVoiceRegState() != state;
        mSS.setVoiceRegState(state);
    }
    updateDataServiceState();
    if (isVoiceRegStateChanged) {
        if (mDefaultPhone.getServiceStateTracker() != null) {
            mDefaultPhone.getServiceStateTracker().onImsServiceStateChanged();
        }
    }
}
#end_block

#method_before
public void setCallForwardingOption(int commandInterfaceCFAction, int commandInterfaceCFReason, String dialingNumber, int serviceClass, int timerSeconds, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "setCallForwardingOption action=" + commandInterfaceCFAction + ", reason=" + commandInterfaceCFReason + " serviceClass=" + serviceClass);
    if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) && (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
        Message resp;
        Cf cf = new Cf(dialingNumber, (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL ? true : false), onComplete);
        resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE, isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cf);
        try {
            ImsUtInterface ut = mCT.getUtInterface();
            ut.updateCallForward(getActionFromCFAction(commandInterfaceCFAction), getConditionFromCFReason(commandInterfaceCFReason), dialingNumber, serviceClass, timerSeconds, resp);
        } catch (ImsException e) {
            sendErrorResponse(onComplete, e);
        }
    } else if (onComplete != null) {
        sendErrorResponse(onComplete);
    }
}
#method_after
public void setCallForwardingOption(int commandInterfaceCFAction, int commandInterfaceCFReason, String dialingNumber, int serviceClass, int timerSeconds, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "setCallForwardingOption action=" + commandInterfaceCFAction + ", reason=" + commandInterfaceCFReason + " serviceClass=" + serviceClass);
    if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) && (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
        Message resp;
        Cf cf = new Cf(dialingNumber, GsmMmiCode.isVoiceUnconditionalForwarding(commandInterfaceCFReason, serviceClass), onComplete);
        resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE, isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cf);
        try {
            ImsUtInterface ut = mCT.getUtInterface();
            ut.updateCallForward(getActionFromCFAction(commandInterfaceCFAction), getConditionFromCFReason(commandInterfaceCFReason), dialingNumber, serviceClass, timerSeconds, resp);
        } catch (ImsException e) {
            sendErrorResponse(onComplete, e);
        }
    } else if (onComplete != null) {
        sendErrorResponse(onComplete);
    }
}
#end_block

#method_before
public void getCallBarring(String facility, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "getCallBarring facility=" + facility);
    Message resp;
    resp = obtainMessage(EVENT_GET_CALL_BARRING_DONE, onComplete);
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        ut.queryCallBarring(getCBTypeFromFacility(facility), resp);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void getCallBarring(String facility, Message onComplete) {
    getCallBarring(facility, onComplete, CommandsInterface.SERVICE_CLASS_NONE);
}
#end_block

#method_before
public void getCallBarring(String facility, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "getCallBarring facility=" + facility);
    Message resp;
    resp = obtainMessage(EVENT_GET_CALL_BARRING_DONE, onComplete);
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        ut.queryCallBarring(getCBTypeFromFacility(facility), resp);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void getCallBarring(String facility, Message onComplete, int serviceClass) {
    if (DBG) {
        Rlog.d(LOG_TAG, "getCallBarring facility=" + facility + ", serviceClass = " + serviceClass);
    }
    Message resp;
    resp = obtainMessage(EVENT_GET_CALL_BARRING_DONE, onComplete);
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        ut.queryCallBarring(getCBTypeFromFacility(facility), resp, serviceClass);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#end_block

#method_before
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "setCallBarring facility=" + facility + ", lockState=" + lockState);
    Message resp;
    resp = obtainMessage(EVENT_SET_CALL_BARRING_DONE, onComplete);
    int action;
    if (lockState) {
        action = CommandsInterface.CF_ACTION_ENABLE;
    } else {
        action = CommandsInterface.CF_ACTION_DISABLE;
    }
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        // password is not required with Ut interface
        ut.updateCallBarring(getCBTypeFromFacility(facility), action, resp, null);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete) {
    setCallBarring(facility, lockState, password, onComplete, CommandsInterface.SERVICE_CLASS_NONE);
}
#end_block

#method_before
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "setCallBarring facility=" + facility + ", lockState=" + lockState);
    Message resp;
    resp = obtainMessage(EVENT_SET_CALL_BARRING_DONE, onComplete);
    int action;
    if (lockState) {
        action = CommandsInterface.CF_ACTION_ENABLE;
    } else {
        action = CommandsInterface.CF_ACTION_DISABLE;
    }
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        // password is not required with Ut interface
        ut.updateCallBarring(getCBTypeFromFacility(facility), action, resp, null);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete, int serviceClass) {
    if (DBG) {
        Rlog.d(LOG_TAG, "setCallBarring facility=" + facility + ", lockState=" + lockState + ", serviceClass = " + serviceClass);
    }
    Message resp;
    resp = obtainMessage(EVENT_SET_CALL_BARRING_DONE, onComplete);
    int action;
    if (lockState) {
        action = CommandsInterface.CF_ACTION_ENABLE;
    } else {
        action = CommandsInterface.CF_ACTION_DISABLE;
    }
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        // password is not required with Ut interface
        ut.updateCallBarring(getCBTypeFromFacility(facility), action, resp, null, serviceClass);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#end_block

#method_before
private void handleExitEmergencyCallbackMode() {
    if (DBG) {
        Rlog.d(LOG_TAG, "handleExitEmergencyCallbackMode: mIsPhoneInEcmState = " + isInEcm());
    }
    if (isInEcm()) {
        setIsInEcm(false);
    }
    // Remove pending exit Ecm runnable, if any
    removeCallbacks(mExitEcmRunnable);
    if (mEcmExitRespRegistrant != null) {
        mEcmExitRespRegistrant.notifyResult(Boolean.TRUE);
    }
    // release wakeLock
    if (mWakeLock.isHeld()) {
        mWakeLock.release();
    }
    // send an Intent
    sendEmergencyCallbackModeChange();
}
#method_after
@Override
protected void handleExitEmergencyCallbackMode() {
    if (DBG) {
        Rlog.d(LOG_TAG, "handleExitEmergencyCallbackMode: mIsPhoneInEcmState = " + isInEcm());
    }
    if (isInEcm()) {
        setIsInEcm(false);
    }
    // Remove pending exit Ecm runnable, if any
    removeCallbacks(mExitEcmRunnable);
    if (mEcmExitRespRegistrant != null) {
        mEcmExitRespRegistrant.notifyResult(Boolean.TRUE);
    }
    // release wakeLock
    if (mWakeLock.isHeld()) {
        mWakeLock.release();
    }
    // send an Intent
    sendEmergencyCallbackModeChange();
    ((GsmCdmaPhone) mDefaultPhone).notifyEmergencyCallRegistrants(false);
}
#end_block

#method_before
// Processes an IMS disconnect cause for possible WFC registration errors and optionally
private void processWfcDisconnectForNotification(ImsReasonInfo imsReasonInfo) {
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        Rlog.e(LOG_TAG, "processDisconnectReason: CarrierConfigManager is not ready");
        return;
    }
    PersistableBundle pb = configManager.getConfigForSubId(getSubId());
    if (pb == null) {
        Rlog.e(LOG_TAG, "processDisconnectReason: no config for subId " + getSubId());
        return;
    }
    final String[] wfcOperatorErrorCodes = pb.getStringArray(CarrierConfigManager.KEY_WFC_OPERATOR_ERROR_CODES_STRING_ARRAY);
    if (wfcOperatorErrorCodes == null) {
        // no operator-specific error codes
        return;
    }
    final String[] wfcOperatorErrorAlertMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorAlertMessages);
    final String[] wfcOperatorErrorNotificationMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorNotificationMessages);
    for (int i = 0; i < wfcOperatorErrorCodes.length; i++) {
        String[] codes = wfcOperatorErrorCodes[i].split("\\|");
        if (codes.length != 2) {
            Rlog.e(LOG_TAG, "Invalid carrier config: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        // Match error code.
        if (!imsReasonInfo.mExtraMessage.startsWith(codes[0])) {
            continue;
        }
        // If there is no delimiter at the end of error code string
        // then we need to verify that we are not matching partial code.
        // EXAMPLE: "REG9" must not match "REG99".
        // NOTE: Error code must not be empty.
        int codeStringLength = codes[0].length();
        char lastChar = codes[0].charAt(codeStringLength - 1);
        if (Character.isLetterOrDigit(lastChar)) {
            if (imsReasonInfo.mExtraMessage.length() > codeStringLength) {
                char nextChar = imsReasonInfo.mExtraMessage.charAt(codeStringLength);
                if (Character.isLetterOrDigit(nextChar)) {
                    continue;
                }
            }
        }
        final CharSequence title = mContext.getText(com.android.internal.R.string.wfcRegErrorTitle);
        int idx = Integer.parseInt(codes[1]);
        if (idx < 0 || idx >= wfcOperatorErrorAlertMessages.length || idx >= wfcOperatorErrorNotificationMessages.length) {
            Rlog.e(LOG_TAG, "Invalid index: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        CharSequence messageAlert = imsReasonInfo.mExtraMessage;
        CharSequence messageNotification = imsReasonInfo.mExtraMessage;
        if (!wfcOperatorErrorAlertMessages[idx].isEmpty()) {
            messageAlert = wfcOperatorErrorAlertMessages[idx];
        }
        if (!wfcOperatorErrorNotificationMessages[idx].isEmpty()) {
            messageNotification = wfcOperatorErrorNotificationMessages[idx];
        }
        // UX requirement is to disable WFC in case of "permanent" registration failures.
        ImsManager.setWfcSetting(mContext, false);
        // If WfcSettings are active then alert will be shown
        // otherwise notification will be added.
        Intent intent = new Intent(ImsManager.ACTION_IMS_REGISTRATION_ERROR);
        intent.putExtra(EXTRA_KEY_ALERT_TITLE, title);
        intent.putExtra(EXTRA_KEY_ALERT_MESSAGE, messageAlert);
        intent.putExtra(EXTRA_KEY_NOTIFICATION_MESSAGE, messageNotification);
        mContext.sendOrderedBroadcast(intent, null, mResultReceiver, null, Activity.RESULT_OK, null, null);
        // so should break the loop after a successful match.
        break;
    }
}
#method_after
// Processes an IMS disconnect cause for possible WFC registration errors and optionally
private void processWfcDisconnectForNotification(ImsReasonInfo imsReasonInfo) {
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        Rlog.e(LOG_TAG, "processDisconnectReason: CarrierConfigManager is not ready");
        return;
    }
    PersistableBundle pb = configManager.getConfigForSubId(getSubId());
    if (pb == null) {
        Rlog.e(LOG_TAG, "processDisconnectReason: no config for subId " + getSubId());
        return;
    }
    final String[] wfcOperatorErrorCodes = pb.getStringArray(CarrierConfigManager.KEY_WFC_OPERATOR_ERROR_CODES_STRING_ARRAY);
    if (wfcOperatorErrorCodes == null) {
        // no operator-specific error codes
        return;
    }
    final String[] wfcOperatorErrorAlertMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorAlertMessages);
    final String[] wfcOperatorErrorNotificationMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorNotificationMessages);
    for (int i = 0; i < wfcOperatorErrorCodes.length; i++) {
        String[] codes = wfcOperatorErrorCodes[i].split("\\|");
        if (codes.length != 2) {
            Rlog.e(LOG_TAG, "Invalid carrier config: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        // Match error code.
        if (!imsReasonInfo.mExtraMessage.startsWith(codes[0])) {
            continue;
        }
        // If there is no delimiter at the end of error code string
        // then we need to verify that we are not matching partial code.
        // EXAMPLE: "REG9" must not match "REG99".
        // NOTE: Error code must not be empty.
        int codeStringLength = codes[0].length();
        char lastChar = codes[0].charAt(codeStringLength - 1);
        if (Character.isLetterOrDigit(lastChar)) {
            if (imsReasonInfo.mExtraMessage.length() > codeStringLength) {
                char nextChar = imsReasonInfo.mExtraMessage.charAt(codeStringLength);
                if (Character.isLetterOrDigit(nextChar)) {
                    continue;
                }
            }
        }
        final CharSequence title = mContext.getText(com.android.internal.R.string.wfcRegErrorTitle);
        int idx = Integer.parseInt(codes[1]);
        if (idx < 0 || idx >= wfcOperatorErrorAlertMessages.length || idx >= wfcOperatorErrorNotificationMessages.length) {
            Rlog.e(LOG_TAG, "Invalid index: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        String messageAlert = imsReasonInfo.mExtraMessage;
        String messageNotification = imsReasonInfo.mExtraMessage;
        if (!wfcOperatorErrorAlertMessages[idx].isEmpty()) {
            messageAlert = String.format(wfcOperatorErrorAlertMessages[idx], // Fill IMS error code into alert message
            imsReasonInfo.mExtraMessage);
        }
        if (!wfcOperatorErrorNotificationMessages[idx].isEmpty()) {
            messageNotification = String.format(wfcOperatorErrorNotificationMessages[idx], // Fill IMS error code into notification
            imsReasonInfo.mExtraMessage);
        }
        // UX requirement is to disable WFC in case of "permanent" registration failures.
        ImsManager.setWfcSetting(mContext, false);
        // If WfcSettings are active then alert will be shown
        // otherwise notification will be added.
        Intent intent = new Intent(ImsManager.ACTION_IMS_REGISTRATION_ERROR);
        intent.putExtra(EXTRA_KEY_ALERT_TITLE, title);
        intent.putExtra(EXTRA_KEY_ALERT_MESSAGE, messageAlert);
        intent.putExtra(EXTRA_KEY_NOTIFICATION_MESSAGE, messageNotification);
        mContext.sendOrderedBroadcast(intent, null, mResultReceiver, null, Activity.RESULT_OK, null, null);
        // so should break the loop after a successful match.
        break;
    }
}
#end_block

#method_before
private void startListeningForCalls() throws ImsException {
    mImsServiceRetryCount = 0;
    mServiceId = mImsManager.open(ImsServiceClass.MMTEL, createIncomingCallPendingIntent(), mImsConnectionStateListener);
    mImsManager.setImsConfigListener(mImsConfigListener);
    // Get the ECBM interface and set IMSPhone's listener object for notifications
    getEcbmInterface().setEcbmStateListener(mPhone.getImsEcbmStateListener());
    if (mPhone.isInEcm()) {
        // Call exit ECBM which will invoke onECBMExited
        mPhone.exitEmergencyCallbackMode();
    }
    int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
    mImsManager.setUiTTYMode(mPhone.getContext(), mPreferredTtyMode, null);
    ImsMultiEndpoint multiEndpoint = getMultiEndpointInterface();
    if (multiEndpoint != null) {
        multiEndpoint.setExternalCallStateListener(mPhone.getExternalCallTracker().getExternalCallStateListener());
    }
    // Set UT interface listener to receive UT indications.
    mUtInterface = getUtInterface();
    mUtInterface.setSuppServiceIndication(this, EVENT_SUPP_SERVICE_INDICATION, null);
    if (mCarrierConfigLoaded) {
        ImsManager.updateImsServiceConfig(mPhone.getContext(), mPhone.getPhoneId(), true);
    }
}
#method_after
private void startListeningForCalls() throws ImsException {
    mImsServiceRetryCount = 0;
    mServiceId = mImsManager.open(ImsServiceClass.MMTEL, createIncomingCallPendingIntent(), mImsConnectionStateListener);
    mImsManager.setImsConfigListener(mImsConfigListener);
    // Get the ECBM interface and set IMSPhone's listener object for notifications
    getEcbmInterface().setEcbmStateListener(mPhone.getImsEcbmStateListener());
    if (mPhone.isInEcm()) {
        // Call exit ECBM which will invoke onECBMExited
        mPhone.exitEmergencyCallbackMode();
    }
    int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
    mImsManager.setUiTTYMode(mPhone.getContext(), mPreferredTtyMode, null);
    ImsMultiEndpoint multiEndpoint = getMultiEndpointInterface();
    if (multiEndpoint != null) {
        multiEndpoint.setExternalCallStateListener(mPhone.getExternalCallTracker().getExternalCallStateListener());
    }
    // Set UT interface listener to receive UT indications.
    mUtInterface = getUtInterface();
    if (mUtInterface != null) {
        mUtInterface.registerForSuppServiceIndication(this, EVENT_SUPP_SERVICE_INDICATION, null);
    }
    if (mCarrierConfigLoaded) {
        ImsManager.updateImsServiceConfig(mPhone.getContext(), mPhone.getPhoneId(), true);
    }
}
#end_block

#method_before
public void dispose() {
    if (DBG)
        log("dispose");
    mRingingCall.dispose();
    mBackgroundCall.dispose();
    mForegroundCall.dispose();
    mHandoverCall.dispose();
    clearDisconnected();
    if (mUtInterface != null) {
        mUtInterface.unSetSuppServiceIndication(this);
    }
    mPhone.getContext().unregisterReceiver(mReceiver);
    mPhone.getDefaultPhone().unregisterForDataEnabledChanged(this);
    removeMessages(EVENT_GET_IMS_SERVICE);
}
#method_after
public void dispose() {
    if (DBG)
        log("dispose");
    mRingingCall.dispose();
    mBackgroundCall.dispose();
    mForegroundCall.dispose();
    mHandoverCall.dispose();
    clearDisconnected();
    if (mUtInterface != null) {
        mUtInterface.unregisterForSuppServiceIndication(this);
    }
    mPhone.getContext().unregisterReceiver(mReceiver);
    mPhone.getDefaultPhone().unregisterForDataEnabledChanged(this);
    removeMessages(EVENT_GET_IMS_SERVICE);
}
#end_block

#method_before
synchronized Connection dial(String dialString, int clirMode, int videoState, Bundle intentExtras) throws CallStateException {
    boolean isPhoneInEcmMode = isPhoneInEcbMode();
    boolean isEmergencyNumber = PhoneNumberUtils.isEmergencyNumber(dialString);
    if (DBG)
        log("dial clirMode=" + clirMode);
    // note that this triggers call state changed notif
    clearDisconnected();
    if (mImsManager == null) {
        throw new CallStateException("service not available");
    }
    if (!canDial()) {
        throw new CallStateException("cannot dial in current state");
    }
    if (isPhoneInEcmMode && isEmergencyNumber) {
        handleEcmTimer(ImsPhone.CANCEL_ECM_TIMER);
    }
    // calls, dial as an audio-only call.
    if (isEmergencyNumber && VideoProfile.isVideo(videoState) && !mAllowEmergencyVideoCalls) {
        loge("dial: carrier does not support video emergency calls; downgrade to audio-only");
        videoState = VideoProfile.STATE_AUDIO_ONLY;
    }
    boolean holdBeforeDial = false;
    // there on hold
    if (mForegroundCall.getState() == ImsPhoneCall.State.ACTIVE) {
        if (mBackgroundCall.getState() != ImsPhoneCall.State.IDLE) {
            // we should have failed in !canDial() above before we get here
            throw new CallStateException("cannot dial in current state");
        }
        // foreground call is empty for the newly dialed connection
        holdBeforeDial = true;
        // Cache the video state for pending MO call.
        mPendingCallVideoState = videoState;
        mPendingIntentExtras = intentExtras;
        switchWaitingOrHoldingAndActive();
    }
    ImsPhoneCall.State fgState = ImsPhoneCall.State.IDLE;
    ImsPhoneCall.State bgState = ImsPhoneCall.State.IDLE;
    mClirMode = clirMode;
    synchronized (mSyncHold) {
        if (holdBeforeDial) {
            fgState = mForegroundCall.getState();
            bgState = mBackgroundCall.getState();
            // holding foreground call failed
            if (fgState == ImsPhoneCall.State.ACTIVE) {
                throw new CallStateException("cannot dial in current state");
            }
            // holding foreground call succeeded
            if (bgState == ImsPhoneCall.State.HOLDING) {
                holdBeforeDial = false;
            }
        }
        mPendingMO = new ImsPhoneConnection(mPhone, checkForTestEmergencyNumber(dialString), this, mForegroundCall, isEmergencyNumber);
        mPendingMO.setVideoState(videoState);
    }
    addConnection(mPendingMO);
    if (!holdBeforeDial) {
        if ((!isPhoneInEcmMode) || (isPhoneInEcmMode && isEmergencyNumber)) {
            dialInternal(mPendingMO, clirMode, videoState, intentExtras);
        } else {
            try {
                getEcbmInterface().exitEmergencyCallbackMode();
            } catch (ImsException e) {
                e.printStackTrace();
                throw new CallStateException("service not available");
            }
            mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
            pendingCallClirMode = clirMode;
            mPendingCallVideoState = videoState;
            pendingCallInEcm = true;
        }
    }
    updatePhoneState();
    mPhone.notifyPreciseCallStateChanged();
    return mPendingMO;
}
#method_after
synchronized Connection dial(String dialString, int clirMode, int videoState, Bundle intentExtras) throws CallStateException {
    boolean isPhoneInEcmMode = isPhoneInEcbMode();
    boolean isEmergencyNumber = mPhoneNumberUtilsProxy.isEmergencyNumber(dialString);
    if (DBG)
        log("dial clirMode=" + clirMode);
    if (isEmergencyNumber) {
        clirMode = CommandsInterface.CLIR_SUPPRESSION;
        if (DBG)
            log("dial emergency call, set clirModIe=" + clirMode);
    }
    // note that this triggers call state changed notif
    clearDisconnected();
    if (mImsManager == null) {
        throw new CallStateException("service not available");
    }
    if (!canDial()) {
        throw new CallStateException("cannot dial in current state");
    }
    if (isPhoneInEcmMode && isEmergencyNumber) {
        handleEcmTimer(ImsPhone.CANCEL_ECM_TIMER);
    }
    // calls, dial as an audio-only call.
    if (isEmergencyNumber && VideoProfile.isVideo(videoState) && !mAllowEmergencyVideoCalls) {
        loge("dial: carrier does not support video emergency calls; downgrade to audio-only");
        videoState = VideoProfile.STATE_AUDIO_ONLY;
    }
    boolean holdBeforeDial = false;
    // there on hold
    if (mForegroundCall.getState() == ImsPhoneCall.State.ACTIVE) {
        if (mBackgroundCall.getState() != ImsPhoneCall.State.IDLE) {
            // we should have failed in !canDial() above before we get here
            throw new CallStateException("cannot dial in current state");
        }
        // foreground call is empty for the newly dialed connection
        holdBeforeDial = true;
        // Cache the video state for pending MO call.
        mPendingCallVideoState = videoState;
        mPendingIntentExtras = intentExtras;
        switchWaitingOrHoldingAndActive();
    }
    ImsPhoneCall.State fgState = ImsPhoneCall.State.IDLE;
    ImsPhoneCall.State bgState = ImsPhoneCall.State.IDLE;
    mClirMode = clirMode;
    synchronized (mSyncHold) {
        if (holdBeforeDial) {
            fgState = mForegroundCall.getState();
            bgState = mBackgroundCall.getState();
            // holding foreground call failed
            if (fgState == ImsPhoneCall.State.ACTIVE) {
                throw new CallStateException("cannot dial in current state");
            }
            // holding foreground call succeeded
            if (bgState == ImsPhoneCall.State.HOLDING) {
                holdBeforeDial = false;
            }
        }
        mPendingMO = new ImsPhoneConnection(mPhone, checkForTestEmergencyNumber(dialString), this, mForegroundCall, isEmergencyNumber);
        mPendingMO.setVideoState(videoState);
    }
    addConnection(mPendingMO);
    if (!holdBeforeDial) {
        if ((!isPhoneInEcmMode) || (isPhoneInEcmMode && isEmergencyNumber)) {
            dialInternal(mPendingMO, clirMode, videoState, intentExtras);
        } else {
            try {
                getEcbmInterface().exitEmergencyCallbackMode();
            } catch (ImsException e) {
                e.printStackTrace();
                throw new CallStateException("service not available");
            }
            mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
            pendingCallClirMode = clirMode;
            mPendingCallVideoState = videoState;
            pendingCallInEcm = true;
        }
    }
    updatePhoneState();
    mPhone.notifyPreciseCallStateChanged();
    return mPendingMO;
}
#end_block

#method_before
boolean isImsServiceReady() {
    if (mImsManager == null) {
        return false;
    }
    return mImsManager.isServiceAvailable();
}
#method_after
boolean isImsServiceReady() {
    if (mImsManager == null) {
        return false;
    }
    return mImsManager.isServiceReady();
}
#end_block

#method_before
private void dialInternal(ImsPhoneConnection conn, int clirMode, int videoState, Bundle intentExtras) {
    if (conn == null) {
        return;
    }
    if (conn.getAddress() == null || conn.getAddress().length() == 0 || conn.getAddress().indexOf(PhoneNumberUtils.WILD) >= 0) {
        // Phone number is invalid
        conn.setDisconnectCause(DisconnectCause.INVALID_NUMBER);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        return;
    }
    // Always unmute when initiating a new call
    setMute(false);
    int serviceType = PhoneNumberUtils.isEmergencyNumber(conn.getAddress()) ? ImsCallProfile.SERVICE_TYPE_EMERGENCY : ImsCallProfile.SERVICE_TYPE_NORMAL;
    int callType = ImsCallProfile.getCallTypeFromVideoState(videoState);
    // TODO(vt): Is this sufficient?  At what point do we know the video state of the call?
    conn.setVideoState(videoState);
    try {
        String[] callees = new String[] { conn.getAddress() };
        ImsCallProfile profile = mImsManager.createCallProfile(mServiceId, serviceType, callType);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_OIR, clirMode);
        // ImsCallProfile key.
        if (intentExtras != null) {
            if (intentExtras.containsKey(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)) {
                intentExtras.putString(ImsCallProfile.EXTRA_DISPLAY_TEXT, cleanseInstantLetteringMessage(intentExtras.getString(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)));
            }
            if (intentExtras.containsKey(ImsCallProfile.EXTRA_IS_CALL_PULL)) {
                profile.mCallExtras.putBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL, intentExtras.getBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL));
                int dialogId = intentExtras.getInt(ImsExternalCallTracker.EXTRA_IMS_EXTERNAL_CALL_ID);
                conn.setIsPulledCall(true);
                conn.setPulledDialogId(dialogId);
            }
            // Pack the OEM-specific call extras.
            profile.mCallExtras.putBundle(ImsCallProfile.EXTRA_OEM_EXTRAS, intentExtras);
        // NOTE: Extras to be sent over the network are packed into the
        // intentExtras individually, with uniquely defined keys.
        // These key-value pairs are processed by IMS Service before
        // being sent to the lower layers/to the network.
        }
        ImsCall imsCall = mImsManager.makeCall(mServiceId, profile, callees, mImsCallListener);
        conn.setImsCall(imsCall);
        mMetrics.writeOnImsCallStart(mPhone.getPhoneId(), imsCall.getSession());
        setVideoCallProvider(conn, imsCall);
        conn.setAllowAddCallDuringVideoCall(mAllowAddCallDuringVideoCall);
    } catch (ImsException e) {
        loge("dialInternal : " + e);
        conn.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        retryGetImsService();
    } catch (RemoteException e) {
    }
}
#method_after
private void dialInternal(ImsPhoneConnection conn, int clirMode, int videoState, Bundle intentExtras) {
    if (conn == null) {
        return;
    }
    if (conn.getAddress() == null || conn.getAddress().length() == 0 || conn.getAddress().indexOf(PhoneNumberUtils.WILD) >= 0) {
        // Phone number is invalid
        conn.setDisconnectCause(DisconnectCause.INVALID_NUMBER);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        return;
    }
    // Always unmute when initiating a new call
    setMute(false);
    int serviceType = mPhoneNumberUtilsProxy.isEmergencyNumber(conn.getAddress()) ? ImsCallProfile.SERVICE_TYPE_EMERGENCY : ImsCallProfile.SERVICE_TYPE_NORMAL;
    int callType = ImsCallProfile.getCallTypeFromVideoState(videoState);
    // TODO(vt): Is this sufficient?  At what point do we know the video state of the call?
    conn.setVideoState(videoState);
    try {
        String[] callees = new String[] { conn.getAddress() };
        ImsCallProfile profile = mImsManager.createCallProfile(mServiceId, serviceType, callType);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_OIR, clirMode);
        // ImsCallProfile key.
        if (intentExtras != null) {
            if (intentExtras.containsKey(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)) {
                intentExtras.putString(ImsCallProfile.EXTRA_DISPLAY_TEXT, cleanseInstantLetteringMessage(intentExtras.getString(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)));
            }
            if (intentExtras.containsKey(ImsCallProfile.EXTRA_IS_CALL_PULL)) {
                profile.mCallExtras.putBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL, intentExtras.getBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL));
                int dialogId = intentExtras.getInt(ImsExternalCallTracker.EXTRA_IMS_EXTERNAL_CALL_ID);
                conn.setIsPulledCall(true);
                conn.setPulledDialogId(dialogId);
            }
            // Pack the OEM-specific call extras.
            profile.mCallExtras.putBundle(ImsCallProfile.EXTRA_OEM_EXTRAS, intentExtras);
        // NOTE: Extras to be sent over the network are packed into the
        // intentExtras individually, with uniquely defined keys.
        // These key-value pairs are processed by IMS Service before
        // being sent to the lower layers/to the network.
        }
        ImsCall imsCall = mImsManager.makeCall(mServiceId, profile, callees, mImsCallListener);
        conn.setImsCall(imsCall);
        mMetrics.writeOnImsCallStart(mPhone.getPhoneId(), imsCall.getSession());
        setVideoCallProvider(conn, imsCall);
        conn.setAllowAddCallDuringVideoCall(mAllowAddCallDuringVideoCall);
    } catch (ImsException e) {
        loge("dialInternal : " + e);
        conn.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        retryGetImsService();
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
public void conference() {
    if (DBG)
        log("conference");
    ImsCall fgImsCall = mForegroundCall.getImsCall();
    if (fgImsCall == null) {
        log("conference no foreground ims call");
        return;
    }
    ImsCall bgImsCall = mBackgroundCall.getImsCall();
    if (bgImsCall == null) {
        log("conference no background ims call");
        return;
    }
    // Keep track of the connect time of the earliest call so that it can be set on the
    // {@code ImsConference} when it is created.
    long foregroundConnectTime = mForegroundCall.getEarliestConnectTime();
    long backgroundConnectTime = mBackgroundCall.getEarliestConnectTime();
    long conferenceConnectTime;
    if (foregroundConnectTime > 0 && backgroundConnectTime > 0) {
        conferenceConnectTime = Math.min(mForegroundCall.getEarliestConnectTime(), mBackgroundCall.getEarliestConnectTime());
        log("conference - using connect time = " + conferenceConnectTime);
    } else if (foregroundConnectTime > 0) {
        log("conference - bg call connect time is 0; using fg = " + foregroundConnectTime);
        conferenceConnectTime = foregroundConnectTime;
    } else {
        log("conference - fg call connect time is 0; using bg = " + backgroundConnectTime);
        conferenceConnectTime = backgroundConnectTime;
    }
    ImsPhoneConnection foregroundConnection = mForegroundCall.getFirstConnection();
    if (foregroundConnection != null) {
        foregroundConnection.setConferenceConnectTime(conferenceConnectTime);
        foregroundConnection.onConnectionEvent(android.telecom.Connection.EVENT_MERGE_START, null);
    }
    ImsPhoneConnection backgroundConnection = findConnection(bgImsCall);
    if (backgroundConnection != null) {
        backgroundConnection.onConnectionEvent(android.telecom.Connection.EVENT_MERGE_START, null);
    }
    try {
        fgImsCall.merge(bgImsCall);
    } catch (ImsException e) {
        log("conference " + e.getMessage());
    }
}
#method_after
public void conference() {
    ImsCall fgImsCall = mForegroundCall.getImsCall();
    if (fgImsCall == null) {
        log("conference no foreground ims call");
        return;
    }
    ImsCall bgImsCall = mBackgroundCall.getImsCall();
    if (bgImsCall == null) {
        log("conference no background ims call");
        return;
    }
    if (fgImsCall.isCallSessionMergePending()) {
        log("conference: skip; foreground call already in process of merging.");
        return;
    }
    if (bgImsCall.isCallSessionMergePending()) {
        log("conference: skip; background call already in process of merging.");
        return;
    }
    // Keep track of the connect time of the earliest call so that it can be set on the
    // {@code ImsConference} when it is created.
    long foregroundConnectTime = mForegroundCall.getEarliestConnectTime();
    long backgroundConnectTime = mBackgroundCall.getEarliestConnectTime();
    long conferenceConnectTime;
    if (foregroundConnectTime > 0 && backgroundConnectTime > 0) {
        conferenceConnectTime = Math.min(mForegroundCall.getEarliestConnectTime(), mBackgroundCall.getEarliestConnectTime());
        log("conference - using connect time = " + conferenceConnectTime);
    } else if (foregroundConnectTime > 0) {
        log("conference - bg call connect time is 0; using fg = " + foregroundConnectTime);
        conferenceConnectTime = foregroundConnectTime;
    } else {
        log("conference - fg call connect time is 0; using bg = " + backgroundConnectTime);
        conferenceConnectTime = backgroundConnectTime;
    }
    String foregroundId = "";
    ImsPhoneConnection foregroundConnection = mForegroundCall.getFirstConnection();
    if (foregroundConnection != null) {
        foregroundConnection.setConferenceConnectTime(conferenceConnectTime);
        foregroundConnection.handleMergeStart();
        foregroundId = foregroundConnection.getTelecomCallId();
    }
    String backgroundId = "";
    ImsPhoneConnection backgroundConnection = findConnection(bgImsCall);
    if (backgroundConnection != null) {
        backgroundConnection.handleMergeStart();
        backgroundId = backgroundConnection.getTelecomCallId();
    }
    log("conference: fgCallId=" + foregroundId + ", bgCallId=" + backgroundId);
    try {
        fgImsCall.merge(bgImsCall);
    } catch (ImsException e) {
        log("conference " + e.getMessage());
    }
}
#end_block

#method_before
// ****** Overridden from Handler
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (DBG)
        log("handleMessage what=" + msg.what);
    switch(msg.what) {
        case EVENT_HANGUP_PENDINGMO:
            if (mPendingMO != null) {
                mPendingMO.onDisconnect();
                removeConnection(mPendingMO);
                mPendingMO = null;
            }
            mPendingIntentExtras = null;
            updatePhoneState();
            mPhone.notifyPreciseCallStateChanged();
            break;
        case EVENT_RESUME_BACKGROUND:
            try {
                resumeWaitingOrHolding();
            } catch (CallStateException e) {
                if (Phone.DEBUG_PHONE) {
                    loge("handleMessage EVENT_RESUME_BACKGROUND exception=" + e);
                }
            }
            break;
        case EVENT_DIAL_PENDINGMO:
            dialInternal(mPendingMO, mClirMode, mPendingCallVideoState, mPendingIntentExtras);
            mPendingIntentExtras = null;
            break;
        case EVENT_EXIT_ECBM_BEFORE_PENDINGMO:
            if (mPendingMO != null) {
                // Send ECBM exit request
                try {
                    getEcbmInterface().exitEmergencyCallbackMode();
                    mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
                    pendingCallClirMode = mClirMode;
                    pendingCallInEcm = true;
                } catch (ImsException e) {
                    e.printStackTrace();
                    mPendingMO.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
                    sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
                }
            }
            break;
        case EVENT_EXIT_ECM_RESPONSE_CDMA:
            // no matter the result, we still do the same here
            if (pendingCallInEcm) {
                dialInternal(mPendingMO, pendingCallClirMode, mPendingCallVideoState, mPendingIntentExtras);
                mPendingIntentExtras = null;
                pendingCallInEcm = false;
            }
            mPhone.unsetOnEcbModeExitResponse(this);
            break;
        case EVENT_VT_DATA_USAGE_UPDATE:
            ar = (AsyncResult) msg.obj;
            ImsCall call = (ImsCall) ar.userObj;
            Long usage = (long) ar.result;
            log("VT data usage update. usage = " + usage + ", imsCall = " + call);
            if (usage > 0) {
                updateVtDataUsage(call, usage);
            }
            break;
        case EVENT_DATA_ENABLED_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.result instanceof Pair) {
                Pair<Boolean, Integer> p = (Pair<Boolean, Integer>) ar.result;
                onDataEnabledChanged(p.first, p.second);
            }
            break;
        case EVENT_GET_IMS_SERVICE:
            try {
                getImsService();
            } catch (ImsException e) {
                loge("getImsService: " + e);
                retryGetImsService();
            }
            break;
        case EVENT_CHECK_FOR_WIFI_HANDOVER:
            if (msg.obj instanceof ImsCall) {
                ImsCall imsCall = (ImsCall) msg.obj;
                if (!imsCall.isWifiCall()) {
                    // Call did not handover to wifi, notify of handover failure.
                    ImsPhoneConnection conn = findConnection(imsCall);
                    if (conn != null) {
                        conn.onHandoverToWifiFailed();
                    }
                }
            }
            break;
        case EVENT_ON_FEATURE_CAPABILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    int serviceClass = args.argi1;
                    int[] enabledFeatures = (int[]) args.arg1;
                    int[] disabledFeatures = (int[]) args.arg2;
                    handleFeatureCapabilityChanged(serviceClass, enabledFeatures, disabledFeatures);
                } finally {
                    args.recycle();
                }
                break;
            }
        case EVENT_SUPP_SERVICE_INDICATION:
            {
                ar = (AsyncResult) msg.obj;
                new ImsPhoneMmiCode(mPhone).processImsSsData(ar);
                break;
            }
    }
}
#method_after
// ****** Overridden from Handler
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (DBG)
        log("handleMessage what=" + msg.what);
    switch(msg.what) {
        case EVENT_HANGUP_PENDINGMO:
            if (mPendingMO != null) {
                mPendingMO.onDisconnect();
                removeConnection(mPendingMO);
                mPendingMO = null;
            }
            mPendingIntentExtras = null;
            updatePhoneState();
            mPhone.notifyPreciseCallStateChanged();
            break;
        case EVENT_RESUME_BACKGROUND:
            try {
                resumeWaitingOrHolding();
            } catch (CallStateException e) {
                if (Phone.DEBUG_PHONE) {
                    loge("handleMessage EVENT_RESUME_BACKGROUND exception=" + e);
                }
            }
            break;
        case EVENT_DIAL_PENDINGMO:
            dialInternal(mPendingMO, mClirMode, mPendingCallVideoState, mPendingIntentExtras);
            mPendingIntentExtras = null;
            break;
        case EVENT_EXIT_ECBM_BEFORE_PENDINGMO:
            if (mPendingMO != null) {
                // Send ECBM exit request
                try {
                    getEcbmInterface().exitEmergencyCallbackMode();
                    mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
                    pendingCallClirMode = mClirMode;
                    pendingCallInEcm = true;
                } catch (ImsException e) {
                    e.printStackTrace();
                    mPendingMO.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
                    sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
                }
            }
            break;
        case EVENT_EXIT_ECM_RESPONSE_CDMA:
            // no matter the result, we still do the same here
            if (pendingCallInEcm) {
                dialInternal(mPendingMO, pendingCallClirMode, mPendingCallVideoState, mPendingIntentExtras);
                mPendingIntentExtras = null;
                pendingCallInEcm = false;
            }
            mPhone.unsetOnEcbModeExitResponse(this);
            break;
        case EVENT_VT_DATA_USAGE_UPDATE:
            ar = (AsyncResult) msg.obj;
            ImsCall call = (ImsCall) ar.userObj;
            Long usage = (long) ar.result;
            log("VT data usage update. usage = " + usage + ", imsCall = " + call);
            if (usage > 0) {
                updateVtDataUsage(call, usage);
            }
            break;
        case EVENT_DATA_ENABLED_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.result instanceof Pair) {
                Pair<Boolean, Integer> p = (Pair<Boolean, Integer>) ar.result;
                onDataEnabledChanged(p.first, p.second);
            }
            break;
        case EVENT_GET_IMS_SERVICE:
            try {
                getImsService();
            } catch (ImsException e) {
                loge("getImsService: " + e);
                retryGetImsService();
            }
            break;
        case EVENT_CHECK_FOR_WIFI_HANDOVER:
            if (msg.obj instanceof ImsCall) {
                ImsCall imsCall = (ImsCall) msg.obj;
                if (!imsCall.isWifiCall()) {
                    // Call did not handover to wifi, notify of handover failure.
                    ImsPhoneConnection conn = findConnection(imsCall);
                    if (conn != null) {
                        conn.onHandoverToWifiFailed();
                    }
                }
            }
            break;
        case EVENT_ON_FEATURE_CAPABILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    int serviceClass = args.argi1;
                    int[] enabledFeatures = (int[]) args.arg1;
                    int[] disabledFeatures = (int[]) args.arg2;
                    handleFeatureCapabilityChanged(serviceClass, enabledFeatures, disabledFeatures);
                } finally {
                    args.recycle();
                }
                break;
            }
        case EVENT_SUPP_SERVICE_INDICATION:
            {
                ar = (AsyncResult) msg.obj;
                ImsPhoneMmiCode mmiCode = new ImsPhoneMmiCode(mPhone);
                try {
                    mmiCode.setIsSsInfo(true);
                    mmiCode.processImsSsData(ar);
                } catch (ImsException e) {
                    Rlog.e(LOG_TAG, "Exception in parsing SS Data: " + e);
                }
                break;
            }
    }
}
#end_block

#method_before
public static GsmMmiCode newFromDialString(String dialString, GsmCdmaPhone phone, UiccCardApplication app, ResultReceiver wrappedCallback) {
    Matcher m;
    GsmMmiCode ret = null;
    m = sPatternSuppService.matcher(dialString);
    // Is this formatted like a standard supplementary service code?
    if (m.matches()) {
        ret = new GsmMmiCode(phone, app);
        ret.mPoundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));
        ret.mAction = makeEmptyNull(m.group(MATCH_GROUP_ACTION));
        ret.mSc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));
        ret.mSia = makeEmptyNull(m.group(MATCH_GROUP_SIA));
        ret.mSib = makeEmptyNull(m.group(MATCH_GROUP_SIB));
        ret.mSic = makeEmptyNull(m.group(MATCH_GROUP_SIC));
        ret.mPwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));
        ret.mDialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));
        ret.mCallbackReceiver = wrappedCallback;
        // in India operator(Mumbai MTNL)
        if (ret.mDialingNumber != null && ret.mDialingNumber.endsWith("#") && dialString.endsWith("#")) {
            ret = new GsmMmiCode(phone, app);
            ret.mPoundString = dialString;
        }
    } else if (dialString.endsWith("#")) {
        // TS 22.030 sec 6.5.3.2
        // "Entry of any characters defined in the 3GPP TS 23.038 [8] Default Alphabet
        // (up to the maximum defined in 3GPP TS 24.080 [10]), followed by #SEND".
        ret = new GsmMmiCode(phone, app);
        ret.mPoundString = dialString;
    } else if (isTwoDigitShortCode(phone.getContext(), dialString)) {
        // Is a country-specific exception to short codes as defined in TS 22.030, 6.5.3.2
        ret = null;
    } else if (isShortCode(dialString, phone)) {
        // this may be a short code, as defined in TS 22.030, 6.5.3.2
        ret = new GsmMmiCode(phone, app);
        ret.mDialingNumber = dialString;
    }
    return ret;
}
#method_after
public static GsmMmiCode newFromDialString(String dialString, GsmCdmaPhone phone, UiccCardApplication app, ResultReceiver wrappedCallback) {
    Matcher m;
    GsmMmiCode ret = null;
    if (phone.getServiceState().getVoiceRoaming() && phone.supportsConversionOfCdmaCallerIdMmiCodesWhileRoaming()) {
        /* The CDMA MMI coded dialString will be converted to a 3GPP MMI Coded dialString
               so that it can be processed by the matcher and code below
             */
        dialString = convertCdmaMmiCodesTo3gppMmiCodes(dialString);
    }
    m = sPatternSuppService.matcher(dialString);
    // Is this formatted like a standard supplementary service code?
    if (m.matches()) {
        ret = new GsmMmiCode(phone, app);
        ret.mPoundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));
        ret.mAction = makeEmptyNull(m.group(MATCH_GROUP_ACTION));
        ret.mSc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));
        ret.mSia = makeEmptyNull(m.group(MATCH_GROUP_SIA));
        ret.mSib = makeEmptyNull(m.group(MATCH_GROUP_SIB));
        ret.mSic = makeEmptyNull(m.group(MATCH_GROUP_SIC));
        ret.mPwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));
        ret.mDialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));
        ret.mCallbackReceiver = wrappedCallback;
        if (ret.mDialingNumber != null && ret.mDialingNumber.endsWith("#") && dialString.endsWith("#")) {
            // According to TS 22.030 6.5.2 "Structure of the MMI",
            // the dialing number should not ending with #.
            // The dialing number ending # is treated as unique USSD,
            // eg, *400#16 digit number# to recharge the prepaid card
            // in India operator(Mumbai MTNL)
            ret = new GsmMmiCode(phone, app);
            ret.mPoundString = dialString;
        } else if (ret.isFacToDial()) {
            // This is a FAC (feature access code) to dial as a normal call.
            ret = null;
        }
    } else if (dialString.endsWith("#")) {
        // TS 22.030 sec 6.5.3.2
        // "Entry of any characters defined in the 3GPP TS 23.038 [8] Default Alphabet
        // (up to the maximum defined in 3GPP TS 24.080 [10]), followed by #SEND".
        ret = new GsmMmiCode(phone, app);
        ret.mPoundString = dialString;
    } else if (isTwoDigitShortCode(phone.getContext(), dialString)) {
        // Is a country-specific exception to short codes as defined in TS 22.030, 6.5.3.2
        ret = null;
    } else if (isShortCode(dialString, phone)) {
        // this may be a short code, as defined in TS 22.030, 6.5.3.2
        ret = new GsmMmiCode(phone, app);
        ret.mDialingNumber = dialString;
    }
    return ret;
}
#end_block

#method_before
public void processCode() throws CallStateException {
    try {
        if (isShortCode()) {
            Rlog.d(LOG_TAG, "processCode: isShortCode");
            // These just get treated as USSD.
            sendUssd(mDialingNumber);
        } else if (mDialingNumber != null) {
            // We should have no dialing numbers here
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        } else if (mSc != null && mSc.equals(SC_CLIP)) {
            Rlog.d(LOG_TAG, "processCode: is CLIP");
            if (isInterrogate()) {
                mPhone.mCi.queryCLIP(obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIR)) {
            Rlog.d(LOG_TAG, "processCode: is CLIR");
            if (isActivate()) {
                mPhone.mCi.setCLIR(CommandsInterface.CLIR_INVOCATION, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isDeactivate()) {
                mPhone.mCi.setCLIR(CommandsInterface.CLIR_SUPPRESSION, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.mCi.getCLIR(obtainMessage(EVENT_GET_CLIR_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (isServiceCodeCallForwarding(mSc)) {
            Rlog.d(LOG_TAG, "processCode: is CF");
            String dialingNumber = mSia;
            int serviceClass = siToServiceClass(mSib);
            int reason = scToCallForwardReason(mSc);
            int time = siToTime(mSic);
            if (isInterrogate()) {
                mPhone.mCi.queryCallForwardStatus(reason, serviceClass, dialingNumber, obtainMessage(EVENT_QUERY_CF_COMPLETE, this));
            } else {
                int cfAction;
                if (isActivate()) {
                    // number, or an activation if not
                    if (isEmptyOrNull(dialingNumber)) {
                        cfAction = CommandsInterface.CF_ACTION_ENABLE;
                        mIsCallFwdReg = false;
                    } else {
                        cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                        mIsCallFwdReg = true;
                    }
                } else if (isDeactivate()) {
                    cfAction = CommandsInterface.CF_ACTION_DISABLE;
                } else if (isRegister()) {
                    cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                } else if (isErasure()) {
                    cfAction = CommandsInterface.CF_ACTION_ERASURE;
                } else {
                    throw new RuntimeException("invalid action");
                }
                int isSettingUnconditionalVoice = (((reason == CommandsInterface.CF_REASON_UNCONDITIONAL) || (reason == CommandsInterface.CF_REASON_ALL)) && (((serviceClass & CommandsInterface.SERVICE_CLASS_VOICE) != 0) || (serviceClass == CommandsInterface.SERVICE_CLASS_NONE))) ? 1 : 0;
                int isEnableDesired = ((cfAction == CommandsInterface.CF_ACTION_ENABLE) || (cfAction == CommandsInterface.CF_ACTION_REGISTRATION)) ? 1 : 0;
                Rlog.d(LOG_TAG, "processCode: is CF setCallForward");
                mPhone.mCi.setCallForward(cfAction, reason, serviceClass, dialingNumber, time, obtainMessage(EVENT_SET_CFF_COMPLETE, isSettingUnconditionalVoice, isEnableDesired, this));
            }
        } else if (isServiceCodeCallBarring(mSc)) {
            // sia = password
            // sib = basic service group
            String password = mSia;
            int serviceClass = siToServiceClass(mSib);
            String facility = scToBarringFacility(mSc);
            if (isInterrogate()) {
                mPhone.mCi.queryFacilityLock(facility, password, serviceClass, obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else if (isActivate() || isDeactivate()) {
                mPhone.mCi.setFacilityLock(facility, isActivate(), password, serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_PWD)) {
            // sia = fac
            // sib = old pwd
            // sic = new pwd
            // pwd = new pwd
            String facility;
            String oldPwd = mSib;
            String newPwd = mSic;
            if (isActivate() || isRegister()) {
                // Even though ACTIVATE is acceptable, this is really termed a REGISTER
                mAction = ACTION_REGISTER;
                if (mSia == null) {
                    // If sc was not specified, treat it as BA_ALL.
                    facility = CommandsInterface.CB_FACILITY_BA_ALL;
                } else {
                    facility = scToBarringFacility(mSia);
                }
                if (newPwd.equals(mPwd)) {
                    mPhone.mCi.changeBarringPassword(facility, oldPwd, newPwd, obtainMessage(EVENT_SET_COMPLETE, this));
                } else {
                    // password mismatch; return error
                    handlePasswordError(com.android.internal.R.string.passwordIncorrect);
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_WAIT)) {
            // sia = basic service group
            int serviceClass = siToServiceClass(mSia);
            if (isActivate() || isDeactivate()) {
                mPhone.mCi.setCallWaiting(isActivate(), serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.mCi.queryCallWaiting(serviceClass, obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (isPinPukCommand()) {
            // TODO: This is the same as the code in CmdaMmiCode.java,
            // MmiCode should be an abstract or base class and this and
            // other common variables and code should be promoted.
            // sia = old PIN or PUK
            // sib = new PIN
            // sic = new PIN
            String oldPinOrPuk = mSia;
            String newPinOrPuk = mSib;
            int pinLen = newPinOrPuk.length();
            if (isRegister()) {
                if (!newPinOrPuk.equals(mSic)) {
                    // password mismatch; return error
                    handlePasswordError(com.android.internal.R.string.mismatchPin);
                } else if (pinLen < 4 || pinLen > 8) {
                    // invalid length
                    handlePasswordError(com.android.internal.R.string.invalidPin);
                } else if (mSc.equals(SC_PIN) && mUiccApplication != null && mUiccApplication.getState() == AppState.APPSTATE_PUK) {
                    // Sim is puk-locked
                    handlePasswordError(com.android.internal.R.string.needPuk);
                } else if (mUiccApplication != null) {
                    Rlog.d(LOG_TAG, "processCode: process mmi service code using UiccApp sc=" + mSc);
                    // We have an app and the pre-checks are OK
                    if (mSc.equals(SC_PIN)) {
                        mUiccApplication.changeIccLockPassword(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PIN2)) {
                        mUiccApplication.changeIccFdnPassword(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PUK)) {
                        mUiccApplication.supplyPuk(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PUK2)) {
                        mUiccApplication.supplyPuk2(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else {
                        throw new RuntimeException("uicc unsupported service code=" + mSc);
                    }
                } else {
                    throw new RuntimeException("No application mUiccApplicaiton is null");
                }
            } else {
                throw new RuntimeException("Ivalid register/action=" + mAction);
            }
        } else if (mPoundString != null) {
            sendUssd(mPoundString);
        } else {
            Rlog.d(LOG_TAG, "processCode: Invalid or Unsupported MMI Code");
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        }
    } catch (RuntimeException exc) {
        mState = State.FAILED;
        mMessage = mContext.getText(com.android.internal.R.string.mmiError);
        Rlog.d(LOG_TAG, "processCode: RuntimeException=" + exc);
        mPhone.onMMIDone(this);
    }
}
#method_after
public void processCode() throws CallStateException {
    try {
        if (isShortCode()) {
            Rlog.d(LOG_TAG, "processCode: isShortCode");
            // These just get treated as USSD.
            sendUssd(mDialingNumber);
        } else if (mDialingNumber != null) {
            // We should have no dialing numbers here
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        } else if (mSc != null && mSc.equals(SC_CLIP)) {
            Rlog.d(LOG_TAG, "processCode: is CLIP");
            if (isInterrogate()) {
                mPhone.mCi.queryCLIP(obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIR)) {
            Rlog.d(LOG_TAG, "processCode: is CLIR");
            if (isActivate()) {
                mPhone.mCi.setCLIR(CommandsInterface.CLIR_INVOCATION, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isDeactivate()) {
                mPhone.mCi.setCLIR(CommandsInterface.CLIR_SUPPRESSION, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.mCi.getCLIR(obtainMessage(EVENT_GET_CLIR_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (isServiceCodeCallForwarding(mSc)) {
            Rlog.d(LOG_TAG, "processCode: is CF");
            String dialingNumber = mSia;
            int serviceClass = siToServiceClass(mSib);
            int reason = scToCallForwardReason(mSc);
            int time = siToTime(mSic);
            if (isInterrogate()) {
                mPhone.mCi.queryCallForwardStatus(reason, serviceClass, dialingNumber, obtainMessage(EVENT_QUERY_CF_COMPLETE, this));
            } else {
                int cfAction;
                if (isActivate()) {
                    // number, or an activation if not
                    if (isEmptyOrNull(dialingNumber)) {
                        cfAction = CommandsInterface.CF_ACTION_ENABLE;
                        mIsCallFwdReg = false;
                    } else {
                        cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                        mIsCallFwdReg = true;
                    }
                } else if (isDeactivate()) {
                    cfAction = CommandsInterface.CF_ACTION_DISABLE;
                } else if (isRegister()) {
                    cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                } else if (isErasure()) {
                    cfAction = CommandsInterface.CF_ACTION_ERASURE;
                } else {
                    throw new RuntimeException("invalid action");
                }
                int isEnableDesired = ((cfAction == CommandsInterface.CF_ACTION_ENABLE) || (cfAction == CommandsInterface.CF_ACTION_REGISTRATION)) ? 1 : 0;
                Rlog.d(LOG_TAG, "processCode: is CF setCallForward");
                mPhone.mCi.setCallForward(cfAction, reason, serviceClass, dialingNumber, time, obtainMessage(EVENT_SET_CFF_COMPLETE, isVoiceUnconditionalForwarding(reason, serviceClass) ? 1 : 0, isEnableDesired, this));
            }
        } else if (isServiceCodeCallBarring(mSc)) {
            // sia = password
            // sib = basic service group
            String password = mSia;
            int serviceClass = siToServiceClass(mSib);
            String facility = scToBarringFacility(mSc);
            if (isInterrogate()) {
                mPhone.mCi.queryFacilityLock(facility, password, serviceClass, obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else if (isActivate() || isDeactivate()) {
                mPhone.mCi.setFacilityLock(facility, isActivate(), password, serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_PWD)) {
            // sia = fac
            // sib = old pwd
            // sic = new pwd
            // pwd = new pwd
            String facility;
            String oldPwd = mSib;
            String newPwd = mSic;
            if (isActivate() || isRegister()) {
                // Even though ACTIVATE is acceptable, this is really termed a REGISTER
                mAction = ACTION_REGISTER;
                if (mSia == null) {
                    // If sc was not specified, treat it as BA_ALL.
                    facility = CommandsInterface.CB_FACILITY_BA_ALL;
                } else {
                    facility = scToBarringFacility(mSia);
                }
                if (newPwd.equals(mPwd)) {
                    mPhone.mCi.changeBarringPassword(facility, oldPwd, newPwd, obtainMessage(EVENT_SET_COMPLETE, this));
                } else {
                    // password mismatch; return error
                    handlePasswordError(com.android.internal.R.string.passwordIncorrect);
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_WAIT)) {
            // sia = basic service group
            int serviceClass = siToServiceClass(mSia);
            if (isActivate() || isDeactivate()) {
                mPhone.mCi.setCallWaiting(isActivate(), serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.mCi.queryCallWaiting(serviceClass, obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (isPinPukCommand()) {
            // TODO: This is the same as the code in CmdaMmiCode.java,
            // MmiCode should be an abstract or base class and this and
            // other common variables and code should be promoted.
            // sia = old PIN or PUK
            // sib = new PIN
            // sic = new PIN
            String oldPinOrPuk = mSia;
            String newPinOrPuk = mSib;
            int pinLen = newPinOrPuk.length();
            if (isRegister()) {
                if (!newPinOrPuk.equals(mSic)) {
                    // password mismatch; return error
                    handlePasswordError(com.android.internal.R.string.mismatchPin);
                } else if (pinLen < 4 || pinLen > 8) {
                    // invalid length
                    handlePasswordError(com.android.internal.R.string.invalidPin);
                } else if (mSc.equals(SC_PIN) && mUiccApplication != null && mUiccApplication.getState() == AppState.APPSTATE_PUK) {
                    // Sim is puk-locked
                    handlePasswordError(com.android.internal.R.string.needPuk);
                } else if (mUiccApplication != null) {
                    Rlog.d(LOG_TAG, "processCode: process mmi service code using UiccApp sc=" + mSc);
                    // We have an app and the pre-checks are OK
                    if (mSc.equals(SC_PIN)) {
                        mUiccApplication.changeIccLockPassword(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PIN2)) {
                        mUiccApplication.changeIccFdnPassword(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PUK)) {
                        mUiccApplication.supplyPuk(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PUK2)) {
                        mUiccApplication.supplyPuk2(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else {
                        throw new RuntimeException("uicc unsupported service code=" + mSc);
                    }
                } else {
                    throw new RuntimeException("No application mUiccApplicaiton is null");
                }
            } else {
                throw new RuntimeException("Ivalid register/action=" + mAction);
            }
        } else if (mPoundString != null) {
            sendUssd(mPoundString);
        } else {
            Rlog.d(LOG_TAG, "processCode: Invalid or Unsupported MMI Code");
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        }
    } catch (RuntimeException exc) {
        mState = State.FAILED;
        mMessage = mContext.getText(com.android.internal.R.string.mmiError);
        Rlog.d(LOG_TAG, "processCode: RuntimeException=" + exc);
        mPhone.onMMIDone(this);
    }
}
#end_block

#method_before
private void initOnce(CommandsInterface ci) {
    if (ci instanceof SimulatedRadioControl) {
        mSimulatedRadioControl = (SimulatedRadioControl) ci;
    }
    mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
    mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
    mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
    mIccCardProxy = mTelephonyComponentFactory.makeIccCardProxy(mContext, mCi, mPhoneId);
    mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
    mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mCi.registerForOn(this, EVENT_RADIO_ON, null);
    mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
    // GSM
    mCi.setOnUSSD(this, EVENT_USSD, null);
    mCi.setOnSs(this, EVENT_SS, null);
    // CDMA
    mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext, mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
    mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext, EriManager.ERI_FROM_XML);
    mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
    mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE, null);
    // get the string that specifies the carrier OTA Sp number
    mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(getPhoneId(), "");
    mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
    mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
    mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
    mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
}
#method_after
private void initOnce(CommandsInterface ci) {
    if (ci instanceof SimulatedRadioControl) {
        mSimulatedRadioControl = (SimulatedRadioControl) ci;
    }
    mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
    mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
    mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
    mIccCardProxy = mTelephonyComponentFactory.makeIccCardProxy(mContext, mCi, mPhoneId);
    mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
    mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mCi.registerForOn(this, EVENT_RADIO_ON, null);
    mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
    // GSM
    mCi.setOnUSSD(this, EVENT_USSD, null);
    mCi.setOnSs(this, EVENT_SS, null);
    // CDMA
    mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext, mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
    mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext, EriManager.ERI_FROM_XML);
    mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
    mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE, null);
    mCi.registerForModemReset(this, EVENT_MODEM_RESET, null);
    // get the string that specifies the carrier OTA Sp number
    mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(getPhoneId(), "");
    mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
    mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
    mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
    mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
    mCDM = new CarrierKeyDownloadManager(this);
}
#end_block

#method_before
@Override
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    return CarrierInfoManager.getCarrierInfoForImsiEncryption(keyType);
}
#method_after
@Override
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    return CarrierInfoManager.getCarrierInfoForImsiEncryption(keyType, mContext);
}
#end_block

#method_before
@Override
public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
    CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo);
}
#method_after
@Override
public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
    CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, mContext);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service
            ImsManager.updateImsServiceConfig(mContext, mPhoneId, true);
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            if (!isPhoneTypeGsm()) {
                mSST.pollState();
            }
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service
            ImsManager.updateImsServiceConfig(mContext, mPhoneId, true);
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            if (!isPhoneTypeGsm()) {
                mSST.pollState();
            }
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#end_block

#method_before
private void processIccRecordEvents(int eventCode) {
    switch(eventCode) {
        case IccRecords.EVENT_CFI:
            notifyCallForwardingIndicator();
            break;
    }
}
#method_after
private void processIccRecordEvents(int eventCode) {
    switch(eventCode) {
        case IccRecords.EVENT_CFI:
            logi("processIccRecordEvents: EVENT_CFI");
            notifyCallForwardingIndicator();
            break;
    }
}
#end_block

#method_before
/**
 * Operations for the supplementary service configuration
 */
@Override
public void queryCallBarring(int cbType, Message result) {
    if (DBG) {
        log("queryCallBarring :: Ut=" + miUt + ", cbType=" + cbType);
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.queryCallBarring(cbType);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#method_after
/**
 * Operations for the supplementary service configuration
 */
@Override
public void queryCallBarring(int cbType, Message result) {
    queryCallBarring(cbType, result, SERVICE_CLASS_NONE);
}
#end_block

#method_before
/**
 * Operations for the supplementary service configuration
 */
@Override
public void queryCallBarring(int cbType, Message result) {
    if (DBG) {
        log("queryCallBarring :: Ut=" + miUt + ", cbType=" + cbType);
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.queryCallBarring(cbType);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#method_after
@Override
public void queryCallBarring(int cbType, Message result, int serviceClass) {
    if (DBG) {
        log("queryCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", serviceClass=" + serviceClass);
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.queryCallBarringForServiceClass(cbType, serviceClass);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#end_block

#method_before
@Override
public void updateCallBarring(int cbType, int action, Message result, String[] barrList) {
    if (DBG) {
        if (barrList != null) {
            String bList = new String();
            for (int i = 0; i < barrList.length; i++) {
                bList.concat(barrList[i] + " ");
            }
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action + ", barrList=" + bList);
        } else {
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action);
        }
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.updateCallBarring(cbType, action, barrList);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#method_after
@Override
public void updateCallBarring(int cbType, int action, Message result, String[] barrList) {
    updateCallBarring(cbType, action, result, barrList, SERVICE_CLASS_NONE);
}
#end_block

#method_before
@Override
public void updateCallBarring(int cbType, int action, Message result, String[] barrList) {
    if (DBG) {
        if (barrList != null) {
            String bList = new String();
            for (int i = 0; i < barrList.length; i++) {
                bList.concat(barrList[i] + " ");
            }
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action + ", barrList=" + bList);
        } else {
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action);
        }
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.updateCallBarring(cbType, action, barrList);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#method_after
@Override
public void updateCallBarring(int cbType, int action, Message result, String[] barrList, int serviceClass) {
    if (DBG) {
        if (barrList != null) {
            String bList = new String();
            for (int i = 0; i < barrList.length; i++) {
                bList.concat(barrList[i] + " ");
            }
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action + ", serviceClass=" + serviceClass + ", barrList=" + bList);
        } else {
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action + ", serviceClass=" + serviceClass);
        }
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.updateCallBarringForServiceClass(cbType, action, barrList, serviceClass);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#end_block

#method_before
@Override
public void onSupplementaryServiceIndication(ImsSsData ssData) {
    if (mSsIndicationRegistrant != null) {
        mSsIndicationRegistrant.notifyRegistrant(new AsyncResult(null, ssData, null));
    }
}
#method_after
@Override
public void onSupplementaryServiceIndication(ImsSsData ssData) {
    if (mSsIndicationRegistrant != null) {
        mSsIndicationRegistrant.notifyResult(ssData);
    }
}
#end_block

#method_before
public static String toString(int cause) {
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case DIAL_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_MODIFIED_TO_DIAL_VIDEO";
        case DIAL_VIDEO_MODIFIED_TO_SS:
            return "DIAL_VIDEO_MODIFIED_TO_SS";
        case DIAL_VIDEO_MODIFIED_TO_USSD:
            return "DIAL_VIDEO_MODIFIED_TO_USSD";
        case DIAL_VIDEO_MODIFIED_TO_DIAL:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL";
        case DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case IMS_ACCESS_BLOCKED:
            return "IMS_ACCESS_BLOCKED";
        case LOW_BATTERY:
            return "LOW_BATTERY";
        case DIAL_LOW_BATTERY:
            return "DIAL_LOW_BATTERY";
        case EMERGENCY_TEMP_FAILURE:
            return "EMERGENCY_TEMP_FAILURE";
        case EMERGENCY_PERM_FAILURE:
            return "EMERGENCY_PERM_FAILURE";
        default:
            return "INVALID: " + cause;
    }
}
#method_after
public static String toString(int cause) {
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case DIAL_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_MODIFIED_TO_DIAL_VIDEO";
        case DIAL_VIDEO_MODIFIED_TO_SS:
            return "DIAL_VIDEO_MODIFIED_TO_SS";
        case DIAL_VIDEO_MODIFIED_TO_USSD:
            return "DIAL_VIDEO_MODIFIED_TO_USSD";
        case DIAL_VIDEO_MODIFIED_TO_DIAL:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL";
        case DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case IMS_ACCESS_BLOCKED:
            return "IMS_ACCESS_BLOCKED";
        case LOW_BATTERY:
            return "LOW_BATTERY";
        case DIAL_LOW_BATTERY:
            return "DIAL_LOW_BATTERY";
        case EMERGENCY_TEMP_FAILURE:
            return "EMERGENCY_TEMP_FAILURE";
        case EMERGENCY_PERM_FAILURE:
            return "EMERGENCY_PERM_FAILURE";
        case NORMAL_UNSPECIFIED:
            return "NORMAL_UNSPECIFIED";
        default:
            return "INVALID: " + cause;
    }
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(mServiceType);
    out.writeInt(mRequestType);
    out.writeInt(mTeleserviceType);
    out.writeInt(mServiceClass);
    out.writeInt(mResult);
    out.writeIntArray(mSsInfo);
    out.writeParcelableArray(mCfInfo, 0);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(serviceType);
    out.writeInt(requestType);
    out.writeInt(teleserviceType);
    out.writeInt(serviceClass);
    out.writeInt(result);
    out.writeIntArray(ssInfo);
    out.writeParcelableArray(cfInfo, 0);
}
#end_block

#method_before
private void readFromParcel(Parcel in) {
    mServiceType = in.readInt();
    mRequestType = in.readInt();
    mTeleserviceType = in.readInt();
    mServiceClass = in.readInt();
    mResult = in.readInt();
    mSsInfo = in.createIntArray();
    mCfInfo = (ImsCallForwardInfo[]) in.readParcelableArray(this.getClass().getClassLoader());
}
#method_after
private void readFromParcel(Parcel in) {
    serviceType = in.readInt();
    requestType = in.readInt();
    teleserviceType = in.readInt();
    serviceClass = in.readInt();
    result = in.readInt();
    ssInfo = in.createIntArray();
    cfInfo = (ImsCallForwardInfo[]) in.readParcelableArray(this.getClass().getClassLoader());
}
#end_block

#method_before
public boolean isTypeCF() {
    return (mServiceType == SS_CFU || mServiceType == SS_CF_BUSY || mServiceType == SS_CF_NO_REPLY || mServiceType == SS_CF_NOT_REACHABLE || mServiceType == SS_CF_ALL || mServiceType == SS_CF_ALL_CONDITIONAL);
}
#method_after
public boolean isTypeCF() {
    return (serviceType == SS_CFU || serviceType == SS_CF_BUSY || serviceType == SS_CF_NO_REPLY || serviceType == SS_CF_NOT_REACHABLE || serviceType == SS_CF_ALL || serviceType == SS_CF_ALL_CONDITIONAL);
}
#end_block

#method_before
public boolean isTypeUnConditional() {
    return (mServiceType == SS_CFU || mServiceType == SS_CF_ALL);
}
#method_after
public boolean isTypeUnConditional() {
    return (serviceType == SS_CFU || serviceType == SS_CF_ALL);
}
#end_block

#method_before
public boolean isTypeCW() {
    return (mServiceType == SS_WAIT);
}
#method_after
public boolean isTypeCW() {
    return (serviceType == SS_WAIT);
}
#end_block

#method_before
public boolean isTypeClip() {
    return (mServiceType == SS_CLIP);
}
#method_after
public boolean isTypeClip() {
    return (serviceType == SS_CLIP);
}
#end_block

#method_before
public boolean isTypeColr() {
    return (mServiceType == SS_COLR);
}
#method_after
public boolean isTypeColr() {
    return (serviceType == SS_COLR);
}
#end_block

#method_before
public boolean isTypeColp() {
    return (mServiceType == SS_COLP);
}
#method_after
public boolean isTypeColp() {
    return (serviceType == SS_COLP);
}
#end_block

#method_before
public boolean isTypeClir() {
    return (mServiceType == SS_CLIR);
}
#method_after
public boolean isTypeClir() {
    return (serviceType == SS_CLIR);
}
#end_block

#method_before
public boolean isTypeIcb() {
    return (mServiceType == SS_INCOMING_BARRING_DN || mServiceType == SS_INCOMING_BARRING_ANONYMOUS);
}
#method_after
public boolean isTypeIcb() {
    return (serviceType == SS_INCOMING_BARRING_DN || serviceType == SS_INCOMING_BARRING_ANONYMOUS);
}
#end_block

#method_before
public boolean isTypeBarring() {
    return (mServiceType == SS_BAOC || mServiceType == SS_BAOIC || mServiceType == SS_BAOIC_EXC_HOME || mServiceType == SS_BAIC || mServiceType == SS_BAIC_ROAMING || mServiceType == SS_ALL_BARRING || mServiceType == SS_OUTGOING_BARRING || mServiceType == SS_INCOMING_BARRING);
}
#method_after
public boolean isTypeBarring() {
    return (serviceType == SS_BAOC || serviceType == SS_BAOIC || serviceType == SS_BAOIC_EXC_HOME || serviceType == SS_BAIC || serviceType == SS_BAIC_ROAMING || serviceType == SS_ALL_BARRING || serviceType == SS_OUTGOING_BARRING || serviceType == SS_INCOMING_BARRING);
}
#end_block

#method_before
public boolean isTypeInterrogation() {
    return (mRequestType == SS_INTERROGATION);
}
#method_after
public boolean isTypeInterrogation() {
    return (requestType == SS_INTERROGATION);
}
#end_block

#method_before
public String toString() {
    return "[ImsSsData] " + "ServiceType: " + mServiceType + " RequestType: " + mRequestType + " TeleserviceType: " + mTeleserviceType + " ServiceClass: " + mServiceClass + " Result: " + mResult;
}
#method_after
public String toString() {
    return "[ImsSsData] " + "ServiceType: " + serviceType + " RequestType: " + requestType + " TeleserviceType: " + teleserviceType + " ServiceClass: " + serviceClass + " Result: " + result;
}
#end_block

#method_before
private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, final int policyFlags, final int scanFlags, long currentTime, @Nullable UserHandle user) throws PackageManagerException {
    if (DEBUG_PACKAGE_SCANNING) {
        if ((policyFlags & PackageParser.PARSE_CHATTY) != 0)
            Log.d(TAG, "Scanning package " + pkg.packageName);
    }
    applyPolicy(pkg, policyFlags);
    assertPackageIsValid(pkg, policyFlags, scanFlags);
    if (Build.IS_DEBUGGABLE && pkg.isPrivilegedApp() && !SystemProperties.getBoolean("pm.dexopt.priv-apps", true)) {
        PackageManagerServiceUtils.logPackageHasUncompressedCode(pkg);
    }
    // Initialize package source and resource directories
    final File scanFile = new File(pkg.codePath);
    final File destCodeFile = new File(pkg.applicationInfo.getCodePath());
    final File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
    SharedUserSetting suid = null;
    PackageSetting pkgSetting = null;
    // Getting the package setting may have a side-effect, so if we
    // are only checking if scan would succeed, stash a copy of the
    // old setting to restore at the end.
    PackageSetting nonMutatedPs = null;
    // We keep references to the derived CPU Abis from settings in oder to reuse
    // them in the case where we're not upgrading or booting for the first time.
    String primaryCpuAbiFromSettings = null;
    String secondaryCpuAbiFromSettings = null;
    boolean foundPkgSettings = false;
    // writer
    synchronized (mPackages) {
        if (pkg.mSharedUserId != null) {
            // SIDE EFFECTS; may potentially allocate a new shared user
            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, /*pkgFlags*/
            0, /*pkgPrivateFlags*/
            true);
            if (DEBUG_PACKAGE_SCANNING) {
                if ((policyFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + suid.userId + "): packages=" + suid.packages);
            }
        }
        // Check if we are renaming from an original package name.
        PackageSetting origPackage = null;
        String realName = null;
        if (pkg.mOriginalPackages != null) {
            // This package may need to be renamed to a previously
            // installed name.  Let's check on that...
            final String renamed = mSettings.getRenamedPackageLPr(pkg.mRealPackage);
            if (pkg.mOriginalPackages.contains(renamed)) {
                // This package had originally been installed as the
                // original name, and we have already taken care of
                // transitioning to the new one.  Just update the new
                // one to continue using the old name.
                realName = pkg.mRealPackage;
                if (!pkg.packageName.equals(renamed)) {
                    // Callers into this function may have already taken
                    // care of renaming the package; only do it here if
                    // it is not already done.
                    pkg.setPackageName(renamed);
                }
            } else {
                for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
                    if ((origPackage = mSettings.getPackageLPr(pkg.mOriginalPackages.get(i))) != null) {
                        // original name...  should we use it?
                        if (!verifyPackageUpdateLPr(origPackage, pkg)) {
                            // New package is not compatible with original.
                            origPackage = null;
                            continue;
                        } else if (origPackage.sharedUser != null) {
                            // Make sure uid is compatible between packages.
                            if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                                Slog.w(TAG, "Unable to migrate data from " + origPackage.name + " to " + pkg.packageName + ": old uid " + origPackage.sharedUser.name + " differs from " + pkg.mSharedUserId);
                                origPackage = null;
                                continue;
                            }
                        // TODO: Add case when shared user id is added [b/28144775]
                        } else {
                            if (DEBUG_UPGRADE)
                                Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + origPackage.name);
                        }
                        break;
                    }
                }
            }
        }
        if (mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        // See comments in nonMutatedPs declaration
        if ((scanFlags & SCAN_CHECK_ONLY) != 0) {
            PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName);
            if (foundPs != null) {
                nonMutatedPs = new PackageSetting(foundPs);
            }
        }
        if ((scanFlags & SCAN_FIRST_BOOT_OR_UPGRADE) == 0) {
            PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName);
            if (foundPs != null) {
                primaryCpuAbiFromSettings = foundPs.primaryCpuAbiString;
                secondaryCpuAbiFromSettings = foundPs.secondaryCpuAbiString;
                foundPkgSettings = true;
            }
        }
        pkgSetting = mSettings.getPackageLPr(pkg.packageName);
        if (pkgSetting != null && pkgSetting.sharedUser != suid) {
            PackageManagerService.reportSettingsProblem(Log.WARN, "Package " + pkg.packageName + " shared user changed from " + (pkgSetting.sharedUser != null ? pkgSetting.sharedUser.name : "<nothing>") + " to " + (suid != null ? suid.name : "<nothing>") + "; replacing with new");
            pkgSetting = null;
        }
        final PackageSetting oldPkgSetting = pkgSetting == null ? null : new PackageSetting(pkgSetting);
        final PackageSetting disabledPkgSetting = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
        String[] usesStaticLibraries = null;
        if (pkg.usesStaticLibraries != null) {
            usesStaticLibraries = new String[pkg.usesStaticLibraries.size()];
            pkg.usesStaticLibraries.toArray(usesStaticLibraries);
        }
        if (pkgSetting == null) {
            final String parentPackageName = (pkg.parentPackage != null) ? pkg.parentPackage.packageName : null;
            final boolean instantApp = (scanFlags & SCAN_AS_INSTANT_APP) != 0;
            // REMOVE SharedUserSetting from method; update in a separate call
            pkgSetting = Settings.createNewSetting(pkg.packageName, origPackage, disabledPkgSetting, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.mVersionCode, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, true, /*allowInstall*/
            instantApp, parentPackageName, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
            // SIDE EFFECTS; updates system state; move elsewhere
            if (origPackage != null) {
                mSettings.addRenamedPackageLPw(pkg.packageName, origPackage.name);
            }
            mSettings.addUserToSettingLPw(pkgSetting);
        } else {
            // REMOVE SharedUserSetting from method; update in a separate call.
            // 
            // TODO(narayan): This update is bogus. nativeLibraryDir & primaryCpuAbi,
            // secondaryCpuAbi are not known at this point so we always update them
            // to null here, only to reset them at a later point.
            Settings.updatePackageSetting(pkgSetting, disabledPkgSetting, suid, destCodeFile, pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
        }
        // SIDE EFFECTS; persists system state to files on disk; move elsewhere
        mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting);
        // SIDE EFFECTS; modifies system state; move elsewhere
        if (pkgSetting.origPackage != null) {
            // If we are first transitioning from an original package,
            // fix up the new package's name now.  We need to do this after
            // looking up the package under its new name, so getPackageLP
            // can take care of fiddling things correctly.
            pkg.setPackageName(origPackage.name);
            // File a report about this.
            String msg = "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name;
            reportSettingsProblem(Log.WARN, msg);
            // Make a note of it.
            if ((scanFlags & SCAN_CHECK_ONLY) == 0) {
                mTransferedPackages.add(origPackage.name);
            }
            // No longer need to retain this.
            pkgSetting.origPackage = null;
        }
        // SIDE EFFECTS; modifies system state; move elsewhere
        if ((scanFlags & SCAN_CHECK_ONLY) == 0 && realName != null) {
            // Make a note of it.
            mTransferedPackages.add(pkg.packageName);
        }
        if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) {
            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
        }
        if ((scanFlags & SCAN_BOOTING) == 0 && (policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
            // Check all shared libraries and map to their actual file path.
            // We only do this here for apps not on a system dir, because those
            // are the only ones that can fail an install due to this.  We
            // will take care of the system apps by updating all of their
            // library paths after the scan is done. Also during the initial
            // scan don't update any libs as we do this wholesale after all
            // apps are scanned to avoid dependency based scanning.
            updateSharedLibrariesLPr(pkg, null);
        }
        if (mFoundPolicyFile) {
            SELinuxMMAC.assignSeInfoValue(pkg);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        pkg.mExtras = pkgSetting;
        // Static shared libs have same package with different versions where
        // we internally use a synthetic package name to allow multiple versions
        // of the same package, therefore we need to compare signatures against
        // the package setting for the latest library version.
        PackageSetting signatureCheckPs = pkgSetting;
        if (pkg.applicationInfo.isStaticSharedLibrary()) {
            SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
            if (libraryEntry != null) {
                signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);
            }
        }
        if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
            if (checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } else {
                if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                } else {
                    pkgSetting.signatures.mSignatures = pkg.mSignatures;
                    String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                    reportSettingsProblem(Log.WARN, msg);
                }
            }
        } else {
            try {
                // SIDE EFFECTS; compareSignaturesCompat() changes KeysetManagerService
                verifySignaturesLP(signatureCheckPs, pkg);
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } catch (PackageManagerException e) {
                if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw e;
                }
                // The signature has changed, but this package is in the system
                // image...  let's recover!
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
                // that unreasonable.
                if (signatureCheckPs.sharedUser != null) {
                    if (compareSignatures(signatureCheckPs.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                        throw new PackageManagerException(INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, "Signature mismatch for shared user: " + pkgSetting.sharedUser);
                    }
                }
                // File a report about this.
                String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                reportSettingsProblem(Log.WARN, msg);
            }
        }
        if ((scanFlags & SCAN_CHECK_ONLY) == 0 && pkg.mAdoptPermissions != null) {
            // another package.
            for (int i = pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
                final String origName = pkg.mAdoptPermissions.get(i);
                final PackageSetting orig = mSettings.getPackageLPr(origName);
                if (orig != null) {
                    if (verifyPackageUpdateLPr(orig, pkg)) {
                        Slog.i(TAG, "Adopting permissions from " + origName + " to " + pkg.packageName);
                        // SIDE EFFECTS; updates permissions system state; move elsewhere
                        mSettings.transferPermissionsLPw(origName, pkg.packageName);
                    }
                }
            }
        }
    }
    pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName);
    if (pkg != mPlatformPackage) {
        // Get all of our default paths setup
        pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM);
    }
    final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
    if ((scanFlags & SCAN_NEW_INSTALL) == 0) {
        if (!foundPkgSettings || (scanFlags & SCAN_FIRST_BOOT_OR_UPGRADE) != 0) {
            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "derivePackageAbi");
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, scanFile, cpuAbiOverride, extractNativeLibs, mAppLib32InstallDir);
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
            // structure. Try to detect abi based on directory structure.
            if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
                setBundledAppAbisAndRoots(pkg, pkgSetting);
                setNativeLibraryPaths(pkg, mAppLib32InstallDir);
            }
        } else {
            // This is not a first boot or an upgrade, don't bother deriving the
            // ABI during the scan. Instead, trust the value that was stored in the
            // package setting.
            pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings;
            pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings;
            setNativeLibraryPaths(pkg, mAppLib32InstallDir);
            if (DEBUG_ABI_SELECTION) {
                Slog.i(TAG, "Using ABIS and native lib paths from settings : " + pkg.packageName + " " + pkg.applicationInfo.primaryCpuAbi + ", " + pkg.applicationInfo.secondaryCpuAbi);
            }
        }
    } else {
        if ((scanFlags & SCAN_MOVE) != 0) {
            // We haven't run dex-opt for this move (since we've moved the compiled output too)
            // but we already have this packages package info in the PackageSetting. We just
            // use that and derive the native library path based on the new codepath.
            pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
        }
        // Set native library paths again. For moves, the path will be updated based on the
        // ABIs we've determined above. For non-moves, the path will be updated based on the
        // ABIs we determined during compilation, but the path will depend on the final
        // package path (after the rename away from the stage path).
        setNativeLibraryPaths(pkg, mAppLib32InstallDir);
    }
    // the same UID correctly.
    if (mPlatformPackage == pkg) {
        pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
    }
    // account.
    if ((scanFlags & SCAN_NO_DEX) == 0 && (scanFlags & SCAN_NEW_INSTALL) != 0) {
        if (cpuAbiOverride == null && pkgSetting.cpuAbiOverrideString != null) {
            Slog.w(TAG, "Ignoring persisted ABI override " + cpuAbiOverride + " for package " + pkg.packageName);
        }
    }
    pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
    pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
    pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
    // Copy the derived override back to the parsed package, so that we can
    // update the package settings accordingly.
    pkg.cpuAbiOverride = cpuAbiOverride;
    if (DEBUG_ABI_SELECTION) {
        Slog.d(TAG, "Resolved nativeLibraryRoot for " + pkg.applicationInfo.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
    }
    // Push the derived path down into PackageSettings so we know what to
    // clean up at uninstall time.
    pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
    if (DEBUG_ABI_SELECTION) {
        Log.d(TAG, "Abis for package[" + pkg.packageName + "] are" + " primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
    }
    // SIDE EFFECTS; removes DEX files from disk; move elsewhere
    if ((scanFlags & SCAN_BOOTING) == 0 && pkgSetting.sharedUser != null) {
        // We don't do this here during boot because we can do it all
        // at once after scanning all existing packages.
        // 
        // We also do this *before* we perform dexopt on this package, so that
        // we can avoid redundant dexopts, and also to make sure we've got the
        // code and package path correct.
        adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);
    }
    if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST;
    }
    if (isSystemApp(pkg)) {
        pkgSetting.isOrphaned = true;
    }
    // Take care of first install / last update times.
    final long scanFileTime = getLastModifiedTime(pkg, scanFile);
    if (currentTime != 0) {
        if (pkgSetting.firstInstallTime == 0) {
            pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;
        } else if ((scanFlags & SCAN_UPDATE_TIME) != 0) {
            pkgSetting.lastUpdateTime = currentTime;
        }
    } else if (pkgSetting.firstInstallTime == 0) {
        // We need *something*.  Take time time stamp of the file.
        pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;
    } else if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {
        if (scanFileTime != pkgSetting.timeStamp) {
            // A package on the system image has changed; consider this
            // to be an update.
            pkgSetting.lastUpdateTime = scanFileTime;
        }
    }
    pkgSetting.setTimeStamp(scanFileTime);
    if ((scanFlags & SCAN_CHECK_ONLY) != 0) {
        if (nonMutatedPs != null) {
            synchronized (mPackages) {
                mSettings.mPackages.put(nonMutatedPs.name, nonMutatedPs);
            }
        }
    } else {
        final int userId = user == null ? 0 : user.getIdentifier();
        // Modify state for the given package setting
        commitPackageSettings(pkg, pkgSetting, user, scanFlags, (policyFlags & PackageParser.PARSE_CHATTY) != 0);
        if (pkgSetting.getInstantApp(userId)) {
            mInstantAppRegistry.addInstantAppLPw(userId, pkgSetting.appId);
        }
    }
    return pkg;
}
#method_after
private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, final int policyFlags, final int scanFlags, long currentTime, @Nullable UserHandle user) throws PackageManagerException {
    if (DEBUG_PACKAGE_SCANNING) {
        if ((policyFlags & PackageParser.PARSE_CHATTY) != 0)
            Log.d(TAG, "Scanning package " + pkg.packageName);
    }
    applyPolicy(pkg, policyFlags);
    assertPackageIsValid(pkg, policyFlags, scanFlags);
    if (Build.IS_DEBUGGABLE && pkg.isPrivilegedApp() && !SystemProperties.getBoolean("pm.dexopt.priv-apps", true)) {
        PackageManagerServiceUtils.logPackageHasUncompressedCode(pkg);
    }
    // Initialize package source and resource directories
    final File scanFile = new File(pkg.codePath);
    final File destCodeFile = new File(pkg.applicationInfo.getCodePath());
    final File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
    SharedUserSetting suid = null;
    PackageSetting pkgSetting = null;
    // Getting the package setting may have a side-effect, so if we
    // are only checking if scan would succeed, stash a copy of the
    // old setting to restore at the end.
    PackageSetting nonMutatedPs = null;
    // We keep references to the derived CPU Abis from settings in oder to reuse
    // them in the case where we're not upgrading or booting for the first time.
    String primaryCpuAbiFromSettings = null;
    String secondaryCpuAbiFromSettings = null;
    boolean needToDeriveAbi = (scanFlags & SCAN_FIRST_BOOT_OR_UPGRADE) != 0;
    // writer
    synchronized (mPackages) {
        if (pkg.mSharedUserId != null) {
            // SIDE EFFECTS; may potentially allocate a new shared user
            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, /*pkgFlags*/
            0, /*pkgPrivateFlags*/
            true);
            if (DEBUG_PACKAGE_SCANNING) {
                if ((policyFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + suid.userId + "): packages=" + suid.packages);
            }
        }
        // Check if we are renaming from an original package name.
        PackageSetting origPackage = null;
        String realName = null;
        if (pkg.mOriginalPackages != null) {
            // This package may need to be renamed to a previously
            // installed name.  Let's check on that...
            final String renamed = mSettings.getRenamedPackageLPr(pkg.mRealPackage);
            if (pkg.mOriginalPackages.contains(renamed)) {
                // This package had originally been installed as the
                // original name, and we have already taken care of
                // transitioning to the new one.  Just update the new
                // one to continue using the old name.
                realName = pkg.mRealPackage;
                if (!pkg.packageName.equals(renamed)) {
                    // Callers into this function may have already taken
                    // care of renaming the package; only do it here if
                    // it is not already done.
                    pkg.setPackageName(renamed);
                }
            } else {
                for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
                    if ((origPackage = mSettings.getPackageLPr(pkg.mOriginalPackages.get(i))) != null) {
                        // original name...  should we use it?
                        if (!verifyPackageUpdateLPr(origPackage, pkg)) {
                            // New package is not compatible with original.
                            origPackage = null;
                            continue;
                        } else if (origPackage.sharedUser != null) {
                            // Make sure uid is compatible between packages.
                            if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                                Slog.w(TAG, "Unable to migrate data from " + origPackage.name + " to " + pkg.packageName + ": old uid " + origPackage.sharedUser.name + " differs from " + pkg.mSharedUserId);
                                origPackage = null;
                                continue;
                            }
                        // TODO: Add case when shared user id is added [b/28144775]
                        } else {
                            if (DEBUG_UPGRADE)
                                Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + origPackage.name);
                        }
                        break;
                    }
                }
            }
        }
        if (mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        // See comments in nonMutatedPs declaration
        if ((scanFlags & SCAN_CHECK_ONLY) != 0) {
            PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName);
            if (foundPs != null) {
                nonMutatedPs = new PackageSetting(foundPs);
            }
        }
        if (!needToDeriveAbi) {
            PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName);
            if (foundPs != null) {
                primaryCpuAbiFromSettings = foundPs.primaryCpuAbiString;
                secondaryCpuAbiFromSettings = foundPs.secondaryCpuAbiString;
            } else {
                // when re-adding a system package failed after uninstalling updates.
                needToDeriveAbi = true;
            }
        }
        pkgSetting = mSettings.getPackageLPr(pkg.packageName);
        if (pkgSetting != null && pkgSetting.sharedUser != suid) {
            PackageManagerService.reportSettingsProblem(Log.WARN, "Package " + pkg.packageName + " shared user changed from " + (pkgSetting.sharedUser != null ? pkgSetting.sharedUser.name : "<nothing>") + " to " + (suid != null ? suid.name : "<nothing>") + "; replacing with new");
            pkgSetting = null;
        }
        final PackageSetting oldPkgSetting = pkgSetting == null ? null : new PackageSetting(pkgSetting);
        final PackageSetting disabledPkgSetting = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
        String[] usesStaticLibraries = null;
        if (pkg.usesStaticLibraries != null) {
            usesStaticLibraries = new String[pkg.usesStaticLibraries.size()];
            pkg.usesStaticLibraries.toArray(usesStaticLibraries);
        }
        if (pkgSetting == null) {
            final String parentPackageName = (pkg.parentPackage != null) ? pkg.parentPackage.packageName : null;
            final boolean instantApp = (scanFlags & SCAN_AS_INSTANT_APP) != 0;
            // REMOVE SharedUserSetting from method; update in a separate call
            pkgSetting = Settings.createNewSetting(pkg.packageName, origPackage, disabledPkgSetting, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.mVersionCode, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, true, /*allowInstall*/
            instantApp, parentPackageName, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
            // SIDE EFFECTS; updates system state; move elsewhere
            if (origPackage != null) {
                mSettings.addRenamedPackageLPw(pkg.packageName, origPackage.name);
            }
            mSettings.addUserToSettingLPw(pkgSetting);
        } else {
            // REMOVE SharedUserSetting from method; update in a separate call.
            // 
            // TODO(narayan): This update is bogus. nativeLibraryDir & primaryCpuAbi,
            // secondaryCpuAbi are not known at this point so we always update them
            // to null here, only to reset them at a later point.
            Settings.updatePackageSetting(pkgSetting, disabledPkgSetting, suid, destCodeFile, pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
        }
        // SIDE EFFECTS; persists system state to files on disk; move elsewhere
        mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting);
        // SIDE EFFECTS; modifies system state; move elsewhere
        if (pkgSetting.origPackage != null) {
            // If we are first transitioning from an original package,
            // fix up the new package's name now.  We need to do this after
            // looking up the package under its new name, so getPackageLP
            // can take care of fiddling things correctly.
            pkg.setPackageName(origPackage.name);
            // File a report about this.
            String msg = "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name;
            reportSettingsProblem(Log.WARN, msg);
            // Make a note of it.
            if ((scanFlags & SCAN_CHECK_ONLY) == 0) {
                mTransferedPackages.add(origPackage.name);
            }
            // No longer need to retain this.
            pkgSetting.origPackage = null;
        }
        // SIDE EFFECTS; modifies system state; move elsewhere
        if ((scanFlags & SCAN_CHECK_ONLY) == 0 && realName != null) {
            // Make a note of it.
            mTransferedPackages.add(pkg.packageName);
        }
        if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) {
            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
        }
        if ((scanFlags & SCAN_BOOTING) == 0 && (policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
            // Check all shared libraries and map to their actual file path.
            // We only do this here for apps not on a system dir, because those
            // are the only ones that can fail an install due to this.  We
            // will take care of the system apps by updating all of their
            // library paths after the scan is done. Also during the initial
            // scan don't update any libs as we do this wholesale after all
            // apps are scanned to avoid dependency based scanning.
            updateSharedLibrariesLPr(pkg, null);
        }
        if (mFoundPolicyFile) {
            SELinuxMMAC.assignSeInfoValue(pkg);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        pkg.mExtras = pkgSetting;
        // Static shared libs have same package with different versions where
        // we internally use a synthetic package name to allow multiple versions
        // of the same package, therefore we need to compare signatures against
        // the package setting for the latest library version.
        PackageSetting signatureCheckPs = pkgSetting;
        if (pkg.applicationInfo.isStaticSharedLibrary()) {
            SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
            if (libraryEntry != null) {
                signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);
            }
        }
        if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
            if (checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } else {
                if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                } else {
                    pkgSetting.signatures.mSignatures = pkg.mSignatures;
                    String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                    reportSettingsProblem(Log.WARN, msg);
                }
            }
        } else {
            try {
                // SIDE EFFECTS; compareSignaturesCompat() changes KeysetManagerService
                verifySignaturesLP(signatureCheckPs, pkg);
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } catch (PackageManagerException e) {
                if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw e;
                }
                // The signature has changed, but this package is in the system
                // image...  let's recover!
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
                // that unreasonable.
                if (signatureCheckPs.sharedUser != null) {
                    if (compareSignatures(signatureCheckPs.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                        throw new PackageManagerException(INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, "Signature mismatch for shared user: " + pkgSetting.sharedUser);
                    }
                }
                // File a report about this.
                String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                reportSettingsProblem(Log.WARN, msg);
            }
        }
        if ((scanFlags & SCAN_CHECK_ONLY) == 0 && pkg.mAdoptPermissions != null) {
            // another package.
            for (int i = pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
                final String origName = pkg.mAdoptPermissions.get(i);
                final PackageSetting orig = mSettings.getPackageLPr(origName);
                if (orig != null) {
                    if (verifyPackageUpdateLPr(orig, pkg)) {
                        Slog.i(TAG, "Adopting permissions from " + origName + " to " + pkg.packageName);
                        // SIDE EFFECTS; updates permissions system state; move elsewhere
                        mSettings.transferPermissionsLPw(origName, pkg.packageName);
                    }
                }
            }
        }
    }
    pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName);
    if (pkg != mPlatformPackage) {
        // Get all of our default paths setup
        pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM);
    }
    final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
    if ((scanFlags & SCAN_NEW_INSTALL) == 0) {
        if (needToDeriveAbi) {
            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "derivePackageAbi");
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, scanFile, cpuAbiOverride, extractNativeLibs, mAppLib32InstallDir);
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
            // structure. Try to detect abi based on directory structure.
            if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
                setBundledAppAbisAndRoots(pkg, pkgSetting);
                setNativeLibraryPaths(pkg, mAppLib32InstallDir);
            }
        } else {
            // This is not a first boot or an upgrade, don't bother deriving the
            // ABI during the scan. Instead, trust the value that was stored in the
            // package setting.
            pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings;
            pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings;
            setNativeLibraryPaths(pkg, mAppLib32InstallDir);
            if (DEBUG_ABI_SELECTION) {
                Slog.i(TAG, "Using ABIS and native lib paths from settings : " + pkg.packageName + " " + pkg.applicationInfo.primaryCpuAbi + ", " + pkg.applicationInfo.secondaryCpuAbi);
            }
        }
    } else {
        if ((scanFlags & SCAN_MOVE) != 0) {
            // We haven't run dex-opt for this move (since we've moved the compiled output too)
            // but we already have this packages package info in the PackageSetting. We just
            // use that and derive the native library path based on the new codepath.
            pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
        }
        // Set native library paths again. For moves, the path will be updated based on the
        // ABIs we've determined above. For non-moves, the path will be updated based on the
        // ABIs we determined during compilation, but the path will depend on the final
        // package path (after the rename away from the stage path).
        setNativeLibraryPaths(pkg, mAppLib32InstallDir);
    }
    // the same UID correctly.
    if (mPlatformPackage == pkg) {
        pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
    }
    // account.
    if ((scanFlags & SCAN_NO_DEX) == 0 && (scanFlags & SCAN_NEW_INSTALL) != 0) {
        if (cpuAbiOverride == null && pkgSetting.cpuAbiOverrideString != null) {
            Slog.w(TAG, "Ignoring persisted ABI override " + cpuAbiOverride + " for package " + pkg.packageName);
        }
    }
    pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
    pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
    pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
    // Copy the derived override back to the parsed package, so that we can
    // update the package settings accordingly.
    pkg.cpuAbiOverride = cpuAbiOverride;
    if (DEBUG_ABI_SELECTION) {
        Slog.d(TAG, "Resolved nativeLibraryRoot for " + pkg.applicationInfo.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
    }
    // Push the derived path down into PackageSettings so we know what to
    // clean up at uninstall time.
    pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
    if (DEBUG_ABI_SELECTION) {
        Log.d(TAG, "Abis for package[" + pkg.packageName + "] are" + " primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
    }
    // SIDE EFFECTS; removes DEX files from disk; move elsewhere
    if ((scanFlags & SCAN_BOOTING) == 0 && pkgSetting.sharedUser != null) {
        // We don't do this here during boot because we can do it all
        // at once after scanning all existing packages.
        // 
        // We also do this *before* we perform dexopt on this package, so that
        // we can avoid redundant dexopts, and also to make sure we've got the
        // code and package path correct.
        adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);
    }
    if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST;
    }
    if (isSystemApp(pkg)) {
        pkgSetting.isOrphaned = true;
    }
    // Take care of first install / last update times.
    final long scanFileTime = getLastModifiedTime(pkg, scanFile);
    if (currentTime != 0) {
        if (pkgSetting.firstInstallTime == 0) {
            pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;
        } else if ((scanFlags & SCAN_UPDATE_TIME) != 0) {
            pkgSetting.lastUpdateTime = currentTime;
        }
    } else if (pkgSetting.firstInstallTime == 0) {
        // We need *something*.  Take time time stamp of the file.
        pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;
    } else if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {
        if (scanFileTime != pkgSetting.timeStamp) {
            // A package on the system image has changed; consider this
            // to be an update.
            pkgSetting.lastUpdateTime = scanFileTime;
        }
    }
    pkgSetting.setTimeStamp(scanFileTime);
    if ((scanFlags & SCAN_CHECK_ONLY) != 0) {
        if (nonMutatedPs != null) {
            synchronized (mPackages) {
                mSettings.mPackages.put(nonMutatedPs.name, nonMutatedPs);
            }
        }
    } else {
        final int userId = user == null ? 0 : user.getIdentifier();
        // Modify state for the given package setting
        commitPackageSettings(pkg, pkgSetting, user, scanFlags, (policyFlags & PackageParser.PARSE_CHATTY) != 0);
        if (pkgSetting.getInstantApp(userId)) {
            mInstantAppRegistry.addInstantAppLPw(userId, pkgSetting.appId);
        }
    }
    return pkg;
}
#end_block

#method_before
public static boolean readInstallPolicy() {
    // Temp structure to hold the rules while we parse the xml file
    List<Policy> policies = new ArrayList<>();
    FileReader policyFile = null;
    XmlPullParser parser = Xml.newPullParser();
    for (int i = 0; i < MAC_PERMISSIONS.length; i++) {
        if (!MAC_PERMISSIONS[i].exists()) {
            continue;
        }
        try {
            policyFile = new FileReader(MAC_PERMISSIONS[i]);
            Slog.d(TAG, "Using policy file " + MAC_PERMISSIONS[i]);
            parser.setInput(policyFile);
            parser.nextTag();
            parser.require(XmlPullParser.START_TAG, null, "policy");
            while (parser.next() != XmlPullParser.END_TAG) {
                if (parser.getEventType() != XmlPullParser.START_TAG) {
                    continue;
                }
                switch(parser.getName()) {
                    case "signer":
                        policies.add(readSignerOrThrow(parser));
                        break;
                    default:
                        skip(parser);
                }
            }
        } catch (IllegalStateException | IllegalArgumentException | XmlPullParserException ex) {
            StringBuilder sb = new StringBuilder("Exception @");
            sb.append(parser.getPositionDescription());
            sb.append(" while parsing ");
            sb.append(MAC_PERMISSIONS[i]);
            sb.append(":");
            sb.append(ex);
            Slog.w(TAG, sb.toString());
            return false;
        } catch (IOException ioe) {
            Slog.w(TAG, "Exception parsing " + MAC_PERMISSIONS[i], ioe);
            return false;
        } finally {
            IoUtils.closeQuietly(policyFile);
        }
    }
    // Now sort the policy stanzas
    PolicyComparator policySort = new PolicyComparator();
    Collections.sort(policies, policySort);
    if (policySort.foundDuplicate()) {
        Slog.w(TAG, "ERROR! Duplicate entries found parsing mac_permissions.xml files");
        return false;
    }
    synchronized (sPolicies) {
        sPolicies = policies;
        if (DEBUG_POLICY_ORDER) {
            for (Policy policy : sPolicies) {
                Slog.d(TAG, "Policy: " + policy.toString());
            }
        }
    }
    return true;
}
#method_after
public static boolean readInstallPolicy() {
    // Temp structure to hold the rules while we parse the xml file
    List<Policy> policies = new ArrayList<>();
    FileReader policyFile = null;
    XmlPullParser parser = Xml.newPullParser();
    synchronized (sMacPermissions) {
        // Only initialize it once.
        if (sMacPermissions.isEmpty()) {
            // Platform mac permissions.
            sMacPermissions.add(new File(Environment.getRootDirectory(), "/etc/selinux/plat_mac_permissions.xml"));
            // Vendor mac permissions.
            // The filename has been renamed from nonplat_mac_permissions to
            // vendor_mac_permissions. Either of them should exist.
            File vendorMacPermission = new File(Environment.getVendorDirectory(), "/etc/selinux/vendor_mac_permissions.xml");
            if (vendorMacPermission.exists()) {
                sMacPermissions.add(vendorMacPermission);
            } else {
                // For backward compatibility.
                sMacPermissions.add(new File(Environment.getVendorDirectory(), "/etc/selinux/nonplat_mac_permissions.xml"));
            }
            // ODM mac permissions (optional).
            File odmMacPermission = new File(Environment.getOdmDirectory(), "/etc/selinux/odm_mac_permissions.xml");
            if (odmMacPermission.exists()) {
                sMacPermissions.add(odmMacPermission);
            }
        }
    }
    final int count = sMacPermissions.size();
    for (int i = 0; i < count; ++i) {
        File macPermission = sMacPermissions.get(i);
        try {
            policyFile = new FileReader(macPermission);
            Slog.d(TAG, "Using policy file " + macPermission);
            parser.setInput(policyFile);
            parser.nextTag();
            parser.require(XmlPullParser.START_TAG, null, "policy");
            while (parser.next() != XmlPullParser.END_TAG) {
                if (parser.getEventType() != XmlPullParser.START_TAG) {
                    continue;
                }
                switch(parser.getName()) {
                    case "signer":
                        policies.add(readSignerOrThrow(parser));
                        break;
                    default:
                        skip(parser);
                }
            }
        } catch (IllegalStateException | IllegalArgumentException | XmlPullParserException ex) {
            StringBuilder sb = new StringBuilder("Exception @");
            sb.append(parser.getPositionDescription());
            sb.append(" while parsing ");
            sb.append(macPermission);
            sb.append(":");
            sb.append(ex);
            Slog.w(TAG, sb.toString());
            return false;
        } catch (IOException ioe) {
            Slog.w(TAG, "Exception parsing " + macPermission, ioe);
            return false;
        } finally {
            IoUtils.closeQuietly(policyFile);
        }
    }
    // Now sort the policy stanzas
    PolicyComparator policySort = new PolicyComparator();
    Collections.sort(policies, policySort);
    if (policySort.foundDuplicate()) {
        Slog.w(TAG, "ERROR! Duplicate entries found parsing mac_permissions.xml files");
        return false;
    }
    synchronized (sPolicies) {
        sPolicies = policies;
        if (DEBUG_POLICY_ORDER) {
            for (Policy policy : sPolicies) {
                Slog.d(TAG, "Policy: " + policy.toString());
            }
        }
    }
    return true;
}
#end_block

#method_before
// / CHECK-START: void Main.staticallyAligned(int[]) loop_optimization (before)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<One>>,<<AddI:i\d+>>]          loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Phi>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Phi>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyAligned(int[]) loop_optimization (after)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Nrm>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Nrm>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                 loop:<<Loop>>      outer_loop:none
// 
// / CHECK-NOT:                ArrayGet
static void staticallyAligned(int[] a) {
    // So no peeling, aligned vector, no cleanup.
    for (int i = 1; i < 9; i++) {
        a[i] += 1;
    }
}
#method_after
// / CHECK-START: void Main.staticallyAligned(int[]) loop_optimization (before)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<One>>,<<AddI:i\d+>>]          loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Phi>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Phi>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyAligned(int[]) loop_optimization (after)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]                            loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Phi>>,<<One>>]                                   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Nrm>>]          alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Nrm>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                                    loop:<<Loop>>      outer_loop:none
// 
// / CHECK-NOT:                ArrayGet
static void staticallyAligned(int[] a) {
    // So no peeling, aligned vector, no cleanup.
    for (int i = 1; i < 9; i++) {
        a[i] += 1;
    }
}
#end_block

#method_before
// / CHECK-START: void Main.staticallyAlignedN(int[]) loop_optimization (before)
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Par:l\d+>>   NullCheck                            loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<One>>,<<AddI:i\d+>>]          loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Phi>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Phi>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyAlignedN(int[]) loop_optimization (after)
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<Par:l\d+>>   NullCheck                            loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Nrm>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Nrm>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                 loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<PhiC:i\d+>>  Phi [<<Phi>>,<<AddIC:i\d+>>]         loop:<<Clean:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmC:i\d+>>  Add [<<PhiC>>,<<One>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<NrmC>>]          loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<AddC:i\d+>>  Add [<<Get>>,<<One>>]                loop:<<Clean>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmC>>,<<AddC>>] loop:<<Clean>>      outer_loop:none
static void staticallyAlignedN(int[] a) {
    // So no peeling, aligned vector, cleanup.
    for (int i = 1; i < a.length; i++) {
        a[i] += 1;
    }
}
#method_after
// / CHECK-START: void Main.staticallyAlignedN(int[]) loop_optimization (before)
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Par:l\d+>>   NullCheck                            loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<One>>,<<AddI:i\d+>>]          loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Phi>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Phi>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyAlignedN(int[]) loop_optimization (after)
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<Par:l\d+>>   NullCheck                            loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]                            loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Phi>>,<<One>>]                                   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Nrm>>]          alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Nrm>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                                    loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<PhiC:i\d+>>  Phi [<<Phi>>,<<AddIC:i\d+>>]         loop:<<Clean:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmC:i\d+>>  Add [<<PhiC>>,<<One>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<NrmC>>]          loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<AddC:i\d+>>  Add [<<Get>>,<<One>>]                loop:<<Clean>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmC>>,<<AddC>>] loop:<<Clean>>      outer_loop:none
static void staticallyAlignedN(int[] a) {
    // So no peeling, aligned vector, cleanup.
    for (int i = 1; i < a.length; i++) {
        a[i] += 1;
    }
}
#end_block

#method_before
// / CHECK-START: void Main.staticallyMisaligned(int[]) loop_optimization (before)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Phi>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Phi>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyMisaligned(int[]) loop_optimization (after)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<PhiP:i\d+>>  Phi [<<Zero>>,<<AddIP:i\d+>>]        loop:<<Peel:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<PhiP>>]          loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddP:i\d+>>  Add [<<Get>>,<<One>>]                loop:<<Peel>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<PhiP>>,<<AddP>>] loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddIP>>      Add [<<PhiP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<PhiP>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Phi>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Phi>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                 loop:<<Loop>>      outer_loop:none
// 
// / CHECK-NOT:                ArrayGet
static void staticallyMisaligned(int[] a) {
    // Static peeling to the rescue, aligned vector, no cleanup.
    for (int i = 0; i < 9; i++) {
        a[i] += 1;
    }
}
#method_after
// / CHECK-START: void Main.staticallyMisaligned(int[]) loop_optimization (before)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Phi>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Phi>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyMisaligned(int[]) loop_optimization (after)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<PhiP:i\d+>>  Phi [<<Zero>>,<<AddIP:i\d+>>]        loop:<<Peel:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<PhiP>>]          loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddP:i\d+>>  Add [<<Get>>,<<One>>]                loop:<<Peel>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<PhiP>>,<<AddP>>] loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddIP>>      Add [<<PhiP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<PhiP>>,<<AddI:i\d+>>]                            loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Phi>>]          alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Phi>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                                    loop:<<Loop>>      outer_loop:none
// 
// / CHECK-NOT:                ArrayGet
static void staticallyMisaligned(int[] a) {
    // Static peeling to the rescue, aligned vector, no cleanup.
    for (int i = 0; i < 9; i++) {
        a[i] += 1;
    }
}
#end_block

#method_before
// / CHECK-START: void Main.staticallyMisalignedN(int[]) loop_optimization (before)
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                       loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Par:l\d+>>   NullCheck                           loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]        loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Phi>>]          loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Phi>>,<<Add>>]  loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]               loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyMisalignedN(int[]) loop_optimization (after)
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<Par:l\d+>>   NullCheck                            loop:none
// / CHECK-DAG: <<PhiP:i\d+>>  Phi [<<Zero>>,<<AddIP:i\d+>>]        loop:<<Peel:B\d+>> outer_loop:none
// / CHECK-DAG: <<GetP:i\d+>>  ArrayGet [<<Par>>,<<PhiP>>]          loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddP:i\d+>>  Add [<<GetP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<PhiP>>,<<AddP>>] loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddIP>>      Add [<<PhiP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<PhiP>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Phi>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Phi>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                 loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<PhiC:i\d+>>  Phi [<<Phi>>,<<AddIC:i\d+>>]         loop:<<Clean:B\d+>> outer_loop:none
// / CHECK-DAG: <<GetC:i\d+>>  ArrayGet [<<Par>>,<<PhiC>>]          loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<AddC:i\d+>>  Add [<<GetC>>,<<One>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<PhiC>>,<<AddC>>] loop:<<Clean>>      outer_loop:none
static void staticallyMisalignedN(int[] a) {
    // Static peeling to the rescue, aligned vector, cleanup.
    for (int i = 0; i < a.length; i++) {
        a[i] += 1;
    }
}
#method_after
// / CHECK-START: void Main.staticallyMisalignedN(int[]) loop_optimization (before)
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                       loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Par:l\d+>>   NullCheck                           loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]        loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Phi>>]          loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Phi>>,<<Add>>]  loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]               loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyMisalignedN(int[]) loop_optimization (after)
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<Par:l\d+>>   NullCheck                            loop:none
// / CHECK-DAG: <<PhiP:i\d+>>  Phi [<<Zero>>,<<AddIP:i\d+>>]        loop:<<Peel:B\d+>> outer_loop:none
// / CHECK-DAG: <<GetP:i\d+>>  ArrayGet [<<Par>>,<<PhiP>>]          loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddP:i\d+>>  Add [<<GetP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<PhiP>>,<<AddP>>] loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddIP>>      Add [<<PhiP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<PhiP>>,<<AddI:i\d+>>]                            loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Phi>>]          alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Phi>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                                    loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<PhiC:i\d+>>  Phi [<<Phi>>,<<AddIC:i\d+>>]         loop:<<Clean:B\d+>> outer_loop:none
// / CHECK-DAG: <<GetC:i\d+>>  ArrayGet [<<Par>>,<<PhiC>>]          loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<AddC:i\d+>>  Add [<<GetC>>,<<One>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<PhiC>>,<<AddC>>] loop:<<Clean>>      outer_loop:none
static void staticallyMisalignedN(int[] a) {
    // Static peeling to the rescue, aligned vector, cleanup.
    for (int i = 0; i < a.length; i++) {
        a[i] += 1;
    }
}
#end_block

#method_before
// / CHECK-START: void Main.staticallyUnknownAligned(int[], int) loop_optimization (before)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Off:i\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Off>>,<<Phi>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Nrm>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Nrm>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyUnknownAligned(int[], int) loop_optimization (after)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Off:i\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<PhiP:i\d+>>  Phi [<<Zero>>,<<AddIP:i\d+>>]        loop:<<Peel:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmP:i\d+>>  Add [<<PhiP>>,<<Off>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<NrmP>>]          loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddP:i\d+>>  Add [<<Get>>,<<One>>]                loop:<<Peel>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmP>>,<<AddP>>] loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddIP>>      Add [<<PhiP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<PhiP>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Phi>>,<<Off>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Nrm>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Nrm>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                 loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<PhiC:i\d+>>  Phi [<<Phi>>,<<AddIC:i\d+>>]         loop:<<Clean:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmC:i\d+>>  Add [<<PhiC>>,<<Off>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<GetC:i\d+>>  ArrayGet [<<Par>>,<<NrmC>>]          loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<AddC:i\d+>>  Add [<<GetC>>,<<One>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmC>>,<<AddC>>] loop:<<Clean>>      outer_loop:none
static void staticallyUnknownAligned(int[] a, int off) {
    // Dynamic peeling to the rescue, aligned vector, cleanup.
    for (int i = 0; i < 9; i++) {
        a[off + i] += 1;
    }
}
#method_after
// / CHECK-START: void Main.staticallyUnknownAligned(int[], int) loop_optimization (before)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Off:i\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Off>>,<<Phi>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Nrm>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Nrm>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyUnknownAligned(int[], int) loop_optimization (after)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Off:i\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<PhiP:i\d+>>  Phi [<<Zero>>,<<AddIP:i\d+>>]        loop:<<Peel:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmP:i\d+>>  Add [<<PhiP>>,<<Off>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<NrmP>>]          loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddP:i\d+>>  Add [<<Get>>,<<One>>]                loop:<<Peel>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmP>>,<<AddP>>] loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddIP>>      Add [<<PhiP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<PhiP>>,<<AddI:i\d+>>]                            loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Phi>>,<<Off>>]                                   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Nrm>>]          alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Nrm>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                                    loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<PhiC:i\d+>>  Phi [<<Phi>>,<<AddIC:i\d+>>]         loop:<<Clean:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmC:i\d+>>  Add [<<PhiC>>,<<Off>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<GetC:i\d+>>  ArrayGet [<<Par>>,<<NrmC>>]          loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<AddC:i\d+>>  Add [<<GetC>>,<<One>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmC>>,<<AddC>>] loop:<<Clean>>      outer_loop:none
static void staticallyUnknownAligned(int[] a, int off) {
    // Dynamic peeling to the rescue, aligned vector, cleanup.
    for (int i = 0; i < 9; i++) {
        a[off + i] += 1;
    }
}
#end_block

#method_before
// / CHECK-START: void Main.staticallyUnknownAlignedN(int[], int, int) loop_optimization (before)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Off:i\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Off>>,<<Phi>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Nrm>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Nrm>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyUnknownAlignedN(int[], int, int) loop_optimization (after)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Off:i\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<PhiP:i\d+>>  Phi [<<Zero>>,<<AddIP:i\d+>>]        loop:<<Peel:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmP:i\d+>>  Add [<<PhiP>>,<<Off>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<NrmP>>]          loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddP:i\d+>>  Add [<<Get>>,<<One>>]                loop:<<Peel>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmP>>,<<AddP>>] loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddIP>>      Add [<<PhiP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<PhiP>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Phi>>,<<Off>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Nrm>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Nrm>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>> outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                 loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<PhiC:i\d+>>  Phi [<<Phi>>,<<AddIC:i\d+>>]         loop:<<Clean:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmC:i\d+>>  Add [<<PhiC>>,<<Off>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<GetC:i\d+>>  ArrayGet [<<Par>>,<<NrmC>>]          loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<AddC:i\d+>>  Add [<<GetC>>,<<One>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmC>>,<<AddC>>] loop:<<Clean>>      outer_loop:none
static void staticallyUnknownAlignedN(int[] a, int off, int n) {
    // Dynamic peeling to the rescue, aligned vector, cleanup.
    for (int i = 0; i < n; i++) {
        a[off + i] += 1;
    }
}
#method_after
// / CHECK-START: void Main.staticallyUnknownAlignedN(int[], int, int) loop_optimization (before)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Off:i\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<Zero>>,<<AddI:i\d+>>]         loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Off>>,<<Phi>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<Nrm>>]           loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>   Add [<<Get>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<Nrm>>,<<Add>>]   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<One>>]                loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM: void Main.staticallyUnknownAlignedN(int[], int, int) loop_optimization (after)
// / CHECK-DAG: <<Par:l\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Off:i\d+>>   ParameterValue                       loop:none
// / CHECK-DAG: <<Zero:i\d+>>  IntConstant 0                        loop:none
// / CHECK-DAG: <<One:i\d+>>   IntConstant 1                        loop:none
// / CHECK-DAG: <<Vl:i\d+>>    IntConstant 2                        loop:none
// / CHECK-DAG: <<PhiP:i\d+>>  Phi [<<Zero>>,<<AddIP:i\d+>>]        loop:<<Peel:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmP:i\d+>>  Add [<<PhiP>>,<<Off>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Get:i\d+>>   ArrayGet [<<Par>>,<<NrmP>>]          loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddP:i\d+>>  Add [<<Get>>,<<One>>]                loop:<<Peel>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmP>>,<<AddP>>] loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<AddIP>>      Add [<<PhiP>>,<<One>>]               loop:<<Peel>>      outer_loop:none
// / CHECK-DAG: <<Repl:d\d+>>  VecReplicateScalar [<<One>>]         loop:none
// / CHECK-DAG: <<Phi:i\d+>>   Phi [<<PhiP>>,<<AddI:i\d+>>]                            loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Nrm:i\d+>>   Add [<<Phi>>,<<Off>>]                                   loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Load:d\d+>>  VecLoad [<<Par>>,<<Nrm>>]          alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:d\d+>>   VecAdd [<<Load>>,<<Repl>>]                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:                VecStore [<<Par>>,<<Nrm>>,<<Add>>] alignment:ALIGN(8,0) loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<AddI>>       Add [<<Phi>>,<<Vl>>]                                    loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<PhiC:i\d+>>  Phi [<<Phi>>,<<AddIC:i\d+>>]         loop:<<Clean:B\d+>> outer_loop:none
// / CHECK-DAG: <<NrmC:i\d+>>  Add [<<PhiC>>,<<Off>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<GetC:i\d+>>  ArrayGet [<<Par>>,<<NrmC>>]          loop:<<Clean>>      outer_loop:none
// / CHECK-DAG: <<AddC:i\d+>>  Add [<<GetC>>,<<One>>]               loop:<<Clean>>      outer_loop:none
// / CHECK-DAG:                ArraySet [<<Par>>,<<NrmC>>,<<AddC>>] loop:<<Clean>>      outer_loop:none
static void staticallyUnknownAlignedN(int[] a, int off, int n) {
    // Dynamic peeling to the rescue, aligned vector, cleanup.
    for (int i = 0; i < n; i++) {
        a[off + i] += 1;
    }
}
#end_block

#method_before
@Test
public void testSocketResourceTrackerLimitation() throws Exception {
    List<IpSecUdpEncapResponse> openUdpEncapSockets = new ArrayList<IpSecUdpEncapResponse>();
    // Reserve sockets until it fails.
    for (int i = 0; i < MAX_NUM_ENCAP_SOCKETS; i++) {
        IpSecUdpEncapResponse newUdpEncapSocket = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
        assertNotNull(newUdpEncapSocket);
        if (IpSecManager.Status.OK != newUdpEncapSocket.status) {
            break;
        }
        openUdpEncapSockets.add(newUdpEncapSocket);
    }
    // Assert that the total sockets quota has a reasonable limit.
    assertTrue("Number of open UDP encap sockets is negative", openUdpEncapSockets.size() > 0);
    assertTrue("Number of open UDP encap sockets is out of bound", openUdpEncapSockets.size() < MAX_NUM_ENCAP_SOCKETS);
    // Try to reserve one more UDP encapsulation socket, and should fail.
    IpSecUdpEncapResponse extraUdpEncapSocket = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(extraUdpEncapSocket);
    assertEquals(IpSecManager.Status.RESOURCE_UNAVAILABLE, extraUdpEncapSocket.status);
    // Close one of the open UDP encapsulation sockets.
    mIpSecService.closeUdpEncapsulationSocket(openUdpEncapSockets.get(0).resourceId);
    openUdpEncapSockets.get(0).fileDescriptor.close();
    openUdpEncapSockets.remove(0);
    // Try to reserve one more UDP encapsulation socket, and should be successful.
    extraUdpEncapSocket = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(extraUdpEncapSocket);
    assertEquals(IpSecManager.Status.OK, extraUdpEncapSocket.status);
    openUdpEncapSockets.add(extraUdpEncapSocket);
    // Close open UDP sockets.
    for (IpSecUdpEncapResponse openSocket : openUdpEncapSockets) {
        mIpSecService.closeUdpEncapsulationSocket(openSocket.resourceId);
        openSocket.fileDescriptor.close();
    }
}
#method_after
@Test
public void testSocketResourceTrackerLimitation() throws Exception {
    List<IpSecUdpEncapResponse> openUdpEncapSockets = new ArrayList<IpSecUdpEncapResponse>();
    // Reserve sockets until it fails.
    for (int i = 0; i < MAX_NUM_ENCAP_SOCKETS; i++) {
        IpSecUdpEncapResponse newUdpEncapSocket = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
        assertNotNull(newUdpEncapSocket);
        if (IpSecManager.Status.OK != newUdpEncapSocket.status) {
            break;
        }
        openUdpEncapSockets.add(newUdpEncapSocket);
    }
    // Assert that the total sockets quota has a reasonable limit.
    assertTrue("No UDP encap socket was open", !openUdpEncapSockets.isEmpty());
    assertTrue("Number of open UDP encap sockets is out of bound", openUdpEncapSockets.size() < MAX_NUM_ENCAP_SOCKETS);
    // Try to reserve one more UDP encapsulation socket, and should fail.
    IpSecUdpEncapResponse extraUdpEncapSocket = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(extraUdpEncapSocket);
    assertEquals(IpSecManager.Status.RESOURCE_UNAVAILABLE, extraUdpEncapSocket.status);
    // Close one of the open UDP encapsulation sockets.
    mIpSecService.closeUdpEncapsulationSocket(openUdpEncapSockets.get(0).resourceId);
    openUdpEncapSockets.get(0).fileDescriptor.close();
    openUdpEncapSockets.remove(0);
    // Try to reserve one more UDP encapsulation socket, and should be successful.
    extraUdpEncapSocket = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(extraUdpEncapSocket);
    assertEquals(IpSecManager.Status.OK, extraUdpEncapSocket.status);
    openUdpEncapSockets.add(extraUdpEncapSocket);
    // Close open UDP sockets.
    for (IpSecUdpEncapResponse openSocket : openUdpEncapSockets) {
        mIpSecService.closeUdpEncapsulationSocket(openSocket.resourceId);
        openSocket.fileDescriptor.close();
    }
}
#end_block

#method_before
@Override
public int getDisplayRule(String plmn) {
    // TODO together with spn
    return 0;
}
#method_after
@Override
public int getDisplayRule(ServiceState serviceState) {
    // TODO together with spn
    return 0;
}
#end_block

#method_before
@Override
public int getDisplayRule(String plmn) {
    // Not applicable to Isim
    return 0;
}
#method_after
@Override
public int getDisplayRule(ServiceState serviceState) {
    // Not applicable to Isim
    return 0;
}
#end_block

#method_before
@Override
public String toString() {
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    return "mDestroyed=" + mDestroyed + " mContext=" + mContext + " mCi=" + mCi + " mFh=" + mFh + " mParentApp=" + mParentApp + " recordsLoadedRegistrants=" + mRecordsLoadedRegistrants + " mImsiReadyRegistrants=" + mImsiReadyRegistrants + " mRecordsEventsRegistrants=" + mRecordsEventsRegistrants + " mNewSmsRegistrants=" + mNewSmsRegistrants + " mNetworkSelectionModeAutomaticRegistrants=" + mNetworkSelectionModeAutomaticRegistrants + " recordsToLoad=" + mRecordsToLoad + " adnCache=" + mAdnCache + " recordsRequested=" + mRecordsRequested + " lockedRecordsRequested=" + mLockedRecordsRequested + " iccid=" + iccIdToPrint + " msisdnTag=" + mMsisdnTag + " voiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum) + " voiceMailTag=" + mVoiceMailTag + " voiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum) + " newVoiceMailTag=" + mNewVoiceMailTag + " isVoiceMailFixed=" + mIsVoiceMailFixed + " mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null") + (mCarrierTestOverride.isInTestMode() ? (" mFakeImsi=" + ((mFakeImsi != null) ? mFakeImsi : "null")) : "") + " mncLength=" + mMncLength + " mailboxIndex=" + mMailboxIndex + " spn=" + mSpn + (mCarrierTestOverride.isInTestMode() ? (" mFakeSpn=" + ((mFakeSpn != null) ? mFakeSpn : "null")) : "");
}
#method_after
@Override
public String toString() {
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    return "mDestroyed=" + mDestroyed + " mContext=" + mContext + " mCi=" + mCi + " mFh=" + mFh + " mParentApp=" + mParentApp + " recordsToLoad=" + mRecordsToLoad + " adnCache=" + mAdnCache + " recordsRequested=" + mRecordsRequested + " lockedRecordsRequested=" + mLockedRecordsRequested + " iccid=" + iccIdToPrint + " msisdnTag=" + mMsisdnTag + " voiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum) + " voiceMailTag=" + mVoiceMailTag + " voiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum) + " newVoiceMailTag=" + mNewVoiceMailTag + " isVoiceMailFixed=" + mIsVoiceMailFixed + " mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null") + (mCarrierTestOverride.isInTestMode() ? " mFakeImsi=" + mFakeImsi : "") + " mncLength=" + mMncLength + " mailboxIndex=" + mMailboxIndex + " spn=" + mSpn + (mCarrierTestOverride.isInTestMode() ? " mFakeSpn=" + mFakeSpn : "");
}
#end_block

#method_before
public void registerForLockedRecordsLoaded(Handler h, int what, Object obj) {
    if (mDestroyed.get()) {
        return;
    }
    Registrant r = new Registrant(h, what, obj);
    mLockedRecordsLoadedRegistrants.add(r);
    if (mRecordsToLoad == 0 && mLockedRecordsRequested) {
        r.notifyRegistrant(new AsyncResult(null, null, null));
    }
}
#method_after
public void registerForLockedRecordsLoaded(Handler h, int what, Object obj) {
    if (mDestroyed.get()) {
        return;
    }
    Registrant r = new Registrant(h, what, obj);
    mLockedRecordsLoadedRegistrants.add(r);
    if (getLockedRecordsLoaded()) {
        r.notifyRegistrant(new AsyncResult(null, null, null));
    }
}
#end_block

#method_before
protected void setServiceProviderName(String spn) {
    mSpn = spn;
}
#method_after
protected void setServiceProviderName(String spn) {
    if (!TextUtils.equals(mSpn, spn)) {
        mSpnUpdatedRegistrants.notifyRegistrants();
        mSpn = spn;
    }
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("IccRecords: " + this);
    pw.println(" mDestroyed=" + mDestroyed);
    pw.println(" mCi=" + mCi);
    pw.println(" mFh=" + mFh);
    pw.println(" mParentApp=" + mParentApp);
    pw.println(" recordsLoadedRegistrants: size=" + mRecordsLoadedRegistrants.size());
    for (int i = 0; i < mRecordsLoadedRegistrants.size(); i++) {
        pw.println("  recordsLoadedRegistrants[" + i + "]=" + ((Registrant) mRecordsLoadedRegistrants.get(i)).getHandler());
    }
    pw.println(" mImsiReadyRegistrants: size=" + mImsiReadyRegistrants.size());
    for (int i = 0; i < mImsiReadyRegistrants.size(); i++) {
        pw.println("  mImsiReadyRegistrants[" + i + "]=" + ((Registrant) mImsiReadyRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsEventsRegistrants: size=" + mRecordsEventsRegistrants.size());
    for (int i = 0; i < mRecordsEventsRegistrants.size(); i++) {
        pw.println("  mRecordsEventsRegistrants[" + i + "]=" + ((Registrant) mRecordsEventsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNewSmsRegistrants: size=" + mNewSmsRegistrants.size());
    for (int i = 0; i < mNewSmsRegistrants.size(); i++) {
        pw.println("  mNewSmsRegistrants[" + i + "]=" + ((Registrant) mNewSmsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNetworkSelectionModeAutomaticRegistrants: size=" + mNetworkSelectionModeAutomaticRegistrants.size());
    for (int i = 0; i < mNetworkSelectionModeAutomaticRegistrants.size(); i++) {
        pw.println("  mNetworkSelectionModeAutomaticRegistrants[" + i + "]=" + ((Registrant) mNetworkSelectionModeAutomaticRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsRequested=" + mRecordsRequested);
    pw.println(" mLockedRecordsRequested=" + mLockedRecordsRequested);
    pw.println(" mRecordsToLoad=" + mRecordsToLoad);
    pw.println(" mRdnCache=" + mAdnCache);
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    pw.println(" iccid=" + iccIdToPrint);
    pw.println(" mMsisdn=" + Rlog.pii(VDBG, mMsisdn));
    pw.println(" mMsisdnTag=" + mMsisdnTag);
    pw.println(" mVoiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum));
    pw.println(" mVoiceMailTag=" + mVoiceMailTag);
    pw.println(" mNewVoiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum));
    pw.println(" mNewVoiceMailTag=" + mNewVoiceMailTag);
    pw.println(" mIsVoiceMailFixed=" + mIsVoiceMailFixed);
    pw.println(" mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null"));
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeImsi=" + ((mFakeImsi != null) ? mFakeImsi : "null"));
    }
    pw.println(" mMncLength=" + mMncLength);
    pw.println(" mMailboxIndex=" + mMailboxIndex);
    pw.println(" mSpn=" + mSpn);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeSpn=" + ((mFakeSpn != null) ? mFakeSpn : "null"));
    }
    pw.flush();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("IccRecords: " + this);
    pw.println(" mDestroyed=" + mDestroyed);
    pw.println(" mCi=" + mCi);
    pw.println(" mFh=" + mFh);
    pw.println(" mParentApp=" + mParentApp);
    pw.println(" recordsLoadedRegistrants: size=" + mRecordsLoadedRegistrants.size());
    for (int i = 0; i < mRecordsLoadedRegistrants.size(); i++) {
        pw.println("  recordsLoadedRegistrants[" + i + "]=" + ((Registrant) mRecordsLoadedRegistrants.get(i)).getHandler());
    }
    pw.println(" mLockedRecordsLoadedRegistrants: size=" + mLockedRecordsLoadedRegistrants.size());
    for (int i = 0; i < mLockedRecordsLoadedRegistrants.size(); i++) {
        pw.println("  mLockedRecordsLoadedRegistrants[" + i + "]=" + ((Registrant) mLockedRecordsLoadedRegistrants.get(i)).getHandler());
    }
    pw.println(" mImsiReadyRegistrants: size=" + mImsiReadyRegistrants.size());
    for (int i = 0; i < mImsiReadyRegistrants.size(); i++) {
        pw.println("  mImsiReadyRegistrants[" + i + "]=" + ((Registrant) mImsiReadyRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsEventsRegistrants: size=" + mRecordsEventsRegistrants.size());
    for (int i = 0; i < mRecordsEventsRegistrants.size(); i++) {
        pw.println("  mRecordsEventsRegistrants[" + i + "]=" + ((Registrant) mRecordsEventsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNewSmsRegistrants: size=" + mNewSmsRegistrants.size());
    for (int i = 0; i < mNewSmsRegistrants.size(); i++) {
        pw.println("  mNewSmsRegistrants[" + i + "]=" + ((Registrant) mNewSmsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNetworkSelectionModeAutomaticRegistrants: size=" + mNetworkSelectionModeAutomaticRegistrants.size());
    for (int i = 0; i < mNetworkSelectionModeAutomaticRegistrants.size(); i++) {
        pw.println("  mNetworkSelectionModeAutomaticRegistrants[" + i + "]=" + ((Registrant) mNetworkSelectionModeAutomaticRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsRequested=" + mRecordsRequested);
    pw.println(" mLockedRecordsRequested=" + mLockedRecordsRequested);
    pw.println(" mRecordsToLoad=" + mRecordsToLoad);
    pw.println(" mRdnCache=" + mAdnCache);
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    pw.println(" iccid=" + iccIdToPrint);
    pw.println(" mMsisdn=" + Rlog.pii(VDBG, mMsisdn));
    pw.println(" mMsisdnTag=" + mMsisdnTag);
    pw.println(" mVoiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum));
    pw.println(" mVoiceMailTag=" + mVoiceMailTag);
    pw.println(" mNewVoiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum));
    pw.println(" mNewVoiceMailTag=" + mNewVoiceMailTag);
    pw.println(" mIsVoiceMailFixed=" + mIsVoiceMailFixed);
    pw.println(" mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null"));
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeImsi=" + mFakeImsi);
    }
    pw.println(" mMncLength=" + mMncLength);
    pw.println(" mMailboxIndex=" + mMailboxIndex);
    pw.println(" mSpn=" + mSpn);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeSpn=" + mFakeSpn);
    }
    pw.flush();
}
#end_block

#method_before
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        return true;
    }
    return false;
}
#method_after
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        // empty EF_CFIS should be considered as call forward disabled
        for (byte b : data) {
            if (b != (byte) 0xFF) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                if (mImsi != null && mImsi.length() >= 6) {
                    log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                }
                String imsi = getIMSI();
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                    String mccmncCode = imsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(imsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED && imsi.length() >= 3 + mMncLength) {
                    log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    if (mCarrierTestOverride.isInTestMode() && getIMSI() != null) {
                        imsi = getIMSI();
                        try {
                            int mcc = Integer.parseInt(imsi.substring(0, 3));
                            mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            log("[TestMode] mMncLength=" + mMncLength);
                        } catch (NumberFormatException e) {
                            mMncLength = UNKNOWN;
                            loge("[TestMode] Corrupt IMSI! mMncLength=" + mMncLength);
                        }
                    } else {
                        ar = (AsyncResult) msg.obj;
                        data = (byte[]) ar.result;
                        if (ar.exception != null) {
                            break;
                        }
                        log("EF_AD: " + IccUtils.bytesToHexString(data));
                        if (data.length < 3) {
                            log("Corrupt AD data on SIM");
                            break;
                        }
                        if (data.length == 3) {
                            log("MNC length not present in EF_AD");
                            break;
                        }
                        mMncLength = data[3] & 0xf;
                        log("setting4 mMncLength=" + mMncLength);
                    }
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    // IMSI could be a value reading from Sim or a fake IMSI if in the test mode
                    imsi = getIMSI();
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                        String mccmncCode = imsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (imsi != null) {
                            try {
                                int mcc = Integer.parseInt(imsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (imsi != null && mMncLength != UNKNOWN && imsi.length() >= 3 + mMncLength) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                if (mImsi != null && mImsi.length() >= 6) {
                    log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                }
                String imsi = getIMSI();
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                    String mccmncCode = imsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(imsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED && imsi.length() >= 3 + mMncLength) {
                    log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    if (mCarrierTestOverride.isInTestMode() && getIMSI() != null) {
                        imsi = getIMSI();
                        try {
                            int mcc = Integer.parseInt(imsi.substring(0, 3));
                            mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            log("[TestMode] mMncLength=" + mMncLength);
                        } catch (NumberFormatException e) {
                            mMncLength = UNKNOWN;
                            loge("[TestMode] Corrupt IMSI! mMncLength=" + mMncLength);
                        }
                    } else {
                        ar = (AsyncResult) msg.obj;
                        data = (byte[]) ar.result;
                        if (ar.exception != null) {
                            break;
                        }
                        log("EF_AD: " + IccUtils.bytesToHexString(data));
                        if (data.length < 3) {
                            log("Corrupt AD data on SIM");
                            break;
                        }
                        if (data.length == 3) {
                            log("MNC length not present in EF_AD");
                            break;
                        }
                        mMncLength = data[3] & 0xf;
                        log("setting4 mMncLength=" + mMncLength);
                    }
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    // IMSI could be a value reading from Sim or a fake IMSI if in the test mode
                    imsi = getIMSI();
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                        String mccmncCode = imsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (imsi != null) {
                            try {
                                int mcc = Integer.parseInt(imsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (imsi != null && mMncLength != UNKNOWN && imsi.length() >= 3 + mMncLength) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        log("PNN: " + mPnnHomeName);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
@Override
public int getDisplayRule(String plmn) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (isOnMatchingPlmn(plmn)) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#method_after
@Override
public int getDisplayRule(ServiceState serviceState) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (useRoamingFromServiceState() ? !serviceState.getRoaming() : isOnMatchingPlmn(serviceState.getOperatorNumeric())) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid1=" + ((mFakeGid1 != null) ? mFakeGid1 : "null"));
    }
    pw.println(" mGid2=" + mGid2);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid2=" + ((mFakeGid2 != null) ? mFakeGid2 : "null"));
    }
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid1=" + mFakeGid1);
    }
    pw.println(" mGid2=" + mGid2);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid2=" + mFakeGid2);
    }
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakePnnHomeName=" + mFakePnnHomeName);
    }
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_RADIO_OFF_OR_UNAVAILABLE:
            mRadioState = mCi.getRadioState();
            updateExternalState();
            break;
        case EVENT_RADIO_ON:
            mRadioState = RadioState.RADIO_ON;
            if (!mInitialized) {
                updateQuietMode();
            } else {
                // updateQuietMode() triggers ICC_CHANGED, which eventually
                // calls updateExternalState; thus, we don't need this in the
                // above case
                updateExternalState();
            }
            break;
        case EVENT_ICC_CHANGED:
            if (mInitialized) {
                updateIccAvailability();
            }
            break;
        case EVENT_ICC_ABSENT:
            mAbsentRegistrants.notifyRegistrants();
            setExternalState(State.ABSENT);
            break;
        case EVENT_ICC_LOCKED:
            processLockedState();
            break;
        case EVENT_APP_READY:
            setExternalState(State.READY);
            break;
        case EVENT_RECORDS_LOADED:
            // Update the MCC/MNC.
            if (mIccRecords != null) {
                String operator = mIccRecords.getOperatorNumeric();
                log("operator=" + operator + " mPhoneId=" + mPhoneId);
                if (!TextUtils.isEmpty(operator)) {
                    mTelephonyManager.setSimOperatorNumericForPhone(mPhoneId, operator);
                    String countryCode = operator.substring(0, 3);
                    if (countryCode != null) {
                        mTelephonyManager.setSimCountryIsoForPhone(mPhoneId, MccTable.countryCodeForMcc(Integer.parseInt(countryCode)));
                    } else {
                        loge("EVENT_RECORDS_LOADED Country code is null");
                    }
                } else {
                    loge("EVENT_RECORDS_LOADED Operator name is null");
                }
            }
            if (mUiccCard != null && !mUiccCard.areCarrierPriviligeRulesLoaded()) {
                mUiccCard.registerForCarrierPrivilegeRulesLoaded(this, EVENT_CARRIER_PRIVILEGES_LOADED, null);
            } else {
                onRecordsLoaded();
            }
            break;
        case EVENT_IMSI_READY:
            broadcastIccStateChangedIntent(IccCardConstants.INTENT_VALUE_ICC_IMSI, null);
            break;
        case EVENT_NETWORK_LOCKED:
            mNetworkLockedRegistrants.notifyRegistrants();
            setExternalState(State.NETWORK_LOCKED);
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            updateQuietMode();
            break;
        case EVENT_SUBSCRIPTION_ACTIVATED:
            log("EVENT_SUBSCRIPTION_ACTIVATED");
            onSubscriptionActivated();
            break;
        case EVENT_SUBSCRIPTION_DEACTIVATED:
            log("EVENT_SUBSCRIPTION_DEACTIVATED");
            onSubscriptionDeactivated();
            break;
        case EVENT_ICC_RECORD_EVENTS:
            if ((mCurrentAppType == UiccController.APP_FAM_3GPP) && (mIccRecords != null)) {
                AsyncResult ar = (AsyncResult) msg.obj;
                int eventCode = (Integer) ar.result;
                if (eventCode == SIMRecords.EVENT_SPN) {
                    mTelephonyManager.setSimOperatorNameForPhone(mPhoneId, mIccRecords.getServiceProviderName());
                }
            }
            break;
        case EVENT_CARRIER_PRIVILEGES_LOADED:
            log("EVENT_CARRIER_PRIVILEGES_LOADED");
            if (mUiccCard != null) {
                mUiccCard.unregisterForCarrierPrivilegeRulesLoaded(this);
            }
            onRecordsLoaded();
            break;
        default:
            loge("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_RADIO_OFF_OR_UNAVAILABLE:
            mRadioState = mCi.getRadioState();
            updateExternalState();
            break;
        case EVENT_RADIO_ON:
            mRadioState = RadioState.RADIO_ON;
            if (!mInitialized) {
                updateQuietMode();
            } else {
                // updateQuietMode() triggers ICC_CHANGED, which eventually
                // calls updateExternalState; thus, we don't need this in the
                // above case
                updateExternalState();
            }
            break;
        case EVENT_ICC_CHANGED:
            if (mInitialized) {
                updateIccAvailability();
            }
            break;
        case EVENT_ICC_ABSENT:
            setExternalState(State.ABSENT);
            break;
        case EVENT_ICC_LOCKED:
            processLockedState();
            break;
        case EVENT_APP_READY:
            setExternalState(State.READY);
            break;
        case EVENT_RECORDS_LOADED:
            // Update the MCC/MNC.
            if (mIccRecords != null) {
                String operator = mIccRecords.getOperatorNumeric();
                log("operator=" + operator + " mPhoneId=" + mPhoneId);
                if (!TextUtils.isEmpty(operator)) {
                    mTelephonyManager.setSimOperatorNumericForPhone(mPhoneId, operator);
                    String countryCode = operator.substring(0, 3);
                    if (countryCode != null) {
                        mTelephonyManager.setSimCountryIsoForPhone(mPhoneId, MccTable.countryCodeForMcc(Integer.parseInt(countryCode)));
                    } else {
                        loge("EVENT_RECORDS_LOADED Country code is null");
                    }
                } else {
                    loge("EVENT_RECORDS_LOADED Operator name is null");
                }
            }
            if (mUiccCard != null && !mUiccCard.areCarrierPriviligeRulesLoaded()) {
                mUiccCard.registerForCarrierPrivilegeRulesLoaded(this, EVENT_CARRIER_PRIVILEGES_LOADED, null);
            } else {
                onRecordsLoaded();
            }
            break;
        case EVENT_IMSI_READY:
            broadcastIccStateChangedIntent(IccCardConstants.INTENT_VALUE_ICC_IMSI, null);
            break;
        case EVENT_NETWORK_LOCKED:
            mNetworkLockedRegistrants.notifyRegistrants();
            setExternalState(State.NETWORK_LOCKED);
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            updateQuietMode();
            break;
        case EVENT_SUBSCRIPTION_ACTIVATED:
            log("EVENT_SUBSCRIPTION_ACTIVATED");
            onSubscriptionActivated();
            break;
        case EVENT_SUBSCRIPTION_DEACTIVATED:
            log("EVENT_SUBSCRIPTION_DEACTIVATED");
            onSubscriptionDeactivated();
            break;
        case EVENT_ICC_RECORD_EVENTS:
            if ((mCurrentAppType == UiccController.APP_FAM_3GPP) && (mIccRecords != null)) {
                AsyncResult ar = (AsyncResult) msg.obj;
                int eventCode = (Integer) ar.result;
                if (eventCode == SIMRecords.EVENT_SPN) {
                    mTelephonyManager.setSimOperatorNameForPhone(mPhoneId, mIccRecords.getServiceProviderName());
                }
            }
            break;
        case EVENT_CARRIER_PRIVILEGES_LOADED:
            log("EVENT_CARRIER_PRIVILEGES_LOADED");
            if (mUiccCard != null) {
                mUiccCard.unregisterForCarrierPrivilegeRulesLoaded(this);
            }
            onRecordsLoaded();
            break;
        default:
            loge("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
private void updateExternalState() {
    // been received from UiccController.
    if (mUiccCard == null) {
        setExternalState(State.UNKNOWN);
        return;
    }
    if (mUiccCard.getCardState() == CardState.CARDSTATE_ABSENT) {
        /*
             * Both IccCardProxy and UiccController are registered for
             * RadioState changes. When the UiccController receives a radio
             * state changed to Unknown it will dispose of all of the IccCard
             * objects, which will then notify the IccCardProxy and the null
             * object will force the state to unknown. However, because the
             * IccCardProxy is also registered for RadioState changes, it will
             * recieve that signal first. By triggering on radio state changes
             * directly, we reduce the time window during which the modem is
             * UNAVAILABLE but the IccStatus is reported as something valid.
             * This is not ideal.
             */
        if (mRadioState == RadioState.RADIO_UNAVAILABLE) {
            setExternalState(State.UNKNOWN);
        } else {
            setExternalState(State.ABSENT);
        }
        return;
    }
    if (mUiccCard.getCardState() == CardState.CARDSTATE_ERROR) {
        setExternalState(State.CARD_IO_ERROR);
        return;
    }
    if (mUiccCard.getCardState() == CardState.CARDSTATE_RESTRICTED) {
        setExternalState(State.CARD_RESTRICTED);
        return;
    }
    if (mUiccApplication == null) {
        setExternalState(State.NOT_READY);
        return;
    }
    // By process of elimination, the UICC Card State = PRESENT
    switch(mUiccApplication.getState()) {
        case APPSTATE_UNKNOWN:
            /*
                 * APPSTATE_UNKNOWN is a catch-all state reported whenever the app
                 * is not explicitly in one of the other states. To differentiate the
                 * case where we know that there is a card present, but the APP is not
                 * ready, we choose NOT_READY here instead of unknown. This is possible
                 * in at least two cases:
                 * 1) A transient during the process of the SIM bringup
                 * 2) There is no valid App on the SIM to load, which can be the case with an
                 *    eSIM/soft SIM.
                 */
            setExternalState(State.NOT_READY);
            break;
        case APPSTATE_DETECTED:
            HandleDetectedState();
            break;
        case APPSTATE_PIN:
            setExternalState(State.PIN_REQUIRED);
            break;
        case APPSTATE_PUK:
            PinState pin1State = mUiccApplication.getPin1State();
            if (pin1State.isPermBlocked()) {
                setExternalState(State.PERM_DISABLED);
                return;
            }
            setExternalState(State.PUK_REQUIRED);
            break;
        case APPSTATE_SUBSCRIPTION_PERSO:
            if (mUiccApplication.getPersoSubState() == PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
                setExternalState(State.NETWORK_LOCKED);
            }
            // Otherwise don't change external SIM state.
            break;
        case APPSTATE_READY:
            setExternalState(State.READY);
            break;
    }
}
#method_after
private void updateExternalState() {
    // been received from UiccController.
    if (mUiccCard == null) {
        setExternalState(State.UNKNOWN);
        return;
    }
    if (mUiccCard.getCardState() == CardState.CARDSTATE_ABSENT) {
        /*
             * Both IccCardProxy and UiccController are registered for
             * RadioState changes. When the UiccController receives a radio
             * state changed to Unknown it will dispose of all of the IccCard
             * objects, which will then notify the IccCardProxy and the null
             * object will force the state to unknown. However, because the
             * IccCardProxy is also registered for RadioState changes, it will
             * recieve that signal first. By triggering on radio state changes
             * directly, we reduce the time window during which the modem is
             * UNAVAILABLE but the IccStatus is reported as something valid.
             * This is not ideal.
             */
        if (mRadioState == RadioState.RADIO_UNAVAILABLE) {
            setExternalState(State.UNKNOWN);
        } else {
            setExternalState(State.ABSENT);
        }
        return;
    }
    if (mUiccCard.getCardState() == CardState.CARDSTATE_ERROR) {
        setExternalState(State.CARD_IO_ERROR);
        return;
    }
    if (mUiccCard.getCardState() == CardState.CARDSTATE_RESTRICTED) {
        setExternalState(State.CARD_RESTRICTED);
        return;
    }
    if (mUiccApplication == null) {
        setExternalState(State.NOT_READY);
        return;
    }
    // By process of elimination, the UICC Card State = PRESENT
    switch(mUiccApplication.getState()) {
        case APPSTATE_UNKNOWN:
            /*
                 * APPSTATE_UNKNOWN is a catch-all state reported whenever the app
                 * is not explicitly in one of the other states. To differentiate the
                 * case where we know that there is a card present, but the APP is not
                 * ready, we choose NOT_READY here instead of unknown. This is possible
                 * in at least two cases:
                 * 1) A transient during the process of the SIM bringup
                 * 2) There is no valid App on the SIM to load, which can be the case with an
                 *    eSIM/soft SIM.
                 */
            setExternalState(State.NOT_READY);
            break;
        case APPSTATE_DETECTED:
            HandleDetectedState();
            break;
        case APPSTATE_SUBSCRIPTION_PERSO:
            if (mUiccApplication.getPersoSubState() == PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
                setExternalState(State.NETWORK_LOCKED);
            }
            // Otherwise don't change external SIM state.
            break;
        case APPSTATE_READY:
            setExternalState(State.READY);
            break;
    }
}
#end_block

#method_before
private void setExternalState(State newState, boolean override) {
    synchronized (mLock) {
        if (mPhoneId == null || !SubscriptionManager.isValidSlotIndex(mPhoneId)) {
            loge("setExternalState: mPhoneId=" + mPhoneId + " is invalid; Return!!");
            return;
        }
        if (!override && newState == mExternalState) {
            log("setExternalState: !override and newstate unchanged from " + newState);
            return;
        }
        mExternalState = newState;
        log("setExternalState: set mPhoneId=" + mPhoneId + " mExternalState=" + mExternalState);
        mTelephonyManager.setSimStateForPhone(mPhoneId, getState().toString());
        // For locked states, we should be sending internal broadcast.
        if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(getIccStateIntentString(mExternalState))) {
            broadcastInternalIccStateChangedIntent(getIccStateIntentString(mExternalState), getIccStateReason(mExternalState));
        } else {
            broadcastIccStateChangedIntent(getIccStateIntentString(mExternalState), getIccStateReason(mExternalState));
        }
        // TODO: Need to notify registrants for other states as well.
        if (State.ABSENT == mExternalState) {
            mAbsentRegistrants.notifyRegistrants();
        }
    }
}
#method_after
private void setExternalState(State newState, boolean override) {
    synchronized (mLock) {
        if (mPhoneId == null || !SubscriptionManager.isValidSlotIndex(mPhoneId)) {
            loge("setExternalState: mPhoneId=" + mPhoneId + " is invalid; Return!!");
            return;
        }
        if (!override && newState == mExternalState) {
            log("setExternalState: !override and newstate unchanged from " + newState);
            return;
        }
        mExternalState = newState;
        log("setExternalState: set mPhoneId=" + mPhoneId + " mExternalState=" + mExternalState);
        mTelephonyManager.setSimStateForPhone(mPhoneId, getState().toString());
        // For locked states, we should be sending internal broadcast.
        if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(getIccStateIntentString(mExternalState))) {
            broadcastInternalIccStateChangedIntent(getIccStateIntentString(mExternalState), getIccStateReason(mExternalState));
        } else {
            broadcastIccStateChangedIntent(getIccStateIntentString(mExternalState), getIccStateReason(mExternalState));
        }
    }
}
#end_block

#method_before
private void processLockedState() {
    synchronized (mLock) {
        if (mUiccApplication == null) {
            // Don't need to do anything if non-existent application is locked
            return;
        }
        PinState pin1State = mUiccApplication.getPin1State();
        if (pin1State == PinState.PINSTATE_ENABLED_PERM_BLOCKED) {
            setExternalState(State.PERM_DISABLED);
            return;
        }
        AppState appState = mUiccApplication.getState();
        switch(appState) {
            case APPSTATE_PIN:
                mPinLockedRegistrants.notifyRegistrants();
                setExternalState(State.PIN_REQUIRED);
                break;
            case APPSTATE_PUK:
                setExternalState(State.PUK_REQUIRED);
                break;
            case APPSTATE_DETECTED:
            case APPSTATE_READY:
            case APPSTATE_SUBSCRIPTION_PERSO:
            case APPSTATE_UNKNOWN:
                // Neither required
                break;
        }
    }
}
#method_after
private void processLockedState() {
    synchronized (mLock) {
        if (mUiccApplication == null) {
            // Don't need to do anything if non-existent application is locked
            return;
        }
        PinState pin1State = mUiccApplication.getPin1State();
        if (pin1State == PinState.PINSTATE_ENABLED_PERM_BLOCKED) {
            setExternalState(State.PERM_DISABLED);
            return;
        }
        AppState appState = mUiccApplication.getState();
        switch(appState) {
            case APPSTATE_PIN:
                setExternalState(State.PIN_REQUIRED);
                break;
            case APPSTATE_PUK:
                setExternalState(State.PUK_REQUIRED);
                break;
            case APPSTATE_DETECTED:
            case APPSTATE_READY:
            case APPSTATE_SUBSCRIPTION_PERSO:
            case APPSTATE_UNKNOWN:
                // Neither required
                break;
        }
    }
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("IccCardProxy: " + this);
    pw.println(" mContext=" + mContext);
    pw.println(" mCi=" + mCi);
    pw.println(" mAbsentRegistrants: size=" + mAbsentRegistrants.size());
    for (int i = 0; i < mAbsentRegistrants.size(); i++) {
        pw.println("  mAbsentRegistrants[" + i + "]=" + ((Registrant) mAbsentRegistrants.get(i)).getHandler());
    }
    pw.println(" mPinLockedRegistrants: size=" + mPinLockedRegistrants.size());
    for (int i = 0; i < mPinLockedRegistrants.size(); i++) {
        pw.println("  mPinLockedRegistrants[" + i + "]=" + ((Registrant) mPinLockedRegistrants.get(i)).getHandler());
    }
    pw.println(" mNetworkLockedRegistrants: size=" + mNetworkLockedRegistrants.size());
    for (int i = 0; i < mNetworkLockedRegistrants.size(); i++) {
        pw.println("  mNetworkLockedRegistrants[" + i + "]=" + ((Registrant) mNetworkLockedRegistrants.get(i)).getHandler());
    }
    pw.println(" mCurrentAppType=" + mCurrentAppType);
    pw.println(" mUiccController=" + mUiccController);
    pw.println(" mUiccCard=" + mUiccCard);
    pw.println(" mUiccApplication=" + mUiccApplication);
    pw.println(" mIccRecords=" + mIccRecords);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRadioState=" + mRadioState);
    pw.println(" mQuietMode=" + mQuietMode);
    pw.println(" mInitialized=" + mInitialized);
    pw.println(" mExternalState=" + mExternalState);
    pw.flush();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("IccCardProxy: " + this);
    pw.println(" mContext=" + mContext);
    pw.println(" mCi=" + mCi);
    pw.println(" mNetworkLockedRegistrants: size=" + mNetworkLockedRegistrants.size());
    for (int i = 0; i < mNetworkLockedRegistrants.size(); i++) {
        pw.println("  mNetworkLockedRegistrants[" + i + "]=" + ((Registrant) mNetworkLockedRegistrants.get(i)).getHandler());
    }
    pw.println(" mCurrentAppType=" + mCurrentAppType);
    pw.println(" mUiccController=" + mUiccController);
    pw.println(" mUiccCard=" + mUiccCard);
    pw.println(" mUiccApplication=" + mUiccApplication);
    pw.println(" mIccRecords=" + mIccRecords);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRadioState=" + mRadioState);
    pw.println(" mQuietMode=" + mQuietMode);
    pw.println(" mInitialized=" + mInitialized);
    pw.println(" mExternalState=" + mExternalState);
    pw.flush();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_SIM_LOCKED_QUERY_ICCID_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                QueryIccIdUserObj uObj = (QueryIccIdUserObj) ar.userObj;
                int slotId = uObj.slotId;
                logd("handleMessage : <EVENT_SIM_LOCKED_QUERY_ICCID_DONE> SIM" + (slotId + 1));
                if (ar.exception == null) {
                    if (ar.result != null) {
                        byte[] data = (byte[]) ar.result;
                        mIccId[slotId] = IccUtils.bchToString(data, 0, data.length);
                    } else {
                        logd("Null ar");
                        mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                    }
                } else {
                    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                    logd("Query IccId fail: " + ar.exception);
                }
                logd("sIccId[" + slotId + "] = " + mIccId[slotId]);
                if (isAllIccIdQueryDone()) {
                    updateSubscriptionInfoByIccId();
                }
                broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, uObj.reason);
                if (!ICCID_STRING_FOR_NO_SIM.equals(mIccId[slotId])) {
                    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
                }
                break;
            }
        case EVENT_GET_NETWORK_SELECTION_MODE_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                Integer slotId = (Integer) ar.userObj;
                if (ar.exception == null && ar.result != null) {
                    int[] modes = (int[]) ar.result;
                    if (modes[0] == 1) {
                        // Manual mode.
                        mPhone[slotId].setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    logd("EVENT_GET_NETWORK_SELECTION_MODE_DONE: error getting network mode.");
                }
                break;
            }
        case EVENT_SIM_LOADED:
            handleSimLoaded(msg.arg1);
            break;
        case EVENT_SIM_ABSENT:
            handleSimAbsent(msg.arg1);
            break;
        case EVENT_SIM_LOCKED:
            handleSimLocked(msg.arg1, (String) msg.obj);
            break;
        case EVENT_SIM_UNKNOWN:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            break;
        case EVENT_SIM_IO_ERROR:
            handleSimError(msg.arg1);
            break;
        case EVENT_SIM_RESTRICTED:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            break;
        case EVENT_REFRESH_EMBEDDED_SUBSCRIPTIONS:
            if (updateEmbeddedSubscriptions()) {
                SubscriptionController.getInstance().notifySubscriptionInfoChanged();
            }
            if (msg.obj != null) {
                ((Runnable) msg.obj).run();
            }
            break;
        default:
            logd("Unknown msg:" + msg.what);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_GET_NETWORK_SELECTION_MODE_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                Integer slotId = (Integer) ar.userObj;
                if (ar.exception == null && ar.result != null) {
                    int[] modes = (int[]) ar.result;
                    if (modes[0] == 1) {
                        // Manual mode.
                        mPhone[slotId].setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    logd("EVENT_GET_NETWORK_SELECTION_MODE_DONE: error getting network mode.");
                }
                break;
            }
        case EVENT_SIM_LOADED:
            handleSimLoaded(msg.arg1);
            break;
        case EVENT_SIM_ABSENT:
            handleSimAbsent(msg.arg1);
            break;
        case EVENT_SIM_LOCKED:
            handleSimLocked(msg.arg1, (String) msg.obj);
            break;
        case EVENT_SIM_UNKNOWN:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            break;
        case EVENT_SIM_IO_ERROR:
            handleSimError(msg.arg1);
            break;
        case EVENT_SIM_RESTRICTED:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            break;
        case EVENT_REFRESH_EMBEDDED_SUBSCRIPTIONS:
            if (updateEmbeddedSubscriptions()) {
                SubscriptionController.getInstance().notifySubscriptionInfoChanged();
            }
            if (msg.obj != null) {
                ((Runnable) msg.obj).run();
            }
            break;
        default:
            logd("Unknown msg:" + msg.what);
    }
}
#end_block

#method_before
private void handleSimLocked(int slotId, String reason) {
    if (mIccId[slotId] != null && mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug in");
        mIccId[slotId] = null;
    }
    String iccId = mIccId[slotId];
    if (iccId == null) {
        IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
        if (records.getFullIccId() == null) {
            logd("handleSimLocked: IccID null");
            return;
        }
        mIccId[slotId] = records.getFullIccId();
    } else {
        logd("NOT Querying IccId its already set sIccid[" + slotId + "]=" + iccId);
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, reason);
}
#method_after
private void handleSimLocked(int slotId, String reason) {
    if (mIccId[slotId] != null && mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug in");
        mIccId[slotId] = null;
    }
    String iccId = mIccId[slotId];
    if (iccId == null) {
        IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
        if (stripIccIdSuffix(records.getFullIccId()) == null) {
            logd("handleSimLocked: IccID null");
            return;
        }
        mIccId[slotId] = stripIccIdSuffix(records.getFullIccId());
    } else {
        logd("NOT Querying IccId its already set sIccid[" + slotId + "]=" + iccId);
    }
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, reason);
}
#end_block

#method_before
private void handleSimLoaded(int slotId) {
    logd("handleSimLoaded: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    int loadedSlotId = slotId;
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("handleSimLoaded: IccRecords null");
        return;
    }
    if (records.getFullIccId() == null) {
        logd("handleSimLoaded: IccID null");
        return;
    }
    mIccId[slotId] = records.getFullIccId();
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            TelephonyManager tm = TelephonyManager.getDefault();
            String operator = tm.getSimOperatorNumeric(subId);
            slotId = SubscriptionController.getInstance().getPhoneId(subId);
            if (!TextUtils.isEmpty(operator)) {
                if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                    MccTable.updateMccMncConfiguration(mContext, operator, false);
                }
                SubscriptionController.getInstance().setMccMnc(operator, subId);
            } else {
                logd("EVENT_RECORDS_LOADED Operator name is null");
            }
            String msisdn = tm.getLine1Number(subId);
            ContentResolver contentResolver = mContext.getContentResolver();
            if (msisdn != null) {
                SubscriptionController.getInstance().setDisplayNumber(msisdn, subId);
            }
            SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
            String nameToSet;
            String simCarrierName = tm.getSimOperatorName(subId);
            if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                if (!TextUtils.isEmpty(simCarrierName)) {
                    nameToSet = simCarrierName;
                } else {
                    nameToSet = "CARD " + Integer.toString(slotId + 1);
                }
                logd("sim name = " + nameToSet);
                SubscriptionController.getInstance().setDisplayName(nameToSet, subId);
            }
            /* Update preferred network type and network selection mode on SIM change.
                 * Storing last subId in SharedPreference for now to detect SIM change. */
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
            if (storedSubId != subId) {
                int networkType = RILConstants.PREFERRED_NETWORK_MODE;
                // Set the modem network mode
                mPhone[slotId].setPreferredNetworkType(networkType, null);
                Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
                // Only support automatic selection mode on SIM change.
                mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
                // Update stored subId
                SharedPreferences.Editor editor = sp.edit();
                editor.putInt(CURR_SUBID + slotId, subId);
                editor.apply();
            }
        }
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    updateCarrierServices(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#method_after
private void handleSimLoaded(int slotId) {
    logd("handleSimLoaded: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    int loadedSlotId = slotId;
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("handleSimLoaded: IccRecords null");
        return;
    }
    if (stripIccIdSuffix(records.getFullIccId()) == null) {
        logd("handleSimLoaded: IccID null");
        return;
    }
    mIccId[slotId] = stripIccIdSuffix(records.getFullIccId());
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            TelephonyManager tm = TelephonyManager.getDefault();
            String operator = tm.getSimOperatorNumeric(subId);
            slotId = SubscriptionController.getInstance().getPhoneId(subId);
            if (!TextUtils.isEmpty(operator)) {
                if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                    MccTable.updateMccMncConfiguration(mContext, operator, false);
                }
                SubscriptionController.getInstance().setMccMnc(operator, subId);
            } else {
                logd("EVENT_RECORDS_LOADED Operator name is null");
            }
            String msisdn = tm.getLine1Number(subId);
            ContentResolver contentResolver = mContext.getContentResolver();
            if (msisdn != null) {
                SubscriptionController.getInstance().setDisplayNumber(msisdn, subId);
            }
            SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
            String nameToSet;
            String simCarrierName = tm.getSimOperatorName(subId);
            if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                if (!TextUtils.isEmpty(simCarrierName)) {
                    nameToSet = simCarrierName;
                } else {
                    nameToSet = "CARD " + Integer.toString(slotId + 1);
                }
                logd("sim name = " + nameToSet);
                SubscriptionController.getInstance().setDisplayName(nameToSet, subId);
            }
            /* Update preferred network type and network selection mode on SIM change.
                 * Storing last subId in SharedPreference for now to detect SIM change. */
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
            if (storedSubId != subId) {
                int networkType = RILConstants.PREFERRED_NETWORK_MODE;
                // Set the modem network mode
                mPhone[slotId].setPreferredNetworkType(networkType, null);
                Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
                // Only support automatic selection mode on SIM change.
                mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
                // Update stored subId
                SharedPreferences.Editor editor = sp.edit();
                editor.putInt(CURR_SUBID + slotId, subId);
                editor.apply();
            }
        }
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    updateCarrierServices(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#end_block

#method_before
@Test
public // TODO: Currently 10% flaky so not part of pre-submit for now
void testMaxAspectRatioResizeableActivity() throws Exception {
    final Context context = InstrumentationRegistry.getInstrumentation().getContext();
    final Activity testActivity = launchActivity(mMaxAspectRatioResizeableActivity);
    PollingCheck.waitFor(testActivity::hasWindowFocus);
    View rootView = testActivity.findViewById(android.R.id.content);
    final Context displayContext = context.createDisplayContext(rootView.getDisplay());
    final float expected = getAspectRatio(displayContext);
    // Since this activity is resizeable, its aspect ratio shouldn't be less than the device's
    runTest(testActivity, actual -> {
        if (aspectRatioEqual(expected, actual) || expected < actual)
            return;
        fail("actual=" + actual + " is less than expected=" + expected);
    });
}
#method_after
@Test
public // TODO: Currently 10% flaky so not part of pre-submit for now
void testMaxAspectRatioResizeableActivity() throws Exception {
    final Context context = InstrumentationRegistry.getInstrumentation().getContext();
    final float expected = getAspectRatio(context);
    final Activity testActivity = launchActivity(mMaxAspectRatioResizeableActivity);
    PollingCheck.waitFor(testActivity::hasWindowFocus);
    Display testDisplay = testActivity.findViewById(android.R.id.content).getDisplay();
    // context, then can use DisplayManager to get the aspect ratio of the correct display.
    if (testDisplay.getDisplayId() != Display.DEFAULT_DISPLAY) {
        return;
    }
    // Since this activity is resizeable, its aspect ratio shouldn't be less than the device's
    runTest(testActivity, actual -> {
        if (aspectRatioEqual(expected, actual) || expected < actual)
            return;
        fail("actual=" + actual + " is less than expected=" + expected);
    });
}
#end_block

#method_before
protected boolean isUiModeLockedToVrHeadset() throws DeviceNotAvailableException {
    final String output = runCommandAndPrintOutput("dumpsys uimode");
    Integer curUiMode = null;
    Boolean uiModeLocked = null;
    for (String line : output.split("\\n")) {
        line = line.trim();
        Matcher matcher = sCurrentUiModePattern.matcher(line);
        if (matcher.find()) {
            curUiMode = Integer.parseInt(matcher.group(1), 16);
        }
        matcher = sUiModeLockedPattern.matcher(line);
        if (matcher.find()) {
            uiModeLocked = matcher.group(1).equals("true");
        }
    }
    boolean uiModeLockedToVrHeadset = (curUiMode != null) && (uiModeLocked != null) && ((curUiMode & 0x0f) == 0x07) && uiModeLocked;
    if (uiModeLockedToVrHeadset) {
        CLog.logAndDisplay(LogLevel.INFO, "UI mode is locked to VR headset");
    }
    return uiModeLockedToVrHeadset;
}
#method_after
protected boolean isUiModeLockedToVrHeadset() throws DeviceNotAvailableException {
    final String output = runCommandAndPrintOutput("dumpsys uimode");
    Integer curUiMode = null;
    Boolean uiModeLocked = null;
    for (String line : output.split("\\n")) {
        line = line.trim();
        Matcher matcher = sCurrentUiModePattern.matcher(line);
        if (matcher.find()) {
            curUiMode = Integer.parseInt(matcher.group(1), 16);
        }
        matcher = sUiModeLockedPattern.matcher(line);
        if (matcher.find()) {
            uiModeLocked = matcher.group(1).equals("true");
        }
    }
    boolean uiModeLockedToVrHeadset = (curUiMode != null) && (uiModeLocked != null) && ((curUiMode & UI_MODE_TYPE_MASK) == UI_MODE_TYPE_VR_HEADSET) && uiModeLocked;
    if (uiModeLockedToVrHeadset) {
        CLog.logAndDisplay(LogLevel.INFO, "UI mode is locked to VR headset");
    }
    return uiModeLockedToVrHeadset;
}
#end_block

#method_before
private boolean packageIsBrowser(String packageName, int userId) {
    List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, PackageManager.MATCH_ALL, userId);
    final int N = list.size();
    for (int i = 0; i < N; i++) {
        ResolveInfo info = list.get(i);
        if (packageName.equals(info.activityInfo.packageName)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean packageIsBrowser(String packageName, int userId) {
    List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, PackageManager.MATCH_ALL, userId);
    final int N = list.size();
    for (int i = 0; i < N; i++) {
        ResolveInfo info = list.get(i);
        if (info.priority >= 0 && packageName.equals(info.activityInfo.packageName)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void replacePackageLIF(PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, String installerPackageName, PackageInstalledInfo res, int installReason) {
    final boolean isInstantApp = (scanFlags & SCAN_AS_INSTANT_APP) != 0;
    final PackageParser.Package oldPackage;
    final PackageSetting ps;
    final String pkgName = pkg.packageName;
    final int[] allUsers;
    final int[] installedUsers;
    synchronized (mPackages) {
        oldPackage = mPackages.get(pkgName);
        if (DEBUG_INSTALL)
            Slog.d(TAG, "replacePackageLI: new=" + pkg + ", old=" + oldPackage);
        // don't allow upgrade to target a release SDK from a pre-release SDK
        final boolean oldTargetsPreRelease = oldPackage.applicationInfo.targetSdkVersion == android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        final boolean newTargetsPreRelease = pkg.applicationInfo.targetSdkVersion == android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        if (oldTargetsPreRelease && !newTargetsPreRelease && ((policyFlags & PackageParser.PARSE_FORCE_SDK) == 0)) {
            Slog.w(TAG, "Can't install package targeting released sdk");
            res.setReturnCode(PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
            return;
        }
        ps = mSettings.mPackages.get(pkgName);
        // verify signatures are valid
        if (shouldCheckUpgradeKeySetLP(ps, scanFlags)) {
            if (!checkUpgradeKeySetLP(ps, pkg)) {
                res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "New package not signed by keys specified by upgrade-keysets: " + pkgName);
                return;
            }
        } else {
            // default to original signature matching
            if (compareSignatures(oldPackage.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "New package has a different signature: " + pkgName);
                return;
            }
        }
        // don't allow a system upgrade unless the upgrade hash matches
        if (oldPackage.restrictUpdateHash != null && oldPackage.isSystemApp()) {
            byte[] digestBytes = null;
            try {
                final MessageDigest digest = MessageDigest.getInstance("SHA-512");
                updateDigest(digest, new File(pkg.baseCodePath));
                if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
                    for (String path : pkg.splitCodePaths) {
                        updateDigest(digest, new File(path));
                    }
                }
                digestBytes = digest.digest();
            } catch (NoSuchAlgorithmException | IOException e) {
                res.setError(INSTALL_FAILED_INVALID_APK, "Could not compute hash: " + pkgName);
                return;
            }
            if (!Arrays.equals(oldPackage.restrictUpdateHash, digestBytes)) {
                res.setError(INSTALL_FAILED_INVALID_APK, "New package fails restrict-update check: " + pkgName);
                return;
            }
            // retain upgrade restriction
            pkg.restrictUpdateHash = oldPackage.restrictUpdateHash;
        }
        // Check for shared user id changes
        String invalidPackageName = getParentOrChildPackageChangedSharedUser(oldPackage, pkg);
        if (invalidPackageName != null) {
            res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE, "Package " + invalidPackageName + " tried to change user " + oldPackage.mSharedUserId);
            return;
        }
        // check if the new package supports all of the abis which the old package supports
        boolean oldPkgSupportMultiArch = oldPackage.applicationInfo.secondaryCpuAbi != null;
        // allow new package containing no native libs to pass this check
        boolean newPkgSupportMultiArch = pkg.applicationInfo.primaryCpuAbi == null || pkg.applicationInfo.secondaryCpuAbi != null;
        if (isSystemApp(oldPackage) && oldPkgSupportMultiArch && !newPkgSupportMultiArch) {
            res.setError(INSTALL_FAILED_SYSTEM_APP_UPDATE_CPU_ABI_INSUFFICIENT, "Abort upgrade system package from multi-arch to single-arch app");
            return;
        }
        // In case of rollback, remember per-user/profile install state
        allUsers = sUserManager.getUserIds();
        installedUsers = ps.queryInstalledUsers(allUsers, true);
        // don't allow an upgrade from full to ephemeral
        if (isInstantApp) {
            if (user == null || user.getIdentifier() == UserHandle.USER_ALL) {
                for (int currentUser : allUsers) {
                    if (!ps.getInstantApp(currentUser)) {
                        // can't downgrade from full to instant
                        Slog.w(TAG, "Can't replace full app with instant app: " + pkgName + " for user: " + currentUser);
                        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
                        return;
                    }
                }
            } else if (!ps.getInstantApp(user.getIdentifier())) {
                // can't downgrade from full to instant
                Slog.w(TAG, "Can't replace full app with instant app: " + pkgName + " for user: " + user.getIdentifier());
                res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
                return;
            }
        }
    }
    // Update what is removed
    res.removedInfo = new PackageRemovedInfo(this);
    res.removedInfo.uid = oldPackage.applicationInfo.uid;
    res.removedInfo.removedPackage = oldPackage.packageName;
    res.removedInfo.installerPackageName = ps.installerPackageName;
    res.removedInfo.isStaticSharedLib = pkg.staticSharedLibName != null;
    res.removedInfo.isUpdate = true;
    res.removedInfo.origUsers = installedUsers;
    res.removedInfo.installReasons = new SparseArray<>(installedUsers.length);
    for (int i = 0; i < installedUsers.length; i++) {
        final int userId = installedUsers[i];
        res.removedInfo.installReasons.put(userId, ps.getInstallReason(userId));
    }
    final int childCount = (oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        boolean childPackageUpdated = false;
        PackageParser.Package childPkg = oldPackage.childPackages.get(i);
        final PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
        if (res.addedChildPackages != null) {
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            if (childRes != null) {
                childRes.removedInfo.uid = childPkg.applicationInfo.uid;
                childRes.removedInfo.removedPackage = childPkg.packageName;
                if (childPs != null) {
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                childRes.removedInfo.isUpdate = true;
                childRes.removedInfo.installReasons = res.removedInfo.installReasons;
                childPackageUpdated = true;
            }
        }
        if (!childPackageUpdated) {
            PackageRemovedInfo childRemovedRes = new PackageRemovedInfo(this);
            childRemovedRes.removedPackage = childPkg.packageName;
            if (childPs != null) {
                childRemovedRes.installerPackageName = childPs.installerPackageName;
            }
            childRemovedRes.isUpdate = false;
            childRemovedRes.dataRemoved = true;
            synchronized (mPackages) {
                if (childPs != null) {
                    childRemovedRes.origUsers = childPs.queryInstalledUsers(allUsers, true);
                }
            }
            if (res.removedInfo.removedChildPackages == null) {
                res.removedInfo.removedChildPackages = new ArrayMap<>();
            }
            res.removedInfo.removedChildPackages.put(childPkg.packageName, childRemovedRes);
        }
    }
    boolean sysPkg = (isSystemApp(oldPackage));
    if (sysPkg) {
        // Set the system/privileged flags as needed
        final boolean privileged = (oldPackage.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0;
        final int systemPolicyFlags = policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0);
        replaceSystemPackageLIF(oldPackage, pkg, systemPolicyFlags, scanFlags, user, allUsers, installerPackageName, res, installReason);
    } else {
        replaceNonSystemPackageLIF(oldPackage, pkg, policyFlags, scanFlags, user, allUsers, installerPackageName, res, installReason);
    }
}
#method_after
private void replacePackageLIF(PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, String installerPackageName, PackageInstalledInfo res, int installReason) {
    final boolean isInstantApp = (scanFlags & SCAN_AS_INSTANT_APP) != 0;
    final PackageParser.Package oldPackage;
    final PackageSetting ps;
    final String pkgName = pkg.packageName;
    final int[] allUsers;
    final int[] installedUsers;
    synchronized (mPackages) {
        oldPackage = mPackages.get(pkgName);
        if (DEBUG_INSTALL)
            Slog.d(TAG, "replacePackageLI: new=" + pkg + ", old=" + oldPackage);
        // don't allow upgrade to target a release SDK from a pre-release SDK
        final boolean oldTargetsPreRelease = oldPackage.applicationInfo.targetSdkVersion == android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        final boolean newTargetsPreRelease = pkg.applicationInfo.targetSdkVersion == android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        if (oldTargetsPreRelease && !newTargetsPreRelease && ((policyFlags & PackageParser.PARSE_FORCE_SDK) == 0)) {
            Slog.w(TAG, "Can't install package targeting released sdk");
            res.setReturnCode(PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
            return;
        }
        ps = mSettings.mPackages.get(pkgName);
        // verify signatures are valid
        if (shouldCheckUpgradeKeySetLP(ps, scanFlags)) {
            if (!checkUpgradeKeySetLP(ps, pkg)) {
                res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "New package not signed by keys specified by upgrade-keysets: " + pkgName);
                return;
            }
        } else {
            // default to original signature matching
            if (compareSignatures(oldPackage.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "New package has a different signature: " + pkgName);
                return;
            }
        }
        // don't allow a system upgrade unless the upgrade hash matches
        if (oldPackage.restrictUpdateHash != null && oldPackage.isSystemApp()) {
            byte[] digestBytes = null;
            try {
                final MessageDigest digest = MessageDigest.getInstance("SHA-512");
                updateDigest(digest, new File(pkg.baseCodePath));
                if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
                    for (String path : pkg.splitCodePaths) {
                        updateDigest(digest, new File(path));
                    }
                }
                digestBytes = digest.digest();
            } catch (NoSuchAlgorithmException | IOException e) {
                res.setError(INSTALL_FAILED_INVALID_APK, "Could not compute hash: " + pkgName);
                return;
            }
            if (!Arrays.equals(oldPackage.restrictUpdateHash, digestBytes)) {
                res.setError(INSTALL_FAILED_INVALID_APK, "New package fails restrict-update check: " + pkgName);
                return;
            }
            // retain upgrade restriction
            pkg.restrictUpdateHash = oldPackage.restrictUpdateHash;
        }
        // Check for shared user id changes
        String invalidPackageName = getParentOrChildPackageChangedSharedUser(oldPackage, pkg);
        if (invalidPackageName != null) {
            res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE, "Package " + invalidPackageName + " tried to change user " + oldPackage.mSharedUserId);
            return;
        }
        // check if the new package supports all of the abis which the old package supports
        boolean oldPkgSupportMultiArch = oldPackage.applicationInfo.secondaryCpuAbi != null;
        boolean newPkgSupportMultiArch = pkg.applicationInfo.secondaryCpuAbi != null;
        if (isSystemApp(oldPackage) && oldPkgSupportMultiArch && !newPkgSupportMultiArch) {
            res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Update to package " + pkgName + " doesn't support multi arch");
            return;
        }
        // In case of rollback, remember per-user/profile install state
        allUsers = sUserManager.getUserIds();
        installedUsers = ps.queryInstalledUsers(allUsers, true);
        // don't allow an upgrade from full to ephemeral
        if (isInstantApp) {
            if (user == null || user.getIdentifier() == UserHandle.USER_ALL) {
                for (int currentUser : allUsers) {
                    if (!ps.getInstantApp(currentUser)) {
                        // can't downgrade from full to instant
                        Slog.w(TAG, "Can't replace full app with instant app: " + pkgName + " for user: " + currentUser);
                        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
                        return;
                    }
                }
            } else if (!ps.getInstantApp(user.getIdentifier())) {
                // can't downgrade from full to instant
                Slog.w(TAG, "Can't replace full app with instant app: " + pkgName + " for user: " + user.getIdentifier());
                res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
                return;
            }
        }
    }
    // Update what is removed
    res.removedInfo = new PackageRemovedInfo(this);
    res.removedInfo.uid = oldPackage.applicationInfo.uid;
    res.removedInfo.removedPackage = oldPackage.packageName;
    res.removedInfo.installerPackageName = ps.installerPackageName;
    res.removedInfo.isStaticSharedLib = pkg.staticSharedLibName != null;
    res.removedInfo.isUpdate = true;
    res.removedInfo.origUsers = installedUsers;
    res.removedInfo.installReasons = new SparseArray<>(installedUsers.length);
    for (int i = 0; i < installedUsers.length; i++) {
        final int userId = installedUsers[i];
        res.removedInfo.installReasons.put(userId, ps.getInstallReason(userId));
    }
    final int childCount = (oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        boolean childPackageUpdated = false;
        PackageParser.Package childPkg = oldPackage.childPackages.get(i);
        final PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
        if (res.addedChildPackages != null) {
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            if (childRes != null) {
                childRes.removedInfo.uid = childPkg.applicationInfo.uid;
                childRes.removedInfo.removedPackage = childPkg.packageName;
                if (childPs != null) {
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                childRes.removedInfo.isUpdate = true;
                childRes.removedInfo.installReasons = res.removedInfo.installReasons;
                childPackageUpdated = true;
            }
        }
        if (!childPackageUpdated) {
            PackageRemovedInfo childRemovedRes = new PackageRemovedInfo(this);
            childRemovedRes.removedPackage = childPkg.packageName;
            if (childPs != null) {
                childRemovedRes.installerPackageName = childPs.installerPackageName;
            }
            childRemovedRes.isUpdate = false;
            childRemovedRes.dataRemoved = true;
            synchronized (mPackages) {
                if (childPs != null) {
                    childRemovedRes.origUsers = childPs.queryInstalledUsers(allUsers, true);
                }
            }
            if (res.removedInfo.removedChildPackages == null) {
                res.removedInfo.removedChildPackages = new ArrayMap<>();
            }
            res.removedInfo.removedChildPackages.put(childPkg.packageName, childRemovedRes);
        }
    }
    boolean sysPkg = (isSystemApp(oldPackage));
    if (sysPkg) {
        // Set the system/privileged flags as needed
        final boolean privileged = (oldPackage.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0;
        final int systemPolicyFlags = policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0);
        replaceSystemPackageLIF(oldPackage, pkg, systemPolicyFlags, scanFlags, user, allUsers, installerPackageName, res, installReason);
    } else {
        replaceNonSystemPackageLIF(oldPackage, pkg, policyFlags, scanFlags, user, allUsers, installerPackageName, res, installReason);
    }
}
#end_block

#method_before
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    boolean replace = false;
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    if (instantApp) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (fullApp) {
        scanFlags |= SCAN_AS_FULL_APP;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (instantApp && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (instantApp ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    pp.setCallback(mPackageParserCallback);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Instant apps must have target SDK >= O and have targetSanboxVersion >= 2
    if (instantApp && pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.N_MR1) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target O");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must target O");
        return;
    }
    if (instantApp && pkg.applicationInfo.targetSandboxVersion != 2) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must use targetSanboxVersion 2");
        return;
    }
    if (pkg.applicationInfo.isStaticSharedLibrary()) {
        // Static shared libraries have synthetic package names
        renameStaticSharedLibraryPackage(pkg);
        // No static shared libs on external storage
        if (onExternal) {
            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Packages declaring static-shared libs cannot be updated");
            return;
        }
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo(this);
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.certificates != null) {
            try {
                PackageParser.populateCertificates(pkg, args.certificates);
            } catch (PackageParserException e) {
                // there was something wrong with the certificates we were given;
                // try to pull them from the APK
                PackageParser.collectCertificates(pkg, parseFlags);
            }
        } else {
            PackageParser.collectCertificates(pkg, parseFlags);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.getRenamedPackageLPr(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent apps from downgrading their targetSandbox.
                final int oldTargetSandbox = oldPackage.applicationInfo.targetSandboxVersion;
                final int newTargetSandbox = pkg.applicationInfo.targetSandboxVersion;
                if (oldTargetSandbox == 2 && newTargetSandbox != 2) {
                    res.setError(PackageManager.INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Package " + pkg.packageName + " new target sandbox " + newTargetSandbox + " is incompatible with the previous value of" + oldTargetSandbox + ".");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // Static shared libs have same package with different versions where
            // we internally use a synthetic package name to allow multiple versions
            // of the same package, therefore we need to compare signatures against
            // the package setting for the latest library version.
            PackageSetting signatureCheckPs = ps;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                if (libraryEntry != null) {
                    signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);
                }
            }
            // bail early here before tripping over redefined permissions.
            if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
                if (!checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    verifySignaturesLP(signatureCheckPs, pkg);
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            PackageParser.Permission perm = pkg.permissions.get(i);
            BasePermission bp = mSettings.mPermissions.get(perm.info.name);
            // Don't allow anyone but the system to define ephemeral permissions.
            if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_FLAG_EPHEMERAL) != 0 && !systemApp) {
                Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                perm.info.protectionLevel &= ~PermissionInfo.PROTECTION_FLAG_EPHEMERAL;
            }
            // Check whether the newly-scanned package wants to define an already-defined perm
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) {
                    sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                } else {
                    sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!bp.sourcePackage.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                        res.origPermission = perm.info.name;
                        res.origPackage = bp.sourcePackage;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName)) {
                    // it as dangerous leading to the group auto-grant.
                    if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS) {
                        if (bp != null && !bp.isRuntime()) {
                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                            perm.info.protectionLevel = bp.protectionLevel;
                        }
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (instantApp) {
            // Abort update; system app can't be replaced with an instant app
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Cannot update a system app with an instant app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, extractNativeLibs, mAppLib32InstallDir);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPr(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    // Verify if we need to dexopt the app.
    // 
    // NOTE: it is *important* to call dexopt after doRename which will sync the
    // package data from PackageParser.Package and its corresponding ApplicationInfo.
    // 
    // We only need to dexopt if the package meets ALL of the following conditions:
    // 1) it is not forward locked.
    // 2) it is not on on an external ASEC container.
    // 3) it is not an instant app or if it is then dexopt is enabled via gservices.
    // 
    // Note that we do not dexopt instant apps by default. dexopt can take some time to
    // complete, so we skip this step during installation. Instead, we'll take extra time
    // the first time the instant app starts. It's preferred to do it this way to provide
    // continuous progress to the useur instead of mysteriously blocking somewhere in the
    // middle of running an instant app. The default behaviour can be overridden
    // via gservices.
    final boolean performDexopt = !forwardLocked && !pkg.applicationInfo.isExternalAsec() && (!instantApp || Global.getInt(mContext.getContentResolver(), Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0);
    if (performDexopt) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
        // Do not run PackageDexOptimizer through the local performDexOpt
        // method because `pkg` may not be in `mPackages` yet.
        // 
        // Also, don't fail application installs if the dexopt step fails.
        DexoptOptions dexoptOptions = new DexoptOptions(pkg.packageName, REASON_INSTALL, DexoptOptions.DEXOPT_BOOT_COMPLETE);
        mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, /* instructionSets */
        getOrCreateCompilerPackageStats(pkg), mDexManager.getPackageUseInfoOrDefault(pkg.packageName), dexoptOptions);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Notify BackgroundDexOptService that the package has been changed.
    // If this is an update of a package which used to fail to compile,
    // BackgroundDexOptService will remove it from its blacklist.
    // TODO: Layering violation
    BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                // Static libs have a synthetic package name containing the version
                // and cannot be updated as an update would get a new package name,
                // unless this is the exact same version code which is useful for
                // development.
                PackageParser.Package existingPkg = mPackages.get(pkg.packageName);
                if (existingPkg != null && existingPkg.mVersionCode != pkg.mVersionCode) {
                    res.setError(INSTALL_FAILED_DUPLICATE_PACKAGE, "Packages declaring " + "static-shared libs cannot be updated");
                    return;
                }
            }
            replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res, args.installReason);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res, args.installReason);
        }
    }
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
            ps.setUpdateAvailable(false);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            updateSequenceNumberLP(ps, res.newUsers);
            updateInstantAppInstallerLocked(pkgName);
        }
    }
}
#method_after
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean instantApp = ((installFlags & PackageManager.INSTALL_INSTANT_APP) != 0);
    final boolean fullApp = ((installFlags & PackageManager.INSTALL_FULL_APP) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    boolean replace = false;
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    if (instantApp) {
        scanFlags |= SCAN_AS_INSTANT_APP;
    }
    if (fullApp) {
        scanFlags |= SCAN_AS_FULL_APP;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (instantApp && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (instantApp ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    pp.setCallback(mPackageParserCallback);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Instant apps must have target SDK >= O and have targetSanboxVersion >= 2
    if (instantApp && pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.N_MR1) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target O");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must target O");
        return;
    }
    if (instantApp && pkg.applicationInfo.targetSandboxVersion != 2) {
        Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
        res.setError(INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Instant app package must use targetSanboxVersion 2");
        return;
    }
    if (pkg.applicationInfo.isStaticSharedLibrary()) {
        // Static shared libraries have synthetic package names
        renameStaticSharedLibraryPackage(pkg);
        // No static shared libs on external storage
        if (onExternal) {
            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Packages declaring static-shared libs cannot be updated");
            return;
        }
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo(this);
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                    childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.certificates != null) {
            try {
                PackageParser.populateCertificates(pkg, args.certificates);
            } catch (PackageParserException e) {
                // there was something wrong with the certificates we were given;
                // try to pull them from the APK
                PackageParser.collectCertificates(pkg, parseFlags);
            }
        } else {
            PackageParser.collectCertificates(pkg, parseFlags);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.getRenamedPackageLPr(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent apps from downgrading their targetSandbox.
                final int oldTargetSandbox = oldPackage.applicationInfo.targetSandboxVersion;
                final int newTargetSandbox = pkg.applicationInfo.targetSandboxVersion;
                if (oldTargetSandbox == 2 && newTargetSandbox != 2) {
                    res.setError(PackageManager.INSTALL_FAILED_SANDBOX_VERSION_DOWNGRADE, "Package " + pkg.packageName + " new target sandbox " + newTargetSandbox + " is incompatible with the previous value of" + oldTargetSandbox + ".");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // Static shared libs have same package with different versions where
            // we internally use a synthetic package name to allow multiple versions
            // of the same package, therefore we need to compare signatures against
            // the package setting for the latest library version.
            PackageSetting signatureCheckPs = ps;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                if (libraryEntry != null) {
                    signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);
                }
            }
            // bail early here before tripping over redefined permissions.
            if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
                if (!checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    verifySignaturesLP(signatureCheckPs, pkg);
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            PackageParser.Permission perm = pkg.permissions.get(i);
            BasePermission bp = mSettings.mPermissions.get(perm.info.name);
            // Don't allow anyone but the system to define ephemeral permissions.
            if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_FLAG_EPHEMERAL) != 0 && !systemApp) {
                Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                perm.info.protectionLevel &= ~PermissionInfo.PROTECTION_FLAG_EPHEMERAL;
            }
            // Check whether the newly-scanned package wants to define an already-defined perm
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) {
                    sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                } else {
                    sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!bp.sourcePackage.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                        res.origPermission = perm.info.name;
                        res.origPackage = bp.sourcePackage;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName)) {
                    // it as dangerous leading to the group auto-grant.
                    if ((perm.info.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS) {
                        if (bp != null && !bp.isRuntime()) {
                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                            perm.info.protectionLevel = bp.protectionLevel;
                        }
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (instantApp) {
            // Abort update; system app can't be replaced with an instant app
            res.setError(INSTALL_FAILED_INSTANT_APP_INVALID, "Cannot update a system app with an instant app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            final boolean extractNativeLibs = !pkg.isLibrary();
            derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, extractNativeLibs, mAppLib32InstallDir);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPr(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    if (!instantApp) {
        startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    } else {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Not verifying instant app install for app links: " + pkgName);
        }
    }
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                // Static libs have a synthetic package name containing the version
                // and cannot be updated as an update would get a new package name,
                // unless this is the exact same version code which is useful for
                // development.
                PackageParser.Package existingPkg = mPackages.get(pkg.packageName);
                if (existingPkg != null && existingPkg.mVersionCode != pkg.mVersionCode) {
                    res.setError(INSTALL_FAILED_DUPLICATE_PACKAGE, "Packages declaring " + "static-shared libs cannot be updated");
                    return;
                }
            }
            replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res, args.installReason);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res, args.installReason);
        }
    }
    // Check whether we need to dexopt the app.
    // 
    // NOTE: it is IMPORTANT to call dexopt:
    // - after doRename which will sync the package data from PackageParser.Package and its
    // corresponding ApplicationInfo.
    // - after installNewPackageLIF or replacePackageLIF which will update result with the
    // uid of the application (pkg.applicationInfo.uid).
    // This update happens in place!
    // 
    // We only need to dexopt if the package meets ALL of the following conditions:
    // 1) it is not forward locked.
    // 2) it is not on on an external ASEC container.
    // 3) it is not an instant app or if it is then dexopt is enabled via gservices.
    // 
    // Note that we do not dexopt instant apps by default. dexopt can take some time to
    // complete, so we skip this step during installation. Instead, we'll take extra time
    // the first time the instant app starts. It's preferred to do it this way to provide
    // continuous progress to the useur instead of mysteriously blocking somewhere in the
    // middle of running an instant app. The default behaviour can be overridden
    // via gservices.
    final boolean performDexopt = (res.returnCode == PackageManager.INSTALL_SUCCEEDED) && !forwardLocked && !pkg.applicationInfo.isExternalAsec() && (!instantApp || Global.getInt(mContext.getContentResolver(), Global.INSTANT_APP_DEXOPT_ENABLED, 0) != 0);
    if (performDexopt) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
        // Do not run PackageDexOptimizer through the local performDexOpt
        // method because `pkg` may not be in `mPackages` yet.
        // 
        // Also, don't fail application installs if the dexopt step fails.
        DexoptOptions dexoptOptions = new DexoptOptions(pkg.packageName, REASON_INSTALL, DexoptOptions.DEXOPT_BOOT_COMPLETE);
        mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, /* instructionSets */
        getOrCreateCompilerPackageStats(pkg), mDexManager.getPackageUseInfoOrDefault(pkg.packageName), dexoptOptions);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // Notify BackgroundDexOptService that the package has been changed.
    // If this is an update of a package which used to fail to compile,
    // BackgroundDexOptService will remove it from its blacklist.
    // TODO: Layering violation
    BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
            ps.setUpdateAvailable(false);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.getPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
            updateSequenceNumberLP(ps, res.newUsers);
            updateInstantAppInstallerLocked(pkgName);
        }
    }
}
#end_block

#method_before
public void testCollectDeviceInfo() throws Exception {
    if (!mActivityList.contains(getClass().getName())) {
        return;
    }
    final File dir = makeResultDir();
    if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
        failed("External storage is not mounted");
    } else if (dir == null) {
        failed("Cannot create directory for device info files");
    } else {
        try {
            File jsonFile = new File(dir, getClass().getSimpleName() + ".deviceinfo.json");
            jsonFile.createNewFile();
            mResultFilePath = jsonFile.getAbsolutePath();
            DeviceInfoStore store = new DeviceInfoStore(jsonFile);
            store.open();
            collectDeviceInfo(store);
            store.close();
            if (mResultCode == ResultCode.STARTED) {
                mResultCode = ResultCode.COMPLETED;
            }
        } catch (Exception e) {
            failed("Could not collect device info", e);
        }
    }
    String message = getClass().getSimpleName() + " collection completed.";
    assertEquals(message, ResultCode.COMPLETED, mResultCode);
}
#method_after
public void testCollectDeviceInfo() throws Exception {
    if (!mActivityList.contains(getClass().getName())) {
        return;
    }
    final File dir;
    if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
        failed("External storage is not mounted");
    } else if ((dir = makeResultDir()) == null) {
        failed("Cannot create directory for device info files");
    } else {
        try {
            File jsonFile = new File(dir, getClass().getSimpleName() + ".deviceinfo.json");
            jsonFile.createNewFile();
            mResultFilePath = jsonFile.getAbsolutePath();
            DeviceInfoStore store = new DeviceInfoStore(jsonFile);
            store.open();
            collectDeviceInfo(store);
            store.close();
            if (mResultCode == ResultCode.STARTED) {
                mResultCode = ResultCode.COMPLETED;
            }
        } catch (Exception e) {
            failed("Could not collect device info", e);
        }
    }
    String message = getClass().getSimpleName() + " collection completed.";
    assertEquals(message, ResultCode.COMPLETED, mResultCode);
}
#end_block

#method_before
private void handleCommand(CommandParams cmdParams, boolean isProactiveCmd) {
    CatLog.d(this, cmdParams.getCommandType().name());
    // Log all proactive commands.
    if (isProactiveCmd) {
        if (mUiccController != null) {
            mUiccController.addCardLog("ProactiveCommand mSlotId=" + mSlotId + " cmdParams=" + cmdParams);
        }
    }
    CharSequence message;
    ResultCode resultCode;
    CatCmdMessage cmdMsg = new CatCmdMessage(cmdParams);
    switch(cmdParams.getCommandType()) {
        case SET_UP_MENU:
            if (removeMenu(cmdMsg.getMenu())) {
                mMenuCmd = null;
            } else {
                mMenuCmd = cmdMsg;
            }
            resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK;
            sendTerminalResponse(cmdParams.mCmdDet, resultCode, false, 0, null);
            break;
        case DISPLAY_TEXT:
            break;
        case REFRESH:
            // ME side only handles refresh commands which meant to remove IDLE
            // MODE TEXT.
            cmdParams.mCmdDet.typeOfCommand = CommandType.SET_UP_IDLE_MODE_TEXT.value();
            break;
        case SET_UP_IDLE_MODE_TEXT:
            resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK;
            sendTerminalResponse(cmdParams.mCmdDet, resultCode, false, 0, null);
            break;
        case SET_UP_EVENT_LIST:
            if (isSupportedSetupEventCommand(cmdMsg)) {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            } else {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.BEYOND_TERMINAL_CAPABILITY, false, 0, null);
            }
            break;
        case PROVIDE_LOCAL_INFORMATION:
            ResponseData resp;
            switch(cmdParams.mCmdDet.commandQualifier) {
                case CommandParamsFactory.DTTZ_SETTING:
                    resp = new DTTZResponseData(null);
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, resp);
                    break;
                case CommandParamsFactory.LANGUAGE_SETTING:
                    resp = new LanguageResponseData(Locale.getDefault().getLanguage());
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, resp);
                    break;
                default:
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            }
            // No need to start STK app here.
            return;
        case LAUNCH_BROWSER:
            if ((((LaunchBrowserParams) cmdParams).mConfirmMsg.text != null) && (((LaunchBrowserParams) cmdParams).mConfirmMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.launchBrowserDefault);
                ((LaunchBrowserParams) cmdParams).mConfirmMsg.text = message.toString();
            }
            break;
        case SELECT_ITEM:
        case GET_INPUT:
        case GET_INKEY:
            break;
        case SEND_DTMF:
        case SEND_SMS:
        case SEND_SS:
        case SEND_USSD:
            if ((((DisplayTextParams) cmdParams).mTextMsg.text != null) && (((DisplayTextParams) cmdParams).mTextMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.sending);
                ((DisplayTextParams) cmdParams).mTextMsg.text = message.toString();
            }
            break;
        case PLAY_TONE:
            break;
        case SET_UP_CALL:
            if ((((CallSetupParams) cmdParams).mConfirmMsg.text != null) && (((CallSetupParams) cmdParams).mConfirmMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.SetupCallDefault);
                ((CallSetupParams) cmdParams).mConfirmMsg.text = message.toString();
            }
            break;
        case OPEN_CHANNEL:
        case CLOSE_CHANNEL:
        case RECEIVE_DATA:
        case SEND_DATA:
            BIPClientParams cmd = (BIPClientParams) cmdParams;
            /* Per 3GPP specification 102.223,
                 * if the alpha identifier is not provided by the UICC,
                 * the terminal MAY give information to the user
                 * noAlphaUsrCnf defines if you need to show user confirmation or not
                 */
            boolean noAlphaUsrCnf = false;
            try {
                noAlphaUsrCnf = mContext.getResources().getBoolean(com.android.internal.R.bool.config_stkNoAlphaUsrCnf);
            } catch (NotFoundException e) {
                noAlphaUsrCnf = false;
            }
            if ((cmd.mTextMsg.text == null) && (cmd.mHasAlphaId || noAlphaUsrCnf)) {
                CatLog.d(this, "cmd " + cmdParams.getCommandType() + " with null alpha id");
                // If alpha length is zero, we just respond with OK.
                if (isProactiveCmd) {
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
                } else if (cmdParams.getCommandType() == CommandType.OPEN_CHANNEL) {
                    mCmdIf.handleCallSetupRequestFromSim(true, null);
                }
                return;
            }
            // Respond with permanent failure to avoid retry if STK app is not present.
            if (!mStkAppInstalled) {
                CatLog.d(this, "No STK application found.");
                if (isProactiveCmd) {
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.BEYOND_TERMINAL_CAPABILITY, false, 0, null);
                    return;
                }
            }
            /*
                 * CLOSE_CHANNEL, RECEIVE_DATA and SEND_DATA can be delivered by
                 * either PROACTIVE_COMMAND or EVENT_NOTIFY.
                 * If PROACTIVE_COMMAND is used for those commands, send terminal
                 * response here.
                 */
            if (isProactiveCmd && ((cmdParams.getCommandType() == CommandType.CLOSE_CHANNEL) || (cmdParams.getCommandType() == CommandType.RECEIVE_DATA) || (cmdParams.getCommandType() == CommandType.SEND_DATA))) {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            }
            break;
        default:
            CatLog.d(this, "Unsupported command");
            return;
    }
    mCurrntCmd = cmdMsg;
    broadcastCatCmdIntent(cmdMsg);
}
#method_after
private void handleCommand(CommandParams cmdParams, boolean isProactiveCmd) {
    CatLog.d(this, cmdParams.getCommandType().name());
    // Log all proactive commands.
    if (isProactiveCmd) {
        if (mUiccController != null) {
            mUiccController.addCardLog("ProactiveCommand mSlotId=" + mSlotId + " cmdParams=" + cmdParams);
        }
    }
    CharSequence message;
    ResultCode resultCode;
    CatCmdMessage cmdMsg = new CatCmdMessage(cmdParams);
    switch(cmdParams.getCommandType()) {
        case SET_UP_MENU:
            if (removeMenu(cmdMsg.getMenu())) {
                mMenuCmd = null;
            } else {
                mMenuCmd = cmdMsg;
            }
            resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK;
            sendTerminalResponse(cmdParams.mCmdDet, resultCode, false, 0, null);
            break;
        case DISPLAY_TEXT:
            break;
        case REFRESH:
            // ME side only handles refresh commands which meant to remove IDLE
            // MODE TEXT.
            cmdParams.mCmdDet.typeOfCommand = CommandType.SET_UP_IDLE_MODE_TEXT.value();
            break;
        case SET_UP_IDLE_MODE_TEXT:
            resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK;
            sendTerminalResponse(cmdParams.mCmdDet, resultCode, false, 0, null);
            break;
        case SET_UP_EVENT_LIST:
            if (isSupportedSetupEventCommand(cmdMsg)) {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            } else {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.BEYOND_TERMINAL_CAPABILITY, false, 0, null);
            }
            break;
        case PROVIDE_LOCAL_INFORMATION:
            ResponseData resp;
            switch(cmdParams.mCmdDet.commandQualifier) {
                case CommandParamsFactory.DTTZ_SETTING:
                    resp = new DTTZResponseData(null);
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, resp);
                    break;
                case CommandParamsFactory.LANGUAGE_SETTING:
                    resp = new LanguageResponseData(Locale.getDefault().getLanguage());
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, resp);
                    break;
                default:
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            }
            // No need to start STK app here.
            return;
        case LAUNCH_BROWSER:
            if ((((LaunchBrowserParams) cmdParams).mConfirmMsg.text != null) && (((LaunchBrowserParams) cmdParams).mConfirmMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.launchBrowserDefault);
                ((LaunchBrowserParams) cmdParams).mConfirmMsg.text = message.toString();
            }
            break;
        case SELECT_ITEM:
        case GET_INPUT:
        case GET_INKEY:
            break;
        case SEND_DTMF:
        case SEND_SMS:
        case SEND_SS:
        case SEND_USSD:
            if ((((DisplayTextParams) cmdParams).mTextMsg.text != null) && (((DisplayTextParams) cmdParams).mTextMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.sending);
                ((DisplayTextParams) cmdParams).mTextMsg.text = message.toString();
            }
            break;
        case PLAY_TONE:
            break;
        case SET_UP_CALL:
            if ((((CallSetupParams) cmdParams).mConfirmMsg.text != null) && (((CallSetupParams) cmdParams).mConfirmMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.SetupCallDefault);
                ((CallSetupParams) cmdParams).mConfirmMsg.text = message.toString();
            }
            break;
        case LANGUAGE_NOTIFICATION:
            String language = ((LanguageParams) cmdParams).mLanguage;
            ResultCode result = ResultCode.OK;
            if (language != null && language.length() > 0) {
                try {
                    changeLanguage(language);
                } catch (RemoteException e) {
                    result = ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS;
                }
            }
            sendTerminalResponse(cmdParams.mCmdDet, result, false, 0, null);
            return;
        case OPEN_CHANNEL:
        case CLOSE_CHANNEL:
        case RECEIVE_DATA:
        case SEND_DATA:
            BIPClientParams cmd = (BIPClientParams) cmdParams;
            /* Per 3GPP specification 102.223,
                 * if the alpha identifier is not provided by the UICC,
                 * the terminal MAY give information to the user
                 * noAlphaUsrCnf defines if you need to show user confirmation or not
                 */
            boolean noAlphaUsrCnf = false;
            try {
                noAlphaUsrCnf = mContext.getResources().getBoolean(com.android.internal.R.bool.config_stkNoAlphaUsrCnf);
            } catch (NotFoundException e) {
                noAlphaUsrCnf = false;
            }
            if ((cmd.mTextMsg.text == null) && (cmd.mHasAlphaId || noAlphaUsrCnf)) {
                CatLog.d(this, "cmd " + cmdParams.getCommandType() + " with null alpha id");
                // If alpha length is zero, we just respond with OK.
                if (isProactiveCmd) {
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
                } else if (cmdParams.getCommandType() == CommandType.OPEN_CHANNEL) {
                    mCmdIf.handleCallSetupRequestFromSim(true, null);
                }
                return;
            }
            // Respond with permanent failure to avoid retry if STK app is not present.
            if (!mStkAppInstalled) {
                CatLog.d(this, "No STK application found.");
                if (isProactiveCmd) {
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.BEYOND_TERMINAL_CAPABILITY, false, 0, null);
                    return;
                }
            }
            /*
                 * CLOSE_CHANNEL, RECEIVE_DATA and SEND_DATA can be delivered by
                 * either PROACTIVE_COMMAND or EVENT_NOTIFY.
                 * If PROACTIVE_COMMAND is used for those commands, send terminal
                 * response here.
                 */
            if (isProactiveCmd && ((cmdParams.getCommandType() == CommandType.CLOSE_CHANNEL) || (cmdParams.getCommandType() == CommandType.RECEIVE_DATA) || (cmdParams.getCommandType() == CommandType.SEND_DATA))) {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            }
            break;
        default:
            CatLog.d(this, "Unsupported command");
            return;
    }
    mCurrntCmd = cmdMsg;
    broadcastCatCmdIntent(cmdMsg);
}
#end_block

#method_before
private void encodeOptionalTags(CommandDetails cmdDet, ResultCode resultCode, Input cmdInput, ByteArrayOutputStream buf) {
    CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    if (cmdType != null) {
        switch(cmdType) {
            case GET_INPUT:
            case GET_INKEY:
                // occured, then add DURATION TLV for variable timeout case.
                if ((resultCode.value() == ResultCode.NO_RESPONSE_FROM_USER.value()) && (cmdInput != null) && (cmdInput.duration != null)) {
                    getInKeyResponse(buf, cmdInput);
                }
                break;
            case PROVIDE_LOCAL_INFORMATION:
                if ((cmdDet.commandQualifier == CommandParamsFactory.LANGUAGE_SETTING) && (resultCode.value() == ResultCode.OK.value())) {
                    getPliResponse(buf);
                }
                break;
            default:
                CatLog.d(this, "encodeOptionalTags() Unsupported Cmd details=" + cmdDet);
                break;
        }
    } else {
        CatLog.d(this, "encodeOptionalTags() bad Cmd details=" + cmdDet);
    }
}
#method_after
private void encodeOptionalTags(CommandDetails cmdDet, ResultCode resultCode, Input cmdInput, ByteArrayOutputStream buf) {
    CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    if (cmdType != null) {
        switch(cmdType) {
            case GET_INPUT:
            case GET_INKEY:
                // GET INPUT command should also be handled in the same manner.
                if ((resultCode.value() == ResultCode.NO_RESPONSE_FROM_USER.value()) && (cmdInput != null) && (cmdInput.duration != null)) {
                    getInKeyResponse(buf, cmdInput);
                }
                break;
            case PROVIDE_LOCAL_INFORMATION:
                if ((cmdDet.commandQualifier == CommandParamsFactory.LANGUAGE_SETTING) && (resultCode.value() == ResultCode.OK.value())) {
                    getPliResponse(buf);
                }
                break;
            default:
                CatLog.d(this, "encodeOptionalTags() Unsupported Cmd details=" + cmdDet);
                break;
        }
    } else {
        CatLog.d(this, "encodeOptionalTags() bad Cmd details=" + cmdDet);
    }
}
#end_block

#method_before
private void handleCmdResponse(CatResponseMessage resMsg) {
    // However, we should allow Stk framework to send the message to ICC.
    if (!validateResponse(resMsg)) {
        return;
    }
    ResponseData resp = null;
    boolean helpRequired = false;
    CommandDetails cmdDet = resMsg.getCmdDetails();
    AppInterface.CommandType type = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    switch(resMsg.mResCode) {
        case HELP_INFO_REQUIRED:
            helpRequired = true;
        // fall through
        case OK:
        case PRFRMD_WITH_PARTIAL_COMPREHENSION:
        case PRFRMD_WITH_MISSING_INFO:
        case PRFRMD_WITH_ADDITIONAL_EFS_READ:
        case PRFRMD_ICON_NOT_DISPLAYED:
        case PRFRMD_MODIFIED_BY_NAA:
        case PRFRMD_LIMITED_SERVICE:
        case PRFRMD_WITH_MODIFICATION:
        case PRFRMD_NAA_NOT_ACTIVE:
        case PRFRMD_TONE_NOT_PLAYED:
        case LAUNCH_BROWSER_ERROR:
        case TERMINAL_CRNTLY_UNABLE_TO_PROCESS:
            switch(type) {
                case SET_UP_MENU:
                    helpRequired = resMsg.mResCode == ResultCode.HELP_INFO_REQUIRED;
                    sendMenuSelection(resMsg.mUsersMenuSelection, helpRequired);
                    return;
                case SELECT_ITEM:
                    resp = new SelectItemResponseData(resMsg.mUsersMenuSelection);
                    break;
                case GET_INPUT:
                case GET_INKEY:
                    Input input = mCurrntCmd.geInput();
                    if (!input.yesNo) {
                        // string object.
                        if (!helpRequired) {
                            resp = new GetInkeyInputResponseData(resMsg.mUsersInput, input.ucs2, input.packed);
                        }
                    } else {
                        resp = new GetInkeyInputResponseData(resMsg.mUsersYesNoSelection);
                    }
                    break;
                case DISPLAY_TEXT:
                    if (resMsg.mResCode == ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS) {
                        // For screenbusy case there will be addtional information in the terminal
                        // response. And the value of the additional information byte is 0x01.
                        resMsg.setAdditionalInfo(0x01);
                    } else {
                        resMsg.mIncludeAdditionalInfo = false;
                        resMsg.mAdditionalInfo = 0;
                    }
                    break;
                case LAUNCH_BROWSER:
                    break;
                // 3GPP TS.102.223: Open Channel alpha confirmation should not send TR
                case OPEN_CHANNEL:
                case SET_UP_CALL:
                    mCmdIf.handleCallSetupRequestFromSim(resMsg.mUsersConfirm, null);
                    // No need to send terminal response for SET UP CALL. The user's
                    // confirmation result is send back using a dedicated ril message
                    // invoked by the CommandInterface call above.
                    mCurrntCmd = null;
                    return;
                case SET_UP_EVENT_LIST:
                    if (IDLE_SCREEN_AVAILABLE_EVENT == resMsg.mEventValue) {
                        eventDownload(resMsg.mEventValue, DEV_ID_DISPLAY, DEV_ID_UICC, resMsg.mAddedInfo, false);
                    } else {
                        eventDownload(resMsg.mEventValue, DEV_ID_TERMINAL, DEV_ID_UICC, resMsg.mAddedInfo, false);
                    }
                    // No need to send the terminal response after event download.
                    return;
                default:
                    break;
            }
            break;
        case BACKWARD_MOVE_BY_USER:
        case USER_NOT_ACCEPT:
            // sending a terminal response.
            if (type == CommandType.SET_UP_CALL || type == CommandType.OPEN_CHANNEL) {
                mCmdIf.handleCallSetupRequestFromSim(false, null);
                mCurrntCmd = null;
                return;
            } else {
                resp = null;
            }
            break;
        case NO_RESPONSE_FROM_USER:
        case UICC_SESSION_TERM_BY_USER:
            resp = null;
            break;
        default:
            return;
    }
    sendTerminalResponse(cmdDet, resMsg.mResCode, resMsg.mIncludeAdditionalInfo, resMsg.mAdditionalInfo, resp);
    mCurrntCmd = null;
}
#method_after
private void handleCmdResponse(CatResponseMessage resMsg) {
    // However, we should allow Stk framework to send the message to ICC.
    if (!validateResponse(resMsg)) {
        return;
    }
    ResponseData resp = null;
    boolean helpRequired = false;
    CommandDetails cmdDet = resMsg.getCmdDetails();
    AppInterface.CommandType type = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    switch(resMsg.mResCode) {
        case HELP_INFO_REQUIRED:
            helpRequired = true;
        // fall through
        case OK:
        case PRFRMD_WITH_PARTIAL_COMPREHENSION:
        case PRFRMD_WITH_MISSING_INFO:
        case PRFRMD_WITH_ADDITIONAL_EFS_READ:
        case PRFRMD_ICON_NOT_DISPLAYED:
        case PRFRMD_MODIFIED_BY_NAA:
        case PRFRMD_LIMITED_SERVICE:
        case PRFRMD_WITH_MODIFICATION:
        case PRFRMD_NAA_NOT_ACTIVE:
        case PRFRMD_TONE_NOT_PLAYED:
        case LAUNCH_BROWSER_ERROR:
        case TERMINAL_CRNTLY_UNABLE_TO_PROCESS:
            switch(type) {
                case SET_UP_MENU:
                    helpRequired = resMsg.mResCode == ResultCode.HELP_INFO_REQUIRED;
                    sendMenuSelection(resMsg.mUsersMenuSelection, helpRequired);
                    return;
                case SELECT_ITEM:
                    resp = new SelectItemResponseData(resMsg.mUsersMenuSelection);
                    break;
                case GET_INPUT:
                case GET_INKEY:
                    Input input = mCurrntCmd.geInput();
                    if (!input.yesNo) {
                        // string object.
                        if (!helpRequired) {
                            resp = new GetInkeyInputResponseData(resMsg.mUsersInput, input.ucs2, input.packed);
                        }
                    } else {
                        resp = new GetInkeyInputResponseData(resMsg.mUsersYesNoSelection);
                    }
                    break;
                case DISPLAY_TEXT:
                    if (resMsg.mResCode == ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS) {
                        // For screenbusy case there will be addtional information in the terminal
                        // response. And the value of the additional information byte is 0x01.
                        resMsg.setAdditionalInfo(0x01);
                    } else {
                        resMsg.mIncludeAdditionalInfo = false;
                        resMsg.mAdditionalInfo = 0;
                    }
                    break;
                case LAUNCH_BROWSER:
                    if (resMsg.mResCode == ResultCode.LAUNCH_BROWSER_ERROR) {
                        // Additional info for Default URL unavailable.
                        resMsg.setAdditionalInfo(0x04);
                    } else {
                        resMsg.mIncludeAdditionalInfo = false;
                        resMsg.mAdditionalInfo = 0;
                    }
                    break;
                // 3GPP TS.102.223: Open Channel alpha confirmation should not send TR
                case OPEN_CHANNEL:
                case SET_UP_CALL:
                    mCmdIf.handleCallSetupRequestFromSim(resMsg.mUsersConfirm, null);
                    // No need to send terminal response for SET UP CALL. The user's
                    // confirmation result is send back using a dedicated ril message
                    // invoked by the CommandInterface call above.
                    mCurrntCmd = null;
                    return;
                case SET_UP_EVENT_LIST:
                    if (IDLE_SCREEN_AVAILABLE_EVENT == resMsg.mEventValue) {
                        eventDownload(resMsg.mEventValue, DEV_ID_DISPLAY, DEV_ID_UICC, resMsg.mAddedInfo, false);
                    } else {
                        eventDownload(resMsg.mEventValue, DEV_ID_TERMINAL, DEV_ID_UICC, resMsg.mAddedInfo, false);
                    }
                    // No need to send the terminal response after event download.
                    return;
                default:
                    break;
            }
            break;
        case BACKWARD_MOVE_BY_USER:
        case USER_NOT_ACCEPT:
            // sending a terminal response.
            if (type == CommandType.SET_UP_CALL || type == CommandType.OPEN_CHANNEL) {
                mCmdIf.handleCallSetupRequestFromSim(false, null);
                mCurrntCmd = null;
                return;
            } else {
                resp = null;
            }
            break;
        case NO_RESPONSE_FROM_USER:
            // instead use dedicated API
            if (type == CommandType.SET_UP_CALL) {
                mCmdIf.handleCallSetupRequestFromSim(false, null);
                mCurrntCmd = null;
                return;
            }
        case UICC_SESSION_TERM_BY_USER:
            resp = null;
            break;
        default:
            return;
    }
    sendTerminalResponse(cmdDet, resMsg.mResCode, resMsg.mIncludeAdditionalInfo, resMsg.mAdditionalInfo, resp);
    mCurrntCmd = null;
}
#end_block

#method_before
void make(BerTlv berTlv) {
    if (berTlv == null) {
        return;
    }
    // reset global state parameters.
    mCmdParams = null;
    mIconLoadState = LOAD_NO_ICON;
    // only proactive command messages are processed.
    if (berTlv.getTag() != BerTlv.BER_PROACTIVE_COMMAND_TAG) {
        sendCmdParams(ResultCode.CMD_TYPE_NOT_UNDERSTOOD);
        return;
    }
    boolean cmdPending = false;
    List<ComprehensionTlv> ctlvs = berTlv.getComprehensionTlvs();
    // process command dtails from the tlv list.
    CommandDetails cmdDet = processCommandDetails(ctlvs);
    if (cmdDet == null) {
        sendCmdParams(ResultCode.CMD_TYPE_NOT_UNDERSTOOD);
        return;
    }
    // extract command type enumeration from the raw value stored inside
    // the Command Details object.
    AppInterface.CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    if (cmdType == null) {
        // This PROACTIVE COMMAND is presently not handled. Hence set
        // result code as BEYOND_TERMINAL_CAPABILITY in TR.
        mCmdParams = new CommandParams(cmdDet);
        sendCmdParams(ResultCode.BEYOND_TERMINAL_CAPABILITY);
        return;
    }
    // proactive command length is incorrect.
    if (!berTlv.isLengthValid()) {
        mCmdParams = new CommandParams(cmdDet);
        sendCmdParams(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
        return;
    }
    try {
        switch(cmdType) {
            case SET_UP_MENU:
                cmdPending = processSelectItem(cmdDet, ctlvs);
                break;
            case SELECT_ITEM:
                cmdPending = processSelectItem(cmdDet, ctlvs);
                break;
            case DISPLAY_TEXT:
                cmdPending = processDisplayText(cmdDet, ctlvs);
                break;
            case SET_UP_IDLE_MODE_TEXT:
                cmdPending = processSetUpIdleModeText(cmdDet, ctlvs);
                break;
            case GET_INKEY:
                cmdPending = processGetInkey(cmdDet, ctlvs);
                break;
            case GET_INPUT:
                cmdPending = processGetInput(cmdDet, ctlvs);
                break;
            case SEND_DTMF:
            case SEND_SMS:
            case SEND_SS:
            case SEND_USSD:
                cmdPending = processEventNotify(cmdDet, ctlvs);
                break;
            case GET_CHANNEL_STATUS:
            case SET_UP_CALL:
                cmdPending = processSetupCall(cmdDet, ctlvs);
                break;
            case REFRESH:
                processRefresh(cmdDet, ctlvs);
                cmdPending = false;
                break;
            case LAUNCH_BROWSER:
                cmdPending = processLaunchBrowser(cmdDet, ctlvs);
                break;
            case PLAY_TONE:
                cmdPending = processPlayTone(cmdDet, ctlvs);
                break;
            case SET_UP_EVENT_LIST:
                cmdPending = processSetUpEventList(cmdDet, ctlvs);
                break;
            case PROVIDE_LOCAL_INFORMATION:
                cmdPending = processProvideLocalInfo(cmdDet, ctlvs);
                break;
            case OPEN_CHANNEL:
            case CLOSE_CHANNEL:
            case RECEIVE_DATA:
            case SEND_DATA:
                cmdPending = processBIPClient(cmdDet, ctlvs);
                break;
            default:
                // unsupported proactive commands
                mCmdParams = new CommandParams(cmdDet);
                sendCmdParams(ResultCode.BEYOND_TERMINAL_CAPABILITY);
                return;
        }
    } catch (ResultException e) {
        CatLog.d(this, "make: caught ResultException e=" + e);
        mCmdParams = new CommandParams(cmdDet);
        sendCmdParams(e.result());
        return;
    }
    if (!cmdPending) {
        sendCmdParams(ResultCode.OK);
    }
}
#method_after
void make(BerTlv berTlv) {
    if (berTlv == null) {
        return;
    }
    // reset global state parameters.
    mCmdParams = null;
    mIconLoadState = LOAD_NO_ICON;
    // only proactive command messages are processed.
    if (berTlv.getTag() != BerTlv.BER_PROACTIVE_COMMAND_TAG) {
        sendCmdParams(ResultCode.CMD_TYPE_NOT_UNDERSTOOD);
        return;
    }
    boolean cmdPending = false;
    List<ComprehensionTlv> ctlvs = berTlv.getComprehensionTlvs();
    // process command dtails from the tlv list.
    CommandDetails cmdDet = processCommandDetails(ctlvs);
    if (cmdDet == null) {
        sendCmdParams(ResultCode.CMD_TYPE_NOT_UNDERSTOOD);
        return;
    }
    // extract command type enumeration from the raw value stored inside
    // the Command Details object.
    AppInterface.CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    if (cmdType == null) {
        // This PROACTIVE COMMAND is presently not handled. Hence set
        // result code as BEYOND_TERMINAL_CAPABILITY in TR.
        mCmdParams = new CommandParams(cmdDet);
        sendCmdParams(ResultCode.BEYOND_TERMINAL_CAPABILITY);
        return;
    }
    // proactive command length is incorrect.
    if (!berTlv.isLengthValid()) {
        mCmdParams = new CommandParams(cmdDet);
        sendCmdParams(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
        return;
    }
    try {
        switch(cmdType) {
            case SET_UP_MENU:
                cmdPending = processSelectItem(cmdDet, ctlvs);
                break;
            case SELECT_ITEM:
                cmdPending = processSelectItem(cmdDet, ctlvs);
                break;
            case DISPLAY_TEXT:
                cmdPending = processDisplayText(cmdDet, ctlvs);
                break;
            case SET_UP_IDLE_MODE_TEXT:
                cmdPending = processSetUpIdleModeText(cmdDet, ctlvs);
                break;
            case GET_INKEY:
                cmdPending = processGetInkey(cmdDet, ctlvs);
                break;
            case GET_INPUT:
                cmdPending = processGetInput(cmdDet, ctlvs);
                break;
            case SEND_DTMF:
            case SEND_SMS:
            case SEND_SS:
            case SEND_USSD:
                cmdPending = processEventNotify(cmdDet, ctlvs);
                break;
            case GET_CHANNEL_STATUS:
            case SET_UP_CALL:
                cmdPending = processSetupCall(cmdDet, ctlvs);
                break;
            case REFRESH:
                processRefresh(cmdDet, ctlvs);
                cmdPending = false;
                break;
            case LAUNCH_BROWSER:
                cmdPending = processLaunchBrowser(cmdDet, ctlvs);
                break;
            case PLAY_TONE:
                cmdPending = processPlayTone(cmdDet, ctlvs);
                break;
            case SET_UP_EVENT_LIST:
                cmdPending = processSetUpEventList(cmdDet, ctlvs);
                break;
            case PROVIDE_LOCAL_INFORMATION:
                cmdPending = processProvideLocalInfo(cmdDet, ctlvs);
                break;
            case LANGUAGE_NOTIFICATION:
                cmdPending = processLanguageNotification(cmdDet, ctlvs);
                break;
            case OPEN_CHANNEL:
            case CLOSE_CHANNEL:
            case RECEIVE_DATA:
            case SEND_DATA:
                cmdPending = processBIPClient(cmdDet, ctlvs);
                break;
            default:
                // unsupported proactive commands
                mCmdParams = new CommandParams(cmdDet);
                sendCmdParams(ResultCode.BEYOND_TERMINAL_CAPABILITY);
                return;
        }
    } catch (ResultException e) {
        CatLog.d(this, "make: caught ResultException e=" + e);
        mCmdParams = new CommandParams(cmdDet);
        sendCmdParams(e.result());
        return;
    }
    if (!cmdPending) {
        sendCmdParams(ResultCode.OK);
    }
}
#end_block

#method_before
private boolean processPlayTone(CommandDetails cmdDet, List<ComprehensionTlv> ctlvs) throws ResultException {
    CatLog.d(this, "process PlayTone");
    Tone tone = null;
    TextMessage textMsg = new TextMessage();
    Duration duration = null;
    IconId iconId = null;
    ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TONE, ctlvs);
    if (ctlv != null) {
        // Nothing to do for null objects.
        if (ctlv.getLength() > 0) {
            try {
                byte[] rawValue = ctlv.getRawValue();
                int valueIndex = ctlv.getValueIndex();
                int toneVal = rawValue[valueIndex];
                tone = Tone.fromInt(toneVal);
            } catch (IndexOutOfBoundsException e) {
                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
            }
        }
    }
    // parse alpha identifier
    ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID, ctlvs);
    if (ctlv != null) {
        textMsg.text = ValueParser.retrieveAlphaId(ctlv);
    }
    // parse tone duration
    ctlv = searchForTag(ComprehensionTlvTag.DURATION, ctlvs);
    if (ctlv != null) {
        duration = ValueParser.retrieveDuration(ctlv);
    }
    // parse icon identifier
    ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
    if (ctlv != null) {
        iconId = ValueParser.retrieveIconId(ctlv);
        textMsg.iconSelfExplanatory = iconId.selfExplanatory;
    }
    boolean vibrate = (cmdDet.commandQualifier & 0x01) != 0x00;
    textMsg.responseNeeded = false;
    mCmdParams = new PlayToneParams(cmdDet, textMsg, tone, duration, vibrate);
    if (iconId != null) {
        mIconLoadState = LOAD_SINGLE_ICON;
        mIconLoader.loadIcon(iconId.recordNumber, this.obtainMessage(MSG_ID_LOAD_ICON_DONE));
        return true;
    }
    return false;
}
#method_after
private boolean processPlayTone(CommandDetails cmdDet, List<ComprehensionTlv> ctlvs) throws ResultException {
    CatLog.d(this, "process PlayTone");
    Tone tone = null;
    TextMessage textMsg = new TextMessage();
    Duration duration = null;
    IconId iconId = null;
    ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TONE, ctlvs);
    if (ctlv != null) {
        // Nothing to do for null objects.
        if (ctlv.getLength() > 0) {
            try {
                byte[] rawValue = ctlv.getRawValue();
                int valueIndex = ctlv.getValueIndex();
                int toneVal = rawValue[valueIndex];
                tone = Tone.fromInt(toneVal);
            } catch (IndexOutOfBoundsException e) {
                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
            }
        }
    }
    // parse alpha identifier
    ctlv = searchForTag(ComprehensionTlvTag.ALPHA_ID, ctlvs);
    if (ctlv != null) {
        textMsg.text = ValueParser.retrieveAlphaId(ctlv);
        // message text will be null.
        if (textMsg.text == null)
            textMsg.text = "";
    }
    // parse tone duration
    ctlv = searchForTag(ComprehensionTlvTag.DURATION, ctlvs);
    if (ctlv != null) {
        duration = ValueParser.retrieveDuration(ctlv);
    }
    // parse icon identifier
    ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
    if (ctlv != null) {
        iconId = ValueParser.retrieveIconId(ctlv);
        textMsg.iconSelfExplanatory = iconId.selfExplanatory;
    }
    boolean vibrate = (cmdDet.commandQualifier & 0x01) != 0x00;
    textMsg.responseNeeded = false;
    mCmdParams = new PlayToneParams(cmdDet, textMsg, tone, duration, vibrate);
    if (iconId != null) {
        mIconLoadState = LOAD_SINGLE_ICON;
        mIconLoader.loadIcon(iconId.recordNumber, this.obtainMessage(MSG_ID_LOAD_ICON_DONE));
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public int updateCallBarringForServiceClass(int cbType, int action, int serviceClass, String[] barrList) throws RemoteException {
    return -1;
}
#method_after
@Override
public int updateCallBarringForServiceClass(int cbType, int action, String[] barrList, int serviceClass) throws RemoteException {
    return -1;
}
#end_block

#method_before
static ImsPhoneMmiCode newFromDialString(String dialString, ImsPhone phone, ResultReceiver wrappedCallback) {
    Matcher m;
    ImsPhoneMmiCode ret = null;
    m = sPatternSuppService.matcher(dialString);
    // Is this formatted like a standard supplementary service code?
    if (m.matches()) {
        ret = new ImsPhoneMmiCode(phone);
        ret.mPoundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));
        ret.mAction = makeEmptyNull(m.group(MATCH_GROUP_ACTION));
        ret.mSc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));
        ret.mSia = makeEmptyNull(m.group(MATCH_GROUP_SIA));
        ret.mSib = makeEmptyNull(m.group(MATCH_GROUP_SIB));
        ret.mSic = makeEmptyNull(m.group(MATCH_GROUP_SIC));
        ret.mPwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));
        ret.mDialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));
        ret.mCallbackReceiver = wrappedCallback;
        // in India operator(Mumbai MTNL)
        if (ret.mDialingNumber != null && ret.mDialingNumber.endsWith("#") && dialString.endsWith("#")) {
            ret = new ImsPhoneMmiCode(phone);
            ret.mPoundString = dialString;
        }
    } else if (dialString.endsWith("#")) {
        // TS 22.030 sec 6.5.3.2
        // "Entry of any characters defined in the 3GPP TS 23.038 [8] Default Alphabet
        // (up to the maximum defined in 3GPP TS 24.080 [10]), followed by #SEND".
        ret = new ImsPhoneMmiCode(phone);
        ret.mPoundString = dialString;
    } else if (isTwoDigitShortCode(phone.getContext(), dialString)) {
        // Is a country-specific exception to short codes as defined in TS 22.030, 6.5.3.2
        ret = null;
    } else if (isShortCode(dialString, phone)) {
        // this may be a short code, as defined in TS 22.030, 6.5.3.2
        ret = new ImsPhoneMmiCode(phone);
        ret.mDialingNumber = dialString;
    }
    return ret;
}
#method_after
static ImsPhoneMmiCode newFromDialString(String dialString, ImsPhone phone, ResultReceiver wrappedCallback) {
    Matcher m;
    ImsPhoneMmiCode ret = null;
    if (phone.getDefaultPhone().getServiceState().getVoiceRoaming() && phone.getDefaultPhone().supportsConversionOfCdmaCallerIdMmiCodesWhileRoaming()) {
        /* The CDMA MMI coded dialString will be converted to a 3GPP MMI Coded dialString
               so that it can be processed by the matcher and code below
             */
        dialString = convertCdmaMmiCodesTo3gppMmiCodes(dialString);
    }
    m = sPatternSuppService.matcher(dialString);
    // Is this formatted like a standard supplementary service code?
    if (m.matches()) {
        ret = new ImsPhoneMmiCode(phone);
        ret.mPoundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));
        ret.mAction = makeEmptyNull(m.group(MATCH_GROUP_ACTION));
        ret.mSc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));
        ret.mSia = makeEmptyNull(m.group(MATCH_GROUP_SIA));
        ret.mSib = makeEmptyNull(m.group(MATCH_GROUP_SIB));
        ret.mSic = makeEmptyNull(m.group(MATCH_GROUP_SIC));
        ret.mPwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));
        ret.mDialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));
        ret.mCallbackReceiver = wrappedCallback;
        // in India operator(Mumbai MTNL)
        if (ret.mDialingNumber != null && ret.mDialingNumber.endsWith("#") && dialString.endsWith("#")) {
            ret = new ImsPhoneMmiCode(phone);
            ret.mPoundString = dialString;
        }
    } else if (dialString.endsWith("#")) {
        // TS 22.030 sec 6.5.3.2
        // "Entry of any characters defined in the 3GPP TS 23.038 [8] Default Alphabet
        // (up to the maximum defined in 3GPP TS 24.080 [10]), followed by #SEND".
        ret = new ImsPhoneMmiCode(phone);
        ret.mPoundString = dialString;
    } else if (isTwoDigitShortCode(phone.getContext(), dialString)) {
        // Is a country-specific exception to short codes as defined in TS 22.030, 6.5.3.2
        ret = null;
    } else if (isShortCode(dialString, phone)) {
        // this may be a short code, as defined in TS 22.030, 6.5.3.2
        ret = new ImsPhoneMmiCode(phone);
        ret.mDialingNumber = dialString;
    }
    return ret;
}
#end_block

#method_before
boolean isSupportedOverImsPhone() {
    if (isShortCode())
        return true;
    else if (mDialingNumber != null)
        return false;
    else if (isServiceCodeCallForwarding(mSc) || isServiceCodeCallBarring(mSc) || (mSc != null && mSc.equals(SC_WAIT)) || (mSc != null && mSc.equals(SC_CLIR)) || (mSc != null && mSc.equals(SC_CLIP)) || (mSc != null && mSc.equals(SC_COLR)) || (mSc != null && mSc.equals(SC_COLP)) || (mSc != null && mSc.equals(SC_BS_MT)) || (mSc != null && mSc.equals(SC_BAICa))) {
        try {
            int serviceClass = siToServiceClass(mSib);
            if (serviceClass != SERVICE_CLASS_NONE && serviceClass != SERVICE_CLASS_VOICE && serviceClass != (SERVICE_CLASS_PACKET + SERVICE_CLASS_DATA_SYNC)) {
                return false;
            }
            return true;
        } catch (RuntimeException exc) {
            Rlog.d(LOG_TAG, "Invalid service class " + exc);
        }
    } else if (isPinPukCommand() || (mSc != null && (mSc.equals(SC_PWD) || mSc.equals(SC_CLIP) || mSc.equals(SC_CLIR)))) {
        return false;
    } else if (mPoundString != null)
        return true;
    return false;
}
#method_after
boolean isSupportedOverImsPhone() {
    if (isShortCode())
        return true;
    else if (isServiceCodeCallForwarding(mSc) || isServiceCodeCallBarring(mSc) || (mSc != null && mSc.equals(SC_WAIT)) || (mSc != null && mSc.equals(SC_CLIR)) || (mSc != null && mSc.equals(SC_CLIP)) || (mSc != null && mSc.equals(SC_COLR)) || (mSc != null && mSc.equals(SC_COLP)) || (mSc != null && mSc.equals(SC_BS_MT)) || (mSc != null && mSc.equals(SC_BAICa))) {
        try {
            int serviceClass = siToServiceClass(mSib);
            if (serviceClass != SERVICE_CLASS_NONE && serviceClass != SERVICE_CLASS_VOICE && serviceClass != (SERVICE_CLASS_PACKET + SERVICE_CLASS_DATA_SYNC)) {
                return false;
            }
            return true;
        } catch (RuntimeException exc) {
            Rlog.d(LOG_TAG, "Invalid service class " + exc);
        }
    } else if (isPinPukCommand() || (mSc != null && (mSc.equals(SC_PWD) || mSc.equals(SC_CLIP) || mSc.equals(SC_CLIR)))) {
        return false;
    } else if (mPoundString != null)
        return true;
    return false;
}
#end_block

#method_before
public void processCode() throws CallStateException {
    try {
        if (isShortCode()) {
            Rlog.d(LOG_TAG, "processCode: isShortCode");
            // These just get treated as USSD.
            Rlog.d(LOG_TAG, "processCode: Sending short code '" + mDialingNumber + "' over CS pipe.");
            throw new CallStateException(Phone.CS_FALLBACK);
        } else if (isServiceCodeCallForwarding(mSc)) {
            Rlog.d(LOG_TAG, "processCode: is CF");
            String dialingNumber = mSia;
            int reason = scToCallForwardReason(mSc);
            int serviceClass = siToServiceClass(mSib);
            int time = siToTime(mSic);
            if (isInterrogate()) {
                mPhone.getCallForwardingOption(reason, obtainMessage(EVENT_QUERY_CF_COMPLETE, this));
            } else {
                int cfAction;
                if (isActivate()) {
                    // number, or an activation if not
                    if (isEmptyOrNull(dialingNumber)) {
                        cfAction = CommandsInterface.CF_ACTION_ENABLE;
                        mIsCallFwdReg = false;
                    } else {
                        cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                        mIsCallFwdReg = true;
                    }
                } else if (isDeactivate()) {
                    cfAction = CommandsInterface.CF_ACTION_DISABLE;
                } else if (isRegister()) {
                    cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                } else if (isErasure()) {
                    cfAction = CommandsInterface.CF_ACTION_ERASURE;
                } else {
                    throw new RuntimeException("invalid action");
                }
                int isSettingUnconditional = ((reason == CommandsInterface.CF_REASON_UNCONDITIONAL) || (reason == CommandsInterface.CF_REASON_ALL)) ? 1 : 0;
                int isEnableDesired = ((cfAction == CommandsInterface.CF_ACTION_ENABLE) || (cfAction == CommandsInterface.CF_ACTION_REGISTRATION)) ? 1 : 0;
                Rlog.d(LOG_TAG, "processCode: is CF setCallForward");
                mPhone.setCallForwardingOption(cfAction, reason, dialingNumber, serviceClass, time, obtainMessage(EVENT_SET_CFF_COMPLETE, isSettingUnconditional, isEnableDesired, this));
            }
        } else if (isServiceCodeCallBarring(mSc)) {
            // sia = password
            // sib = basic service group
            // service group is not supported
            String password = mSia;
            String facility = scToBarringFacility(mSc);
            int serviceClass = siToServiceClass(mSib);
            if (isInterrogate()) {
                mPhone.getCallBarring(facility, serviceClass, obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
            } else if (isActivate() || isDeactivate()) {
                mPhone.setCallBarring(facility, isActivate(), serviceClass, password, obtainMessage(EVENT_SET_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIR)) {
            // Only the UT interface handle is used.
            if (isActivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIR(CommandsInterface.CLIR_INVOCATION, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIR.");
                }
            } else if (isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIR(CommandsInterface.CLIR_SUPPRESSION, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIR.");
                }
            } else if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCLIR(obtainMessage(EVENT_GET_CLIR_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCLIR.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIP)) {
            // NOTE: Refer to the note above.
            if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCLIP(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCLIP.");
                }
            } else if (isActivate() || isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIP(isActivate(), obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIP.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_COLP)) {
            // NOTE: Refer to the note above.
            if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCOLP(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCOLP.");
                }
            } else if (isActivate() || isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLP(isActivate(), obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLP.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_COLR)) {
            // NOTE: Refer to the note above.
            if (isActivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLR(NUM_PRESENTATION_RESTRICTED, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLR.");
                }
            } else if (isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLR(NUM_PRESENTATION_ALLOWED, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLR.");
                }
            } else if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCOLR(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCOLR.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && (mSc.equals(SC_BS_MT))) {
            try {
                if (isInterrogate()) {
                    mPhone.mCT.getUtInterface().queryCallBarring(ImsUtInterface.CB_BS_MT, obtainMessage(EVENT_QUERY_ICB_COMPLETE, this));
                } else {
                    processIcbMmiCodeForUpdate();
                }
            // TODO: isRegister() case needs to be handled.
            } catch (ImsException e) {
                Rlog.d(LOG_TAG, "processCode: Could not get UT handle for ICB.");
            }
        } else if (mSc != null && mSc.equals(SC_BAICa)) {
            int callAction = 0;
            // TODO: Should we route through queryCallBarring() here?
            try {
                if (isInterrogate()) {
                    mPhone.mCT.getUtInterface().queryCallBarring(ImsUtInterface.CB_BIC_ACR, obtainMessage(EVENT_QUERY_ICB_COMPLETE, this));
                } else {
                    if (isActivate()) {
                        callAction = CommandsInterface.CF_ACTION_ENABLE;
                    } else if (isDeactivate()) {
                        callAction = CommandsInterface.CF_ACTION_DISABLE;
                    }
                    mPhone.mCT.getUtInterface().updateCallBarring(ImsUtInterface.CB_BIC_ACR, callAction, obtainMessage(EVENT_SET_COMPLETE, this), null);
                }
            } catch (ImsException e) {
                Rlog.d(LOG_TAG, "processCode: Could not get UT handle for ICBa.");
            }
        } else if (mSc != null && mSc.equals(SC_WAIT)) {
            // sia = basic service group
            int serviceClass = siToServiceClass(mSib);
            if (isActivate() || isDeactivate()) {
                mPhone.setCallWaiting(isActivate(), serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.getCallWaiting(obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mPoundString != null) {
            Rlog.d(LOG_TAG, "processCode: Sending pound string '" + mDialingNumber + "' over CS pipe.");
            throw new CallStateException(Phone.CS_FALLBACK);
        } else {
            Rlog.d(LOG_TAG, "processCode: invalid or unsupported MMI");
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        }
    } catch (RuntimeException exc) {
        mState = State.FAILED;
        mMessage = mContext.getText(com.android.internal.R.string.mmiError);
        Rlog.d(LOG_TAG, "processCode: RuntimeException = " + exc);
        mPhone.onMMIDone(this);
    }
}
#method_after
public void processCode() throws CallStateException {
    try {
        if (isShortCode()) {
            Rlog.d(LOG_TAG, "processCode: isShortCode");
            // These just get treated as USSD.
            Rlog.d(LOG_TAG, "processCode: Sending short code '" + mDialingNumber + "' over CS pipe.");
            throw new CallStateException(Phone.CS_FALLBACK);
        } else if (isServiceCodeCallForwarding(mSc)) {
            Rlog.d(LOG_TAG, "processCode: is CF");
            String dialingNumber = mSia;
            int reason = scToCallForwardReason(mSc);
            int serviceClass = siToServiceClass(mSib);
            int time = siToTime(mSic);
            if (isInterrogate()) {
                mPhone.getCallForwardingOption(reason, obtainMessage(EVENT_QUERY_CF_COMPLETE, this));
            } else {
                int cfAction;
                if (isActivate()) {
                    // number, or an activation if not
                    if (isEmptyOrNull(dialingNumber)) {
                        cfAction = CommandsInterface.CF_ACTION_ENABLE;
                        mIsCallFwdReg = false;
                    } else {
                        cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                        mIsCallFwdReg = true;
                    }
                } else if (isDeactivate()) {
                    cfAction = CommandsInterface.CF_ACTION_DISABLE;
                } else if (isRegister()) {
                    cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                } else if (isErasure()) {
                    cfAction = CommandsInterface.CF_ACTION_ERASURE;
                } else {
                    throw new RuntimeException("invalid action");
                }
                int isSettingUnconditional = ((reason == CommandsInterface.CF_REASON_UNCONDITIONAL) || (reason == CommandsInterface.CF_REASON_ALL)) ? 1 : 0;
                int isEnableDesired = ((cfAction == CommandsInterface.CF_ACTION_ENABLE) || (cfAction == CommandsInterface.CF_ACTION_REGISTRATION)) ? 1 : 0;
                Rlog.d(LOG_TAG, "processCode: is CF setCallForward");
                mPhone.setCallForwardingOption(cfAction, reason, dialingNumber, serviceClass, time, obtainMessage(EVENT_SET_CFF_COMPLETE, isSettingUnconditional, isEnableDesired, this));
            }
        } else if (isServiceCodeCallBarring(mSc)) {
            // sia = password
            // sib = basic service group
            // service group is not supported
            String password = mSia;
            String facility = scToBarringFacility(mSc);
            int serviceClass = siToServiceClass(mSib);
            if (isInterrogate()) {
                mPhone.getCallBarring(facility, obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this), serviceClass);
            } else if (isActivate() || isDeactivate()) {
                mPhone.setCallBarring(facility, isActivate(), password, obtainMessage(EVENT_SET_COMPLETE, this), serviceClass);
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIR)) {
            // Only the UT interface handle is used.
            if (isActivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIR(CommandsInterface.CLIR_INVOCATION, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIR.");
                }
            } else if (isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIR(CommandsInterface.CLIR_SUPPRESSION, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIR.");
                }
            } else if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCLIR(obtainMessage(EVENT_GET_CLIR_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCLIR.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIP)) {
            // NOTE: Refer to the note above.
            if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCLIP(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCLIP.");
                }
            } else if (isActivate() || isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCLIP(isActivate(), obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCLIP.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_COLP)) {
            // NOTE: Refer to the note above.
            if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCOLP(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCOLP.");
                }
            } else if (isActivate() || isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLP(isActivate(), obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLP.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_COLR)) {
            // NOTE: Refer to the note above.
            if (isActivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLR(NUM_PRESENTATION_RESTRICTED, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLR.");
                }
            } else if (isDeactivate()) {
                try {
                    mPhone.mCT.getUtInterface().updateCOLR(NUM_PRESENTATION_ALLOWED, obtainMessage(EVENT_SET_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for updateCOLR.");
                }
            } else if (isInterrogate()) {
                try {
                    mPhone.mCT.getUtInterface().queryCOLR(obtainMessage(EVENT_SUPP_SVC_QUERY_COMPLETE, this));
                } catch (ImsException e) {
                    Rlog.d(LOG_TAG, "processCode: Could not get UT handle for queryCOLR.");
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && (mSc.equals(SC_BS_MT))) {
            try {
                if (isInterrogate()) {
                    mPhone.mCT.getUtInterface().queryCallBarring(ImsUtInterface.CB_BS_MT, obtainMessage(EVENT_QUERY_ICB_COMPLETE, this));
                } else {
                    processIcbMmiCodeForUpdate();
                }
            // TODO: isRegister() case needs to be handled.
            } catch (ImsException e) {
                Rlog.d(LOG_TAG, "processCode: Could not get UT handle for ICB.");
            }
        } else if (mSc != null && mSc.equals(SC_BAICa)) {
            int callAction = 0;
            // TODO: Should we route through queryCallBarring() here?
            try {
                if (isInterrogate()) {
                    mPhone.mCT.getUtInterface().queryCallBarring(ImsUtInterface.CB_BIC_ACR, obtainMessage(EVENT_QUERY_ICB_COMPLETE, this));
                } else {
                    if (isActivate()) {
                        callAction = CommandsInterface.CF_ACTION_ENABLE;
                    } else if (isDeactivate()) {
                        callAction = CommandsInterface.CF_ACTION_DISABLE;
                    }
                    mPhone.mCT.getUtInterface().updateCallBarring(ImsUtInterface.CB_BIC_ACR, callAction, obtainMessage(EVENT_SET_COMPLETE, this), null);
                }
            } catch (ImsException e) {
                Rlog.d(LOG_TAG, "processCode: Could not get UT handle for ICBa.");
            }
        } else if (mSc != null && mSc.equals(SC_WAIT)) {
            // sia = basic service group
            int serviceClass = siToServiceClass(mSib);
            if (isActivate() || isDeactivate()) {
                mPhone.setCallWaiting(isActivate(), serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.getCallWaiting(obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mPoundString != null) {
            Rlog.d(LOG_TAG, "processCode: Sending pound string '" + mDialingNumber + "' over CS pipe.");
            throw new CallStateException(Phone.CS_FALLBACK);
        } else {
            Rlog.d(LOG_TAG, "processCode: invalid or unsupported MMI");
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        }
    } catch (RuntimeException exc) {
        mState = State.FAILED;
        mMessage = mContext.getText(com.android.internal.R.string.mmiError);
        Rlog.d(LOG_TAG, "processCode: RuntimeException = " + exc);
        mPhone.onMMIDone(this);
    }
}
#end_block

#method_before
void setServiceState(int state) {
    mSS.setVoiceRegState(state);
    updateDataServiceState();
}
#method_after
@VisibleForTesting
public void setServiceState(int state) {
    boolean isVoiceRegStateChanged = false;
    synchronized (this) {
        isVoiceRegStateChanged = mSS.getVoiceRegState() != state;
        mSS.setVoiceRegState(state);
    }
    updateDataServiceState();
    if (isVoiceRegStateChanged) {
        if (mDefaultPhone.getServiceStateTracker() != null) {
            mDefaultPhone.getServiceStateTracker().onImsServiceStateChanged();
        }
    }
}
#end_block

#method_before
public void setCallForwardingOption(int commandInterfaceCFAction, int commandInterfaceCFReason, String dialingNumber, int serviceClass, int timerSeconds, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "setCallForwardingOption action=" + commandInterfaceCFAction + ", reason=" + commandInterfaceCFReason + " serviceClass=" + serviceClass);
    if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) && (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
        Message resp;
        Cf cf = new Cf(dialingNumber, (commandInterfaceCFReason == CF_REASON_UNCONDITIONAL ? true : false), onComplete);
        resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE, isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cf);
        try {
            ImsUtInterface ut = mCT.getUtInterface();
            ut.updateCallForward(getActionFromCFAction(commandInterfaceCFAction), getConditionFromCFReason(commandInterfaceCFReason), dialingNumber, serviceClass, timerSeconds, resp);
        } catch (ImsException e) {
            sendErrorResponse(onComplete, e);
        }
    } else if (onComplete != null) {
        sendErrorResponse(onComplete);
    }
}
#method_after
public void setCallForwardingOption(int commandInterfaceCFAction, int commandInterfaceCFReason, String dialingNumber, int serviceClass, int timerSeconds, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "setCallForwardingOption action=" + commandInterfaceCFAction + ", reason=" + commandInterfaceCFReason + " serviceClass=" + serviceClass);
    if ((isValidCommandInterfaceCFAction(commandInterfaceCFAction)) && (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
        Message resp;
        Cf cf = new Cf(dialingNumber, GsmMmiCode.isVoiceUnconditionalForwarding(commandInterfaceCFReason, serviceClass), onComplete);
        resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE, isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cf);
        try {
            ImsUtInterface ut = mCT.getUtInterface();
            ut.updateCallForward(getActionFromCFAction(commandInterfaceCFAction), getConditionFromCFReason(commandInterfaceCFReason), dialingNumber, serviceClass, timerSeconds, resp);
        } catch (ImsException e) {
            sendErrorResponse(onComplete, e);
        }
    } else if (onComplete != null) {
        sendErrorResponse(onComplete);
    }
}
#end_block

#method_before
public void getCallBarring(String facility, int serviceClass, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "getCallBarring facility=" + facility + "serviceClass = " + serviceClass);
    Message resp;
    resp = obtainMessage(EVENT_GET_CALL_BARRING_DONE, onComplete);
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        ut.queryCallBarring(getCBTypeFromFacility(facility), serviceClass, resp);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void getCallBarring(String facility, Message onComplete, int serviceClass) {
    if (DBG) {
        Rlog.d(LOG_TAG, "getCallBarring facility=" + facility + ", serviceClass = " + serviceClass);
    }
    Message resp;
    resp = obtainMessage(EVENT_GET_CALL_BARRING_DONE, onComplete);
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        ut.queryCallBarring(getCBTypeFromFacility(facility), resp, serviceClass);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#end_block

#method_before
public void setCallBarring(String facility, boolean lockState, int serviceClass, String password, Message onComplete) {
    if (DBG)
        Rlog.d(LOG_TAG, "setCallBarring facility=" + facility + ", lockState=" + lockState + "serviceClass = " + serviceClass);
    Message resp;
    resp = obtainMessage(EVENT_SET_CALL_BARRING_DONE, onComplete);
    int action;
    if (lockState) {
        action = CommandsInterface.CF_ACTION_ENABLE;
    } else {
        action = CommandsInterface.CF_ACTION_DISABLE;
    }
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        // password is not required with Ut interface
        ut.updateCallBarring(getCBTypeFromFacility(facility), action, serviceClass, resp, null);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete, int serviceClass) {
    if (DBG) {
        Rlog.d(LOG_TAG, "setCallBarring facility=" + facility + ", lockState=" + lockState + ", serviceClass = " + serviceClass);
    }
    Message resp;
    resp = obtainMessage(EVENT_SET_CALL_BARRING_DONE, onComplete);
    int action;
    if (lockState) {
        action = CommandsInterface.CF_ACTION_ENABLE;
    } else {
        action = CommandsInterface.CF_ACTION_DISABLE;
    }
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        // password is not required with Ut interface
        ut.updateCallBarring(getCBTypeFromFacility(facility), action, resp, null, serviceClass);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#end_block

#method_before
private void handleExitEmergencyCallbackMode() {
    if (DBG) {
        Rlog.d(LOG_TAG, "handleExitEmergencyCallbackMode: mIsPhoneInEcmState = " + isInEcm());
    }
    if (isInEcm()) {
        setIsInEcm(false);
    }
    // Remove pending exit Ecm runnable, if any
    removeCallbacks(mExitEcmRunnable);
    if (mEcmExitRespRegistrant != null) {
        mEcmExitRespRegistrant.notifyResult(Boolean.TRUE);
    }
    // release wakeLock
    if (mWakeLock.isHeld()) {
        mWakeLock.release();
    }
    // send an Intent
    sendEmergencyCallbackModeChange();
}
#method_after
@Override
protected void handleExitEmergencyCallbackMode() {
    if (DBG) {
        Rlog.d(LOG_TAG, "handleExitEmergencyCallbackMode: mIsPhoneInEcmState = " + isInEcm());
    }
    if (isInEcm()) {
        setIsInEcm(false);
    }
    // Remove pending exit Ecm runnable, if any
    removeCallbacks(mExitEcmRunnable);
    if (mEcmExitRespRegistrant != null) {
        mEcmExitRespRegistrant.notifyResult(Boolean.TRUE);
    }
    // release wakeLock
    if (mWakeLock.isHeld()) {
        mWakeLock.release();
    }
    // send an Intent
    sendEmergencyCallbackModeChange();
    ((GsmCdmaPhone) mDefaultPhone).notifyEmergencyCallRegistrants(false);
}
#end_block

#method_before
// Processes an IMS disconnect cause for possible WFC registration errors and optionally
private void processWfcDisconnectForNotification(ImsReasonInfo imsReasonInfo) {
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        Rlog.e(LOG_TAG, "processDisconnectReason: CarrierConfigManager is not ready");
        return;
    }
    PersistableBundle pb = configManager.getConfigForSubId(getSubId());
    if (pb == null) {
        Rlog.e(LOG_TAG, "processDisconnectReason: no config for subId " + getSubId());
        return;
    }
    final String[] wfcOperatorErrorCodes = pb.getStringArray(CarrierConfigManager.KEY_WFC_OPERATOR_ERROR_CODES_STRING_ARRAY);
    if (wfcOperatorErrorCodes == null) {
        // no operator-specific error codes
        return;
    }
    final String[] wfcOperatorErrorAlertMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorAlertMessages);
    final String[] wfcOperatorErrorNotificationMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorNotificationMessages);
    for (int i = 0; i < wfcOperatorErrorCodes.length; i++) {
        String[] codes = wfcOperatorErrorCodes[i].split("\\|");
        if (codes.length != 2) {
            Rlog.e(LOG_TAG, "Invalid carrier config: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        // Match error code.
        if (!imsReasonInfo.mExtraMessage.startsWith(codes[0])) {
            continue;
        }
        // If there is no delimiter at the end of error code string
        // then we need to verify that we are not matching partial code.
        // EXAMPLE: "REG9" must not match "REG99".
        // NOTE: Error code must not be empty.
        int codeStringLength = codes[0].length();
        char lastChar = codes[0].charAt(codeStringLength - 1);
        if (Character.isLetterOrDigit(lastChar)) {
            if (imsReasonInfo.mExtraMessage.length() > codeStringLength) {
                char nextChar = imsReasonInfo.mExtraMessage.charAt(codeStringLength);
                if (Character.isLetterOrDigit(nextChar)) {
                    continue;
                }
            }
        }
        final CharSequence title = mContext.getText(com.android.internal.R.string.wfcRegErrorTitle);
        int idx = Integer.parseInt(codes[1]);
        if (idx < 0 || idx >= wfcOperatorErrorAlertMessages.length || idx >= wfcOperatorErrorNotificationMessages.length) {
            Rlog.e(LOG_TAG, "Invalid index: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        CharSequence messageAlert = imsReasonInfo.mExtraMessage;
        CharSequence messageNotification = imsReasonInfo.mExtraMessage;
        if (!wfcOperatorErrorAlertMessages[idx].isEmpty()) {
            messageAlert = wfcOperatorErrorAlertMessages[idx];
        }
        if (!wfcOperatorErrorNotificationMessages[idx].isEmpty()) {
            messageNotification = wfcOperatorErrorNotificationMessages[idx];
        }
        // UX requirement is to disable WFC in case of "permanent" registration failures.
        ImsManager.setWfcSetting(mContext, false);
        // If WfcSettings are active then alert will be shown
        // otherwise notification will be added.
        Intent intent = new Intent(ImsManager.ACTION_IMS_REGISTRATION_ERROR);
        intent.putExtra(EXTRA_KEY_ALERT_TITLE, title);
        intent.putExtra(EXTRA_KEY_ALERT_MESSAGE, messageAlert);
        intent.putExtra(EXTRA_KEY_NOTIFICATION_MESSAGE, messageNotification);
        mContext.sendOrderedBroadcast(intent, null, mResultReceiver, null, Activity.RESULT_OK, null, null);
        // so should break the loop after a successful match.
        break;
    }
}
#method_after
// Processes an IMS disconnect cause for possible WFC registration errors and optionally
private void processWfcDisconnectForNotification(ImsReasonInfo imsReasonInfo) {
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        Rlog.e(LOG_TAG, "processDisconnectReason: CarrierConfigManager is not ready");
        return;
    }
    PersistableBundle pb = configManager.getConfigForSubId(getSubId());
    if (pb == null) {
        Rlog.e(LOG_TAG, "processDisconnectReason: no config for subId " + getSubId());
        return;
    }
    final String[] wfcOperatorErrorCodes = pb.getStringArray(CarrierConfigManager.KEY_WFC_OPERATOR_ERROR_CODES_STRING_ARRAY);
    if (wfcOperatorErrorCodes == null) {
        // no operator-specific error codes
        return;
    }
    final String[] wfcOperatorErrorAlertMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorAlertMessages);
    final String[] wfcOperatorErrorNotificationMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorNotificationMessages);
    for (int i = 0; i < wfcOperatorErrorCodes.length; i++) {
        String[] codes = wfcOperatorErrorCodes[i].split("\\|");
        if (codes.length != 2) {
            Rlog.e(LOG_TAG, "Invalid carrier config: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        // Match error code.
        if (!imsReasonInfo.mExtraMessage.startsWith(codes[0])) {
            continue;
        }
        // If there is no delimiter at the end of error code string
        // then we need to verify that we are not matching partial code.
        // EXAMPLE: "REG9" must not match "REG99".
        // NOTE: Error code must not be empty.
        int codeStringLength = codes[0].length();
        char lastChar = codes[0].charAt(codeStringLength - 1);
        if (Character.isLetterOrDigit(lastChar)) {
            if (imsReasonInfo.mExtraMessage.length() > codeStringLength) {
                char nextChar = imsReasonInfo.mExtraMessage.charAt(codeStringLength);
                if (Character.isLetterOrDigit(nextChar)) {
                    continue;
                }
            }
        }
        final CharSequence title = mContext.getText(com.android.internal.R.string.wfcRegErrorTitle);
        int idx = Integer.parseInt(codes[1]);
        if (idx < 0 || idx >= wfcOperatorErrorAlertMessages.length || idx >= wfcOperatorErrorNotificationMessages.length) {
            Rlog.e(LOG_TAG, "Invalid index: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        String messageAlert = imsReasonInfo.mExtraMessage;
        String messageNotification = imsReasonInfo.mExtraMessage;
        if (!wfcOperatorErrorAlertMessages[idx].isEmpty()) {
            messageAlert = String.format(wfcOperatorErrorAlertMessages[idx], // Fill IMS error code into alert message
            imsReasonInfo.mExtraMessage);
        }
        if (!wfcOperatorErrorNotificationMessages[idx].isEmpty()) {
            messageNotification = String.format(wfcOperatorErrorNotificationMessages[idx], // Fill IMS error code into notification
            imsReasonInfo.mExtraMessage);
        }
        // UX requirement is to disable WFC in case of "permanent" registration failures.
        ImsManager.setWfcSetting(mContext, false);
        // If WfcSettings are active then alert will be shown
        // otherwise notification will be added.
        Intent intent = new Intent(ImsManager.ACTION_IMS_REGISTRATION_ERROR);
        intent.putExtra(EXTRA_KEY_ALERT_TITLE, title);
        intent.putExtra(EXTRA_KEY_ALERT_MESSAGE, messageAlert);
        intent.putExtra(EXTRA_KEY_NOTIFICATION_MESSAGE, messageNotification);
        mContext.sendOrderedBroadcast(intent, null, mResultReceiver, null, Activity.RESULT_OK, null, null);
        // so should break the loop after a successful match.
        break;
    }
}
#end_block

#method_before
/**
 * Operations for the supplementary service configuration
 */
@Override
public void queryCallBarring(int cbType, Message result) {
    queryCallBarring(cbType, SERVICE_CLASS_NONE, result);
}
#method_after
/**
 * Operations for the supplementary service configuration
 */
@Override
public void queryCallBarring(int cbType, Message result) {
    queryCallBarring(cbType, result, SERVICE_CLASS_NONE);
}
#end_block

#method_before
@Override
public void queryCallBarring(int cbType, int serviceClass, Message result) {
    if (DBG) {
        log("queryCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", serviceClass=" + serviceClass);
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.queryCallBarringForServiceClass(cbType, serviceClass);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#method_after
@Override
public void queryCallBarring(int cbType, Message result, int serviceClass) {
    if (DBG) {
        log("queryCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", serviceClass=" + serviceClass);
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.queryCallBarringForServiceClass(cbType, serviceClass);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#end_block

#method_before
@Override
public void updateCallBarring(int cbType, int action, Message result, String[] barrList) {
    updateCallBarring(cbType, action, SERVICE_CLASS_NONE, result, barrList);
}
#method_after
@Override
public void updateCallBarring(int cbType, int action, Message result, String[] barrList) {
    updateCallBarring(cbType, action, result, barrList, SERVICE_CLASS_NONE);
}
#end_block

#method_before
@Override
public void updateCallBarring(int cbType, int action, int serviceClass, Message result, String[] barrList) {
    if (DBG) {
        if (barrList != null) {
            String bList = new String();
            for (int i = 0; i < barrList.length; i++) {
                bList.concat(barrList[i] + " ");
            }
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action + ", serviceClass=" + serviceClass + ", barrList=" + bList);
        } else {
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action + ", serviceClass=" + serviceClass);
        }
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.updateCallBarringForServiceClass(cbType, action, serviceClass, barrList);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#method_after
@Override
public void updateCallBarring(int cbType, int action, Message result, String[] barrList, int serviceClass) {
    if (DBG) {
        if (barrList != null) {
            String bList = new String();
            for (int i = 0; i < barrList.length; i++) {
                bList.concat(barrList[i] + " ");
            }
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action + ", serviceClass=" + serviceClass + ", barrList=" + bList);
        } else {
            log("updateCallBarring :: Ut=" + miUt + ", cbType=" + cbType + ", action=" + action + ", serviceClass=" + serviceClass);
        }
    }
    synchronized (mLockObj) {
        try {
            int id = miUt.updateCallBarringForServiceClass(cbType, action, barrList, serviceClass);
            if (id < 0) {
                sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
                return;
            }
            mPendingCmds.put(Integer.valueOf(id), result);
        } catch (RemoteException e) {
            sendFailureReport(result, new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
        }
    }
}
#end_block

#method_before
public static HidDeviceNativeInterface getInstance() {
    synchronized (INSTANCE_LOCK) {
        if (sInstance == null) {
            sInstance = new HidDeviceNativeInterface();
        }
        return sInstance;
    }
}
#method_after
public static HidDeviceNativeInterface getInstance() {
    synchronized (INSTANCE_LOCK) {
        if (sInstance == null) {
            setInstance(new HidDeviceNativeInterface());
        }
        return sInstance;
    }
}
#end_block

#method_before
public boolean connect(byte[] btAddress) {
    return connectNative(btAddress);
}
#method_after
public boolean connect(BluetoothDevice device) {
    return connectNative(getByteAddress(device));
}
#end_block

#method_before
private synchronized void onApplicationStateChanged(byte[] address, boolean registered) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onApplicationStateChangedFromNative(address, registered);
    } else {
        // Service must call cleanup() when quiting and native stack shouldn't send any event
        // after cleanup() -> cleanupNative() is called.
        Log.wtfStack(TAG, "FATAL: onApplicationStateChanged() " + "is called from the stack while service is not available.");
    }
}
#method_after
private synchronized void onApplicationStateChanged(byte[] address, boolean registered) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onApplicationStateChangedFromNative(getDevice(address), registered);
    } else {
        Log.wtfStack(TAG, "FATAL: onApplicationStateChanged() " + "is called from the stack while service is not available.");
    }
}
#end_block

#method_before
private synchronized void onConnectStateChanged(byte[] address, int state) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onConnectStateChangedFromNative(address, state);
    } else {
        // Service must call cleanup() when quiting and native stack shouldn't send any event
        // after cleanup() -> cleanupNative() is called.
        Log.wtfStack(TAG, "FATAL: onConnectStateChanged() " + "is called from the stack while service is not available.");
    }
}
#method_after
private synchronized void onConnectStateChanged(byte[] address, int state) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onConnectStateChangedFromNative(getDevice(address), state);
    } else {
        Log.wtfStack(TAG, "FATAL: onConnectStateChanged() " + "is called from the stack while service is not available.");
    }
}
#end_block

#method_before
private synchronized void onGetReport(byte type, byte id, short bufferSize) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onGetReportFromNative(type, id, bufferSize);
    } else {
        // Service must call cleanup() when quiting and native stack shouldn't send any event
        // after cleanup() -> cleanupNative() is called.
        Log.wtfStack(TAG, "FATAL: onGetReport() " + "is called from the stack while service is not available.");
    }
}
#method_after
private synchronized void onGetReport(byte type, byte id, short bufferSize) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onGetReportFromNative(type, id, bufferSize);
    } else {
        Log.wtfStack(TAG, "FATAL: onGetReport() " + "is called from the stack while service is not available.");
    }
}
#end_block

#method_before
private synchronized void onSetReport(byte reportType, byte reportId, byte[] data) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onSetReportFromNative(reportType, reportId, data);
    } else {
        // Service must call cleanup() when quiting and native stack shouldn't send any event
        // after cleanup() -> cleanupNative() is called.
        Log.wtfStack(TAG, "FATAL: onSetReport() " + "is called from the stack while service is not available.");
    }
}
#method_after
private synchronized void onSetReport(byte reportType, byte reportId, byte[] data) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onSetReportFromNative(reportType, reportId, data);
    } else {
        Log.wtfStack(TAG, "FATAL: onSetReport() " + "is called from the stack while service is not available.");
    }
}
#end_block

#method_before
private synchronized void onSetProtocol(byte protocol) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onSetProtocolFromNative(protocol);
    } else {
        // Service must call cleanup() when quiting and native stack shouldn't send any event
        // after cleanup() -> cleanupNative() is called.
        Log.wtfStack(TAG, "FATAL: onSetProtocol() " + "is called from the stack while service is not available.");
    }
}
#method_after
private synchronized void onSetProtocol(byte protocol) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onSetProtocolFromNative(protocol);
    } else {
        Log.wtfStack(TAG, "FATAL: onSetProtocol() " + "is called from the stack while service is not available.");
    }
}
#end_block

#method_before
private synchronized void onIntrData(byte reportId, byte[] data) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onIntrDataFromNative(reportId, data);
    } else {
        // Service must call cleanup() when quiting and native stack shouldn't send any event
        // after cleanup() -> cleanupNative() is called.
        Log.wtfStack(TAG, "FATAL: onIntrData() " + "is called from the stack while service is not available.");
    }
}
#method_after
private synchronized void onIntrData(byte reportId, byte[] data) {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onIntrDataFromNative(reportId, data);
    } else {
        Log.wtfStack(TAG, "FATAL: onIntrData() " + "is called from the stack while service is not available.");
    }
}
#end_block

#method_before
private synchronized void onVirtualCableUnplug() {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onVirtualCableUnplugFromNative();
    } else {
        // Service must call cleanup() when quiting and native stack shouldn't send any event
        // after cleanup() -> cleanupNative() is called.
        Log.wtfStack(TAG, "FATAL: onVirtualCableUnplug() " + "is called from the stack while service is not available.");
    }
}
#method_after
private synchronized void onVirtualCableUnplug() {
    HidDeviceService service = HidDeviceService.getHidDeviceService();
    if (service != null) {
        service.onVirtualCableUnplugFromNative();
    } else {
        Log.wtfStack(TAG, "FATAL: onVirtualCableUnplug() " + "is called from the stack while service is not available.");
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    // Set up mocks and test assets
    MockitoAnnotations.initMocks(this);
    // We cannot mock AdapterService.getAdapterService() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the AdapterService.sAdapterService field.
    Method method = AdapterService.class.getDeclaredMethod("setAdapterService", AdapterService.class);
    method.setAccessible(true);
    method.invoke(mAdapterService, mAdapterService);
    mTargetContext = InstrumentationRegistry.getTargetContext();
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("10:11:12:13:14:15");
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    mSdpSettings = new BluetoothHidDeviceAppSdpSettings("1", "2", "3", (byte) 4, new byte[] {});
    mHidDeviceService = spy(HidDeviceService.getHidDeviceService());
    Assert.assertNotNull(mHidDeviceService);
    Field field = HidDeviceService.class.getDeclaredField("mHandler");
    field.setAccessible(true);
    Assert.assertNotNull(field.get(mHidDeviceService));
}
#method_after
@Before
public void setUp() throws Exception {
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    mTargetContext = InstrumentationRegistry.getTargetContext();
    // Set up mocks and test assets
    MockitoAnnotations.initMocks(this);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("10:11:12:13:14:15");
    IBinder binder = mServiceRule.bindService(new Intent(mTargetContext, HidDeviceService.class));
    mHidDeviceService = ((HidDeviceService.BluetoothHidDeviceBinder) binder).getServiceForTesting();
    Assert.assertNotNull(mHidDeviceService);
    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            mHidDeviceService.start();
        }
    });
    Field field = HidDeviceService.class.getDeclaredField("mHidDeviceNativeInterface");
    field.setAccessible(true);
    HidDeviceNativeInterface nativeInterface = (HidDeviceNativeInterface) field.get(mHidDeviceService);
    Assert.assertEquals(nativeInterface, sHidDeviceNativeInterface);
}
#end_block

#method_before
@After
public void tearDown() {
    mHidDeviceService.cleanup();
}
#method_after
@After
public void tearDown() {
    mHidDeviceService.stop();
    mHidDeviceService.cleanup();
    mHidDeviceService = null;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (DBG) {
        Log.d(TAG, "handleMessage(): msg.what=" + msg.what);
    }
    switch(msg.what) {
        case MESSAGE_APPLICATION_STATE_CHANGED:
            {
                BluetoothDevice device = msg.obj != null ? getDevice((byte[]) msg.obj) : null;
                boolean success = (msg.arg1 != 0);
                if (success) {
                    Log.d(TAG, "success: " + device);
                    mHidDevice = device;
                } else {
                    mHidDevice = null;
                }
                try {
                    if (mCallback != null) {
                        mCallback.onAppStatusChanged(device, mAppConfig, success);
                    } else {
                        break;
                    }
                } catch (RemoteException e) {
                    Log.e(TAG, "e=" + e.toString());
                    e.printStackTrace();
                }
                if (success) {
                    mDeathRcpt = new BluetoothHidDeviceDeathRecipient(HidDeviceService.this, mAppConfig);
                    if (mCallback != null) {
                        IBinder binder = mCallback.asBinder();
                        try {
                            binder.linkToDeath(mDeathRcpt, 0);
                            Log.i(TAG, "IBinder.linkToDeath() ok");
                        } catch (RemoteException e) {
                            e.printStackTrace();
                        }
                    }
                } else if (mDeathRcpt != null) {
                    if (mCallback != null) {
                        IBinder binder = mCallback.asBinder();
                        try {
                            binder.unlinkToDeath(mDeathRcpt, 0);
                            Log.i(TAG, "IBinder.unlinkToDeath() ok");
                        } catch (NoSuchElementException e) {
                            e.printStackTrace();
                        }
                        mDeathRcpt.cleanup();
                        mDeathRcpt = null;
                    }
                }
                if (!success) {
                    mAppConfig = null;
                    mCallback = null;
                }
                break;
            }
        case MESSAGE_CONNECT_STATE_CHANGED:
            {
                BluetoothDevice device = getDevice((byte[]) msg.obj);
                int halState = msg.arg1;
                int state = convertHalState(halState);
                if (state != BluetoothHidDevice.STATE_DISCONNECTED) {
                    mHidDevice = device;
                }
                broadcastConnectionState(device, state);
                try {
                    if (mCallback != null) {
                        mCallback.onConnectionStateChanged(device, state);
                    }
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                break;
            }
        case MESSAGE_GET_REPORT:
            byte type = (byte) msg.arg1;
            byte id = (byte) msg.arg2;
            int bufferSize = msg.obj == null ? 0 : ((Integer) msg.obj).intValue();
            try {
                if (mCallback != null) {
                    mCallback.onGetReport(mHidDevice, type, id, bufferSize);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            break;
        case MESSAGE_SET_REPORT:
            {
                byte reportType = (byte) msg.arg1;
                byte reportId = (byte) msg.arg2;
                byte[] data = ((ByteBuffer) msg.obj).array();
                try {
                    if (mCallback != null) {
                        mCallback.onSetReport(mHidDevice, reportType, reportId, data);
                    }
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                break;
            }
        case MESSAGE_SET_PROTOCOL:
            byte protocol = (byte) msg.arg1;
            try {
                if (mCallback != null) {
                    mCallback.onSetProtocol(mHidDevice, protocol);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            break;
        case MESSAGE_INTR_DATA:
            byte reportId = (byte) msg.arg1;
            byte[] data = ((ByteBuffer) msg.obj).array();
            try {
                if (mCallback != null) {
                    mCallback.onIntrData(mHidDevice, reportId, data);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            break;
        case MESSAGE_VC_UNPLUG:
            try {
                if (mCallback != null) {
                    mCallback.onVirtualCableUnplug(mHidDevice);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            mHidDevice = null;
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (DBG) {
        Log.d(TAG, "handleMessage(): msg.what=" + msg.what);
    }
    switch(msg.what) {
        case MESSAGE_APPLICATION_STATE_CHANGED:
            {
                BluetoothDevice device = msg.obj != null ? (BluetoothDevice) msg.obj : null;
                boolean success = (msg.arg1 != 0);
                if (success) {
                    Log.d(TAG, "App registered, set device to: " + device);
                    mHidDevice = device;
                } else {
                    mHidDevice = null;
                }
                try {
                    if (mCallback != null) {
                        mCallback.onAppStatusChanged(device, mAppConfig, success);
                    } else {
                        break;
                    }
                } catch (RemoteException e) {
                    Log.e(TAG, "e=" + e.toString());
                    e.printStackTrace();
                }
                if (success) {
                    mDeathRcpt = new BluetoothHidDeviceDeathRecipient(HidDeviceService.this, mAppConfig);
                    if (mCallback != null) {
                        IBinder binder = mCallback.asBinder();
                        try {
                            binder.linkToDeath(mDeathRcpt, 0);
                            Log.i(TAG, "IBinder.linkToDeath() ok");
                        } catch (RemoteException e) {
                            e.printStackTrace();
                        }
                    }
                } else if (mDeathRcpt != null) {
                    if (mCallback != null) {
                        IBinder binder = mCallback.asBinder();
                        try {
                            binder.unlinkToDeath(mDeathRcpt, 0);
                            Log.i(TAG, "IBinder.unlinkToDeath() ok");
                        } catch (NoSuchElementException e) {
                            e.printStackTrace();
                        }
                        mDeathRcpt.cleanup();
                        mDeathRcpt = null;
                    }
                }
                if (!success) {
                    mAppConfig = null;
                    mCallback = null;
                }
                break;
            }
        case MESSAGE_CONNECT_STATE_CHANGED:
            {
                BluetoothDevice device = (BluetoothDevice) msg.obj;
                int halState = msg.arg1;
                int state = convertHalState(halState);
                if (state != BluetoothHidDevice.STATE_DISCONNECTED) {
                    mHidDevice = device;
                }
                setAndBroadcastConnectionState(device, state);
                try {
                    if (mCallback != null) {
                        mCallback.onConnectionStateChanged(device, state);
                    }
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                break;
            }
        case MESSAGE_GET_REPORT:
            byte type = (byte) msg.arg1;
            byte id = (byte) msg.arg2;
            int bufferSize = msg.obj == null ? 0 : ((Integer) msg.obj).intValue();
            try {
                if (mCallback != null) {
                    mCallback.onGetReport(mHidDevice, type, id, bufferSize);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            break;
        case MESSAGE_SET_REPORT:
            {
                byte reportType = (byte) msg.arg1;
                byte reportId = (byte) msg.arg2;
                byte[] data = ((ByteBuffer) msg.obj).array();
                try {
                    if (mCallback != null) {
                        mCallback.onSetReport(mHidDevice, reportType, reportId, data);
                    }
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                break;
            }
        case MESSAGE_SET_PROTOCOL:
            byte protocol = (byte) msg.arg1;
            try {
                if (mCallback != null) {
                    mCallback.onSetProtocol(mHidDevice, protocol);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            break;
        case MESSAGE_INTR_DATA:
            byte reportId = (byte) msg.arg1;
            byte[] data = ((ByteBuffer) msg.obj).array();
            try {
                if (mCallback != null) {
                    mCallback.onIntrData(mHidDevice, reportId, data);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            break;
        case MESSAGE_VC_UNPLUG:
            try {
                if (mCallback != null) {
                    mCallback.onVirtualCableUnplug(mHidDevice);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            mHidDevice = null;
            break;
    }
}
#end_block

#method_before
synchronized boolean connect(BluetoothDevice device) {
    if (DBG) {
        Log.d(TAG, "connect(): device=" + device);
    }
    return mHidDeviceNativeInterface.connect(Utils.getByteAddress(device));
}
#method_after
synchronized boolean connect(BluetoothDevice device) {
    if (DBG) {
        Log.d(TAG, "connect(): device=" + device);
    }
    return mHidDeviceNativeInterface.connect(device);
}
#end_block

#method_before
@Override
protected boolean start() {
    if (DBG) {
        Log.d(TAG, "start()");
    }
    setHidDeviceService(this);
    mHandler = new HidDeviceServiceHandler();
    mHidDeviceNativeInterface.init();
    mNativeAvailable = true;
    return true;
}
#method_after
@Override
protected boolean start() {
    if (DBG) {
        Log.d(TAG, "start()");
    }
    mHandler = new HidDeviceServiceHandler();
    setHidDeviceService(this);
    mHidDeviceNativeInterface.init();
    mNativeAvailable = true;
    return true;
}
#end_block

#method_before
public static synchronized HidDeviceService getHidDeviceService() {
    if (sHidDeviceService != null && sHidDeviceService.isAvailable()) {
        if (DBG) {
            Log.d(TAG, "getHidDeviceService(): returning " + sHidDeviceService);
        }
        return sHidDeviceService;
    }
    if (DBG) {
        if (sHidDeviceService == null) {
            Log.d(TAG, "getHidDeviceService(): service is NULL");
        } else if (!sHidDeviceService.isAvailable()) {
            Log.d(TAG, "getHidDeviceService(): service is not available");
        }
    }
    return null;
}
#method_after
public static synchronized HidDeviceService getHidDeviceService() {
    if (sHidDeviceService == null) {
        Log.d(TAG, "getHidDeviceService(): service is NULL");
        return null;
    }
    if (!sHidDeviceService.isAvailable()) {
        Log.d(TAG, "getHidDeviceService(): service is not available");
        return null;
    }
    return sHidDeviceService;
}
#end_block

#method_before
private static synchronized void setHidDeviceService(HidDeviceService instance) {
    if (DBG) {
        Log.d(TAG, "setHidDeviceService(): set to: " + instance);
    }
    sHidDeviceService = instance;
}
#method_after
private static synchronized void setHidDeviceService(HidDeviceService instance) {
    sHidDeviceService = instance;
}
#end_block

#method_before
synchronized void onApplicationStateChangedFromNative(byte[] address, boolean registered) {
    if (DBG) {
        Log.d(TAG, "onApplicationStateChanged(): registered=" + registered);
    }
    Message msg = mHandler.obtainMessage(MESSAGE_APPLICATION_STATE_CHANGED);
    msg.obj = address;
    msg.arg1 = registered ? 1 : 0;
    mHandler.sendMessage(msg);
}
#method_after
synchronized void onApplicationStateChangedFromNative(BluetoothDevice device, boolean registered) {
    if (DBG) {
        Log.d(TAG, "onApplicationStateChanged(): registered=" + registered);
    }
    Message msg = mHandler.obtainMessage(MESSAGE_APPLICATION_STATE_CHANGED);
    msg.obj = device;
    msg.arg1 = registered ? 1 : 0;
    mHandler.sendMessage(msg);
}
#end_block

#method_before
synchronized void onConnectStateChangedFromNative(byte[] address, int state) {
    if (DBG) {
        Log.d(TAG, "onConnectStateChanged(): address=" + Arrays.toString(address) + " state=" + state);
    }
    Message msg = mHandler.obtainMessage(MESSAGE_CONNECT_STATE_CHANGED);
    msg.obj = address;
    msg.arg1 = state;
    mHandler.sendMessage(msg);
}
#method_after
synchronized void onConnectStateChangedFromNative(BluetoothDevice device, int state) {
    if (DBG) {
        Log.d(TAG, "onConnectStateChanged(): device=" + device + " state=" + state);
    }
    Message msg = mHandler.obtainMessage(MESSAGE_CONNECT_STATE_CHANGED);
    msg.obj = device;
    msg.arg1 = state;
    mHandler.sendMessage(msg);
}
#end_block

#method_before
public boolean getContactSharingState() {
    switch(mDevice.getPhonebookAccessPermission()) {
        case BluetoothDevice.ACCESS_ALLOWED:
            return true;
        case BluetoothDevice.ACCESS_REJECTED:
            return false;
        default:
            if (mDevice.getBluetoothClass().getDeviceClass() == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE) {
                mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                return true;
            }
            mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
            return false;
    }
}
#method_after
public boolean getContactSharingState() {
    switch(mDevice.getPhonebookAccessPermission()) {
        case BluetoothDevice.ACCESS_ALLOWED:
            return true;
        case BluetoothDevice.ACCESS_REJECTED:
            return false;
        default:
            if (mDevice.getBluetoothClass().getDeviceClass() == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE) {
                return true;
            }
            return false;
    }
}
#end_block

#method_before
/*
     * TODO(cleanup): Refactor the parsing for addresses to better
     * share code and logic with GSM.  Also, gather all DTMF/BCD
     * processing code in one place.
     */
private static byte[] parseToDtmf(String address) {
    int digits = address.length();
    byte[] result = new byte[digits];
    for (int i = 0; i < digits; i++) {
        char c = address.charAt(i);
        int val = 0;
        if ((c >= '1') && (c <= '9'))
            val = c - '0';
        else if (c == '0')
            val = 10;
        else if (c == '*')
            val = 11;
        else if (c == '#')
            val = 12;
        else
            return null;
        result[i] = (byte) val;
    }
    return result;
}
#method_after
@VisibleForTesting
public static byte[] parseToDtmf(String address) {
    int digits = address.length();
    byte[] result = new byte[digits];
    for (int i = 0; i < digits; i++) {
        char c = address.charAt(i);
        int val = 0;
        if ((c >= '1') && (c <= '9'))
            val = c - '0';
        else if (c == '0')
            val = 10;
        else if (c == '*')
            val = 11;
        else if (c == '#')
            val = 12;
        else
            return null;
        result[i] = (byte) val;
    }
    return result;
}
#end_block

#method_before
public static CdmaSmsAddress parse(String address) {
    CdmaSmsAddress addr = new CdmaSmsAddress();
    addr.address = address;
    addr.ton = TON_UNKNOWN;
    addr.digitMode = DIGIT_MODE_4BIT_DTMF;
    addr.numberPlan = NUMBERING_PLAN_UNKNOWN;
    addr.numberMode = NUMBER_MODE_NOT_DATA_NETWORK;
    byte[] origBytes;
    String filteredAddr = filterNumericSugar(address);
    if (address.indexOf('+') == -1 && filteredAddr != null) {
        // The address is not an international number and it only contains digit and *#
        origBytes = parseToDtmf(filteredAddr);
    } else {
        // 3GPP2 C.S0015-B section 3.4.3.3 Address Parameters
        // NUMBER_MODE should set to 1 for network address and email address.
        addr.digitMode = DIGIT_MODE_8BIT_CHAR;
        addr.numberMode = NUMBER_MODE_DATA_NETWORK;
        if (address.indexOf('@') != -1) {
            // This is an email address
            addr.ton = TON_NATIONAL_OR_EMAIL;
        } else if (address.indexOf('+') != -1) {
            // This is an international number
            // 3GPP2 C.S0015-B section 3.4.3.3 Address Parameters
            // digital mode is set to 1 and number mode is set to 0, type of number should set
            // to the value correspond to the value in 3GPP2 C.S005-D, table2.7.1.3.2.4-2
            addr.numberMode = NUMBER_MODE_NOT_DATA_NETWORK;
            addr.numberPlan = NUMBERING_PLAN_ISDN_TELEPHONY;
            addr.ton = TON_INTERNATIONAL;
        }
        filteredAddr = filterWhitespace(address);
        origBytes = UserData.stringToAscii(filteredAddr);
    }
    if (origBytes == null) {
        return null;
    }
    addr.origBytes = origBytes;
    addr.numberOfDigits = origBytes.length;
    return addr;
}
#method_after
public static CdmaSmsAddress parse(String address) {
    CdmaSmsAddress addr = new CdmaSmsAddress();
    addr.address = address;
    addr.ton = TON_UNKNOWN;
    addr.digitMode = DIGIT_MODE_4BIT_DTMF;
    addr.numberPlan = NUMBERING_PLAN_UNKNOWN;
    addr.numberMode = NUMBER_MODE_NOT_DATA_NETWORK;
    byte[] origBytes;
    String filteredAddr = filterNumericSugar(address);
    if (address.contains("+") || filteredAddr == null) {
        // 3GPP2 C.S0015-B section 3.4.3.3 Address Parameters
        // NUMBER_MODE should set to 1 for network address and email address.
        addr.digitMode = DIGIT_MODE_8BIT_CHAR;
        addr.numberMode = NUMBER_MODE_DATA_NETWORK;
        filteredAddr = filterWhitespace(address);
        if (address.contains("@")) {
            // This is an email address
            addr.ton = TON_NATIONAL_OR_EMAIL;
        } else if (address.contains("+") && filterNumericSugar(address) != null) {
            // This is an international number
            // 3GPP2 C.S0015-B section 3.4.3.3 Address Parameters
            // digit mode is set to 1 and number mode is set to 0, type of number should set
            // to the value correspond to the value in 3GPP2 C.S005-D, table2.7.1.3.2.4-2
            addr.ton = TON_INTERNATIONAL_OR_IP;
            addr.numberPlan = NUMBERING_PLAN_ISDN_TELEPHONY;
            addr.numberMode = NUMBER_MODE_NOT_DATA_NETWORK;
            filteredAddr = filterNumericSugar(address);
        }
        origBytes = UserData.stringToAscii(filteredAddr);
    } else {
        // The address is not an international number and it only contains digit and *#
        origBytes = parseToDtmf(filteredAddr);
    }
    if (origBytes == null) {
        return null;
    }
    addr.origBytes = origBytes;
    addr.numberOfDigits = origBytes.length;
    return addr;
}
#end_block

#method_before
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        return true;
    }
    return false;
}
#method_after
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        // empty EF_CFIS should be considered as call forward disabled
        for (byte b : data) {
            if (b != (byte) 0xFF) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                if (mImsi != null && mImsi.length() >= 6) {
                    log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                }
                String imsi = getIMSI();
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                    String mccmncCode = imsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(imsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED && imsi.length() >= 3 + mMncLength) {
                    log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    if (mCarrierTestOverride.isInTestMode() && getIMSI() != null) {
                        imsi = getIMSI();
                        try {
                            int mcc = Integer.parseInt(imsi.substring(0, 3));
                            mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            log("[TestMode] mMncLength=" + mMncLength);
                        } catch (NumberFormatException e) {
                            mMncLength = UNKNOWN;
                            loge("[TestMode] Corrupt IMSI! mMncLength=" + mMncLength);
                        }
                    } else {
                        ar = (AsyncResult) msg.obj;
                        data = (byte[]) ar.result;
                        if (ar.exception != null) {
                            break;
                        }
                        log("EF_AD: " + IccUtils.bytesToHexString(data));
                        if (data.length < 3) {
                            log("Corrupt AD data on SIM");
                            break;
                        }
                        if (data.length == 3) {
                            log("MNC length not present in EF_AD");
                            break;
                        }
                        mMncLength = data[3] & 0xf;
                        log("setting4 mMncLength=" + mMncLength);
                    }
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    // IMSI could be a value reading from Sim or a fake IMSI if in the test mode
                    imsi = getIMSI();
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                        String mccmncCode = imsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (imsi != null) {
                            try {
                                int mcc = Integer.parseInt(imsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (imsi != null && mMncLength != UNKNOWN && imsi.length() >= 3 + mMncLength) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                if (mImsi != null && mImsi.length() >= 6) {
                    log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                }
                String imsi = getIMSI();
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                    String mccmncCode = imsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(imsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED && imsi.length() >= 3 + mMncLength) {
                    log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    if (mCarrierTestOverride.isInTestMode() && getIMSI() != null) {
                        imsi = getIMSI();
                        try {
                            int mcc = Integer.parseInt(imsi.substring(0, 3));
                            mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            log("[TestMode] mMncLength=" + mMncLength);
                        } catch (NumberFormatException e) {
                            mMncLength = UNKNOWN;
                            loge("[TestMode] Corrupt IMSI! mMncLength=" + mMncLength);
                        }
                    } else {
                        ar = (AsyncResult) msg.obj;
                        data = (byte[]) ar.result;
                        if (ar.exception != null) {
                            break;
                        }
                        log("EF_AD: " + IccUtils.bytesToHexString(data));
                        if (data.length < 3) {
                            log("Corrupt AD data on SIM");
                            break;
                        }
                        if (data.length == 3) {
                            log("MNC length not present in EF_AD");
                            break;
                        }
                        mMncLength = data[3] & 0xf;
                        log("setting4 mMncLength=" + mMncLength);
                    }
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    // IMSI could be a value reading from Sim or a fake IMSI if in the test mode
                    imsi = getIMSI();
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                        String mccmncCode = imsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (imsi != null) {
                            try {
                                int mcc = Integer.parseInt(imsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (imsi != null && mMncLength != UNKNOWN && imsi.length() >= 3 + mMncLength) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        log("PNN: " + mPnnHomeName);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
// ***** Private methods
private void handleCarrierNameOverride() {
    CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configLoader == null) {
        return;
    }
    boolean preferCcName = configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL, false);
    String ccName = configLoader.getConfig().getString(CarrierConfigManager.KEY_CARRIER_NAME_STRING);
    String spn = getServiceProviderName();
    String chosenName = null;
    // and the name were both set by the carrier, so this is safe
    if (preferCcName) {
        chosenName = ccName;
    // If we have a valid SPN and CC is not priority, use it
    } else if (!TextUtils.isEmpty(spn)) {
        chosenName = spn;
    // If carrier config has a default for SIMs without an SPN, use that
    } else if (!TextUtils.isEmpty(ccName)) {
        chosenName = ccName;
    }
    // If one of the override paths gave us a name, use it, otherwise do nothing
    if (chosenName != null) {
        setServiceProviderName(chosenName);
        mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), chosenName);
    }
}
#method_after
// ***** Private methods
private void handleCarrierNameOverride() {
    final int phoneId = mParentApp.getPhoneId();
    SubscriptionController subCon = SubscriptionController.getInstance();
    final int subId = subCon.getSubIdUsingPhoneId(phoneId);
    if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
        loge("subId not valid for Phone " + phoneId);
        return;
    }
    CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configLoader == null) {
        loge("Failed to load a Carrier Config");
        return;
    }
    PersistableBundle config = configLoader.getConfigForSubId(subId);
    boolean preferCcName = config.getBoolean(CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL, false);
    String ccName = config.getString(CarrierConfigManager.KEY_CARRIER_NAME_STRING);
    // a name in carrier config, use the carrier config name as a backup.
    if (preferCcName || (TextUtils.isEmpty(getServiceProviderName()) && !TextUtils.isEmpty(ccName))) {
        setServiceProviderName(ccName);
        mTelephonyManager.setSimOperatorNameForPhone(phoneId, ccName);
    }
    updateCarrierNameForSubscription(subCon, subId);
}
#end_block

#method_before
@Override
public int getDisplayRule(String plmn) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (isOnMatchingPlmn(plmn)) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#method_after
@Override
public int getDisplayRule(ServiceState serviceState) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (useRoamingFromServiceState() ? !serviceState.getRoaming() : isOnMatchingPlmn(serviceState.getOperatorNumeric())) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid1=" + ((mFakeGid1 != null) ? mFakeGid1 : "null"));
    }
    pw.println(" mGid2=" + mGid2);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid2=" + ((mFakeGid2 != null) ? mFakeGid2 : "null"));
    }
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid1=" + mFakeGid1);
    }
    pw.println(" mGid2=" + mGid2);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid2=" + mFakeGid2);
    }
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakePnnHomeName=" + mFakePnnHomeName);
    }
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#end_block

#method_before
private static void setAccessible0(AccessibleObject obj, boolean flag) throws SecurityException {
    if (obj instanceof Constructor && flag == true) {
        Constructor<?> c = (Constructor<?>) obj;
        // BEGIN Android-changed: Additional checks to prevent Method and Field members being
        // made accessible.
        // if (c.getDeclaringClass() == Class.class) {
        // throw new SecurityException("Cannot make a java.lang.Class" +
        // " constructor accessible");
        // }
        Class<?> clazz = c.getDeclaringClass();
        if (c.getDeclaringClass() == Class.class) {
            throw new SecurityException("Can not make a java.lang.Class" + " constructor accessible");
        } else if (clazz == Method.class) {
            throw new SecurityException("Can not make a java.lang.reflect.Method" + " constructor accessible");
        } else if (clazz == Field.class) {
            throw new SecurityException("Can not make a java.lang.reflect.Field" + " constructor accessible");
        }
    // END Android-changed: Additional checks to prevent Method and Field members being made
    // accessible.
    }
    obj.override = flag;
}
#method_after
private static void setAccessible0(AccessibleObject obj, boolean flag) throws SecurityException {
    if (obj instanceof Constructor && flag == true) {
        Constructor<?> c = (Constructor<?>) obj;
        // BEGIN Android-changed: Disallow making Method & Field constructors accessible.
        // if (c.getDeclaringClass() == Class.class) {
        // throw new SecurityException("Cannot make a java.lang.Class" +
        // " constructor accessible");
        // }
        Class<?> clazz = c.getDeclaringClass();
        if (c.getDeclaringClass() == Class.class) {
            throw new SecurityException("Can not make a java.lang.Class" + " constructor accessible");
        } else if (clazz == Method.class) {
            throw new SecurityException("Can not make a java.lang.reflect.Method" + " constructor accessible");
        } else if (clazz == Field.class) {
            throw new SecurityException("Can not make a java.lang.reflect.Field" + " constructor accessible");
        }
    // END Android-changed: Disallow making Method & Field constructors accessible.
    }
    obj.override = flag;
}
#end_block

#method_before
// Android-added: Method to enable zygote reset of random number generator. Called after the
// zygote is forked.
public static void setRandomSeedInternal(long seed) {
    RandomNumberGeneratorHolder.randomNumberGenerator.setSeed(seed);
}
#method_after
// Android-added: setRandomSeedInternal(long), called after zygote forks.
// This allows different processes to have different random seeds.
public static void setRandomSeedInternal(long seed) {
    RandomNumberGeneratorHolder.randomNumberGenerator.setSeed(seed);
}
#end_block

#method_before
default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass) {
    // customized because of the DEX format and code sharing with the runtime.
    return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass);
}
#method_after
default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass) {
    // and code sharing with the runtime.
    return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass);
}
#end_block

#method_before
// BEGIN Android-added: initPattern() and conversion methods between ICU and Java values.
private void initPattern(String pattern) {
    this.icuDecimalFormat = new android.icu.text.DecimalFormat_ICU58(pattern, symbols.getIcuDecimalFormatSymbols());
    updateFieldsFromIcu();
}
#method_after
// BEGIN Android-added: initPattern() and conversion methods between ICU and Java values.
private void initPattern(String pattern) {
    this.icuDecimalFormat = new android.icu.text.DecimalFormat_ICU58_Android(pattern, symbols.getIcuDecimalFormatSymbols());
    updateFieldsFromIcu();
}
#end_block

#method_before
// END Android-added: setParseIntegerOnly()/isParseIntegerOnly() overrides delegating to ICU.
@Override
public Object clone() {
    // BEGIN Android-changed: Use ICU, remove fast path related code.
    try {
        DecimalFormat other = (DecimalFormat) super.clone();
        other.icuDecimalFormat = (android.icu.text.DecimalFormat_ICU58) icuDecimalFormat.clone();
        other.symbols = (DecimalFormatSymbols) symbols.clone();
        return other;
    } catch (Exception e) {
        throw new InternalError();
    }
// END Android-changed: Use ICU, remove fast path related code.
}
#method_after
// END Android-added: setParseIntegerOnly()/isParseIntegerOnly() overrides delegating to ICU.
@Override
public Object clone() {
    // BEGIN Android-changed: Use ICU, remove fast path related code.
    try {
        DecimalFormat other = (DecimalFormat) super.clone();
        other.icuDecimalFormat = (android.icu.text.DecimalFormat_ICU58_Android) icuDecimalFormat.clone();
        other.symbols = (DecimalFormatSymbols) symbols.clone();
        return other;
    } catch (Exception e) {
        throw new InternalError();
    }
// END Android-changed: Use ICU, remove fast path related code.
}
#end_block

#method_before
private boolean compareIcuRoundingIncrement(android.icu.text.DecimalFormat_ICU58 other) {
    BigDecimal increment = this.icuDecimalFormat.getRoundingIncrement();
    if (increment != null) {
        return (other.getRoundingIncrement() != null) && increment.equals(other.getRoundingIncrement());
    }
    return other.getRoundingIncrement() == null;
}
#method_after
private boolean compareIcuRoundingIncrement(android.icu.text.DecimalFormat_ICU58_Android other) {
    BigDecimal increment = this.icuDecimalFormat.getRoundingIncrement();
    if (increment != null) {
        return (other.getRoundingIncrement() != null) && increment.equals(other.getRoundingIncrement());
    }
    return other.getRoundingIncrement() == null;
}
#end_block

#method_before
@Before
public void setUp() {
    // Initialize Mockito mocks
    MockitoAnnotations.initMocks(this);
    // Set failure handler to caputer Log.wtf messages
    Log.setWtfHandler(mFailHandler);
    // Set up Looper thread for the timeout handler
    mThread = new HandlerThread("MediaPlayerWrapperTestThread");
    mThread.start();
    // Set up new metadata that can be used in each test
    mTestMetadata = new MediaMetadata.Builder().putString(MediaMetadata.METADATA_KEY_TITLE, "BT Test Song").putString(MediaMetadata.METADATA_KEY_ARTIST, "BT Test Artist").putString(MediaMetadata.METADATA_KEY_ALBUM, "BT Test Album");
    mTestState = new PlaybackState.Builder().setActiveQueueItemId(100).setState(PlaybackState.STATE_PAUSED, 0, 1.0f);
    mTestQueue = new ArrayList<MediaDescription.Builder>();
    mTestQueue.add(new MediaDescription.Builder().setTitle("BT Test Song").setSubtitle("BT Test Artist").setDescription("BT Test Album").setMediaId("100"));
    mTestQueue.add(new MediaDescription.Builder().setTitle("BT Test Song 2").setSubtitle("BT Test Artist 2").setDescription("BT Test Album 2").setMediaId("101"));
    mTestQueue.add(new MediaDescription.Builder().setTitle("BT Test Song 3").setSubtitle("BT Test Artist 3").setDescription("BT Test Album 3").setMediaId("102"));
    when(mMockController.getPackageName()).thenReturn("mMockController");
    // NOTE: We use doReturn below because using the normal stubing method
    // doesn't immediatly update the stub with the new return value and this
    // can cause the old stub to be used.
    // Stub default metadata for the Media Controller
    doReturn(mTestMetadata.build()).when(mMockController).getMetadata();
    doReturn(mTestState.build()).when(mMockController).getPlaybackState();
    doReturn(getQueueFromDescriptions(mTestQueue)).when(mMockController).getQueue();
    // Turn on testing as a few tests depend on the crashes caused to ensure proper
    // behaviour
    MediaPlayerWrapper.sTesting = true;
}
#method_after
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    // Set failure handler to caputer Log.wtf messages
    Log.setWtfHandler(mFailHandler);
    // Set up Looper thread for the timeout handler
    mThread = new HandlerThread("MediaPlayerWrapperTestThread");
    mThread.start();
    // Set up new metadata that can be used in each test
    mTestMetadata = new MediaMetadata.Builder().putString(MediaMetadata.METADATA_KEY_TITLE, "BT Test Song").putString(MediaMetadata.METADATA_KEY_ARTIST, "BT Test Artist").putString(MediaMetadata.METADATA_KEY_ALBUM, "BT Test Album").putLong(MediaMetadata.METADATA_KEY_DURATION, 5000L);
    mTestState = new PlaybackState.Builder().setActiveQueueItemId(100).setState(PlaybackState.STATE_PAUSED, 0, 1.0f);
    mTestQueue = new ArrayList<MediaDescription.Builder>();
    mTestQueue.add(new MediaDescription.Builder().setTitle("BT Test Song").setSubtitle("BT Test Artist").setDescription("BT Test Album").setMediaId("100"));
    mTestQueue.add(new MediaDescription.Builder().setTitle("BT Test Song 2").setSubtitle("BT Test Artist 2").setDescription("BT Test Album 2").setMediaId("101"));
    mTestQueue.add(new MediaDescription.Builder().setTitle("BT Test Song 3").setSubtitle("BT Test Artist 3").setDescription("BT Test Album 3").setMediaId("102"));
    when(mMockController.getPackageName()).thenReturn("mMockController");
    // NOTE: We use doReturn below because using the normal stubbing method
    // doesn't immediately update the stub with the new return value and this
    // can cause the old stub to be used.
    // Stub default metadata for the Media Controller
    doReturn(mTestMetadata.build()).when(mMockController).getMetadata();
    doReturn(mTestState.build()).when(mMockController).getPlaybackState();
    doReturn(getQueueFromDescriptions(mTestQueue)).when(mMockController).getQueue();
    // Enable testing flag which enables Log.wtf statements. Some tests test against improper
    // behaviour and the TerribleFailureListener is a good way to ensure that the error occured
    MediaPlayerWrapper.sTesting = true;
}
#end_block

#method_before
@Test
public void testNoBrowsingMediaUpdates() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), false);
    wrapper.registerCallback(mTestCbs);
    wrapper.setActive(true);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update Metdata returned by controller
    mTestMetadata.putString(MediaMetadata.METADATA_KEY_TITLE, "New Title");
    doReturn(mTestMetadata.build()).when(mMockController).getMetadata();
    controllerCallbacks.onMetadataChanged(mTestMetadata.build());
    // Assert that only the metadata was updated
    verify(mTestCbs, times(1)).mediaUpdatedCallback(mMediaUpdateData.capture());
    MediaPlayerWrapper.MediaData data = mMediaUpdateData.getValue();
    Assert.assertEquals("Returned Metadata isn't equal to given Metadata", data.metadata.getDescription(), mTestMetadata.build().getDescription());
    Assert.assertNull("Returned Queue isn't null", data.queue);
    Assert.assertNull("Returned PlaybackState isn't null", data.state);
    // Update PlaybackState returned by controller
    mTestState.setActiveQueueItemId(103);
    doReturn(mTestState.build()).when(mMockController).getPlaybackState();
    controllerCallbacks.onPlaybackStateChanged(mTestState.build());
    // Assert that only the PlaybackState was changed
    verify(mTestCbs, times(2)).mediaUpdatedCallback(mMediaUpdateData.capture());
    data = mMediaUpdateData.getValue();
    Assert.assertEquals("Returned PlaybackState isn't equal to given PlaybackState", data.state.toString(), mTestState.build().toString());
    Assert.assertNull("Returned Queue isn't null", data.queue);
    Assert.assertNull("Returned PlaybackState isn't null", data.metadata);
    // Verify that there are no timeout messages pending and there were no timeouts
    Assert.assertFalse(wrapper.getTimeoutHandler().hasMessages(MSG_TIMEOUT));
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
}
#method_after
@Test
public void testNoBrowsingMediaUpdates() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), false);
    wrapper.registerCallback(mTestCbs);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update Metdata returned by controller
    mTestMetadata.putString(MediaMetadata.METADATA_KEY_TITLE, "New Title");
    doReturn(mTestMetadata.build()).when(mMockController).getMetadata();
    controllerCallbacks.onMetadataChanged(mTestMetadata.build());
    // Assert that the metadata was updated and playback state wasn't
    verify(mTestCbs, times(1)).mediaUpdatedCallback(mMediaUpdateData.capture());
    MediaPlayerWrapper.MediaData data = mMediaUpdateData.getValue();
    Assert.assertEquals("Returned Metadata isn't equal to given Metadata", data.metadata.getDescription(), mTestMetadata.build().getDescription());
    Assert.assertEquals("Returned PlaybackState isn't equal to original PlaybackState", data.state.toString(), mTestState.build().toString());
    Assert.assertNull("Returned Queue isn't null", data.queue);
    // Update PlaybackState returned by controller
    mTestState.setActiveQueueItemId(103);
    doReturn(mTestState.build()).when(mMockController).getPlaybackState();
    controllerCallbacks.onPlaybackStateChanged(mTestState.build());
    // Assert that the PlaybackState was changed but metadata stayed the same
    verify(mTestCbs, times(2)).mediaUpdatedCallback(mMediaUpdateData.capture());
    data = mMediaUpdateData.getValue();
    Assert.assertEquals("Returned PlaybackState isn't equal to given PlaybackState", data.state.toString(), mTestState.build().toString());
    Assert.assertEquals("Returned Metadata isn't equal to given Metadata", data.metadata.getDescription(), mTestMetadata.build().getDescription());
    Assert.assertNull("Returned Queue isn't null", data.queue);
    // Verify that there are no timeout messages pending and there were no timeouts
    Assert.assertFalse(wrapper.getTimeoutHandler().hasMessages(MSG_TIMEOUT));
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
}
#end_block

#method_before
@Test
public void testWrapperCleanup() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), false);
    wrapper.registerCallback(mTestCbs);
    wrapper.setActive(true);
    // Cleanup the wrapper
    wrapper.cleanup();
    // Ensure that everything was cleaned up
    verify(mMockController).unregisterCallback(any());
    Assert.assertNull(wrapper.getTimeoutHandler());
}
#method_after
@Test
public void testWrapperCleanup() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), false);
    wrapper.registerCallback(mTestCbs);
    // Cleanup the wrapper
    wrapper.cleanup();
    // Ensure that everything was cleaned up
    verify(mMockController).unregisterCallback(any());
    Assert.assertNull(wrapper.getTimeoutHandler());
}
#end_block

#method_before
@Test
public void testIgnorePlaystateNone() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), false);
    wrapper.registerCallback(mTestCbs);
    wrapper.setActive(true);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update PlaybackState returned by controller
    mTestState.setState(PlaybackState.STATE_NONE, 0, 1.0f);
    doReturn(mTestState.build()).when(mMockController).getPlaybackState();
    controllerCallbacks.onPlaybackStateChanged(mTestState.build());
    // Verify that there was no update
    verify(mTestCbs, never()).mediaUpdatedCallback(any());
    // Verify that there are no timeout messages pending and there were no timeouts
    Assert.assertFalse(wrapper.getTimeoutHandler().hasMessages(MSG_TIMEOUT));
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
}
#method_after
@Test
public void testIgnorePlaystateNone() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), false);
    wrapper.registerCallback(mTestCbs);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update PlaybackState returned by controller
    mTestState.setState(PlaybackState.STATE_NONE, 0, 1.0f);
    doReturn(mTestState.build()).when(mMockController).getPlaybackState();
    controllerCallbacks.onPlaybackStateChanged(mTestState.build());
    // Verify that there was no update
    verify(mTestCbs, never()).mediaUpdatedCallback(any());
    // Verify that there are no timeout messages pending and there were no timeouts
    Assert.assertFalse(wrapper.getTimeoutHandler().hasMessages(MSG_TIMEOUT));
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
}
#end_block

#method_before
@Test
public void testMetadataSync() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), true);
    wrapper.registerCallback(mTestCbs);
    wrapper.setActive(true);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update Metdata returned by controller
    mTestMetadata.putString(MediaMetadata.METADATA_KEY_TITLE, "New Title");
    doReturn(mTestMetadata.build()).when(mMockController).getMetadata();
    controllerCallbacks.onMetadataChanged(mTestMetadata.build());
    // Update PlaybackState returned by controller
    mTestState.setActiveQueueItemId(103);
    doReturn(mTestState.build()).when(mMockController).getPlaybackState();
    controllerCallbacks.onPlaybackStateChanged(mTestState.build());
    // Update Queue returned by controller
    mTestQueue.add(new MediaDescription.Builder().setTitle("New Title").setSubtitle("BT Test Artist").setDescription("BT Test Album").setMediaId("103"));
    doReturn(getQueueFromDescriptions(mTestQueue)).when(mMockController).getQueue();
    controllerCallbacks.onQueueChanged(getQueueFromDescriptions(mTestQueue));
    // Assert that the callback was called with the updated data
    verify(mTestCbs, times(1)).mediaUpdatedCallback(mMediaUpdateData.capture());
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
    MediaPlayerWrapper.MediaData data = mMediaUpdateData.getValue();
    Assert.assertEquals("Returned Metadata isn't equal to given Metadata", data.metadata.getDescription(), mTestMetadata.build().getDescription());
    Assert.assertEquals("Returned PlaybackState isn't equal to given PlaybackState", data.state.toString(), mTestState.build().toString());
    Assert.assertEquals("Returned Queue isn't equal to given Queue", data.queue, getQueueFromDescriptions(mTestQueue));
    // Verify that there are no timeout messages pending and there were no timeouts
    Assert.assertFalse(wrapper.getTimeoutHandler().hasMessages(MSG_TIMEOUT));
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
}
#method_after
@Test
public void testMetadataSync() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), true);
    wrapper.registerCallback(mTestCbs);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update Metdata returned by controller
    mTestMetadata.putString(MediaMetadata.METADATA_KEY_TITLE, "New Title");
    doReturn(mTestMetadata.build()).when(mMockController).getMetadata();
    controllerCallbacks.onMetadataChanged(mTestMetadata.build());
    // Update PlaybackState returned by controller
    mTestState.setActiveQueueItemId(103);
    doReturn(mTestState.build()).when(mMockController).getPlaybackState();
    controllerCallbacks.onPlaybackStateChanged(mTestState.build());
    // Update Queue returned by controller
    mTestQueue.add(new MediaDescription.Builder().setTitle("New Title").setSubtitle("BT Test Artist").setDescription("BT Test Album").setMediaId("103"));
    doReturn(getQueueFromDescriptions(mTestQueue)).when(mMockController).getQueue();
    controllerCallbacks.onQueueChanged(getQueueFromDescriptions(mTestQueue));
    // Assert that the callback was called with the updated data
    verify(mTestCbs, times(1)).mediaUpdatedCallback(mMediaUpdateData.capture());
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
    MediaPlayerWrapper.MediaData data = mMediaUpdateData.getValue();
    Assert.assertEquals("Returned Metadata isn't equal to given Metadata", data.metadata.getDescription(), mTestMetadata.build().getDescription());
    Assert.assertEquals("Returned PlaybackState isn't equal to given PlaybackState", data.state.toString(), mTestState.build().toString());
    Assert.assertEquals("Returned Queue isn't equal to given Queue", data.queue, getQueueFromDescriptions(mTestQueue));
    // Verify that there are no timeout messages pending and there were no timeouts
    Assert.assertFalse(wrapper.getTimeoutHandler().hasMessages(MSG_TIMEOUT));
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
}
#end_block

#method_before
@Test
public void testMetadataSyncFail() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = InstrumentationRegistry.getInstrumentation().acquireLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), true);
    wrapper.registerCallback(mTestCbs);
    wrapper.setActive(true);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update Metdata returned by controller
    mTestMetadata.putString(MediaMetadata.METADATA_KEY_TITLE, "Mismatch Title");
    doReturn(mTestMetadata.build()).when(mMockController).getMetadata();
    controllerCallbacks.onMetadataChanged(mTestMetadata.build());
    // Force the timeout to execute immediatly
    looperManager.execute(looperManager.next());
    // Assert that there was a timeout
    verify(mFailHandler).onTerribleFailure(any(), any(), anyBoolean());
}
#method_after
@Test
public void testMetadataSyncFail() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = InstrumentationRegistry.getInstrumentation().acquireLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), true);
    wrapper.registerCallback(mTestCbs);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update Metdata returned by controller
    mTestMetadata.putString(MediaMetadata.METADATA_KEY_TITLE, "Mismatch Title");
    doReturn(mTestMetadata.build()).when(mMockController).getMetadata();
    controllerCallbacks.onMetadataChanged(mTestMetadata.build());
    // Force the timeout to execute immediately
    looperManager.execute(looperManager.next());
    // Assert that there was a timeout
    verify(mFailHandler).onTerribleFailure(any(), any(), anyBoolean());
}
#end_block

#method_before
@Test
public void testMetadataSyncFuzz() {
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = InstrumentationRegistry.getInstrumentation().acquireLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), true);
    wrapper.registerCallback(mTestCbs);
    wrapper.setActive(true);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    // Update the metadata 100 times
    MediaMetadata.Builder m = new MediaMetadata.Builder();
    PlaybackState.Builder s = new PlaybackState.Builder();
    s.setState(PlaybackState.STATE_PAUSED, 0, 1.0f);
    MediaDescription.Builder d = new MediaDescription.Builder();
    for (int i = 1; i <= 100; i++) {
        // Setup Media Info for current itteration
        m.putString(MediaMetadata.METADATA_KEY_TITLE, "BT Fuzz Song " + i);
        m.putString(MediaMetadata.METADATA_KEY_ARTIST, "BT Fuzz Artist " + i);
        m.putString(MediaMetadata.METADATA_KEY_ALBUM, "BT Fuzz Album " + i);
        s.setActiveQueueItemId(i);
        d.setTitle("BT Fuzz Song " + i);
        d.setSubtitle("BT Fuzz Artist " + i);
        d.setDescription("BT Fuzz Album " + i);
        d.setMediaId(Integer.toString(i));
        // Create a new Queue each time to prevent double counting caused by
        // Playback State matching the updated Queue
        ArrayList<MediaSession.QueueItem> q = new ArrayList<MediaSession.QueueItem>();
        q.add(new MediaSession.QueueItem(d.build(), i));
        // Call the MediaController callbacks in a random order
        ArrayList<Integer> callbackOrder = new ArrayList<>(Arrays.asList(0, 1, 2));
        Collections.shuffle(callbackOrder);
        for (int j = 0; j < 3; j++) {
            switch(callbackOrder.get(j)) {
                case // Update Metadata
                0:
                    doReturn(m.build()).when(mMockController).getMetadata();
                    controllerCallbacks.onMetadataChanged(m.build());
                    break;
                case // Update PlaybackState
                1:
                    doReturn(s.build()).when(mMockController).getPlaybackState();
                    controllerCallbacks.onPlaybackStateChanged(s.build());
                    break;
                case // Update Queue
                2:
                    doReturn(q).when(mMockController).getQueue();
                    controllerCallbacks.onQueueChanged(q);
                    break;
            }
        }
        // Check that the callback was called a certain number of times and
        // that all the Media info matches what was given
        verify(mTestCbs, times(i)).mediaUpdatedCallback(mMediaUpdateData.capture());
        MediaPlayerWrapper.MediaData data = mMediaUpdateData.getValue();
        Assert.assertEquals("Returned Metadata isn't equal to given Metadata", data.metadata.getDescription(), m.build().getDescription());
        Assert.assertEquals("Returned PlaybackState isn't equal to given PlaybackState", data.state.toString(), s.build().toString());
        Assert.assertEquals("Returned Queue isn't equal to given Queue", data.queue, q);
    }
    // Verify that there are no timeout messages pending and there were no timeouts
    Assert.assertFalse(wrapper.getTimeoutHandler().hasMessages(MSG_TIMEOUT));
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
}
#method_after
@Test
public void testMetadataSyncFuzz() {
    // The number of times the random order test is run
    final int numTestLoops = 100;
    // Create the wrapper object and register the looper with the timeout handler
    TestLooperManager looperManager = InstrumentationRegistry.getInstrumentation().acquireLooperManager(mThread.getLooper());
    MediaPlayerWrapper wrapper = MediaPlayerWrapper.wrap(mMockController, mThread.getLooper(), true);
    wrapper.registerCallback(mTestCbs);
    // Grab the callbacks the wrapper registered with the controller
    verify(mMockController).registerCallback(mControllerCbs.capture(), any());
    MediaController.Callback controllerCallbacks = mControllerCbs.getValue();
    MediaMetadata.Builder m = new MediaMetadata.Builder();
    PlaybackState.Builder s = new PlaybackState.Builder();
    s.setState(PlaybackState.STATE_PAUSED, 0, 1.0f);
    MediaDescription.Builder d = new MediaDescription.Builder();
    for (int i = 1; i <= numTestLoops; i++) {
        // Setup Media Info for current itteration
        m.putString(MediaMetadata.METADATA_KEY_TITLE, "BT Fuzz Song " + i);
        m.putString(MediaMetadata.METADATA_KEY_ARTIST, "BT Fuzz Artist " + i);
        m.putString(MediaMetadata.METADATA_KEY_ALBUM, "BT Fuzz Album " + i);
        m.putLong(MediaMetadata.METADATA_KEY_DURATION, 5000L);
        s.setActiveQueueItemId(i);
        d.setTitle("BT Fuzz Song " + i);
        d.setSubtitle("BT Fuzz Artist " + i);
        d.setDescription("BT Fuzz Album " + i);
        d.setMediaId(Integer.toString(i));
        // Create a new Queue each time to prevent double counting caused by
        // Playback State matching the updated Queue
        ArrayList<MediaSession.QueueItem> q = new ArrayList<MediaSession.QueueItem>();
        q.add(new MediaSession.QueueItem(d.build(), i));
        // Call the MediaController callbacks in a random order
        ArrayList<Integer> callbackOrder = new ArrayList<>(Arrays.asList(0, 1, 2));
        Collections.shuffle(callbackOrder);
        for (int j = 0; j < 3; j++) {
            switch(callbackOrder.get(j)) {
                case // Update Metadata
                0:
                    doReturn(m.build()).when(mMockController).getMetadata();
                    controllerCallbacks.onMetadataChanged(m.build());
                    break;
                case // Update PlaybackState
                1:
                    doReturn(s.build()).when(mMockController).getPlaybackState();
                    controllerCallbacks.onPlaybackStateChanged(s.build());
                    break;
                case // Update Queue
                2:
                    doReturn(q).when(mMockController).getQueue();
                    controllerCallbacks.onQueueChanged(q);
                    break;
            }
        }
        // Check that the callback was called a certain number of times and
        // that all the Media info matches what was given
        verify(mTestCbs, times(i)).mediaUpdatedCallback(mMediaUpdateData.capture());
        MediaPlayerWrapper.MediaData data = mMediaUpdateData.getValue();
        Assert.assertEquals("Returned Metadata isn't equal to given Metadata", data.metadata.getDescription(), m.build().getDescription());
        Assert.assertEquals("Returned PlaybackState isn't equal to given PlaybackState", data.state.toString(), s.build().toString());
        Assert.assertEquals("Returned Queue isn't equal to given Queue", data.queue, q);
    }
    // Verify that there are no timeout messages pending and there were no timeouts
    Assert.assertFalse(wrapper.getTimeoutHandler().hasMessages(MSG_TIMEOUT));
    verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o == null)
        return false;
    if (!(o instanceof MediaData))
        return false;
    final MediaData u = (MediaData) o;
    if (!(metadata == null && u.metadata == null) || !(metadata != null && u.metadata != null && metadata.getDescription().equals(u.metadata.getDescription()))) {
        return false;
    }
    if (!(queue == null && u.queue == null) || !(queue != null && u.queue != null && queue.equals(u.queue))) {
        return false;
    }
    if (!(state == null && u.state == null) || !(state != null && u.state != null && state.toString().equals(u.state.toString()))) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o == null)
        return false;
    if (!(o instanceof MediaData))
        return false;
    final MediaData u = (MediaData) o;
    if (!Objects.equals(metadata, u.metadata)) {
        return false;
    }
    if (!Objects.equals(queue, u.queue)) {
        return false;
    }
    if (!playstateEquals(state, u.state)) {
        return false;
    }
    return true;
}
#end_block

#method_before
static MediaPlayerWrapper wrap(MediaController controller, Looper looper, boolean browsable) {
    if (controller == null || looper == null) {
        e("MediaPlayerWrapper.wrap(): Controller or Looper is null");
        return null;
    }
    MediaPlayerWrapper newWrapper = new MediaPlayerWrapper();
    newWrapper.mMediaController = controller;
    newWrapper.mPackageName = controller.getPackageName();
    newWrapper.mLooper = looper;
    newWrapper.mCurrentData.queue = controller.getQueue();
    newWrapper.mCurrentData.metadata = controller.getMetadata();
    newWrapper.mCurrentData.state = controller.getPlaybackState();
    // TODO (apanicke): A decision will need to be made in the future whether to handle all
    // Media Player opperations in this wrapper class or delegate browsing to another seperate
    // class. For now just pass it in as an argument.
    newWrapper.mIsBrowsable = browsable;
    return newWrapper;
}
#method_after
static MediaPlayerWrapper wrap(MediaController controller, Looper looper, boolean browsable) {
    if (controller == null || looper == null) {
        e("MediaPlayerWrapper.wrap(): Null parameter - Controller: " + controller + " | Looper: " + looper);
        return null;
    }
    MediaPlayerWrapper newWrapper;
    newWrapper = new MediaPlayerWrapper();
    newWrapper.mMediaController = controller;
    newWrapper.mPackageName = controller.getPackageName();
    newWrapper.mLooper = looper;
    newWrapper.mIsBrowsable = browsable;
    newWrapper.mCurrentData.queue = newWrapper.getQueue();
    newWrapper.mCurrentData.metadata = newWrapper.getMetadata();
    newWrapper.mCurrentData.state = newWrapper.getPlaybackState();
    return newWrapper;
}
#end_block

#method_before
synchronized void cleanup() {
    unregisterCallback();
    mMediaController = null;
    mLooper = null;
}
#method_after
void cleanup() {
    unregisterCallback();
    mMediaController = null;
    mLooper = null;
}
#end_block

#method_before
List<MediaSession.QueueItem> getQueue() {
    return mMediaController.getQueue();
}
#method_after
List<MediaSession.QueueItem> getQueue() {
    if (!isBrowsable())
        return null;
    return mMediaController.getQueue();
}
#end_block

#method_before
long getActiveQueueID() {
    return mMediaController.getPlaybackState().getActiveQueueItemId();
}
#method_after
long getActiveQueueID() {
    if (mMediaController.getPlaybackState() == null)
        return -1;
    return mMediaController.getPlaybackState().getActiveQueueItemId();
}
#end_block

#method_before
boolean isMetadataSynced() {
    // We only need to check for Metadata sync if browing is supported
    if (isBrowsable()) {
        // Check if currentPlayingQueueId is in the queue
        MediaSession.QueueItem currItem = null;
        for (MediaSession.QueueItem item : getQueue()) {
            if (item.getQueueId() == getActiveQueueID()) {
                // The item exists in the current queue
                currItem = item;
            }
        }
        // Check if current playing song in queue matches current Metadata
        if (currItem == null || !currItem.getDescription().equals(getMetadata().getDescription())) {
            d("Metadata currently out of sync for " + mPackageName);
            d("  └ Current queueItem: " + currItem);
            d("  └ Current metadata : " + getMetadata().getDescription());
            return false;
        }
    }
    return true;
}
#method_after
boolean isMetadataSynced() {
    if (isBrowsable()) {
        // Check if currentPlayingQueueId is in the current Queue
        MediaSession.QueueItem currItem = null;
        for (MediaSession.QueueItem item : getQueue()) {
            if (item.getQueueId() == getActiveQueueID()) {
                // The item exists in the current queue
                currItem = item;
                break;
            }
        }
        // Check if current playing song in Queue matches current Metadata
        if (currItem == null || !currItem.getDescription().equals(getMetadata().getDescription())) {
            if (DEBUG) {
                Log.d(TAG, "Metadata currently out of sync for " + mPackageName);
                Log.d(TAG, "  └ Current queueItem: " + currItem);
                Log.d(TAG, "  └ Current metadata : " + getMetadata().getDescription());
            }
            return false;
        }
    }
    return true;
}
#end_block

#method_before
void registerCallback(Callback callback) {
    if (callback == null) {
        e("Tried registering null callbacks for " + mPackageName);
        return;
    }
    synchronized (mCallbackLock) {
        mRegisteredCallback = callback;
    }
    mControllerCallbacks = new MediaControllerListener(mLooper);
}
#method_after
void registerCallback(Callback callback) {
    if (callback == null) {
        e("Cannot register null callbacks for " + mPackageName);
        return;
    }
    synchronized (mCallbackLock) {
        mRegisteredCallback = callback;
    }
    mControllerCallbacks = new MediaControllerListener(mLooper);
}
#end_block

#method_before
void unregisterCallback() {
    if (mControllerCallbacks == null)
        return;
    mControllerCallbacks.cleanup();
    mControllerCallbacks = null;
    // Prevent a race condition where a callback could be called while a callback is executing
    synchronized (mCallbackLock) {
        mRegisteredCallback = null;
    }
}
#method_after
void unregisterCallback() {
    // Prevent a race condition where a callback could be called while shutting down
    synchronized (mCallbackLock) {
        mRegisteredCallback = null;
    }
    if (mControllerCallbacks == null)
        return;
    mControllerCallbacks.cleanup();
    mControllerCallbacks = null;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (msg.what != MSG_TIMEOUT) {
        Log.wtf(TAG, "Unknown message on timeout handler");
        return;
    }
    Log.e(TAG, "Timeout while waiting for metadata to sync for " + mPackageName);
    Log.e(TAG, "  └ Current Metadata: " + getMetadata().getDescription());
    Log.e(TAG, "  └ Current Playstate: " + getPlaybackState());
    for (int i = 0; i < getQueue().size(); i++) {
        Log.e(TAG, "  └ QueueItem(" + i + "): " + getQueue().get(i));
    }
    if (sTesting)
        Log.wtfStack(TAG, "Crashing the stack");
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (msg.what != MSG_TIMEOUT) {
        Log.wtf(TAG, "Unknown message on timeout handler: " + msg.what);
        return;
    }
    Log.e(TAG, "Timeout while waiting for metadata to sync for " + mPackageName);
    Log.e(TAG, "  └ Current Metadata: " + getMetadata().getDescription());
    Log.e(TAG, "  └ Current Playstate: " + getPlaybackState());
    for (int i = 0; i < getQueue().size(); i++) {
        Log.e(TAG, "  └ QueueItem(" + i + "): " + getQueue().get(i));
    }
    if (sTesting)
        Log.wtfStack(TAG, "Crashing the stack");
}
#end_block

#method_before
void cleanup() {
    synchronized (mTimeoutHandler) {
        mMediaController.unregisterCallback(this);
        mTimeoutHandler.removeMessages(MSG_TIMEOUT);
        mTimeoutHandler = null;
        mNewMediaUpdate = null;
    }
}
#method_after
void cleanup() {
    synchronized (mTimeoutHandlerLock) {
        mMediaController.unregisterCallback(this);
        mTimeoutHandler.removeMessages(TimeoutHandler.MSG_TIMEOUT);
        mTimeoutHandler = null;
    }
}
#end_block

#method_before
void trySendMediaUpdate() {
    synchronized (mTimeoutHandler) {
        if (mTimeoutHandler == null)
            return;
        mTimeoutHandler.removeMessages(MSG_TIMEOUT);
        if (!isMetadataSynced()) {
            d("trySendMediaUpdate(): " + mPackageName + ": Starting media update timeout");
            mTimeoutHandler.sendEmptyMessageDelayed(MSG_TIMEOUT, CALLBACK_TIMEOUT_MS);
            return;
        }
    }
    d("All the metadata is synced");
    if (mNewMediaUpdate.equals(mCurrentData)) {
        Log.w(TAG, "trySendMediaUpdate(): " + mPackageName + " tried to update with no new data");
        return;
    }
    synchronized (mCallbackLock) {
        if (mRegisteredCallback == null) {
            Log.e(TAG, mPackageName + "Trying to send an update with no registered callback");
            return;
        }
        Log.v(TAG, "trySendMediaUpdate(): Metadata has been updated for " + mPackageName);
        mRegisteredCallback.mediaUpdatedCallback(mNewMediaUpdate);
    }
    mCurrentData = mNewMediaUpdate;
    mNewMediaUpdate = new MediaData();
}
#method_after
void trySendMediaUpdate() {
    synchronized (mTimeoutHandlerLock) {
        if (mTimeoutHandler == null)
            return;
        mTimeoutHandler.removeMessages(TimeoutHandler.MSG_TIMEOUT);
        if (!isMetadataSynced()) {
            if (DEBUG) {
                Log.d(TAG, "trySendMediaUpdate(): " + mPackageName + ": Starting media update timeout");
            }
            mTimeoutHandler.sendEmptyMessageDelayed(TimeoutHandler.MSG_TIMEOUT, TimeoutHandler.CALLBACK_TIMEOUT_MS);
            return;
        }
    }
    MediaData newData = new MediaData(getMetadata(), getPlaybackState(), getQueue());
    if (newData.equals(mCurrentData)) {
        // This may happen if the controller is fully synced by the time the
        // first update is completed
        Log.v(TAG, "Trying to update with last sent metadata");
        return;
    }
    synchronized (mCallbackLock) {
        if (mRegisteredCallback == null) {
            Log.e(TAG, mPackageName + "Trying to send an update with no registered callback");
            return;
        }
        Log.v(TAG, "trySendMediaUpdate(): Metadata has been updated for " + mPackageName);
        mRegisteredCallback.mediaUpdatedCallback(newData);
    }
    mCurrentData = newData;
}
#end_block

#method_before
@Override
public void onMetadataChanged(MediaMetadata metadata) {
    if (!isActive())
        e("Callbacks from the non active player " + mPackageName);
    if (sTesting && !metadata.getDescription().equals(getMetadata().getDescription())) {
        Log.wtfStack(TAG, "The callback metadata doesn't match controller metadata");
    }
    Log.v(TAG, "onMetadataChanged(): " + mPackageName + " : " + metadata.getDescription());
    mNewMediaUpdate.metadata = metadata;
    trySendMediaUpdate();
}
#method_after
@Override
public void onMetadataChanged(MediaMetadata metadata) {
    Log.v(TAG, "onMetadataChanged(): " + mPackageName + " : " + metadata.getDescription());
    if (!metadata.equals(getMetadata())) {
        e("The callback metadata doesn't match controller metadata");
    }
    // the nearest second.
    if (metadata.equals(mCurrentData.metadata)) {
        Log.w(TAG, "onMetadataChanged(): " + mPackageName + " tried to update with no new data");
        return;
    }
    trySendMediaUpdate();
}
#end_block

#method_before
@Override
public void onPlaybackStateChanged(PlaybackState state) {
    if (!isActive())
        e("Callbacks from the non active player " + mPackageName);
    if (sTesting && !state.toString().equals(getPlaybackState().toString())) {
        Log.wtfStack(TAG, "The callback state isn't the current state");
    }
    Log.v(TAG, "onPlaybackStateChanged(): " + mPackageName + " : " + state.toString());
    // If there is no playstate ignore the update.
    if (state.getState() == PlaybackState.STATE_NONE) {
        Log.v(TAG, "Waiting to send update as controller has no playback state");
        return;
    }
    mNewMediaUpdate.state = state;
    trySendMediaUpdate();
}
#method_after
@Override
public void onPlaybackStateChanged(PlaybackState state) {
    Log.v(TAG, "onPlaybackStateChanged(): " + mPackageName + " : " + state.toString());
    if (!playstateEquals(state, getPlaybackState())) {
        e("The callback playback state doesn't match the current state");
    }
    if (playstateEquals(state, mCurrentData.state)) {
        Log.w(TAG, "onPlaybackStateChanged(): " + mPackageName + " tried to update with no new data");
        return;
    }
    // If there is no playstate, ignore the update.
    if (state.getState() == PlaybackState.STATE_NONE) {
        Log.v(TAG, "Waiting to send update as controller has no playback state");
        return;
    }
    trySendMediaUpdate();
}
#end_block

#method_before
@Override
public void onQueueChanged(List<MediaSession.QueueItem> queue) {
    Log.v(TAG, "onQueueChanged(): " + mPackageName);
    if (!isActive())
        e("Callbacks from the non active player " + mPackageName);
    if (!isBrowsable()) {
        e("Queue changed for non-browsable player " + mPackageName);
    }
    if (sTesting && !queue.equals(mMediaController.getQueue())) {
        Log.wtfStack(TAG, "The callback queue isn't the current queue");
    }
    for (int i = 0; DEBUG && i < queue.size(); i++) {
        Log.e(TAG, "  └ QueueItem(" + i + "): " + queue.get(i).getDescription());
    }
    mNewMediaUpdate.queue = queue;
    trySendMediaUpdate();
}
#method_after
@Override
public void onQueueChanged(List<MediaSession.QueueItem> queue) {
    Log.v(TAG, "onQueueChanged(): " + mPackageName);
    if (!isBrowsable()) {
        e("Queue changed for non-browsable player " + mPackageName);
        return;
    }
    if (!queue.equals(getQueue())) {
        e("The callback queue isn't the current queue");
    }
    if (queue.equals(mCurrentData.queue)) {
        Log.w(TAG, "onQueueChanged(): " + mPackageName + " tried to update with no new data");
        return;
    }
    if (DEBUG) {
        for (int i = 0; i < queue.size(); i++) {
            Log.d(TAG, "  └ QueueItem(" + i + "): " + queue.get(i));
        }
    }
    trySendMediaUpdate();
}
#end_block

#method_before
private static void e(String message) {
    if (sTesting)
        Log.wtfStack(TAG, message);
    else
        Log.e(TAG, message);
}
#method_after
private static void e(String message) {
    if (sTesting) {
        Log.wtfStack(TAG, message);
    } else {
        Log.e(TAG, message);
    }
}
#end_block

#method_before
public static boolean mvnoMatches(IccRecords r, String mvnoType, String mvnoMatchData) {
    if (mvnoType.equalsIgnoreCase("spn")) {
        if ((r.getServiceProviderName() != null) && r.getServiceProviderName().equalsIgnoreCase(mvnoMatchData)) {
            return true;
        }
    } else if (mvnoType.equalsIgnoreCase("imsi")) {
        String imsiSIM = r.getIMSI();
        if ((imsiSIM != null) && imsiMatches(mvnoMatchData, imsiSIM)) {
            return true;
        }
    } else if (mvnoType.equalsIgnoreCase("gid")) {
        String gid1 = r.getGid1();
        int mvno_match_data_length = mvnoMatchData.length();
        if ((gid1 != null) && (gid1.length() >= mvno_match_data_length) && gid1.substring(0, mvno_match_data_length).equalsIgnoreCase(mvnoMatchData)) {
            return true;
        }
    } else if (mvnoType.equalsIgnoreCase("iccid")) {
        String iccId = r.getIccId();
        if (iccId != null) {
            String[] mvnoIccidList = mvnoMatchData.split(",");
            for (String mvnoIccid : mvnoIccidList) {
                Log.d(TAG, "mvnoIccid: " + mvnoIccid);
                if (iccId.startsWith(mvnoIccid)) {
                    Log.d(TAG, "mvno icc id match found");
                    return true;
                }
            }
        }
    }
    return false;
}
#method_after
public static boolean mvnoMatches(IccRecords r, String mvnoType, String mvnoMatchData) {
    if (mvnoType.equalsIgnoreCase("spn")) {
        if ((r.getServiceProviderName() != null) && r.getServiceProviderName().equalsIgnoreCase(mvnoMatchData)) {
            return true;
        }
    } else if (mvnoType.equalsIgnoreCase("imsi")) {
        String imsiSIM = r.getIMSI();
        if ((imsiSIM != null) && imsiMatches(mvnoMatchData, imsiSIM)) {
            return true;
        }
    } else if (mvnoType.equalsIgnoreCase("gid")) {
        String gid1 = r.getGid1();
        int mvno_match_data_length = mvnoMatchData.length();
        if ((gid1 != null) && (gid1.length() >= mvno_match_data_length) && gid1.substring(0, mvno_match_data_length).equalsIgnoreCase(mvnoMatchData)) {
            return true;
        }
    } else if (mvnoType.equalsIgnoreCase("iccid")) {
        String iccId = r.getIccId();
        if ((iccId != null) && iccidMatches(mvnoMatchData, iccId)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static boolean isMeteredApnType(String type, Context context, int subId, boolean isRoaming) {
    String carrierConfig = (isRoaming) ? CarrierConfigManager.KEY_CARRIER_METERED_ROAMING_APN_TYPES_STRINGS : CarrierConfigManager.KEY_CARRIER_METERED_APN_TYPES_STRINGS;
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        Rlog.e(LOG_TAG, "Carrier config service is not available");
        return true;
    }
    PersistableBundle b = configManager.getConfigForSubId(subId);
    if (b == null) {
        Rlog.e(LOG_TAG, "Can't get the config. subId = " + subId);
        return true;
    }
    String[] meteredApnTypes = b.getStringArray(carrierConfig);
    if (meteredApnTypes == null) {
        Rlog.e(LOG_TAG, carrierConfig + " is not available. " + "subId = " + subId);
        return true;
    }
    HashSet<String> meteredApnSet = new HashSet<>(Arrays.asList(meteredApnTypes));
    if (DBG) {
        Rlog.d(LOG_TAG, "For subId = " + subId + ", metered APN types are " + Arrays.toString(meteredApnSet.toArray()) + " isRoaming: " + isRoaming);
    }
    // If all types of APN are metered, then this APN setting must be metered.
    if (meteredApnSet.contains(PhoneConstants.APN_TYPE_ALL)) {
        if (DBG)
            Rlog.d(LOG_TAG, "All APN types are metered. isRoaming: " + isRoaming);
        return true;
    }
    if (meteredApnSet.contains(type)) {
        if (DBG)
            Rlog.d(LOG_TAG, type + " is metered. isRoaming: " + isRoaming);
        return true;
    } else if (type.equals(PhoneConstants.APN_TYPE_ALL)) {
        // metered, then this APN setting is metered.
        if (meteredApnSet.size() > 0) {
            if (DBG)
                Rlog.d(LOG_TAG, "APN_TYPE_ALL APN is metered. isRoaming: " + isRoaming);
            return true;
        }
    }
    if (DBG)
        Rlog.d(LOG_TAG, type + " is not metered. isRoaming: " + isRoaming);
    return false;
}
#method_after
public static boolean isMeteredApnType(String type, Phone phone) {
    if (phone == null) {
        return true;
    }
    boolean isRoaming = phone.getServiceState().getDataRoaming();
    boolean isIwlan = phone.getServiceState().getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN;
    int subId = phone.getSubId();
    String carrierConfig;
    // the normal metered APN list.
    if (isIwlan) {
        carrierConfig = CarrierConfigManager.KEY_CARRIER_METERED_IWLAN_APN_TYPES_STRINGS;
    } else if (isRoaming) {
        carrierConfig = CarrierConfigManager.KEY_CARRIER_METERED_ROAMING_APN_TYPES_STRINGS;
    } else {
        carrierConfig = CarrierConfigManager.KEY_CARRIER_METERED_APN_TYPES_STRINGS;
    }
    if (DBG) {
        Rlog.d(LOG_TAG, "isMeteredApnType: isRoaming=" + isRoaming + ", isIwlan=" + isIwlan);
    }
    CarrierConfigManager configManager = (CarrierConfigManager) phone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        Rlog.e(LOG_TAG, "Carrier config service is not available");
        return true;
    }
    PersistableBundle b = configManager.getConfigForSubId(subId);
    if (b == null) {
        Rlog.e(LOG_TAG, "Can't get the config. subId = " + subId);
        return true;
    }
    String[] meteredApnTypes = b.getStringArray(carrierConfig);
    if (meteredApnTypes == null) {
        Rlog.e(LOG_TAG, carrierConfig + " is not available. " + "subId = " + subId);
        return true;
    }
    HashSet<String> meteredApnSet = new HashSet<>(Arrays.asList(meteredApnTypes));
    if (DBG) {
        Rlog.d(LOG_TAG, "For subId = " + subId + ", metered APN types are " + Arrays.toString(meteredApnSet.toArray()));
    }
    // If all types of APN are metered, then this APN setting must be metered.
    if (meteredApnSet.contains(PhoneConstants.APN_TYPE_ALL)) {
        if (DBG)
            Rlog.d(LOG_TAG, "All APN types are metered.");
        return true;
    }
    if (meteredApnSet.contains(type)) {
        if (DBG)
            Rlog.d(LOG_TAG, type + " is metered.");
        return true;
    } else if (type.equals(PhoneConstants.APN_TYPE_ALL)) {
        // metered, then this APN setting is metered.
        if (meteredApnSet.size() > 0) {
            if (DBG)
                Rlog.d(LOG_TAG, "APN_TYPE_ALL APN is metered.");
            return true;
        }
    }
    if (DBG)
        Rlog.d(LOG_TAG, type + " is not metered.");
    return false;
}
#end_block

#method_before
public boolean isMetered(Context context, int subId, boolean isRoaming) {
    for (String type : types) {
        // If one of the APN type is metered, then this APN setting is metered.
        if (isMeteredApnType(type, context, subId, isRoaming)) {
            if (DBG)
                Rlog.d(LOG_TAG, "Metered. APN = " + toString() + "isRoaming: " + isRoaming);
            return true;
        }
    }
    if (DBG)
        Rlog.d(LOG_TAG, "Not metered. APN = " + toString() + "isRoaming: " + isRoaming);
    return false;
}
#method_after
public boolean isMetered(Phone phone) {
    if (phone == null) {
        return true;
    }
    for (String type : types) {
        // If one of the APN type is metered, then this APN setting is metered.
        if (isMeteredApnType(type, phone)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
// TODO - if we have this function we should also have hashCode.
@Override
public boolean equals(Object o) {
    if (o instanceof ApnSetting == false) {
        return false;
    }
    ApnSetting other = (ApnSetting) o;
    return carrier.equals(other.carrier) && id == other.id && numeric.equals(other.numeric) && apn.equals(other.apn) && proxy.equals(other.proxy) && mmsc.equals(other.mmsc) && mmsProxy.equals(other.mmsProxy) && TextUtils.equals(mmsPort, other.mmsPort) && port.equals(other.port) && TextUtils.equals(user, other.user) && TextUtils.equals(password, other.password) && authType == other.authType && Arrays.deepEquals(types, other.types) && typesBitmap == other.typesBitmap && protocol.equals(other.protocol) && roamingProtocol.equals(other.roamingProtocol) && carrierEnabled == other.carrierEnabled && bearer == other.bearer && bearerBitmask == other.bearerBitmask && profileId == other.profileId && modemCognitive == other.modemCognitive && maxConns == other.maxConns && waitTime == other.waitTime && maxConnsTime == other.maxConnsTime && mtu == other.mtu && mvnoType.equals(other.mvnoType) && mvnoMatchData.equals(other.mvnoMatchData);
}
#method_after
@VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
public boolean equals(Object o, boolean isDataRoaming) {
    if (!(o instanceof ApnSetting)) {
        return false;
    }
    ApnSetting other = (ApnSetting) o;
    return carrier.equals(other.carrier) && numeric.equals(other.numeric) && apn.equals(other.apn) && proxy.equals(other.proxy) && mmsc.equals(other.mmsc) && mmsProxy.equals(other.mmsProxy) && TextUtils.equals(mmsPort, other.mmsPort) && port.equals(other.port) && TextUtils.equals(user, other.user) && TextUtils.equals(password, other.password) && authType == other.authType && Arrays.deepEquals(types, other.types) && typesBitmap == other.typesBitmap && (isDataRoaming || protocol.equals(other.protocol)) && (!isDataRoaming || roamingProtocol.equals(other.roamingProtocol)) && carrierEnabled == other.carrierEnabled && profileId == other.profileId && modemCognitive == other.modemCognitive && maxConns == other.maxConns && waitTime == other.waitTime && maxConnsTime == other.maxConnsTime && mtu == other.mtu && mvnoType.equals(other.mvnoType) && mvnoMatchData.equals(other.mvnoMatchData);
}
#end_block

#method_before
private void sendMessageToService(HeadsetStackEvent event) {
    HeadsetService service = HeadsetService.getHeadsetService();
    if (service != null) {
        service.messageFromNative(event);
    } else {
        Log.w(TAG, "Event ignored, service not available: " + event);
    }
}
#method_after
private void sendMessageToService(HeadsetStackEvent event) {
    HeadsetService service = HeadsetService.getHeadsetService();
    if (service != null) {
        service.messageFromNative(event);
    } else {
        // Service must call cleanup() when quiting and native stack shouldn't send any event
        // after cleanup() -> cleanupNative() is called.
        Log.wtfStack(TAG, "FATAL: Stack sent event while service is not available: " + event);
    }
}
#end_block

#method_before
private static synchronized void setHeadsetService(HeadsetService instance) {
    if (DBG) {
        Log.d(TAG, "setHeadsetService(): set to: " + sHeadsetService);
    }
    sHeadsetService = instance;
}
#method_after
private static synchronized void setHeadsetService(HeadsetService instance) {
    if (DBG) {
        Log.d(TAG, "setHeadsetService(): set to: " + instance);
    }
    sHeadsetService = instance;
}
#end_block

