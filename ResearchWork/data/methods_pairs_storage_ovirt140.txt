329
#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REBALANCE_STOP);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REBALANCE_STOP);
    super.setActionMessageParameters();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (!glusterVolume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
        return false;
    }
    if (glusterVolume.getAsyncTask() == null || glusterVolume.getAsyncTask().getStatus() != JobExecutionStatus.STARTED) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REBALANCE_NOT_STARTED);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (glusterVolume.getAsyncTask() == null || glusterVolume.getAsyncTask().getType() != GlusterTaskType.REBALANCE_VOLUME || glusterVolume.getAsyncTask().getStatus() != JobExecutionStatus.STARTED) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REBALANCE_NOT_STARTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected StepEnum getStepType() {
    return StepEnum.STOP_REBALANCING_GLUSTER_VOLUME;
}
#method_after
@Override
protected StepEnum getStepType() {
    return StepEnum.REBALANCING_VOLUME;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(vdsReturnaValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        return;
    }
    GlusterAsyncTask asyncTask = getGlusterVolume().getAsyncTask();
    List<Step> steps = DbFacade.getInstance().getStepDao().getStepsByExternalId(asyncTask.getTaskId());
    for (Step step : steps) {
        step.markStepEnded(JobExecutionStatus.ABORTED);
        endStepJob(step);
        clearVolumeTaskAndReleaseLock();
    }
    getReturnValue().setActionReturnValue(vdsReturnaValue);
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(vdsReturnaValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        return;
    }
    endStepJob();
    clearVolumeTaskAndReleaseLock();
    getReturnValue().setActionReturnValue(vdsReturnaValue);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Permissions removal
    bindPresenterWidget(RolePermissionsRemoveConfirmationPopupPresenterWidget.class, RolePermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, RolePermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).connectStorageToDomainByVdsId(getNewMaster(false), getVds().getId())) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), _newMasterStorageDomainId, null, EventType.RECOVERY), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = getBackend().runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDAO().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormat(loadTargetedMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
    }
}
#method_after
@Override
protected void executeCommand() {
    if (StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).connectStorageToDomainByVdsId(getNewMaster(false), getVds().getId())) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), _newMasterStorageDomainId, null, EventType.RECOVERY, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = getBackend().runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDAO().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormat(loadTargetedMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
    }
}
#end_block

#method_before
private void prepare2() {
    PreparingEnlistment enlistment = (PreparingEnlistment) context.enlistment;
    EnlistmentContext enlistmentContext = (EnlistmentContext) enlistment.getContext();
    HostListModel model = enlistmentContext.getModel();
    ConfigureLocalStorageModel configureModel = (ConfigureLocalStorageModel) model.getWindow();
    StoragePool candidate = configureModel.getCandidateDataCenter();
    DataCenterModel dataCenterModel = configureModel.getDataCenter();
    String dataCenterName = (String) dataCenterModel.getName().getEntity();
    if (candidate == null || !StringHelper.stringsEqual(candidate.getName(), dataCenterName)) {
        // Try to find existing data center with the specified name.
        StoragePool dataCenter = context.dataCenterFoundByName;
        if (dataCenter != null) {
            enlistmentContext.setDataCenterId(dataCenter.getId());
            context.enlistment = null;
            enlistment.Prepared();
        } else {
            dataCenter = new StoragePool();
            dataCenter.setName(dataCenterName);
            dataCenter.setdescription((String) dataCenterModel.getDescription().getEntity());
            dataCenter.setComment((String) dataCenterModel.getComment().getEntity());
            dataCenter.setStorageType((StorageType) dataCenterModel.getStorageTypeList().getSelectedItem());
            dataCenter.setcompatibility_version((Version) dataCenterModel.getVersion().getSelectedItem());
            StoragePoolManagementParameter parameters = new StoragePoolManagementParameter(dataCenter);
            parameters.setCorrelationId(getCorrelationId());
            Frontend.RunAction(VdcActionType.AddEmptyStoragePool, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    context.addDataCenterReturnValue = returnValue;
                    prepare3();
                }
            });
        }
    } else {
        enlistmentContext.setDataCenterId(configureModel.getDataCenter().getDataCenterId());
        context.enlistment = null;
        enlistment.Prepared();
    }
}
#method_after
private void prepare2() {
    PreparingEnlistment enlistment = (PreparingEnlistment) context.enlistment;
    EnlistmentContext enlistmentContext = (EnlistmentContext) enlistment.getContext();
    HostListModel model = enlistmentContext.getModel();
    ConfigureLocalStorageModel configureModel = (ConfigureLocalStorageModel) model.getWindow();
    StoragePool candidate = configureModel.getCandidateDataCenter();
    DataCenterModel dataCenterModel = configureModel.getDataCenter();
    String dataCenterName = (String) dataCenterModel.getName().getEntity();
    if (candidate == null || !StringHelper.stringsEqual(candidate.getName(), dataCenterName)) {
        // Try to find existing data center with the specified name.
        StoragePool dataCenter = context.dataCenterFoundByName;
        if (dataCenter != null) {
            enlistmentContext.setDataCenterId(dataCenter.getId());
            context.enlistment = null;
            enlistment.Prepared();
        } else {
            dataCenter = new StoragePool();
            dataCenter.setName(dataCenterName);
            dataCenter.setdescription((String) dataCenterModel.getDescription().getEntity());
            dataCenter.setComment((String) dataCenterModel.getComment().getEntity());
            dataCenter.setStorageType((StorageType) dataCenterModel.getStorageTypeList().getSelectedItem());
            dataCenter.setcompatibility_version((Version) dataCenterModel.getVersion().getSelectedItem());
            StoragePoolManagementParameter parameters = new StoragePoolManagementParameter(dataCenter);
            parameters.setCorrelationId(getCorrelationId());
            Frontend.RunAction(VdcActionType.AddEmptyStoragePool, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    context.addDataCenterReturnValue = result.getReturnValue();
                    prepare3();
                }
            });
        }
    } else {
        enlistmentContext.setDataCenterId(configureModel.getDataCenter().getDataCenterId());
        context.enlistment = null;
        enlistment.Prepared();
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getDisksAllocationModel().setIsVolumeFormatAvailable(false);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(false);
    AsyncDataProvider.getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            final List<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    UnitVmModel model = (UnitVmModel) target;
                    model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, null);
                    initCdImage();
                    getPoolModelBehaviorInitializedEvent().raise(this, EventArgs.Empty);
                }
            }, getModel().getHash()), true, false);
        }
    }, getModel().getHash()), true, false);
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getDisksAllocationModel().setIsVolumeFormatAvailable(false);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(false);
    AsyncDataProvider.getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    UnitVmModel model = (UnitVmModel) target;
                    model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, null);
                    initCdImage();
                    getPoolModelBehaviorInitializedEvent().raise(this, EventArgs.Empty);
                }
            }, getModel().getHash()), true, false);
        }
    }, getModel().getHash()), true, false);
}
#end_block

#method_before
private void processStoragePoolStatus() {
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getVds().getStoragePoolId());
        if (pool != null && pool.getStatus() == StoragePoolStatus.NotOperational) {
            pool.setStatus(StoragePoolStatus.NonResponsive);
            DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), pool.getStatus());
            StoragePoolStatusHandler.PoolStatusChanged(pool.getId(), pool.getStatus());
        }
    }
}
#method_after
private void processStoragePoolStatus() {
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getVds().getStoragePoolId());
        if (pool != null && pool.getStatus() == StoragePoolStatus.NotOperational) {
            pool.setStatus(StoragePoolStatus.NonResponsive);
            DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), pool.getStatus());
            StoragePoolStatusHandler.poolStatusChanged(pool.getId(), pool.getStatus());
        }
    }
}
#end_block

#method_before
private boolean connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    if (result != null) {
        return result.isSuccess();
    }
    return false;
}
#method_after
private boolean connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL, "Trying to connect host " + vds.getHostName() + " with id " + vds.getId() + " to the pool " + getStoragePool().getId()), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    if (result != null) {
        return result.isSuccess();
    }
    return false;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (UpdateStorageDomainsInDb()) {
        // setting storage pool status to maintenance
        StoragePool storagePool = getStoragePool();
        getCompensationContext().snapshotEntity(storagePool);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePool().setStoragePoolFormatType(masterStorageDomain.getStorageFormat());
                DbFacade.getInstance().getStoragePoolDao().update(getStoragePool());
                getCompensationContext().stateChanged();
                StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
                return null;
            }
        });
        // Following code performs only read operations, therefore no need for new transaction
        boolean result = false;
        retVal = null;
        for (VDS vds : getAllRunningVdssInPool()) {
            setVds(vds);
            for (Guid storageDomainId : getParameters().getStorages()) {
                // now the domain should have the mapping
                // with the pool in db
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePool().getId());
                StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVds().getId());
            }
            retVal = addStoragePoolInIrs();
            if (!retVal.getSucceeded() && retVal.getVdsError().getCode() == VdcBllErrors.StorageDomainAccessError) {
                log.warnFormat("Error creating storage pool on vds {0} - continuing", vds.getName());
                continue;
            } else {
                // storage pool creation succeeded or failed
                // but didn't throw exception
                result = retVal.getSucceeded();
                break;
            }
        }
        setSucceeded(result);
        if (!result) {
            if (retVal != null && retVal.getVdsError().getCode() != null) {
                throw new VdcBLLException(retVal.getVdsError().getCode(), retVal.getVdsError().getMessage());
            } else {
                // command
                throw new VdcBLLException(VdcBllErrors.ENGINE_ERROR_CREATING_STORAGE_POOL);
            }
        }
    }
    // Create pool phase completed, no rollback is needed here, so compensation information needs to be cleared!
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    freeLock();
    // if create succeeded activate
    if (getSucceeded()) {
        ActivateStorageDomains();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (UpdateStorageDomainsInDb()) {
        // setting storage pool status to maintenance
        StoragePool storagePool = getStoragePool();
        getCompensationContext().snapshotEntity(storagePool);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePool().setStoragePoolFormatType(masterStorageDomain.getStorageFormat());
                DbFacade.getInstance().getStoragePoolDao().update(getStoragePool());
                getCompensationContext().stateChanged();
                StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
                return null;
            }
        });
        // Following code performs only read operations, therefore no need for new transaction
        boolean result = false;
        retVal = null;
        for (VDS vds : getAllRunningVdssInPool()) {
            setVds(vds);
            for (Guid storageDomainId : getParameters().getStorages()) {
                // now the domain should have the mapping
                // with the pool in db
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePool().getId());
                StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVds().getId());
            }
            retVal = addStoragePoolInIrs();
            if (!retVal.getSucceeded() && retVal.getVdsError().getCode() == VdcBllErrors.StorageDomainAccessError) {
                log.warnFormat("Error creating storage pool on vds {0} - continuing", vds.getName());
                continue;
            } else {
                // storage pool creation succeeded or failed
                // but didn't throw exception
                result = retVal.getSucceeded();
                break;
            }
        }
        setSucceeded(result);
        if (!result) {
            if (retVal != null && retVal.getVdsError().getCode() != null) {
                throw new VdcBLLException(retVal.getVdsError().getCode(), retVal.getVdsError().getMessage());
            } else {
                // command
                throw new VdcBLLException(VdcBllErrors.ENGINE_ERROR_CREATING_STORAGE_POOL);
            }
        }
    }
    // Create pool phase completed, no rollback is needed here, so compensation information needs to be cleared!
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    freeLock();
    // if create succeeded activate
    if (getSucceeded()) {
        ActivateStorageDomains();
    }
}
#end_block

#method_before
private boolean UpdateStorageDomainsInDb() {
    boolean result = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            for (Guid storageDomainId : getParameters().getStorages()) {
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().get(storageDomainId);
                if (storageDomain != null) {
                    StoragePoolIsoMap mapFromDB = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(storageDomain.getId(), getStoragePool().getId()));
                    boolean existingInDb = mapFromDB != null;
                    if (existingInDb) {
                        getCompensationContext().snapshotEntity(mapFromDB);
                    }
                    final StorageDomainStatic staticDomain = storageDomain.getStorageStaticData();
                    boolean staticDomainChanged = false;
                    // version (setmaster_domain_version) depends on the domain upgrade.
                    if (getStoragePool().getcompatibility_version().compareTo(Version.v3_1) >= 0 && staticDomain.getStorageFormat() != StorageFormatType.V3) {
                        if (!staticDomainChanged) {
                            getCompensationContext().snapshotEntity(staticDomain);
                        }
                        staticDomain.setStorageFormat(StorageFormatType.V3);
                        staticDomainChanged = true;
                    }
                    storageDomain.setStoragePoolId(getStoragePool().getId());
                    if (masterStorageDomain == null && storageDomain.getStorageDomainType() == StorageDomainType.Data) {
                        if (!staticDomainChanged) {
                            getCompensationContext().snapshotEntity(staticDomain);
                        }
                        storageDomain.setStorageDomainType(StorageDomainType.Master);
                        staticDomainChanged = true;
                        masterStorageDomain = storageDomain;
                        // The update of storage pool should be without compensation,
                        // this is why we run it in a different SUPRESS transaction.
                        updateStoragePoolMasterDomainVersionInDiffTransaction();
                    }
                    if (staticDomainChanged) {
                        getStorageDomainStaticDAO().update(staticDomain);
                    }
                    storageDomain.setStatus(StorageDomainStatus.Locked);
                    if (existingInDb) {
                        DbFacade.getInstance().getStoragePoolIsoMapDao().update(storageDomain.getStoragePoolIsoMapData());
                    } else {
                        DbFacade.getInstance().getStoragePoolIsoMapDao().save(storageDomain.getStoragePoolIsoMapData());
                        getCompensationContext().snapshotNewEntity(storageDomain.getStoragePoolIsoMapData());
                    }
                } else {
                    return false;
                }
            }
            getCompensationContext().stateChanged();
            return true;
        }
    });
    return result && masterStorageDomain != null;
}
#method_after
private boolean UpdateStorageDomainsInDb() {
    boolean result = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            for (Guid storageDomainId : getParameters().getStorages()) {
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().get(storageDomainId);
                if (storageDomain != null) {
                    StoragePoolIsoMap mapFromDB = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(storageDomain.getId(), getStoragePool().getId()));
                    boolean existingInDb = mapFromDB != null;
                    if (existingInDb) {
                        getCompensationContext().snapshotEntity(mapFromDB);
                    }
                    final StorageDomainStatic staticDomain = storageDomain.getStorageStaticData();
                    boolean staticDomainChanged = false;
                    StorageFormatType requiredFormatType = VersionStorageFormatUtil.getFormatForVersion(getStoragePool().getcompatibility_version());
                    if (staticDomain.getStorageFormat() != requiredFormatType) {
                        if (!staticDomainChanged) {
                            getCompensationContext().snapshotEntity(staticDomain);
                        }
                        staticDomain.setStorageFormat(requiredFormatType);
                        staticDomainChanged = true;
                    }
                    storageDomain.setStoragePoolId(getStoragePool().getId());
                    if (masterStorageDomain == null && storageDomain.getStorageDomainType() == StorageDomainType.Data) {
                        if (!staticDomainChanged) {
                            getCompensationContext().snapshotEntity(staticDomain);
                        }
                        storageDomain.setStorageDomainType(StorageDomainType.Master);
                        staticDomainChanged = true;
                        masterStorageDomain = storageDomain;
                        // The update of storage pool should be without compensation,
                        // this is why we run it in a different SUPRESS transaction.
                        updateStoragePoolMasterDomainVersionInDiffTransaction();
                    }
                    if (staticDomainChanged) {
                        getStorageDomainStaticDAO().update(staticDomain);
                    }
                    storageDomain.setStatus(StorageDomainStatus.Locked);
                    if (existingInDb) {
                        DbFacade.getInstance().getStoragePoolIsoMapDao().update(storageDomain.getStoragePoolIsoMapData());
                    } else {
                        DbFacade.getInstance().getStoragePoolIsoMapDao().save(storageDomain.getStoragePoolIsoMapData());
                        getCompensationContext().snapshotNewEntity(storageDomain.getStoragePoolIsoMapData());
                    }
                } else {
                    return false;
                }
            }
            getCompensationContext().stateChanged();
            return true;
        }
    });
    return result && masterStorageDomain != null;
}
#end_block

#method_before
protected void calcStoragePoolStatusByDomainsStatus() {
    List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    // set masterDomain to the first element of domains with type=master, or null if non have this type.
    StorageDomain masterDomain = LinqUtils.firstOrNull(domains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain a) {
            return a.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = getStoragePoolDAO().get(getStoragePool().getId());
        if ((getStoragePool().getspm_vds_id() == null && poolFromDb.getspm_vds_id() != null) || (getStoragePool().getspm_vds_id() != null && !getStoragePool().getspm_vds_id().equals(poolFromDb.getspm_vds_id()))) {
            getStoragePool().setspm_vds_id(poolFromDb.getspm_vds_id());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setspm_vds_id(null);
        }
        executeInScope(TransactionScopeOption.Required, new TransactionMethod<StoragePool>() {

            @Override
            public StoragePool runInTransaction() {
                getStoragePoolDAO().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#method_after
protected void calcStoragePoolStatusByDomainsStatus() {
    List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    // set masterDomain to the first element of domains with type=master, or null if non have this type.
    StorageDomain masterDomain = LinqUtils.firstOrNull(domains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain a) {
            return a.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = getStoragePoolDAO().get(getStoragePool().getId());
        if ((getStoragePool().getspm_vds_id() == null && poolFromDb.getspm_vds_id() != null) || (getStoragePool().getspm_vds_id() != null && !getStoragePool().getspm_vds_id().equals(poolFromDb.getspm_vds_id()))) {
            getStoragePool().setspm_vds_id(poolFromDb.getspm_vds_id());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setspm_vds_id(null);
        }
        executeInScope(TransactionScopeOption.Required, new TransactionMethod<StoragePool>() {

            @Override
            public StoragePool runInTransaction() {
                getStoragePoolDAO().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#end_block

#method_before
public void onSave() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (!model.validate()) {
        return;
    }
    if ((model.getIsNew() || model.getEntity() == null) && model.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!model.getIsNew() && getSelectedItem() != null && !((Version) model.getVersion().getSelectedItem()).equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && model.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(model.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#method_after
public void onSave() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (!model.validate()) {
        return;
    }
    if ((model.getIsNew() || model.getEntity() == null) && model.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!model.getIsNew() && getSelectedItem() != null && !model.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        StorageFormatType newFormat = VersionStorageFormatUtil.getFormatForVersion((Version) model.getVersion().getSelectedItem());
        StorageFormatType oldFormat = VersionStorageFormatUtil.getFormatForVersion(((StoragePool) getSelectedItem()).getcompatibility_version());
        if (newFormat == oldFormat) {
            confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
        } else {
            confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg());
        }
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && model.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(model.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#end_block

#method_before
@Before
public void setUp() {
    providerId = Guid.newGuid();
    repoStorageDomainId = Guid.newGuid();
    repoImageId = Guid.newGuid().toString();
    diskImageId = Guid.newGuid();
    diskImageGroupId = Guid.newGuid();
    storagePoolId = Guid.newGuid();
    storageDomainId = Guid.newGuid();
    StorageDomain sourceStorageDomain = new StorageDomain();
    sourceStorageDomain.setStorage(providerId.toString());
    StorageDomain destinationStorageDomain = new StorageDomain();
    destinationStorageDomain.setId(storageDomainId);
    destinationStorageDomain.setStoragePoolId(storagePoolId);
    storagePool = new StoragePool();
    storagePool.setId(storagePoolId);
    storagePool.setStatus(StoragePoolStatus.Up);
    Provider provider = new Provider();
    provider.setType(ProviderType.OPENSTACK_IMAGE);
    diskImage = new DiskImage();
    diskImage.setId(diskImageId);
    when(storageDomainDao.get(repoStorageDomainId)).thenReturn(sourceStorageDomain);
    when(storageDomainDao.getAllForStorageDomain(storageDomainId)).thenReturn(Arrays.asList(destinationStorageDomain));
    when(storagePoolDao.get(storagePoolId)).thenReturn(storagePool);
    when(diskImageDao.get(diskImageId)).thenReturn(diskImage);
    when(providerProxy.getImageAsDiskImage(repoImageId)).thenReturn(diskImage);
}
#method_after
@Before
public void setUp() {
    providerId = Guid.newGuid();
    repoStorageDomainId = Guid.newGuid();
    repoImageId = Guid.newGuid().toString();
    diskImageId = Guid.newGuid();
    diskImageGroupId = Guid.newGuid();
    storagePoolId = Guid.newGuid();
    storageDomainId = Guid.newGuid();
    StorageDomain imageStorageDomain = new StorageDomain();
    imageStorageDomain.setStorage(providerId.toString());
    diskStorageDomain = new StorageDomain();
    diskStorageDomain.setId(storageDomainId);
    diskStorageDomain.setStoragePoolId(storagePoolId);
    diskStorageDomain.setStatus(StorageDomainStatus.Active);
    storagePool = new StoragePool();
    storagePool.setId(storagePoolId);
    storagePool.setStatus(StoragePoolStatus.Up);
    Provider provider = new Provider();
    provider.setType(ProviderType.OPENSTACK_IMAGE);
    diskImage = new DiskImage();
    diskImage.setId(diskImageId);
    diskImage.setStorageIds(new ArrayList<>(Arrays.asList(storageDomainId)));
    diskImage.setStoragePoolId(storagePoolId);
    when(storageDomainDao.get(repoStorageDomainId)).thenReturn(imageStorageDomain);
    when(storageDomainDao.getAllForStorageDomain(storageDomainId)).thenReturn(Arrays.asList(diskStorageDomain));
    when(storagePoolDao.get(storagePoolId)).thenReturn(storagePool);
    when(diskDao.get(diskImageGroupId)).thenReturn(diskImage);
    when(diskImageDao.get(diskImageId)).thenReturn(diskImage);
    when(providerProxy.getImageAsDiskImage(repoImageId)).thenReturn(diskImage);
}
#end_block

#method_before
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId, false);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#method_after
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT, "Reconstruct caused by failure to execute spm command"), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId, false);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#end_block

#method_before
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                return result;
            }
        });
    }
}
#method_after
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                return result;
            }
        });
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                result = ProcessDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                result = ProcessDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#end_block

#method_before
@Override
protected void executeVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                ExecuteIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSUnicodeArgumentException ex) {
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            throw ex;
        } catch (IrsOperationFailedNoFailoverException ex) {
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            getCurrentIrsProxyData().getTriedVdssList().clear();
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#method_after
@Override
protected void executeVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                executeIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSUnicodeArgumentException ex) {
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            throw ex;
        } catch (IrsOperationFailedNoFailoverException ex) {
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            getCurrentIrsProxyData().getTriedVdssList().clear();
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#end_block

#method_before
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true);
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT, "IrsBrokerCommand.startReconstruct()"), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true);
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    final StorageFormatType targetFormat;
    if (Version.OpEquality(spVersion, oldSpVersion)) {
        return;
    }
    // when everyone can utilize it.
    if (spVersion.compareTo(Version.v3_0) == 0) {
        targetFormat = StorageFormatType.V2;
    } else if (spVersion.compareTo(Version.v3_1) >= 0) {
        targetFormat = StorageFormatType.V3;
    } else {
        targetFormat = StorageFormatType.V1;
    }
    StorageType spType = storagePool.getStorageType();
    if (targetFormat == StorageFormatType.V2 && !spType.isBlockDomain()) {
        // There is no format V2 for domains that aren't ISCSI/FCP
        return;
    }
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            return null;
        }
    });
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warnFormat("Upgrade procees of Storage Pool {0} has encountered a problem due to following reason: {1}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
}
#method_after
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    if (Version.OpEquality(spVersion, oldSpVersion)) {
        return;
    }
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getFormatForVersion(spVersion);
    StorageType spType = storagePool.getStorageType();
    if (targetFormat == StorageFormatType.V2 && !spType.isBlockDomain()) {
        // There is no format V2 for domains that aren't ISCSI/FCP
        return;
    }
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            return null;
        }
    });
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warnFormat("Upgrade procees of Storage Pool {0} has encountered a problem due to following reason: {1}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setstatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, StorageDomainStatus.Locked);
    ProceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool(), getStoragePool().getStatus());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    if (!getParameters().isInactive()) {
        runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
    }
    if (_isLastMaster && spm != null) {
        final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
        if (!stopSpmReturnValue.getSucceeded()) {
            // no need to continue because DisconnectStoragePool will
            // fail if host is SPM
            log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
            setSucceeded(false);
            return;
        }
        runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setstatus(StorageDomainStatus.InActive);
            } else {
                map.setstatus(StorageDomainStatus.Maintenance);
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getstatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setstatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getstatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setstatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, StorageDomainStatus.Locked);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool(), getStoragePool().getStatus());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    if (!getParameters().isInactive()) {
        runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
    }
    if (_isLastMaster && spm != null) {
        final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
        if (!stopSpmReturnValue.getSucceeded()) {
            // no need to continue because DisconnectStoragePool will
            // fail if host is SPM
            log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
            setSucceeded(false);
            return;
        }
        runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setstatus(StorageDomainStatus.InActive);
            } else {
                map.setstatus(StorageDomainStatus.Maintenance);
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getstatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setstatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getstatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimeout")
public void onTimeout() {
    if (_nonOperationalPools.containsKey(poolId)) {
        try {
            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(poolId);
            if (pool != null && pool.getStatus() == StoragePoolStatus.NotOperational) {
                NonOperationalPoolTreatment(pool);
            }
        } catch (java.lang.Exception e) {
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimeout")
public void onTimeout() {
    if (_nonOperationalPools.containsKey(poolId)) {
        try {
            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(poolId);
            if (pool != null && pool.getStatus() == StoragePoolStatus.NotOperational) {
                nonOperationalPoolTreatment(pool);
            }
        } catch (java.lang.Exception e) {
        }
    }
}
#end_block

#method_before
public static void Init() {
    List<StoragePool> allPools = DbFacade.getInstance().getStoragePoolDao().getAll();
    for (StoragePool pool : allPools) {
        if (pool.getStatus() == StoragePoolStatus.NotOperational) {
            PoolStatusChanged(pool.getId(), StoragePoolStatus.NotOperational);
        }
    }
}
#method_after
public static void Init() {
    List<StoragePool> allPools = DbFacade.getInstance().getStoragePoolDao().getAll();
    for (StoragePool pool : allPools) {
        if (pool.getStatus() == StoragePoolStatus.NotOperational) {
            poolStatusChanged(pool.getId(), StoragePoolStatus.NotOperational);
        }
    }
}
#end_block

#method_before
private static void clearDomainCache(final VDS vds) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(vds.getStoragePoolId(), null, vds.getId(), EventType.VDSCLEARCACHE), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            IrsBrokerCommand.clearVdsFromCache(vds.getStoragePoolId(), vds.getId(), vds.getName());
            return new EventResult(true, EventType.VDSCLEARCACHE);
        }
    });
}
#method_after
private static void clearDomainCache(final VDS vds) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(vds.getStoragePoolId(), null, vds.getId(), EventType.VDSCLEARCACHE, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            IrsBrokerCommand.clearVdsFromCache(vds.getStoragePoolId(), vds.getId(), vds.getName());
            return new EventResult(true, EventType.VDSCLEARCACHE);
        }
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getStoragePool().setStatus(getParameters().getStatus());
    setVdsIdRef(getStoragePool().getspm_vds_id());
    DbFacade.getInstance().getStoragePoolDao().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
    if (getParameters().getStatus() == StoragePoolStatus.NonResponsive || getParameters().getStatus() == StoragePoolStatus.NotOperational) {
        List<StoragePoolIsoMap> storagesStatusInPool = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
        for (StoragePoolIsoMap storageStatusInPool : storagesStatusInPool) {
            if (storageStatusInPool.getstatus() != null && storageStatusInPool.getstatus() == StorageDomainStatus.Active) {
                storageStatusInPool.setstatus(StorageDomainStatus.Unknown);
                DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(storageStatusInPool.getId(), storageStatusInPool.getstatus());
            }
        }
    }
    StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getStoragePool().setStatus(getParameters().getStatus());
    setVdsIdRef(getStoragePool().getspm_vds_id());
    DbFacade.getInstance().getStoragePoolDao().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
    if (getParameters().getStatus() == StoragePoolStatus.NonResponsive || getParameters().getStatus() == StoragePoolStatus.NotOperational) {
        List<StoragePoolIsoMap> storagesStatusInPool = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
        for (StoragePoolIsoMap storageStatusInPool : storagesStatusInPool) {
            if (storageStatusInPool.getstatus() != null && storageStatusInPool.getstatus() == StorageDomainStatus.Active) {
                storageStatusInPool.setstatus(StorageDomainStatus.Unknown);
                DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(storageStatusInPool.getId(), storageStatusInPool.getstatus());
            }
        }
    }
    StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    setSucceeded(true);
}
#end_block

#method_before
public static void Init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class };
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames), VMStatus.class);
    for (Pair<EditableField, String> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVmStatusField, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond());
    }
    COMMANDS_ALLOWED_ON_NON_MANAGED_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_NON_MANAGED_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_NON_MANAGED_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_NON_MANAGED_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_NON_MANAGED_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_NON_MANAGED_VMS.add(VdcActionType.VmLogon);
}
#method_after
public static void Init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class };
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames), VMStatus.class);
    for (Pair<EditableField, String> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVmStatusField, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#end_block

#method_before
public static ValidationResult canRunActionOnNonManagedVm(VM vm, VdcActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if (!vm.isManagedVm()) {
        if (!COMMANDS_ALLOWED_ON_NON_MANAGED_VMS.contains(actionType)) {
            validationResult = new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
        }
    }
    return validationResult;
}
#method_after
public static ValidationResult canRunActionOnNonManagedVm(VM vm, VdcActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if ((vm.isHostedEngine() && !COMMANDS_ALLOWED_ON_HOSTED_ENGINE.contains(actionType)) || (vm.isExternalVm() && !COMMANDS_ALLOWED_ON_EXTERNAL_VMS.contains(actionType))) {
        validationResult = new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, StorageDomainStatus.Locked);
    ProceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    if (!getParameters().isInactive()) {
        runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
    }
    if (_isLastMaster && spm != null) {
        final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
        if (!stopSpmReturnValue.getSucceeded()) {
            // no need to continue because DisconnectStoragePool will
            // fail if host is SPM
            log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
            setSucceeded(false);
            return;
        }
        runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.InActive);
            } else {
                map.setStatus(StorageDomainStatus.Maintenance);
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, StorageDomainStatus.Locked);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    if (!getParameters().isInactive()) {
        runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
    }
    if (_isLastMaster && spm != null) {
        final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
        if (!stopSpmReturnValue.getSucceeded()) {
            // no need to continue because DisconnectStoragePool will
            // fail if host is SPM
            log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
            setSucceeded(false);
            return;
        }
        runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.InActive);
            } else {
                map.setStatus(StorageDomainStatus.Maintenance);
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#end_block

#method_before
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId, false);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#method_after
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT, "Reconstruct caused by failure to execute spm command"), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId, false);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#end_block

#method_before
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                return result;
            }
        });
    }
}
#method_after
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                return result;
            }
        });
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                result = ProcessDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                result = ProcessDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#end_block

#method_before
@Override
protected void executeVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                ExecuteIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSUnicodeArgumentException ex) {
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            throw ex;
        } catch (IrsOperationFailedNoFailoverException ex) {
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            getCurrentIrsProxyData().getTriedVdssList().clear();
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#method_after
@Override
protected void executeVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                executeIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSUnicodeArgumentException ex) {
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            throw ex;
        } catch (IrsOperationFailedNoFailoverException ex) {
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            getCurrentIrsProxyData().getTriedVdssList().clear();
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#end_block

#method_before
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true);
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT, "IrsBrokerCommand.startReconstruct()"), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true);
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
protected void initNetworkInterfaces(final ProfileBehavior behavior, final List<VmNetworkInterface> argNics) {
    boolean hotUpdateSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.NetworkLinkingSupported, getModel().getSelectedCluster().getcompatibility_version().toString());
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VnicProfileView> profiles = (List<VnicProfileView>) returnValue;
            List<VnicInstanceType> vnicInstanceTypes = new ArrayList<VnicInstanceType>();
            List<VmNetworkInterface> nics = (argNics == null) ? new ArrayList<VmNetworkInterface>() : argNics;
            if (nics.isEmpty() && !(profiles.isEmpty() || (profiles.size() == 1 && profiles.get(0) == null))) {
                // create a default if none provided AND if there are profiles to choose from
                VmNetworkInterface networkInterface = new VmNetworkInterface();
                networkInterface.setName(AsyncDataProvider.getNewNicName(null));
                nics.add(networkInterface);
            }
            for (VmNetworkInterface nic : nics) {
                final VnicInstanceType vnicInstanceType = new VnicInstanceType(nic);
                vnicInstanceType.setItems(profiles);
                behavior.initSelectedProfile(vnicInstanceType, vnicInstanceType.getNetworkInterface());
                vnicInstanceTypes.add(vnicInstanceType);
            }
            getModel().getNicsWithLogicalNetworks().setItems(vnicInstanceTypes);
            getModel().getNicsWithLogicalNetworks().setSelectedItem(Linq.firstOrDefault(vnicInstanceTypes));
        }
    });
    behavior.initProfiles(hotUpdateSupported, getModel().getSelectedCluster().getId(), getModel().getSelectedDataCenter().getId(), query);
}
#method_after
protected void initNetworkInterfaces(final ProfileBehavior behavior, final List<VmNetworkInterface> argNics) {
    boolean hotUpdateSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.NetworkLinkingSupported, getModel().getSelectedCluster().getcompatibility_version().toString());
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VnicProfileView> profiles = (List<VnicProfileView>) returnValue;
            List<VnicInstanceType> vnicInstanceTypes = new ArrayList<VnicInstanceType>();
            List<VmNetworkInterface> nics = (argNics == null) ? new ArrayList<VmNetworkInterface>() : argNics;
            if (nics.isEmpty() && profilesExist(profiles)) {
                // create a default if none provided AND if there are profiles to choose from
                VmNetworkInterface networkInterface = new VmNetworkInterface();
                networkInterface.setName(AsyncDataProvider.getNewNicName(null));
                nics.add(networkInterface);
            }
            for (VmNetworkInterface nic : nics) {
                final VnicInstanceType vnicInstanceType = new VnicInstanceType(nic);
                vnicInstanceType.setItems(profiles);
                behavior.initSelectedProfile(vnicInstanceType, vnicInstanceType.getNetworkInterface());
                vnicInstanceTypes.add(vnicInstanceType);
            }
            getModel().getNicsWithLogicalNetworks().setItems(vnicInstanceTypes);
            getModel().getNicsWithLogicalNetworks().setSelectedItem(Linq.firstOrDefault(vnicInstanceTypes));
        }
    });
    behavior.initProfiles(hotUpdateSupported, getModel().getSelectedCluster().getId(), getModel().getSelectedDataCenter().getId(), query);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getDiskImage() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    try {
        if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
            return false;
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDAO().getVmsListForDisk(getDiskImage().getId())) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getDiskImage() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDAO().getVmsListForDisk(getDiskImage().getId())) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    return true;
}
#end_block

#method_before
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            ResourceBundle messagesBundle = theme.getMessagesBundle(locale);
            for (String key : messagesBundle.keySet()) {
                if (key.startsWith(BRAND_PREFIX + "." + prefix) || key.startsWith(COMMON_PREFIX)) {
                    // $NON-NLS-1$
                    // We can potentially override existing values here
                    // but this is fine as the themes are sorted in order
                    // And later messages should override earlier ones.
                    keyValues.put(key.replaceFirst(// $NON-NLS-1$
                    BRAND_PREFIX + "\\." + prefix + "\\.", // $NON-NLS-1$
                    "").replaceFirst(COMMON_PREFIX + "\\.", // $NON-NLS-1$
                    ""), messagesBundle.getString(key));
                }
            }
        }
    }
    return keyValues;
}
#method_after
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            List<ResourceBundle> bundles = theme.getMessagesBundle(locale);
            for (ResourceBundle bundle : bundles) {
                getKeyValuesFromResourceBundle(prefix, keyValues, bundle);
            }
        }
    }
    return keyValues;
}
#end_block

#method_before
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    FileInputStream propertiesFile;
    try {
        propertiesFile = new FileInputStream(propertiesFileName);
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#method_after
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    try (FileInputStream propertiesFile = new FileInputStream(propertiesFileName)) {
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#end_block

#method_before
public ResourceBundle getMessagesBundle() {
    // Default to US Locale.
    return getMessagesBundle(LocaleFilter.DEFAULT_LOCALE);
}
#method_after
public List<ResourceBundle> getMessagesBundle() {
    // Default to US Locale.
    return getMessagesBundle(LocaleFilter.DEFAULT_LOCALE);
}
#end_block

#method_before
public ResourceBundle getMessagesBundle(final Locale locale) {
    ResourceBundle result = null;
    try {
        File themeDirectory = new File(filePath);
        URLClassLoader urlLoader = new URLClassLoader(new URL[] { themeDirectory.toURI().toURL() });
        final String messageFileName = brandingProperties.getProperty(MESSAGES_KEY);
        String bundleName = messageFileName.lastIndexOf(PROPERTIES_FILE_SUFFIX) != -1 ? messageFileName.substring(0, messageFileName.lastIndexOf(PROPERTIES_FILE_SUFFIX)) : messageFileName;
        result = ResourceBundle.getBundle(bundleName, locale, urlLoader);
    } catch (IOException e) {
        // Unable to load messages resource bundle.
        log.warn(// $NON-NLS-1$
        "Unable to read message resource " + "bundle, returning null", // $NON-NLS-1$
        e);
    }
    return result;
}
#method_after
public List<ResourceBundle> getMessagesBundle(final Locale locale) {
    return getBundle(MESSAGES_KEY, locale);
}
#end_block

#method_before
@Test
public void testGetBrandingThemes() {
    List<BrandingTheme> result = testManager.getBrandingThemes();
    // $NON-NLS-1$
    assertNotNull("There should be a result", result);
    // $NON-NLS-1$
    assertEquals("There should be three active themes", 3, result.size());
    List<BrandingTheme> result2 = testManager.getBrandingThemes();
    // $NON-NLS-1$
    assertNotNull("There should be a result", result2);
    // $NON-NLS-1$
    assertEquals("There should be three active themes", 3, result2.size());
    // The second result should be the exact same object as the first one.
    // $NON-NLS-1$
    assertTrue("The result are not the same object", result == result2);
}
#method_after
@Test
public void testGetBrandingThemes() {
    List<BrandingTheme> result = testManager.getBrandingThemes();
    // $NON-NLS-1$
    assertNotNull("There should be a result", result);
    // $NON-NLS-1$
    assertEquals("There should be five active themes", 5, result.size());
    List<BrandingTheme> result2 = testManager.getBrandingThemes();
    // $NON-NLS-1$
    assertNotNull("There should be a result", result2);
    // $NON-NLS-1$
    assertEquals("There should be five active themes", 5, result2.size());
    // The second result should be the exact same object as the first one.
    // $NON-NLS-1$
    assertTrue("The result are not the same object", result == result2);
}
#end_block

#method_before
@Override
protected boolean acquireLockInternal() {
    final boolean acquireLock = super.acquireLockInternal();
    if (!acquireLock && getVm().isAutoStartup()) {
        AutoStartVmsRunner.getInstance().addVmToRun(getParameters().getVmId());
    }
    return acquireLock;
}
#method_after
@Override
protected boolean acquireLockInternal() {
    final boolean acquireLock = super.acquireLockInternal();
    if (!acquireLock && getVm() != null && getVm().isAutoStartup()) {
        AutoStartVmsRunner.getInstance().addVmToRun(getParameters().getVmId());
    }
    return acquireLock;
}
#end_block

#method_before
public GlusterTaskStatus getStatus() {
    return status;
}
#method_after
public JobExecutionStatus getStatus() {
    return status;
}
#end_block

#method_before
public void setStatus(GlusterTaskStatus status) {
    this.status = status;
}
#method_after
public void setStatus(JobExecutionStatus status) {
    this.status = status;
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowOptimize = false;
    } else {
        allowStart = true;
        allowStop = true;
        allowRemove = true;
        allowStartRebalance = true;
        allowOptimize = true;
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
        }
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowOptimize = false;
    } else {
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
        }
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
private void updateActionAvailability() {
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        getRemoveVolumeCommand().setIsExecutionAllowed(false);
        getStopCommand().setIsExecutionAllowed(false);
        getStartCommand().setIsExecutionAllowed(false);
        getRebalanceCommand().setIsExecutionAllowed(false);
        getOptimizeForVirtStoreCommand().setIsExecutionAllowed(false);
    } else {
        getRemoveVolumeCommand().setIsExecutionAllowed(true);
        getStopCommand().setIsExecutionAllowed(true);
        getStartCommand().setIsExecutionAllowed(true);
        getRebalanceCommand().setIsExecutionAllowed(true);
        getOptimizeForVirtStoreCommand().setIsExecutionAllowed(true);
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                getRemoveVolumeCommand().setIsExecutionAllowed(false);
                getStartCommand().setIsExecutionAllowed(false);
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                getStopCommand().setIsExecutionAllowed(false);
                getRebalanceCommand().setIsExecutionAllowed(false);
            }
        }
    }
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getCreateVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowOptimize = false;
    } else {
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            allowStartRebalance = allowStartRebalance && (volume.getAsyncTask() == null || Guid.isNullOrEmpty(volume.getAsyncTask().getTaskId()));
        }
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getCreateVolumeCommand())) {
        createVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getRebalanceCommand())) {
        rebalance();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> transportColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            StringBuilder transportTypes = new StringBuilder();
            Iterator<TransportType> iterator = object.getTransportTypes().iterator();
            while (iterator.hasNext()) {
                TransportType transportType = iterator.next();
                if (transportTypeTranslator.containsKey(transportType)) {
                    transportTypes.append(transportTypeTranslator.get(transportType));
                } else {
                    transportTypes.append(transportType.toString());
                }
                if (iterator.hasNext()) {
                    // $NON-NLS-1$
                    transportTypes.append(", ");
                }
            }
            return transportTypes.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(transportColumn, constants.transportTypesVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> statusColumn = new EnumColumn<GlusterVolumeEntity, GlusterStatus>() {

        @Override
        protected GlusterStatus getRawValue(GlusterVolumeEntity object) {
            return object.getStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVolume(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.createVolumeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> rebalanceSubctions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    rebalanceSubctions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebalanceCommand();
        }
    });
    /*
        rebalanceSubctions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopRebalance()) {
            @Override
            protected UICommand resolveCommand() {
                //return getMainModel().getRebalanceStopCommand();
                return null;
            }
        });
        rebalanceSubctions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.statusRebalance()) {
            @Override
            protected UICommand resolveCommand() {
                return null;
            }
        });
        */
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume(), rebalanceSubctions, CommandLocation.OnlyFromToolBar));
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> transportColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            StringBuilder transportTypes = new StringBuilder();
            Iterator<TransportType> iterator = object.getTransportTypes().iterator();
            while (iterator.hasNext()) {
                TransportType transportType = iterator.next();
                if (transportTypeTranslator.containsKey(transportType)) {
                    transportTypes.append(transportTypeTranslator.get(transportType));
                } else {
                    transportTypes.append(transportType.toString());
                }
                if (iterator.hasNext()) {
                    // $NON-NLS-1$
                    transportTypes.append(", ");
                }
            }
            return transportTypes.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(transportColumn, constants.transportTypesVolume(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> rebalanceSubActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume(), rebalanceSubActions, CommandLocation.ContextAndToolBar));
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setBricks(dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId()));
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setBricks(dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId()));
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setAsyncTask(getAsyncTaskOfVolume(volume.getId()));
    }
}
#end_block

#method_before
@Override
public GlusterVolumeEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterVolumeEntity entity = new GlusterVolumeEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setName(rs.getString("vol_name"));
    entity.setVolumeType(GlusterVolumeType.valueOf(rs.getString("vol_type")));
    entity.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    entity.setReplicaCount(rs.getInt("replica_count"));
    entity.setStripeCount(rs.getInt("stripe_count"));
    entity.setTaskId(getGuidDefaultEmpty(rs, "task_id"));
    return entity;
}
#method_after
@Override
public GlusterVolumeEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterVolumeEntity entity = new GlusterVolumeEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setName(rs.getString("vol_name"));
    entity.setVolumeType(GlusterVolumeType.valueOf(rs.getString("vol_type")));
    entity.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    entity.setReplicaCount(rs.getInt("replica_count"));
    entity.setStripeCount(rs.getInt("stripe_count"));
    return entity;
}
#end_block

#method_before
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("task_id", volume.getTaskId()));
}
#method_after
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()));
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REBALANCE_START);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REBALANCE_START);
    super.setActionMessageParameters();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (!glusterVolume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
        return false;
    }
    if ((glusterVolume.getVolumeType() == GlusterVolumeType.REPLICATE && glusterVolume.getBricks().size() <= glusterVolume.getReplicaCount()) || (glusterVolume.getVolumeType() == GlusterVolumeType.STRIPE && glusterVolume.getBricks().size() <= glusterVolume.getStripeCount()) || (glusterVolume.getBricks().size() == 1)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_BRICKS_ARE_NOT_DISTRIBUTED);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (!glusterVolume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
        return false;
    }
    if (!glusterVolume.getVolumeType().isDistributedType() || (glusterVolume.getBricks().size() == 1)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_BRICKS_ARE_NOT_DISTRIBUTED);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    // VDSM does not support task return yet
    glusterTaskReturn = getBroker().glusterVolumeRebalanceStart(getParameters().getVolumeName(), getParameters().isFixLayoutOnly(), getParameters().isForceAction());
    task = glusterTaskReturn.getGlusterTask();
    // TODO : REMOVE TEMPORARY HACK
    // task = new GlusterAsyncTask();
    // task.setTaskId(Guid.NewGuid());
    setReturnValue(task);
    ProceedProxyReturnValue();
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    glusterTaskReturn = getBroker().glusterVolumeRebalanceStart(getParameters().getVolumeName(), getParameters().isFixLayoutOnly(), getParameters().isForceAction());
    task = glusterTaskReturn.getGlusterTask();
    proceedProxyReturnValue();
    setReturnValue(task);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeTemplatesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_template");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToDeleteTemplatesMsg());
    ArrayList<String> items = new ArrayList<String>();
    ArrayList<VmTemplate> templates = Linq.<VmTemplate>cast(getSelectedItems());
    for (VmTemplate template : templates) {
        if (!template.getId().equals(Guid.Empty)) {
            items.add(template.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeTemplatesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_template");
    ArrayList<String> items = new ArrayList<String>();
    ArrayList<VmTemplate> templates = Linq.<VmTemplate>cast(getSelectedItems());
    for (VmTemplate template : templates) {
        if (!template.getId().equals(Guid.Empty)) {
            items.add(template.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public void edit(MoveHost object) {
    if (!object.isMultiSelection()) {
        table.setSelectionModel(new SingleSelectionModel<EntityModel>());
        table.setSelectionChangeHandler();
    }
    driver.edit(object);
    table.asEditor().edit(object);
}
#method_after
@Override
public void edit(MoveHost object) {
    if (!object.isMultiSelection()) {
        table.setSelectionModel(new SingleSelectionModel<EntityModel>());
        table.addSelectionChangeHandler();
    }
    driver.edit(object);
    table.asEditor().edit(object);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public EventResult submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            return task.get();
        } catch (CancellationException e) {
            log.infoFormat("Failed to submit event using submitEventSync (the event was cancelled)- pool {0} , exception {1}", event.getStoragePoolId(), e);
        } catch (Exception e) {
            log.errorFormat("Failed at submitEventSync, for pool {0} with exception {1}", event.getStoragePoolId(), e);
        }
    }
    return null;
}
#method_after
@Override
public EventResult submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            return task.get();
        } catch (CancellationException e) {
            // CancellationException is normal here, as we cancel future tasks when reconstruct is running
            // This cancellation is also being reported to the log
            // Currently ignoring that exception, writing a debug message, in case other scenario of canceling an exception will be introduced
            log.debugFormat("Failed to submit event using submitEventSync (the event was cancelled)- pool {0} , exception {1}", event.getStoragePoolId(), e);
        } catch (Exception e) {
            log.errorFormat("Failed at submitEventSync, for pool {0} with exception {1}", event.getStoragePoolId(), e);
        }
    }
    return null;
}
#end_block

#method_before
private FutureTask<EventResult> submitTaskInternal(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = null;
    Guid storagePoolId = event.getStoragePoolId();
    ReentrantLock lock = getPoolLock(storagePoolId);
    lock.lock();
    try {
        Event currentEvent = poolCurrentEventMap.get(storagePoolId);
        if (currentEvent != null) {
            switch(currentEvent.getEventType()) {
                case RECOVERY:
                    if (event.getEventType() == EventType.VDSCONNECTTOPOOL || event.getEventType() == EventType.VDSCLEARCACHE || event.getEventType() == EventType.DOMAINFAILOVER) {
                        task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    } else {
                        log.debugFormat("Current event was skiped because of recovery is running now for pool {0}, event {1}", storagePoolId, event);
                    }
                    break;
                case RECONSTRUCT:
                    if (event.getEventType() == EventType.VDSCONNECTTOPOOL || event.getEventType() == EventType.RECOVERY || event.getEventType() == EventType.DOMAINFAILOVER || event.getEventType() == EventType.VDSCLEARCACHE) {
                        task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    } else {
                        log.debugFormat("Current event was skiped because of reconstruct is running now for pool {0}, event {1}", storagePoolId, event);
                    }
                    break;
                default:
                    task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    break;
            }
        } else {
            task = addTaskToQueue(event, callable, storagePoolId, false);
            poolCurrentEventMap.put(storagePoolId, event);
            ThreadPoolUtil.execute(new InternalEventQueueThread(storagePoolId, lock, poolsEventsMap, poolCurrentEventMap));
        }
    } finally {
        lock.unlock();
    }
    return task;
}
#method_after
private FutureTask<EventResult> submitTaskInternal(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = null;
    Guid storagePoolId = event.getStoragePoolId();
    ReentrantLock lock = getPoolLock(storagePoolId);
    lock.lock();
    try {
        Event currentEvent = poolCurrentEventMap.get(storagePoolId);
        if (currentEvent != null) {
            switch(currentEvent.getEventType()) {
                case RECOVERY:
                    if (event.getEventType() == EventType.VDSCONNECTTOPOOL || event.getEventType() == EventType.VDSCLEARCACHE || event.getEventType() == EventType.DOMAINFAILOVER) {
                        task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    } else {
                        log.debugFormat("Current event was skipped because of recovery is running now for pool {0}, event {1}", storagePoolId, event);
                    }
                    break;
                case RECONSTRUCT:
                    if (event.getEventType() == EventType.VDSCONNECTTOPOOL || event.getEventType() == EventType.RECOVERY || event.getEventType() == EventType.DOMAINFAILOVER || event.getEventType() == EventType.VDSCLEARCACHE) {
                        task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    } else {
                        log.debugFormat("Current event was skipped because of reconstruct is running now for pool {0}, event {1}", storagePoolId, event);
                    }
                    break;
                default:
                    task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    break;
            }
        } else {
            task = addTaskToQueue(event, callable, storagePoolId, false);
            poolCurrentEventMap.put(storagePoolId, event);
            ThreadPoolUtil.execute(new InternalEventQueueThread(storagePoolId, lock, poolsEventsMap, poolCurrentEventMap));
        }
    } finally {
        lock.unlock();
    }
    return task;
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        Pair<Event, FutureTask<EventResult>> pair;
        lock.lock();
        try {
            pair = poolsEventsMap.get(storagePoolId).poll();
            if (pair != null) {
                poolCurrentEventMap.put(storagePoolId, pair.getFirst());
            } else {
                poolCurrentEventMap.remove(storagePoolId);
                poolsEventsMap.remove(storagePoolId);
                log.debugFormat("All task for event query were executed pool {0}", storagePoolId);
                break;
            }
        } finally {
            lock.unlock();
        }
        Future<EventResult> futureResult = ThreadPoolUtil.execute(pair.getSecond());
        try {
            if (futureResult.get() == null) {
                EventResult result = pair.getSecond().get();
                if (result != null && result.getEventType() == EventType.RECONSTRUCT) {
                    log.infoFormat("Finished reconstruct for pool {0}. Clearing event queue", storagePoolId);
                    lock.lock();
                    try {
                        LinkedList<Pair<Event, FutureTask<EventResult>>> queue = new LinkedList<Pair<Event, FutureTask<EventResult>>>();
                        for (Pair<Event, FutureTask<EventResult>> task : poolsEventsMap.get(storagePoolId)) {
                            EventType eventType = task.getFirst().getEventType();
                            if (eventType == EventType.VDSCONNECTTOPOOL || ((eventType == EventType.RECOVERY || eventType == EventType.DOMAINFAILOVER || eventType == EventType.VDSCLEARCACHE) && !result.isSuccess())) {
                                queue.add(task);
                            } else {
                                log.infoFormat("The following operation {0} was cancelled, because of recosntruct was run before", task.getFirst());
                                task.getSecond().cancel(true);
                            }
                        }
                        if (queue.isEmpty()) {
                            poolCurrentEventMap.remove(storagePoolId);
                            poolsEventsMap.remove(storagePoolId);
                            break;
                        } else {
                            poolsEventsMap.put(storagePoolId, queue);
                        }
                    } finally {
                        lock.unlock();
                    }
                }
            }
        } catch (Exception e) {
            log.errorFormat("Exception during process of events for pool {0}, error is {1}", storagePoolId, e.getMessage());
        }
    }
}
#method_after
@Override
public void run() {
    while (true) {
        Pair<Event, FutureTask<EventResult>> pair;
        lock.lock();
        try {
            pair = poolsEventsMap.get(storagePoolId).poll();
            if (pair != null) {
                poolCurrentEventMap.put(storagePoolId, pair.getFirst());
            } else {
                poolCurrentEventMap.remove(storagePoolId);
                poolsEventsMap.remove(storagePoolId);
                log.debugFormat("All task for event query were executed pool {0}", storagePoolId);
                break;
            }
        } finally {
            lock.unlock();
        }
        Future<EventResult> futureResult = ThreadPoolUtil.execute(pair.getSecond());
        try {
            if (futureResult.get() == null) {
                EventResult result = pair.getSecond().get();
                if (result != null && result.getEventType() == EventType.RECONSTRUCT) {
                    log.infoFormat("Finished reconstruct for pool {0}. Clearing event queue", storagePoolId);
                    lock.lock();
                    try {
                        LinkedList<Pair<Event, FutureTask<EventResult>>> queue = new LinkedList<Pair<Event, FutureTask<EventResult>>>();
                        for (Pair<Event, FutureTask<EventResult>> task : poolsEventsMap.get(storagePoolId)) {
                            EventType eventType = task.getFirst().getEventType();
                            if (eventType == EventType.VDSCONNECTTOPOOL || ((eventType == EventType.RECOVERY || eventType == EventType.DOMAINFAILOVER || eventType == EventType.VDSCLEARCACHE) && !result.isSuccess())) {
                                queue.add(task);
                            } else {
                                log.infoFormat("The following operation {0} was cancelled, because of reconstruct was run before", task.getFirst());
                                task.getSecond().cancel(true);
                            }
                        }
                        if (queue.isEmpty()) {
                            poolCurrentEventMap.remove(storagePoolId);
                            poolsEventsMap.remove(storagePoolId);
                            break;
                        } else {
                            poolsEventsMap.put(storagePoolId, queue);
                        }
                    } finally {
                        lock.unlock();
                    }
                }
            }
        } catch (Exception e) {
            log.errorFormat("Exception during process of events for pool {0}, error is {1}", storagePoolId, e.getMessage());
        }
    }
}
#end_block

#method_before
private void EndCommandAction() {
    CommandMultiAsyncTasks entityInfo = GetCommandMultiAsyncTasks();
    VdcReturnValueBase vdcReturnValue = null;
    ExecutionContext context = null;
    boolean endActionRuntimeException = false;
    AsyncTasks dbAsyncTask = getParameters().getDbAsyncTask();
    ArrayList<VdcActionParametersBase> imagesParameters = new ArrayList<VdcActionParametersBase>();
    for (EndedTaskInfo taskInfo : entityInfo.getEndedTasksInfo().getTasksInfo()) {
        VdcActionParametersBase childTaskParameters = taskInfo.getTaskParameters().getDbAsyncTask().getTaskParameters();
        boolean childTaskGroupSuccess = childTaskParameters.getTaskGroupSuccess() && taskInfo.getTaskStatus().getTaskEndedSuccessfully();
        childTaskParameters.setTaskGroupSuccess(childTaskGroupSuccess);
        if (!childTaskParameters.equals(dbAsyncTask.getActionParameters())) {
            imagesParameters.add(childTaskParameters);
        }
    }
    dbAsyncTask.getActionParameters().setImagesParameters(imagesParameters);
    try {
        log.infoFormat("CommandAsyncTask::EndCommandAction [within thread] context: Attempting to EndAction '{0}', executionIndex: '{1}'", dbAsyncTask.getActionParameters().getCommandType(), dbAsyncTask.getActionParameters().getExecutionIndex());
        try {
            /**
             * Creates context for the job which monitors the action
             */
            Guid stepId = dbAsyncTask.getStepId();
            if (stepId != null) {
                context = ExecutionHandler.createFinalizingContext(stepId);
            }
            vdcReturnValue = Backend.getInstance().endAction(getEndActionType(dbAsyncTask), dbAsyncTask.getActionParameters(), new CommandContext(context));
        } catch (VdcBLLException ex) {
            log.error(getErrorMessage());
            log.error(ex.toString());
            log.debug(ex);
        } catch (RuntimeException ex) {
            log.error(getErrorMessage(), ex);
            endActionRuntimeException = true;
        }
    } catch (RuntimeException Ex2) {
        log.error("CommandAsyncTask::EndCommandAction [within thread]: An exception has been thrown (not related to 'EndAction' itself)", Ex2);
        endActionRuntimeException = true;
    } finally {
        // if a RuntimeExcpetion occurs we clear the task from db and perform no other action
        if (endActionRuntimeException) {
            handleEndActionRuntimeException(entityInfo, dbAsyncTask);
            return;
        }
        boolean isTaskGroupSuccess = dbAsyncTask.getActionParameters().getTaskGroupSuccess();
        handleEndActionResult(entityInfo, vdcReturnValue, context, isTaskGroupSuccess);
    }
}
#method_after
private void EndCommandAction() {
    CommandMultiAsyncTasks entityInfo = GetCommandMultiAsyncTasks();
    VdcReturnValueBase vdcReturnValue = null;
    ExecutionContext context = null;
    boolean endActionRuntimeException = false;
    AsyncTasks dbAsyncTask = getParameters().getDbAsyncTask();
    ArrayList<VdcActionParametersBase> imagesParameters = new ArrayList<VdcActionParametersBase>();
    for (EndedTaskInfo taskInfo : entityInfo.getEndedTasksInfo().getTasksInfo()) {
        VdcActionParametersBase childTaskParameters = taskInfo.getTaskParameters().getDbAsyncTask().getTaskParameters();
        boolean childTaskGroupSuccess = childTaskParameters.getTaskGroupSuccess() && taskInfo.getTaskStatus().getTaskEndedSuccessfully();
        childTaskParameters.setTaskGroupSuccess(childTaskGroupSuccess);
        if (!childTaskParameters.equals(dbAsyncTask.getActionParameters())) {
            imagesParameters.add(childTaskParameters);
        }
    }
    dbAsyncTask.getActionParameters().setImagesParameters(imagesParameters);
    try {
        log.infoFormat("CommandAsyncTask::EndCommandAction [within thread] context: Attempting to EndAction '{0}', executionIndex: '{1}'", dbAsyncTask.getActionParameters().getCommandType(), dbAsyncTask.getActionParameters().getExecutionIndex());
        try {
            /**
             * Creates context for the job which monitors the action
             */
            Guid stepId = dbAsyncTask.getStepId();
            if (stepId != null) {
                context = ExecutionHandler.createFinalizingContext(stepId);
            }
            vdcReturnValue = Backend.getInstance().endAction(getEndActionType(dbAsyncTask), dbAsyncTask.getActionParameters(), new CommandContext(context));
        } catch (VdcBLLException ex) {
            log.error(getErrorMessage());
            log.error(ex.toString());
            log.debug(ex);
        } catch (RuntimeException ex) {
            log.error(getErrorMessage(), ex);
            endActionRuntimeException = true;
        }
    } catch (RuntimeException Ex2) {
        log.error("CommandAsyncTask::EndCommandAction [within thread]: An exception has been thrown (not related to 'EndAction' itself)", Ex2);
        endActionRuntimeException = true;
    } finally {
        // if a RuntimeExcpetion occurs we clear the task from db and perform no other action
        if (endActionRuntimeException) {
            handleEndActionRuntimeException(entityInfo, dbAsyncTask);
        } else {
            boolean isTaskGroupSuccess = dbAsyncTask.getActionParameters().getTaskGroupSuccess();
            handleEndActionResult(entityInfo, vdcReturnValue, context, isTaskGroupSuccess);
        }
    }
}
#end_block

#method_before
private void handleEndActionRuntimeException(CommandMultiAsyncTasks commandInfo, AsyncTasks dbAsyncTask) {
    try {
        VdcActionType actionType = getParameters().getDbAsyncTask().getaction_type();
        log.infoFormat("CommandAsyncTask::HandleEndActionResult: EndAction for action type '{0}' threw an unrecoverable RuntimeException the task will be cleared.", actionType);
        commandInfo.clearTaskWithRuntimeException(dbAsyncTask.getVdsmTaskId());
        RemoveTaskFromDB();
        if (commandInfo.getAllCleared()) {
            log.infoFormat("CommandAsyncTask::HandleEndActionRuntimeException: Removing CommandMultiAsyncTasks object for entity '{0}'", commandInfo.getCommandId());
            _multiTasksByCommandIds.remove(commandInfo.getCommandId());
        }
    } catch (RuntimeException ex) {
        log.error("CommandAsyncTask::HandleEndActionResult [within thread]: an exception has been thrown", ex);
    }
}
#method_after
private void handleEndActionRuntimeException(CommandMultiAsyncTasks commandInfo, AsyncTasks dbAsyncTask) {
    try {
        VdcActionType actionType = getParameters().getDbAsyncTask().getaction_type();
        log.infoFormat("CommandAsyncTask::HandleEndActionResult: EndAction for action type '{0}' threw an unrecoverable RuntimeException the task will be cleared.", actionType);
        commandInfo.clearTaskByVdsmTaskId(dbAsyncTask.getVdsmTaskId());
        RemoveTaskFromDB();
        if (commandInfo.getAllCleared()) {
            log.infoFormat("CommandAsyncTask::HandleEndActionRuntimeException: Removing CommandMultiAsyncTasks object for entity '{0}'", commandInfo.getCommandId());
            _multiTasksByCommandIds.remove(commandInfo.getCommandId());
        }
    } catch (RuntimeException ex) {
        log.error("CommandAsyncTask::HandleEndActionResult [within thread]: an exception has been thrown", ex);
    }
}
#end_block

#method_before
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    FileInputStream propertiesFile;
    try {
        propertiesFile = new FileInputStream(propertiesFileName);
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#method_after
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    try (FileInputStream propertiesFile = new FileInputStream(propertiesFileName)) {
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#end_block

#method_before
public ResourceBundle getMessagesBundle() {
    // Default to US Locale.
    return getMessagesBundle(LocaleFilter.DEFAULT_LOCALE);
}
#method_after
public List<ResourceBundle> getMessagesBundle() {
    // Default to US Locale.
    return getMessagesBundle(LocaleFilter.DEFAULT_LOCALE);
}
#end_block

#method_before
public ResourceBundle getMessagesBundle(final Locale locale) {
    return getBundle(MESSAGES_KEY, locale);
}
#method_after
public List<ResourceBundle> getMessagesBundle(final Locale locale) {
    return getBundle(MESSAGES_KEY, locale);
}
#end_block

#method_before
private ResourceBundle getBundle(String name, Locale locale) {
    ResourceBundle result = null;
    try {
        File themeDirectory = new File(filePath);
        URLClassLoader urlLoader = new URLClassLoader(new URL[] { themeDirectory.toURI().toURL() });
        final String messageFileName = brandingProperties.getProperty(name);
        if (messageFileName != null) {
            String bundleName = messageFileName.lastIndexOf(PROPERTIES_FILE_SUFFIX) != -1 ? messageFileName.substring(0, messageFileName.lastIndexOf(PROPERTIES_FILE_SUFFIX)) : messageFileName;
            result = ResourceBundle.getBundle(bundleName, locale, urlLoader);
        }
    } catch (IOException e) {
        // Unable to load messages resource bundle.
        log.warn(// $NON-NLS-1$
        "Unable to read resources resource " + "bundle, returning null", // $NON-NLS-1$
        e);
    }
    return result;
}
#method_after
private List<ResourceBundle> getBundle(String name, Locale locale) {
    List<ResourceBundle> result = new ArrayList<ResourceBundle>();
    try {
        File themeDirectory = new File(filePath);
        URLClassLoader urlLoader = new URLClassLoader(new URL[] { themeDirectory.toURI().toURL() });
        final String messageFileNames = brandingProperties.getProperty(name);
        if (messageFileNames != null) {
            // The values can be a comma separated list of file names, split them and load each of them.
            for (String fileName : messageFileNames.split(",")) {
                fileName = fileName.trim();
                String bundleName = fileName.lastIndexOf(PROPERTIES_FILE_SUFFIX) != -1 ? fileName.substring(0, fileName.lastIndexOf(PROPERTIES_FILE_SUFFIX)) : messageFileNames;
                result.add(ResourceBundle.getBundle(bundleName, locale, urlLoader));
            }
        }
    } catch (IOException e) {
        // Unable to load messages resource bundle.
        log.warn(// $NON-NLS-1$
        "Unable to read resources resource " + "bundle, returning null", // $NON-NLS-1$
        e);
    }
    return result;
}
#end_block

#method_before
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            ResourceBundle messagesBundle = theme.getMessagesBundle(locale);
            getKeyValuesFromResourceBundle(prefix, keyValues, messagesBundle);
            ResourceBundle resourcesBundle = theme.getResourceBundle();
            getKeyValuesFromResourceBundle(prefix, keyValues, resourcesBundle);
        }
    }
    return keyValues;
}
#method_after
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            List<ResourceBundle> bundles = theme.getMessagesBundle(locale);
            for (ResourceBundle bundle : bundles) {
                getKeyValuesFromResourceBundle(prefix, keyValues, bundle);
            }
        }
    }
    return keyValues;
}
#end_block

#method_before
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            ResourceBundle messagesBundle = theme.getMessagesBundle(locale);
            for (String key : messagesBundle.keySet()) {
                if (key.startsWith(BRAND_PREFIX + "." + prefix) || key.startsWith(COMMON_PREFIX)) {
                    // $NON-NLS-1$
                    // We can potentially override existing values here
                    // but this is fine as the themes are sorted in order
                    // And later messages should override earlier ones.
                    keyValues.put(key.replaceFirst(// $NON-NLS-1$
                    BRAND_PREFIX + "\\." + prefix + "\\.", // $NON-NLS-1$
                    "").replaceFirst(COMMON_PREFIX + "\\.", // $NON-NLS-1$
                    "").replaceFirst(BRAND_PREFIX + "\\.", // $NON-NLS-1$ //$NON-NLS-2$ //Blank prefix
                    ""), messagesBundle.getString(key));
                }
            }
        }
    }
    return keyValues;
}
#method_after
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            ResourceBundle messagesBundle = theme.getMessagesBundle(locale);
            for (String key : messagesBundle.keySet()) {
                if (key.startsWith(BRAND_PREFIX + "." + prefix) || key.startsWith(COMMON_PREFIX)) {
                    // $NON-NLS-1$
                    // We can potentially override existing values here
                    // but this is fine as the themes are sorted in order
                    // And later messages should override earlier ones.
                    keyValues.put(key.replaceFirst(// $NON-NLS-1$
                    BRAND_PREFIX + "\\." + prefix + "\\.", // $NON-NLS-1$
                    "").replaceFirst(COMMON_PREFIX + "\\.", // $NON-NLS-1$
                    ""), messagesBundle.getString(key));
                }
            }
        }
    }
    return keyValues;
}
#end_block

#method_before
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    FileInputStream propertiesFile = null;
    try {
        propertiesFile = new FileInputStream(propertiesFileName);
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    } finally {
        if (propertiesFile != null) {
            try {
                propertiesFile.close();
            } catch (IOException e) {
                // $NON-NLS-1$
                log.warn("Unable to close properties file");
            }
        }
    }
    return available;
}
#method_after
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    try (FileInputStream propertiesFile = new FileInputStream(propertiesFileName)) {
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#end_block

#method_before
void forceRefresh(M model) {
    if (model instanceof SearchableListModel) {
        UICommand lastExecutedCommand = model.getLastExecutedCommand();
        if (lastExecutedCommand != null && !lastExecutedCommand.getIsCancel()) {
            // Refresh the grid using ForceRefresh command
            SearchableListModel searchableList = (SearchableListModel) model;
            searchableList.getForceRefreshCommand().execute();
        }
    }
}
#method_after
void forceRefresh(M model) {
    if (model instanceof SearchableListModel) {
        UICommand lastExecutedCommand = model.getLastExecutedCommand();
        if (lastExecutedCommand != null && !lastExecutedCommand.getIsCancel()) {
            // Refresh grid after invoking non-cancel command
            SearchableListModel searchableList = (SearchableListModel) model;
            searchableList.forceRefresh();
        }
    }
}
#end_block

#method_before
public ArrayList<Guid> getTaskIdList() {
    return _taskIdList;
}
#method_after
public ArrayList<Guid> getTaskIdList() {
    return taskIdList;
}
#end_block

#method_before
public void setTaskIdList(ArrayList<Guid> value) {
    _taskIdList = value;
}
#method_after
public void setTaskIdList(ArrayList<Guid> value) {
    taskIdList = value;
}
#end_block

#method_before
public NGuid getJobId() {
    return jobId;
}
#method_after
public Guid getJobId() {
    return jobId;
}
#end_block

#method_before
public void setJobId(NGuid jobId) {
    this.jobId = jobId;
}
#method_after
public void setJobId(Guid jobId) {
    this.jobId = jobId;
}
#end_block

#method_before
public static void failTaskWithoutVdsmId(final AsyncTasks task) {
    task.getTaskParameters().setTaskGroupSuccess(false);
    ExecutionHandler.endTaskStep(task.getStepId(), JobExecutionStatus.FAILED);
    removeTaskFromDbByTaskId(task.getTaskId());
    if (task.getTaskType() == AsyncTaskType.unknown) {
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @SuppressWarnings("synthetic-access")
        @Override
        public void run() {
            NGuid stepId = task.getStepId();
            ExecutionContext context = null;
            if (stepId != null) {
                context = ExecutionHandler.createFinalizingContext(stepId.getValue());
            }
            Backend.getInstance().endAction(task.getaction_type(), task.getActionParameters(), new CommandContext(context));
        }
    });
}
#method_after
public static void failTaskWithoutVdsmId(final AsyncTasks task) {
    ThreadPoolUtil.execute(new Runnable() {

        @SuppressWarnings("synthetic-access")
        @Override
        public void run() {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    logAndFailTaskWithoutVdsmId(task);
                    return null;
                }
            });
        }
    });
}
#end_block

#method_before
protected static void removeTaskFromDbByTaskId(Guid taskId) {
    try {
        if (DbFacade.getInstance().getAsyncTaskDao().remove(taskId) != 0) {
            log.infoFormat("BaseAsyncTask::RemoveTaskFromDB: Removed task {0} from DataBase", taskId);
        }
    } catch (RuntimeException e) {
        log.error(String.format("AsyncTaskManager::RemoveTaskFromDB: Removing task %1$s from DataBase threw an exception.", taskId), e);
    }
}
#method_after
protected static void removeTaskFromDbByTaskId(Guid taskId) {
    try {
        if (DbFacade.getInstance().getAsyncTaskDao().remove(taskId) != 0) {
            log.infoFormat("Removed task {0} from DataBase", taskId);
        }
    } catch (RuntimeException e) {
        log.error(String.format("Removing task %1$s from DataBase threw an exception.", taskId), e);
    }
}
#end_block

#method_before
public void AddStoragePoolExistingTasks(StoragePool sp) {
    List<AsyncTaskCreationInfo> currPoolTasks = null;
    try {
        currPoolTasks = (ArrayList<AsyncTaskCreationInfo>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(sp.getId())).getReturnValue();
    } catch (RuntimeException e) {
        log.error(String.format("Getting existing tasks on Storage Pool %1$s failed.", sp.getname()), e);
    }
    if (currPoolTasks != null && currPoolTasks.size() > 0) {
        synchronized (this) {
            final List<SPMAsyncTask> newlyAddedTasks = new ArrayList<SPMAsyncTask>();
            for (AsyncTaskCreationInfo creationInfo : currPoolTasks) {
                creationInfo.setStoragePoolID(sp.getId());
                if (!_tasks.containsKey(creationInfo.getVdsmTaskId())) {
                    try {
                        SPMAsyncTask task = AsyncTaskFactory.Construct(creationInfo);
                        addTaskToManager(task);
                        newlyAddedTasks.add(task);
                    } catch (Exception e) {
                        log.errorFormat("Failed to load task of type {0} with id {1}, due to: {2}.", creationInfo.getTaskType(), creationInfo.getVdsmTaskId(), ExceptionUtils.getRootCauseMessage(e));
                    }
                }
            }
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    for (SPMAsyncTask task : newlyAddedTasks) {
                        AsyncTaskUtils.addOrUpdateTaskInDB(task);
                    }
                    return null;
                }
            });
            for (SPMAsyncTask task : newlyAddedTasks) {
                StartPollingTask(task.getVdsmTaskId());
            }
            log.infoFormat("Discovered {0} tasks on Storage Pool '{1}', {2} added to manager.", currPoolTasks.size(), sp.getname(), newlyAddedTasks.size());
        }
    } else {
        log.infoFormat("Discovered no tasks on Storage Pool {0}", sp.getname());
    }
    List<AsyncTasks> tasksInDForStoragePool = tasksInDbAfterRestart.get(sp.getId());
    if (tasksInDForStoragePool != null) {
        for (AsyncTasks task : tasksInDForStoragePool) {
            if (!_tasks.containsKey(task.getVdsmTaskId())) {
                DbFacade.getInstance().getAsyncTaskDao().removeByVdsmId(task.getVdsmTaskId());
            }
        }
    }
    // Either the tasks were only in DB - so they were removed from db, or they are polled -
    // in any case no need to hold them in the map that represents the tasksInDbAfterRestart
    tasksInDbAfterRestart.remove(sp.getId());
}
#method_after
public void AddStoragePoolExistingTasks(StoragePool sp) {
    List<AsyncTaskCreationInfo> currPoolTasks = null;
    try {
        currPoolTasks = (ArrayList<AsyncTaskCreationInfo>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(sp.getId())).getReturnValue();
    } catch (RuntimeException e) {
        log.error(String.format("Getting existing tasks on Storage Pool %1$s failed.", sp.getName()), e);
    }
    if (currPoolTasks != null && currPoolTasks.size() > 0) {
        synchronized (this) {
            final List<SPMAsyncTask> newlyAddedTasks = new ArrayList<SPMAsyncTask>();
            for (AsyncTaskCreationInfo creationInfo : currPoolTasks) {
                creationInfo.setStoragePoolID(sp.getId());
                if (!_tasks.containsKey(creationInfo.getVdsmTaskId())) {
                    try {
                        SPMAsyncTask task = AsyncTaskFactory.Construct(creationInfo);
                        addTaskToManager(task);
                        newlyAddedTasks.add(task);
                    } catch (Exception e) {
                        log.errorFormat("Failed to load task of type {0} with id {1}, due to: {2}.", creationInfo.getTaskType(), creationInfo.getVdsmTaskId(), ExceptionUtils.getRootCauseMessage(e));
                    }
                }
            }
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    for (SPMAsyncTask task : newlyAddedTasks) {
                        AsyncTaskUtils.addOrUpdateTaskInDB(task);
                    }
                    return null;
                }
            });
            for (SPMAsyncTask task : newlyAddedTasks) {
                StartPollingTask(task.getVdsmTaskId());
            }
            log.infoFormat("Discovered {0} tasks on Storage Pool '{1}', {2} added to manager.", currPoolTasks.size(), sp.getName(), newlyAddedTasks.size());
        }
    } else {
        log.infoFormat("Discovered no tasks on Storage Pool {0}", sp.getName());
    }
    List<AsyncTasks> tasksInDForStoragePool = tasksInDbAfterRestart.get(sp.getId());
    if (tasksInDForStoragePool != null) {
        for (AsyncTasks task : tasksInDForStoragePool) {
            if (!_tasks.containsKey(task.getVdsmTaskId())) {
                DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(task.getVdsmTaskId());
            }
        }
    }
    // Either the tasks were only in DB - so they were removed from db, or they are polled -
    // in any case no need to hold them in the map that represents the tasksInDbAfterRestart
    tasksInDbAfterRestart.remove(sp.getId());
}
#end_block

#method_before
public synchronized void StopStoragePoolTasks(final StoragePool sp) {
    log.infoFormat("Attempting to get and stop tasks on storage pool '{0}'", sp.getname());
    AddStoragePoolExistingTasks(sp);
    List<SPMAsyncTask> list = LinqUtils.filter(_tasks.values(), new Predicate<SPMAsyncTask>() {

        @Override
        public boolean eval(SPMAsyncTask a) {
            return a.getStoragePoolID().equals(sp.getId());
        }
    });
    for (SPMAsyncTask task : list) {
        task.stopTask();
    }
}
#method_after
public synchronized void StopStoragePoolTasks(final StoragePool sp) {
    log.infoFormat("Attempting to get and stop tasks on storage pool '{0}'", sp.getName());
    AddStoragePoolExistingTasks(sp);
    List<SPMAsyncTask> list = LinqUtils.filter(_tasks.values(), new Predicate<SPMAsyncTask>() {

        @Override
        public boolean eval(SPMAsyncTask a) {
            return a.getStoragePoolID().equals(sp.getId());
        }
    });
    for (SPMAsyncTask task : list) {
        task.stopTask();
    }
}
#end_block

#method_before
public synchronized void CancelTasks(List<Guid> taskList) {
    for (Guid taskID : taskList) {
        CancelTask(taskID);
    }
}
#method_after
public synchronized void CancelTasks(List<Guid> vdsmTaskList) {
    for (Guid vdsmTaskId : vdsmTaskList) {
        CancelTask(vdsmTaskId);
    }
}
#end_block

#method_before
public synchronized void CancelTask(Guid taskID) {
    if (_tasks.containsKey(taskID)) {
        log.infoFormat("Attempting to cancel task '{0}'.", taskID);
        _tasks.get(taskID).stopTask();
        _tasks.get(taskID).ConcreteStartPollingTask();
    }
}
#method_after
public synchronized void CancelTask(Guid vdsmTaskId) {
    if (_tasks.containsKey(vdsmTaskId)) {
        log.infoFormat("Attempting to cancel task '{0}'.", vdsmTaskId);
        _tasks.get(vdsmTaskId).stopTask();
        _tasks.get(vdsmTaskId).ConcreteStartPollingTask();
    }
}
#end_block

#method_before
public static VdcReturnValueBase instantiate(SerializationStreamReader streamReader) throws SerializationException {
    // occur first
    VdcReturnValueBase vrvb = new VdcReturnValueBase();
    vrvb.setCanDoAction(streamReader.readBoolean());
    java.util.ArrayList<String> canDoActionMessages = (java.util.ArrayList<String>) streamReader.readObject();
    vrvb.setCanDoActionMessages(canDoActionMessages);
    vrvb.setSucceeded(streamReader.readBoolean());
    vrvb.setIsSyncronious(streamReader.readBoolean());
    vrvb.setActionReturnValue(streamReader.readObject());
    vrvb.setDescription(streamReader.readString());
    java.util.ArrayList<Guid> asyncTaskIdList = (java.util.ArrayList<Guid>) streamReader.readObject();
    vrvb.setAsyncTaskIdList(asyncTaskIdList);
    java.util.ArrayList<Guid> taskIdList = (java.util.ArrayList<Guid>) streamReader.readObject();
    vrvb.setTaskIdList(taskIdList);
    vrvb.setEndActionTryAgain(streamReader.readBoolean());
    vrvb.setFault((VdcFault) streamReader.readObject());
    return vrvb;
}
#method_after
public static VdcReturnValueBase instantiate(SerializationStreamReader streamReader) throws SerializationException {
    // occur first
    VdcReturnValueBase vrvb = new VdcReturnValueBase();
    vrvb.setCanDoAction(streamReader.readBoolean());
    java.util.ArrayList<String> canDoActionMessages = (java.util.ArrayList<String>) streamReader.readObject();
    vrvb.setCanDoActionMessages(canDoActionMessages);
    vrvb.setSucceeded(streamReader.readBoolean());
    vrvb.setIsSyncronious(streamReader.readBoolean());
    vrvb.setActionReturnValue(streamReader.readObject());
    vrvb.setDescription(streamReader.readString());
    java.util.ArrayList<Guid> asyncTaskIdList = (java.util.ArrayList<Guid>) streamReader.readObject();
    vrvb.setTaskPlaceHolderIdList(asyncTaskIdList);
    java.util.ArrayList<Guid> taskIdList = (java.util.ArrayList<Guid>) streamReader.readObject();
    vrvb.setTaskIdList(taskIdList);
    vrvb.setEndActionTryAgain(streamReader.readBoolean());
    vrvb.setFault((VdcFault) streamReader.readObject());
    return vrvb;
}
#end_block

#method_before
public static void serialize(SerializationStreamWriter streamWriter, VdcReturnValueBase instance) throws SerializationException {
    streamWriter.writeBoolean(instance.getCanDoAction());
    streamWriter.writeObject(instance.getCanDoActionMessages());
    streamWriter.writeBoolean(instance.getSucceeded());
    streamWriter.writeBoolean(instance.getIsSyncronious());
    streamWriter.writeObject(instance.getActionReturnValue());
    streamWriter.writeString(instance.getDescription());
    streamWriter.writeObject(instance.getAsyncTaskIdList());
    streamWriter.writeObject(instance.getTaskIdList());
    streamWriter.writeBoolean(instance.getEndActionTryAgain());
    streamWriter.writeObject(instance.getFault());
}
#method_after
public static void serialize(SerializationStreamWriter streamWriter, VdcReturnValueBase instance) throws SerializationException {
    streamWriter.writeBoolean(instance.getCanDoAction());
    streamWriter.writeObject(instance.getCanDoActionMessages());
    streamWriter.writeBoolean(instance.getSucceeded());
    streamWriter.writeBoolean(instance.getIsSyncronious());
    streamWriter.writeObject(instance.getActionReturnValue());
    streamWriter.writeString(instance.getDescription());
    streamWriter.writeObject(instance.getTaskPlaceHolderIdList());
    streamWriter.writeObject(instance.getTaskIdList());
    streamWriter.writeBoolean(instance.getEndActionTryAgain());
    streamWriter.writeObject(instance.getFault());
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    for (Guid asyncTaskId : getReturnValue().getAsyncTaskIdList()) {
        AsyncTasks task = DbFacade.getInstance().getAsyncTaskDao().get(asyncTaskId);
        if (task.getTaskId().equals(NGuid.Empty)) {
            AsyncTaskManager.failTaskWithoutVdsmId(task);
        }
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
        AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
        if (Guid.isNullOrEmpty(task.getVdsmTaskId())) {
            AsyncTaskManager.failTaskWithoutVdsmId(task);
        }
    }
}
#end_block

#method_before
protected void compensate() {
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().compensate();
        revertPreviousHandlers();
    } else {
        internalCompensate();
    }
}
#method_after
protected void compensate() {
    if (hasTaskHandlers()) {
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        revertPreviousHandlers();
    } else {
        internalCompensate();
    }
}
#end_block

#method_before
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endWithFailure();
        revertPreviousHandlers();
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#method_after
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        if (hasStepsToRevert()) {
            getCurrentTaskHandler().endWithFailure();
            revertPreviousHandlers();
        }
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#end_block

#method_before
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        logRollbackedTask();
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#method_after
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (hasStepsToRevert()) {
        logRollbackedTask();
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    } else {
        setSucceeded(true);
    }
}
#end_block

#method_before
protected boolean checkUserAuthorization(Guid userId, final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final NGuid permId = getDbFacade().getEntityPermissions(userId, actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAuthorization(Guid userId, final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final Guid permId = getDbFacade().getEntityPermissions(userId, actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final NGuid permId = getDbFacade().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getDbFacade().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append("Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, VdcObjectType entityType, Guid... entityIds) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        Step taskStep = ExecutionHandler.addTaskStep(getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        SPMAsyncTask task = concreteCreateTask(taskId, asyncTaskCreationInfo, parentCommand);
        retValue = task.getVdsmTaskId();
        task.setEntityType(entityType);
        task.setAssociatedEntities(entityIds);
        AsyncTaskUtils.addOrUpdateTaskInDB(task);
        getAsyncTaskManager().lockAndAddTaskToManager(task);
        retValue = task.getVdsmTaskId();
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#method_after
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, VdcObjectType entityType, Guid... entityIds) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(taskId, asyncTaskCreationInfo, parentCommand, description, entityType, entityIds);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#end_block

#method_before
private AsyncTasks getAsyncTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTasks asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
    }
    if (asyncTask != null) {
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
    } else {
        asyncTask = createAsyncTask(asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#method_after
private AsyncTasks getAsyncTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTasks asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
    }
    if (asyncTask != null) {
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setActionParameters(getParentParameters(parentCommand));
        asyncTask.setTaskParameters(getParameters());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
    } else {
        asyncTask = createAsyncTask(asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#end_block

#method_before
private AsyncTasks createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParametersForTask(parentCommand, getParameters());
    if (parentParameters.getParametersCurrentUser() == null && getCurrentUser() != null) {
        parentParameters.setParametersCurrentUser(getCurrentUser());
    }
    return new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), parentParameters, getParameters(), asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType());
}
#method_after
private AsyncTasks createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), getParentParameters(parentCommand), getParameters(), asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType());
}
#end_block

#method_before
protected boolean acquireLock() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        isReleaseExecute = annotation.isReleaseAtEndOfExecute();
        if (!annotation.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#method_after
protected boolean acquireLock() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        releaseLocksAtEndOfExecute = annotation.isReleaseAtEndOfExecute();
        if (!annotation.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#end_block

#method_before
public final boolean acquireLockAsyncTask() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        isReleaseExecute = annotation.isReleaseAtEndOfExecute();
        if (!isReleaseExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#method_after
public final boolean acquireLockAsyncTask() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        releaseLocksAtEndOfExecute = annotation.isReleaseAtEndOfExecute();
        if (!releaseLocksAtEndOfExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#end_block

#method_before
private void freeLockExecute() {
    if (isReleaseExecute || !getSucceeded()) {
        freeLock();
    }
}
#method_after
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || !hasTasks()) {
        freeLock();
    }
}
#end_block

#method_before
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        if (oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType() || (entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors()) || oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci()) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(oldVmBase, entity, params.isBalloonEnabled());
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
    }
}
#method_after
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(oldVmBase, entity, params.isBalloonEnabled());
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
    }
}
#end_block

#method_before
@Override
public void setEntity(Object value) {
    if (allKeyValueMap == null) {
        saveEntity = value;
        return;
    }
    List<KeyValueLineModel> list = new ArrayList<KeyValueLineModel>();
    KeyValueLineModel lineModel;
    if (value != null) {
        String split = (String) value;
        if (split.isEmpty()) {
            return;
        }
        String[] lines = split.split(PROPERTIES_DELIMETER);
        keyValueMap_used = new HashMap<String, String>();
        String[] splitLine;
        for (String line : lines) {
            if (line.isEmpty()) {
                continue;
            }
            splitLine = line.split(KEY_VALUE_DELIMETER, 2);
            String key = splitLine[0];
            if (allKeyValueMap.containsKey(key)) {
                keyValueMap_used.put(key, splitLine[1]);
            }
        }
        for (Map.Entry<String, String> stringStringEntry : keyValueMap_used.entrySet()) {
            lineModel = new KeyValueLineModel(this);
            lineModel.getKeys().setItems(getAvailbleKeys(stringStringEntry.getKey()));
            lineModel.getKeys().setSelectedItem(stringStringEntry.getKey());
            if (allRegExKeys.containsKey(stringStringEntry.getKey())) {
                lineModel.getValue().setIsAvailable(false);
                lineModel.getValues().setIsAvailable(true);
                lineModel.getValues().setItems(allRegExKeys.get(stringStringEntry.getKey()));
                lineModel.getValues().setSelectedItem(stringStringEntry.getValue());
            } else {
                lineModel.getValue().setEntity(stringStringEntry.getValue());
            }
            list.add(lineModel);
        }
    } else {
        lineModel = new KeyValueLineModel(this);
        lineModel.getKeys().setItems(getAvailbleKeys());
        list.add(lineModel);
    }
    for (final KeyValueLineModel keyValueLineModel : list) {
        keyValueLineModel.getKeys().getSelectedItemChangedEvent().addListener(keyChangedListener);
    }
    getKeyValueLines().setItems(list);
}
#method_after
@Override
public void setEntity(Object value) {
    if (allKeyValueMap == null) {
        saveEntity = value;
        return;
    }
    List<KeyValueLineModel> list = new ArrayList<KeyValueLineModel>();
    KeyValueLineModel lineModel;
    if (value != null) {
        String split = (String) value;
        if (split.isEmpty()) {
            return;
        }
        String[] lines = split.split(PROPERTIES_DELIMETER);
        keyValueMap_used = new HashMap<String, String>();
        String[] splitLine;
        for (String line : lines) {
            if (line.isEmpty()) {
                continue;
            }
            splitLine = line.split(KEY_VALUE_DELIMETER, 2);
            String key = splitLine[0];
            if (allKeyValueMap.containsKey(key)) {
                keyValueMap_used.put(key, splitLine[1]);
            }
        }
        for (Map.Entry<String, String> entry : keyValueMap_used.entrySet()) {
            lineModel = new KeyValueLineModel(this);
            lineModel.getKeys().setItems(getAvailbleKeys(entry.getKey()));
            lineModel.getKeys().setSelectedItem(entry.getKey());
            if (allRegExKeys.containsKey(entry.getKey())) {
                lineModel.getValue().setIsAvailable(false);
                lineModel.getValues().setIsAvailable(true);
                lineModel.getValues().setItems(allRegExKeys.get(entry.getKey()));
                lineModel.getValues().setSelectedItem(entry.getValue());
            } else {
                lineModel.getValue().setEntity(entry.getValue());
            }
            list.add(lineModel);
        }
    } else {
        lineModel = new KeyValueLineModel(this);
        lineModel.getKeys().setItems(getAvailbleKeys());
        list.add(lineModel);
    }
    for (final KeyValueLineModel keyValueLineModel : list) {
        keyValueLineModel.getKeys().getSelectedItemChangedEvent().addListener(keyChangedListener);
    }
    getKeyValueLines().setItems(list);
}
#end_block

#method_before
@Override
public String getPrefix(String namespaceURI) {
    for (Map.Entry<String, String> stringStringEntry : prefixToUri.entrySet()) {
        if (stringStringEntry.getValue().equals(namespaceURI))
            return stringStringEntry.getKey();
    }
    return null;
}
#method_after
@Override
public String getPrefix(String namespaceURI) {
    for (Map.Entry<String, String> prexiToUriEntry : prefixToUri.entrySet()) {
        if (prexiToUriEntry.getValue().equals(namespaceURI)) {
            return prexiToUriEntry.getKey();
        }
    }
    return null;
}
#end_block

#method_before
@Override
public Iterator getPrefixes(String namespaceURI) {
    List<String> prefixes = new LinkedList<String>();
    for (Map.Entry<String, String> stringStringEntry : prefixToUri.entrySet()) {
        if (stringStringEntry.getValue().equals(namespaceURI))
            prefixes.add(stringStringEntry.getKey());
    }
    return prefixes.iterator();
}
#method_after
@Override
public Iterator getPrefixes(String namespaceURI) {
    List<String> prefixes = new LinkedList<String>();
    for (Map.Entry<String, String> prefixToUriEntry : prefixToUri.entrySet()) {
        if (prefixToUriEntry.getValue().equals(namespaceURI)) {
            prefixes.add(prefixToUriEntry.getKey());
        }
    }
    return prefixes.iterator();
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    buildVmData();
    mVmReturn = getBroker().create(createInfo);
    logCommandInfo();
    ProceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm);
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    buildVmData();
    mVmReturn = getBroker().create(createInfo);
    logCommandInfo();
    proceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm);
}
#end_block

#method_before
private void logCommandInfo() {
    final char EQUAL = '=';
    final String SEP = ",";
    StringBuilder info = new StringBuilder();
    String sep = "";
    for (Map.Entry<String, Object> stringObjectEntry : createInfo.entrySet()) {
        info.append(sep);
        info.append(stringObjectEntry.getKey());
        info.append(EQUAL);
        info.append(stringObjectEntry.getValue());
        sep = SEP;
    }
    log.infoFormat("{0} {1}", getClass().getName(), info.toString());
}
#method_after
private void logCommandInfo() {
    final char EQUAL = '=';
    final String SEP = ",";
    StringBuilder info = new StringBuilder();
    String sep = "";
    for (Map.Entry<String, Object> createInfoEntry : createInfo.entrySet()) {
        info.append(sep);
        info.append(createInfoEntry.getKey());
        info.append(EQUAL);
        info.append(createInfoEntry.getValue());
        sep = SEP;
    }
    log.infoFormat("{0} {1}", getClass().getName(), info.toString());
}
#end_block

#method_before
private void verifyCorrectOvfDataUpdaterRun(Guid storagePoolId, Collection<Guid> needToBeUpdated, Collection<Guid> removedGuids) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> storagePoolMetadataUpdatedMap = executedUpdatedMetadataForStoragePool.get(storagePoolId);
    Map<Guid, Long> storagePoolUpdateOvfGenerationsInDb = executedUpdatedOvfGenerationIdsInDb.get(storagePoolId);
    assertTrue("not all needed vms/templates were updated in vdsm", CollectionUtils.isEqualCollection(storagePoolMetadataUpdatedMap.keySet(), needToBeUpdated));
    assertTrue("not all needed vms/templates were updated in db", CollectionUtils.isEqualCollection(storagePoolUpdateOvfGenerationsInDb.keySet(), needToBeUpdated));
    for (Map.Entry<Guid, KeyValuePairCompat<String, List<Guid>>> entry : storagePoolMetadataUpdatedMap.entrySet()) {
        assertEquals("wrong ovf data stored in storage for vm/template", entry.getKey().toString(), entry.getValue().getKey());
    }
    for (Map.Entry<Guid, Long> guidLongEntry : storagePoolUpdateOvfGenerationsInDb.entrySet()) {
        boolean isCorrectVersion = false;
        if (vms.get(guidLongEntry.getKey()) != null) {
            isCorrectVersion = guidLongEntry.getValue().equals(vms.get(guidLongEntry.getKey()).getDbGeneration());
        } else if (templates.get(guidLongEntry.getKey()) != null) {
            isCorrectVersion = guidLongEntry.getValue().equals(templates.get(guidLongEntry.getKey()).getDbGeneration());
        }
        assertTrue("wrong new ovf version persisted for vm/template", isCorrectVersion);
    }
    assertTrue("not all needed vms/templates were removed from vdsm", CollectionUtils.isEqualCollection(removedGuids, executedRemovedIds.get(storagePoolId)));
}
#method_after
private void verifyCorrectOvfDataUpdaterRun(Guid storagePoolId, Collection<Guid> needToBeUpdated, Collection<Guid> removedGuids) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> storagePoolMetadataUpdatedMap = executedUpdatedMetadataForStoragePool.get(storagePoolId);
    Map<Guid, Long> storagePoolUpdateOvfGenerationsInDb = executedUpdatedOvfGenerationIdsInDb.get(storagePoolId);
    assertTrue("not all needed vms/templates were updated in vdsm", CollectionUtils.isEqualCollection(storagePoolMetadataUpdatedMap.keySet(), needToBeUpdated));
    assertTrue("not all needed vms/templates were updated in db", CollectionUtils.isEqualCollection(storagePoolUpdateOvfGenerationsInDb.keySet(), needToBeUpdated));
    for (Map.Entry<Guid, KeyValuePairCompat<String, List<Guid>>> entry : storagePoolMetadataUpdatedMap.entrySet()) {
        assertEquals("wrong ovf data stored in storage for vm/template", entry.getKey().toString(), entry.getValue().getKey());
    }
    for (Map.Entry<Guid, Long> storagePoolGenerationEntry : storagePoolUpdateOvfGenerationsInDb.entrySet()) {
        boolean isCorrectVersion = false;
        if (vms.get(storagePoolGenerationEntry.getKey()) != null) {
            isCorrectVersion = storagePoolGenerationEntry.getValue().equals(vms.get(storagePoolGenerationEntry.getKey()).getDbGeneration());
        } else if (templates.get(storagePoolGenerationEntry.getKey()) != null) {
            isCorrectVersion = storagePoolGenerationEntry.getValue().equals(templates.get(storagePoolGenerationEntry.getKey()).getDbGeneration());
        }
        assertTrue("wrong new ovf version persisted for vm/template", isCorrectVersion);
    }
    assertTrue("not all needed vms/templates were removed from vdsm", CollectionUtils.isEqualCollection(removedGuids, executedRemovedIds.get(storagePoolId)));
}
#end_block

#method_before
void resolveChanges() {
    Set<Object> selectedKeys = selectedSet.keySet();
    List<Object> visibleKeys = new ArrayList<Object>();
    for (T visible : dataDisplay.getVisibleItems()) {
        visibleKeys.add(getKey(visible));
    }
    if (!visibleKeys.containsAll(selectedKeys)) {
        for (Map.Entry<Object, T> objectTEntry : selectedSet.entrySet()) {
            if (!visibleKeys.contains(objectTEntry.getKey()))
                selectionChanges.put(objectTEntry.getValue(), false);
        }
    }
    if (selectionChanges.isEmpty()) {
        return;
    }
    boolean changed = false;
    for (Map.Entry<T, Boolean> entry : selectionChanges.entrySet()) {
        T object = entry.getKey();
        boolean selected = entry.getValue();
        Object key = getKey(object);
        T oldValue = selectedSet.get(key);
        if (selected) {
            if (oldValue == null || !oldValue.equals(object)) {
                selectedSet.put(getKey(object), object);
                changed = true;
            }
        } else {
            if (oldValue != null) {
                selectedSet.remove(key);
                changed = true;
            }
        }
    }
    selectionChanges.clear();
    if (changed) {
        SelectionChangeEvent.fire(this);
    }
}
#method_after
void resolveChanges() {
    Set<Object> selectedKeys = selectedSet.keySet();
    List<Object> visibleKeys = new ArrayList<Object>();
    for (T visible : dataDisplay.getVisibleItems()) {
        visibleKeys.add(getKey(visible));
    }
    if (!visibleKeys.containsAll(selectedKeys)) {
        for (Map.Entry<Object, T> selectedEntry : selectedSet.entrySet()) {
            if (!visibleKeys.contains(selectedEntry.getKey())) {
                selectionChanges.put(selectedEntry.getValue(), false);
            }
        }
    }
    if (selectionChanges.isEmpty()) {
        return;
    }
    boolean changed = false;
    for (Map.Entry<T, Boolean> entry : selectionChanges.entrySet()) {
        T object = entry.getKey();
        boolean selected = entry.getValue();
        Object key = getKey(object);
        T oldValue = selectedSet.get(key);
        if (selected) {
            if (oldValue == null || !oldValue.equals(object)) {
                selectedSet.put(getKey(object), object);
                changed = true;
            }
        } else {
            if (oldValue != null) {
                selectedSet.remove(key);
                changed = true;
            }
        }
    }
    selectionChanges.clear();
    if (changed) {
        SelectionChangeEvent.fire(this);
    }
}
#end_block

#method_before
private boolean getItemOldState(Object userObject) {
    for (Map.Entry<Object, Boolean> objectBooleanEntry : oldItemStatesMap.entrySet()) {
        if (objectBooleanEntry.getKey() != null && userObject != null && objectBooleanEntry.getKey().equals(userObject)) {
            return objectBooleanEntry.getValue();
        }
    }
    return false;
}
#method_after
private boolean getItemOldState(Object userObject) {
    for (Map.Entry<Object, Boolean> oldItemStatesEntry : oldItemStatesMap.entrySet()) {
        if (oldItemStatesEntry.getKey() != null && userObject != null && oldItemStatesEntry.getKey().equals(userObject)) {
            return oldItemStatesEntry.getValue();
        }
    }
    return false;
}
#end_block

#method_before
public static void cancelTimer(String timerName) {
    for (Map.Entry<String, Timer> stringTimerEntry : timerList.entrySet()) {
        if (stringTimerEntry.getKey().equals(timerName)) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.fine("Cancelling the timer '" + stringTimerEntry.getKey() + "'");
            stringTimerEntry.getValue().cancel();
        }
    }
}
#method_after
public static void cancelTimer(String timerName) {
    for (Map.Entry<String, Timer> timerEntry : timerList.entrySet()) {
        if (timerEntry.getKey().equals(timerName)) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.fine("Cancelling the timer '" + timerEntry.getKey() + "'");
            timerEntry.getValue().cancel();
        }
    }
}
#end_block

#method_before
// we get "Afghanistan Standard Time" we return "175"
// the "Afghanistan Standard Time" is the vm Key that we get from the method getTimezoneKey()
public static String getTimezoneIndexByKey(String key) {
    for (Map.Entry<String, Integer> stringIntegerEntry : timeZoneIndex.entrySet()) {
        if (getTimezoneKey(stringIntegerEntry.getKey()).equals(key)) {
            return stringIntegerEntry.getValue().toString();
        }
    }
    log.errorFormat("getTimezoneIndexByKey: cannot find timezone key '{0}'", key);
    return key;
}
#method_after
// we get "Afghanistan Standard Time" we return "175"
// the "Afghanistan Standard Time" is the vm Key that we get from the method getTimezoneKey()
public static String getTimezoneIndexByKey(String key) {
    for (Map.Entry<String, Integer> timeZoneEntry : timeZoneIndex.entrySet()) {
        if (getTimezoneKey(timeZoneEntry.getKey()).equals(key)) {
            return timeZoneEntry.getValue().toString();
        }
    }
    log.errorFormat("getTimezoneIndexByKey: cannot find timezone key '{0}'", key);
    return key;
}
#end_block

#method_before
private void checkIfDefaultStorageApplicableForAllDisks() {
    boolean isDefaultStorageApplicableForAllDisks = true;
    StorageDomain defaultStorage = (StorageDomain) getStorage().getSelectedItem();
    for (Entry<Guid, ImportDiskData> guidImportDiskDataEntry : diskImportDataMap.entrySet()) {
        ImportDiskData importData = guidImportDiskDataEntry.getValue();
        if (defaultStorage != null && !importData.getStorageDomains().contains(defaultStorage)) {
            isDefaultStorageApplicableForAllDisks = false;
            break;
        } else {
            importData.setSelectedStorageDomain(defaultStorage);
        }
    }
    if ((getMessage() == null || getMessage().isEmpty()) && !isDefaultStorageApplicableForAllDisks) {
        setMessage(ConstantsManager.getInstance().getConstants().importNotApplicableForDefaultStorage());
    }
}
#method_after
private void checkIfDefaultStorageApplicableForAllDisks() {
    boolean isDefaultStorageApplicableForAllDisks = true;
    StorageDomain defaultStorage = (StorageDomain) getStorage().getSelectedItem();
    for (ImportDiskData importData : diskImportDataMap.values()) {
        if (defaultStorage != null && !importData.getStorageDomains().contains(defaultStorage)) {
            isDefaultStorageApplicableForAllDisks = false;
            break;
        } else {
            importData.setSelectedStorageDomain(defaultStorage);
        }
    }
    if ((getMessage() == null || getMessage().isEmpty()) && !isDefaultStorageApplicableForAllDisks) {
        setMessage(ConstantsManager.getInstance().getConstants().importNotApplicableForDefaultStorage());
    }
}
#end_block

#method_before
protected void getTemplatesFromExportDomain() {
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePool.getId(), ((StorageDomain) getEntity()).getId());
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, new AsyncQuery(ImportVmModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<VmTemplate, List<DiskImage>> dictionary = (HashMap<VmTemplate, List<DiskImage>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Map<Guid, Guid> tempMap = new HashMap<Guid, Guid>();
            for (Entry<VmTemplate, List<DiskImage>> entry : dictionary.entrySet()) {
                tempMap.put(entry.getKey().getId(), null);
            }
            for (Entry<Guid, List<Disk>> guidListEntry : missingTemplateDiskMap.entrySet()) {
                if (tempMap.containsKey(guidListEntry.getKey())) {
                    for (Disk disk : guidListEntry.getValue()) {
                        addDiskImportData(disk.getId(), filteredStorageDomains, ((DiskImage) disk).getVolumeType(), new EntityModel(true));
                    }
                } else {
                    showCloseMessage(ConstantsManager.getInstance().getConstants().errorTemplateCannotBeFoundMessage());
                    return;
                }
            }
            ImportVmModel.this.setMessage(ConstantsManager.getInstance().getConstants().importMissingStorages());
            for (ImportVmData vmData : (List<ImportVmData>) getItems()) {
                if (!Guid.Empty.equals(vmData.getVm().getVmtGuid()) && missingTemplateDiskMap.containsKey(vmData.getVm().getVmtGuid())) {
                    vmData.setTemplateExistsInSetup(false);
                }
            }
            postInitDisks();
        }
    }));
}
#method_after
protected void getTemplatesFromExportDomain() {
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePool.getId(), ((StorageDomain) getEntity()).getId());
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, new AsyncQuery(ImportVmModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<VmTemplate, List<DiskImage>> dictionary = (HashMap<VmTemplate, List<DiskImage>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Map<Guid, Guid> tempMap = new HashMap<Guid, Guid>();
            for (Entry<VmTemplate, List<DiskImage>> entry : dictionary.entrySet()) {
                tempMap.put(entry.getKey().getId(), null);
            }
            for (Entry<Guid, List<Disk>> missingTemplateEntry : missingTemplateDiskMap.entrySet()) {
                if (tempMap.containsKey(missingTemplateEntry.getKey())) {
                    for (Disk disk : missingTemplateEntry.getValue()) {
                        addDiskImportData(disk.getId(), filteredStorageDomains, ((DiskImage) disk).getVolumeType(), new EntityModel(true));
                    }
                } else {
                    showCloseMessage(ConstantsManager.getInstance().getConstants().errorTemplateCannotBeFoundMessage());
                    return;
                }
            }
            ImportVmModel.this.setMessage(ConstantsManager.getInstance().getConstants().importMissingStorages());
            for (ImportVmData vmData : (List<ImportVmData>) getItems()) {
                if (!Guid.Empty.equals(vmData.getVm().getVmtGuid()) && missingTemplateDiskMap.containsKey(vmData.getVm().getVmtGuid())) {
                    vmData.setTemplateExistsInSetup(false);
                }
            }
            postInitDisks();
        }
    }));
}
#end_block

#method_before
private void saveNewConsumptionValues(Map<Guid, Quota> quotaMap, Map<Guid, Double> newUsedGlobalStorageSize, Map<Guid, Map<Guid, Double>> newUsedSpecificStorageSize) {
    // cache new storage size.
    for (Map.Entry<Guid, Double> entry : newUsedGlobalStorageSize.entrySet()) {
        Quota quota = quotaMap.get(entry.getKey());
        double value = entry.getValue();
        if (value < 0) {
            log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", entry.getKey());
            quotaMap.remove(entry.getKey());
            continue;
        }
        quota.getGlobalQuotaStorage().setStorageSizeGBUsage(value);
    }
    for (Map.Entry<Guid, Map<Guid, Double>> guidMapEntry : newUsedSpecificStorageSize.entrySet()) {
        Quota quota = quotaMap.get(guidMapEntry.getKey());
        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
            if (guidMapEntry.getValue().containsKey(quotaStorage.getStorageId())) {
                double value = guidMapEntry.getValue().get(quotaStorage.getStorageId());
                if (value < 0) {
                    log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", guidMapEntry.getKey());
                    quotaMap.remove(guidMapEntry.getKey());
                    continue;
                }
                quotaStorage.setStorageSizeGBUsage(value);
            }
        }
    }
}
#method_after
private void saveNewConsumptionValues(Map<Guid, Quota> quotaMap, Map<Guid, Double> newUsedGlobalStorageSize, Map<Guid, Map<Guid, Double>> newUsedSpecificStorageSize) {
    // cache new storage size.
    for (Map.Entry<Guid, Double> entry : newUsedGlobalStorageSize.entrySet()) {
        Quota quota = quotaMap.get(entry.getKey());
        double value = entry.getValue();
        if (value < 0) {
            log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", entry.getKey());
            quotaMap.remove(entry.getKey());
            continue;
        }
        quota.getGlobalQuotaStorage().setStorageSizeGBUsage(value);
    }
    for (Map.Entry<Guid, Map<Guid, Double>> quotaStorageEntry : newUsedSpecificStorageSize.entrySet()) {
        Quota quota = quotaMap.get(quotaStorageEntry.getKey());
        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
            if (quotaStorageEntry.getValue().containsKey(quotaStorage.getStorageId())) {
                double value = quotaStorageEntry.getValue().get(quotaStorage.getStorageId());
                if (value < 0) {
                    log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaStorageEntry.getKey());
                    quotaMap.remove(quotaStorageEntry.getKey());
                    continue;
                }
                quotaStorage.setStorageSizeGBUsage(value);
            }
        }
    }
}
#end_block

#method_before
@Override
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    for (Map.Entry<String, String> stringStringEntry : columnNameDict.entrySet()) {
        if (typeDict.get(stringStringEntry.getKey()) == String.class && !notFreeTextSearchableFieldsList.contains(stringStringEntry.getKey())) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, stringStringEntry.getValue(), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#method_after
@Override
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    for (Map.Entry<String, String> columnNameEntry : columnNameDict.entrySet()) {
        if (typeDict.get(columnNameEntry.getKey()) == String.class && !notFreeTextSearchableFieldsList.contains(columnNameEntry.getKey())) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, columnNameEntry.getValue(), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Set parameters for messeging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Set parameters for messaging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected Guid findImageForSameDrive(Guid snapshotId) {
    List<DiskImage> imagesFromSanpshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage diskImage : imagesFromSanpshot) {
        if (getDiskImage().getId().equals(diskImage.getId())) {
            return diskImage.getImageId();
        }
    }
    return null;
}
#method_after
protected Guid findImageForSameDrive(Guid snapshotId) {
    List<DiskImage> imagesFromSnapshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage diskImage : imagesFromSnapshot) {
        if (getDiskImage().getId().equals(diskImage.getId())) {
            return diskImage.getImageId();
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null && Guid.Empty.equals(super.getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
    }
    if (!ImagesHandler.CheckImagesConfiguration(getStorageDomainId(), getParameters().getDiskInfoList(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null && Guid.Empty.equals(super.getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
    }
    if (!ImagesHandler.checkImagesConfiguration(getStorageDomainId(), getParameters().getDiskInfoList(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return super.canDoAction();
}
#end_block

#method_before
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    Guid vmSnapshotId = Guid.newGuid();
    for (DiskImage diskImage : mImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = executeChildCommand(diskImage.getImageId());
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#method_after
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    for (DiskImage diskImage : mImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = executeChildCommand(diskImage.getImageId());
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#end_block

#method_before
protected boolean checkImageConfiguration() {
    return ImagesHandler.CheckImageConfiguration(getStorageDomain().getStorageStaticData(), getDiskImageInfo(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkImageConfiguration() {
    return ImagesHandler.checkImageConfiguration(getStorageDomain().getStorageStaticData(), getDiskImageInfo(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected boolean updateVnicForBackwardCompatibility() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper();
    if (!validate(vnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVmTemplate(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean updateVnicForBackwardCompatibility() {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVmTemplate(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean updateVnicForBackwardCompatibility() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper();
    if (!validate(vnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVm().getStaticData(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean updateVnicForBackwardCompatibility() {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVm().getStaticData(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean validateImageConfig(List<String> canDoActionMessages, Map<Guid, StorageDomain> domainsMap, DiskImage image) {
    return ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
}
#method_after
private boolean validateImageConfig(List<String> canDoActionMessages, Map<Guid, StorageDomain> domainsMap, DiskImage image) {
    return ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVdsCluster()) {
        return false;
    }
    Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
    if (!setDomainsForMemoryImages(domainMap)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
        if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#method_after
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVdsCluster()) {
        return false;
    }
    Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
    if (!setDomainsForMemoryImages(domainMap)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
        if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName(), getAuditLogTypeForInvalidInterfaces());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
protected void synchronizeNics(VM vm, CompensationContext compensationContext, Guid userId) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getVdsGroupId(), vm.getStoragePoolId(), vm.getVdsGroupCompatibilityVersion());
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, userId);
        vmInterfaceManager.add(vmInterface, compensationContext, false, vm.getVdsGroupCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
}
#method_after
protected void synchronizeNics(VM vm, CompensationContext compensationContext, Guid userId) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getVdsGroupId(), vm.getStoragePoolId(), vm.getVdsGroupCompatibilityVersion(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, userId);
        vmInterfaceManager.add(vmInterface, compensationContext, false, vm.getVdsGroupCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#end_block

#method_before
private boolean updateNicWithVnicProfile(VmNetworkInterface iface, Guid userId) {
    if (iface.getNetworkName() == null) {
        if (FeatureSupported.networkLinking(compatibilityVersion)) {
            iface.setVnicProfileId(null);
            return true;
        } else {
            return false;
        }
    }
    Network network = networksInClusterByName.get(iface.getNetworkName());
    if (network == null || !network.isVmNetwork()) {
        return false;
    }
    VnicProfile vnicProfile = getVnicProfileForNetwork(vnicProfilesInDc, network, iface.getVnicProfileName());
    if (vnicProfile == null) {
        vnicProfile = findVnicProfileForUser(userId, network);
        if (vnicProfile == null) {
            return false;
        }
    }
    iface.setVnicProfileId(vnicProfile.getId());
    return true;
}
#method_after
private boolean updateNicWithVnicProfile(VmNetworkInterface iface, Guid userId) {
    if (iface.getNetworkName() == null) {
        if (FeatureSupported.networkLinking(compatibilityVersion)) {
            iface.setVnicProfileId(null);
            return true;
        } else {
            return false;
        }
    }
    Network network = getNetworksInCluster().get(iface.getNetworkName());
    if (network == null || !network.isVmNetwork()) {
        return false;
    }
    VnicProfile vnicProfile = getVnicProfileForNetwork(network, iface.getVnicProfileName());
    if (vnicProfile == null) {
        vnicProfile = findVnicProfileForUser(userId, network);
        if (vnicProfile == null) {
            return false;
        }
    }
    iface.setVnicProfileId(vnicProfile.getId());
    return true;
}
#end_block

#method_before
private VnicProfile getVnicProfileForNetwork(List<VnicProfileView> vnicProfiles, Network network, String vnicProfileName) {
    if (vnicProfileName == null) {
        return null;
    }
    for (VnicProfileView vnicProfile : vnicProfiles) {
        if (ObjectUtils.equals(vnicProfile.getNetworkId(), network.getId()) && vnicProfileName.equals(vnicProfile.getName())) {
            return vnicProfile;
        }
    }
    return null;
}
#method_after
private VnicProfile getVnicProfileForNetwork(Network network, String vnicProfileName) {
    if (vnicProfileName == null) {
        return null;
    }
    for (VnicProfileView vnicProfile : getVnicProfilesInDc()) {
        if (ObjectUtils.equals(vnicProfile.getNetworkId(), network.getId()) && vnicProfileName.equals(vnicProfile.getName())) {
            return vnicProfile;
        }
    }
    return null;
}
#end_block

#method_before
private boolean isVnicProfilePermitted(Guid userId, VnicProfile profile, boolean portMirroringRequired) {
    return portMirroringRequired == profile.isPortMirroring() && getPermissionDAO().getEntityPermissions(userId, ActionGroup.CONFIGURE_VM_NETWORK, profile.getId(), VdcObjectType.VnicProfile) != null;
}
#method_after
private static boolean isVnicProfilePermitted(Guid userId, VnicProfile profile, boolean portMirroringRequired) {
    return portMirroringRequired == profile.isPortMirroring() && getPermissionDAO().getEntityPermissions(userId, ActionGroup.CONFIGURE_VM_NETWORK, profile.getId(), VdcObjectType.VnicProfile) != null;
}
#end_block

#method_before
public void auditInvalidInterfaces(String entityName, AuditLogType logType) {
    if (!invalidNetworkNames.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("EntityName", entityName);
        logable.addCustomValue("Networks", StringUtils.join(invalidNetworkNames, ','));
        logable.addCustomValue("Interfaces", StringUtils.join(invalidIfaceNames, ','));
        AuditLogDirector.log(logable, logType);
    }
}
#method_after
public void auditInvalidInterfaces(String entityName) {
    if (!invalidNetworkNames.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("EntityName", entityName);
        logable.addCustomValue("Networks", StringUtils.join(invalidNetworkNames, ','));
        logable.addCustomValue("Interfaces", StringUtils.join(invalidIfaceNames, ','));
        AuditLogDirector.log(logable, logType);
    }
}
#end_block

#method_before
public ValidationResult updateNicForBackwardCompatibility(VmNetworkInterface nic, VmBase vm, Guid userId) {
    if (nic.getVnicProfileId() != null) {
        return ValidationResult.VALID;
    }
    if (nic.getNetworkName() == null) {
        if (nic.isPortMirroring()) {
            return new ValidationResult(VdcBllMessages.PORT_MIRRORING_REQUIRES_NETWORK);
        } else {
            return ValidationResult.VALID;
        }
    }
    Network network = getNetworkDao().getByNameAndCluster(nic.getNetworkName(), vm.getVdsGroupId());
    if (network == null) {
        return new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER);
    }
    List<VnicProfile> vnicProfiles = getVnicProfileDao().getAllForNetwork(network.getId());
    for (VnicProfile profile : vnicProfiles) {
        if (isVnicProfilePermitted(userId, profile, nic.isPortMirroring())) {
            nic.setVnicProfileId(profile.getId());
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_FIND_VNIC_PROFILE_FOR_NETWORK);
}
#method_after
public static ValidationResult updateNicForBackwardCompatibility(VmNetworkInterface nic, VmBase vm, Guid userId) {
    if (nic.getVnicProfileId() != null) {
        return ValidationResult.VALID;
    }
    if (nic.getNetworkName() == null) {
        if (nic.isPortMirroring()) {
            return new ValidationResult(VdcBllMessages.PORT_MIRRORING_REQUIRES_NETWORK);
        } else {
            return ValidationResult.VALID;
        }
    }
    Network network = getNetworkDao().getByNameAndCluster(nic.getNetworkName(), vm.getVdsGroupId());
    if (network == null) {
        return new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER);
    }
    List<VnicProfile> vnicProfiles = getVnicProfileDao().getAllForNetwork(network.getId());
    for (VnicProfile profile : vnicProfiles) {
        if (isVnicProfilePermitted(userId, profile, nic.isPortMirroring())) {
            nic.setVnicProfileId(profile.getId());
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_FIND_VNIC_PROFILE_FOR_NETWORK);
}
#end_block

#method_before
private NetworkDao getNetworkDao() {
    return DbFacade.getInstance().getNetworkDao();
}
#method_after
private static NetworkDao getNetworkDao() {
    return DbFacade.getInstance().getNetworkDao();
}
#end_block

#method_before
private VnicProfileDao getVnicProfileDao() {
    return DbFacade.getInstance().getVnicProfileDao();
}
#method_after
private static VnicProfileDao getVnicProfileDao() {
    return DbFacade.getInstance().getVnicProfileDao();
}
#end_block

#method_before
private PermissionDAO getPermissionDAO() {
    return DbFacade.getInstance().getPermissionDao();
}
#method_after
private static PermissionDAO getPermissionDAO() {
    return DbFacade.getInstance().getPermissionDao();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.CheckImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getParameters().getImages());
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getSize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getParameters().getImages());
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getSize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVmTemplate().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version());
    for (VmNetworkInterface iface : getVmTemplate().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.newGuid());
        }
        iface.setVmId(getVmTemplateId());
        VmNic nic = new VmNic();
        nic.setId(iface.getId());
        nic.setVmTemplateId(getVmTemplateId());
        nic.setName(iface.getName());
        nic.setLinked(iface.isLinked());
        nic.setSpeed(iface.getSpeed());
        nic.setType(iface.getType());
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        nic.setVnicProfileId(iface.getVnicProfileId());
        getVmNicDao().save(nic);
        getCompensationContext().snapshotNewEntity(nic);
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        nic.setStatistics(iStat);
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        getDbFacade().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmTemplateName(), getAuditLogTypeForInvalidInterfaces());
}
#method_after
protected void addVmInterfaces() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVmTemplate().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVmTemplate().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.newGuid());
        }
        iface.setVmId(getVmTemplateId());
        VmNic nic = new VmNic();
        nic.setId(iface.getId());
        nic.setVmTemplateId(getVmTemplateId());
        nic.setName(iface.getName());
        nic.setLinked(iface.isLinked());
        nic.setSpeed(iface.getSpeed());
        nic.setType(iface.getType());
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        nic.setVnicProfileId(iface.getVnicProfileId());
        getVmNicDao().save(nic);
        getCompensationContext().snapshotNewEntity(nic);
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        nic.setStatistics(iStat);
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        getDbFacade().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmTemplateName());
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    VdcReturnValueBase vdcReturnValueBase = super.endAction();
    freeLock();
    return vdcReturnValueBase;
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    try {
        return super.endAction();
    } finally {
        freeLock();
    }
}
#end_block

#method_before
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || !hasTasks()) {
        freeLock();
    }
}
#method_after
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || (!hasTasks() && !(this instanceof IVdsAsyncCommand))) {
        freeLock();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (readOnly ? 1231 : 1237);
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((appMode == null) ? ApplicationMode.VirtOnly.getValue() : appMode.getValue());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (readOnly ? 1231 : 1237);
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((appMode == null) ? 0 : appMode.getValue());
    return result;
}
#end_block

#method_before
private String getDiskIsBeingMigratedMessage() {
    if (cachedDiskIsBeingMigratedMessage == null) {
        StringBuilder builder = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_BEING_MIGRATED.name());
        if (getImage() != null) {
            builder.append(String.format("$DiskName %1$s", getDiskAlias()));
        }
        builder.append(String.format("$OperationType %1$s", ImageOperation.Move == getParameters().getOperation() ? "moved" : "copied"));
        cachedDiskIsBeingMigratedMessage = builder.toString();
    }
    return cachedDiskIsBeingMigratedMessage;
}
#method_after
private String getDiskIsBeingMigratedMessage() {
    if (cachedDiskIsBeingMigratedMessage == null) {
        StringBuilder builder = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_BEING_MIGRATED.name());
        if (getImage() != null) {
            builder.append(String.format("$DiskName %1$s", getDiskAlias()));
        }
        cachedDiskIsBeingMigratedMessage = builder.toString();
    }
    return cachedDiskIsBeingMigratedMessage;
}
#end_block

#method_before
@Mapping(from = Network.class, to = org.ovirt.engine.core.common.businessentities.network.Network.class)
public static org.ovirt.engine.core.common.businessentities.network.Network map(Network model, org.ovirt.engine.core.common.businessentities.network.Network template) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.Network();
    entity.setCluster(template != null && template.getCluster() != null ? template.getCluster() : new NetworkCluster());
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setDataCenterId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddr(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetVlan()) {
        if (model.getVlan().getId() == null) {
            entity.setVlanId(null);
        } else {
            try {
                entity.setVlanId(model.getVlan().getId());
            } catch (NumberFormatException e) {
            // REVIST: handle parse error
            }
        }
    }
    if (model.isSetStp()) {
        entity.setStp(model.isStp());
    }
    if (model.isSetUsages()) {
        List<NetworkUsage> networkUsages = new ArrayList<NetworkUsage>();
        for (String usage : model.getUsages().getUsages()) {
            networkUsages.add(NetworkUsage.fromValue(usage));
        }
        entity.getCluster().setDisplay(networkUsages.contains(NetworkUsage.DISPLAY));
        entity.getCluster().setMigration(networkUsages.contains(NetworkUsage.MIGRATION));
        entity.setVmNetwork(networkUsages.contains(NetworkUsage.VM));
    }
    if (model.isSetMtu()) {
        entity.setMtu(model.getMtu());
    }
    if (model.isSetDisplay()) {
        // for backward compatibility use display tag or usage tag
        entity.getCluster().setDisplay(model.isDisplay());
    }
    if (model.isSetRequired()) {
        entity.getCluster().setRequired(model.isRequired());
    }
    return entity;
}
#method_after
@Mapping(from = Network.class, to = org.ovirt.engine.core.common.businessentities.network.Network.class)
public static org.ovirt.engine.core.common.businessentities.network.Network map(Network model, org.ovirt.engine.core.common.businessentities.network.Network template) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.Network();
    entity.setCluster(template != null && template.getCluster() != null ? template.getCluster() : new NetworkCluster());
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setDataCenterId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddr(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetVlan()) {
        entity.setVlanId(model.getVlan().getId());
    }
    if (model.isSetStp()) {
        entity.setStp(model.isStp());
    }
    if (model.isSetUsages()) {
        List<NetworkUsage> networkUsages = new ArrayList<NetworkUsage>();
        for (String usage : model.getUsages().getUsages()) {
            networkUsages.add(NetworkUsage.fromValue(usage));
        }
        entity.getCluster().setDisplay(networkUsages.contains(NetworkUsage.DISPLAY));
        entity.getCluster().setMigration(networkUsages.contains(NetworkUsage.MIGRATION));
        entity.setVmNetwork(networkUsages.contains(NetworkUsage.VM));
    }
    if (model.isSetMtu()) {
        entity.setMtu(model.getMtu());
    }
    if (model.isSetDisplay()) {
        // for backward compatibility use display tag or usage tag
        entity.getCluster().setDisplay(model.isDisplay());
    }
    if (model.isSetRequired()) {
        entity.getCluster().setRequired(model.isRequired());
    }
    return entity;
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setInfo(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress(null);
    Frontend.RunQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(((VDSGroup) getSelectedItem()).getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel model = (ClusterListModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be ArrayList<VDS> or VdcQueryReturnValue with return value ArrayList<VDS>");
            }
            boolean result = false;
            for (VDS host : hosts) {
                if (VDSStatus.NonResponsive == host.getStatus()) {
                    result = true;
                    break;
                }
            }
            if (result) {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#method_after
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress(null);
    Frontend.RunQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(((VDSGroup) getSelectedItem()).getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel model = (ClusterListModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            }
            boolean foundNRHosts = false;
            if (hosts != null) {
                for (VDS host : hosts) {
                    if (VDSStatus.NonResponsive == host.getStatus()) {
                        foundNRHosts = true;
                        break;
                    }
                }
            }
            if (foundNRHosts) {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && acquireLockInternal() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration(canDoActionMessages) && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#method_after
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && acquireLockInternal() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration() && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#end_block

#method_before
protected boolean checkImageConfiguration(List<String> canDoActionMessages) {
    return ImagesHandler.CheckImageConfiguration(getStorageDomain().getStorageStaticData(), getImage(), canDoActionMessages);
}
#method_after
protected boolean checkImageConfiguration() {
    return ImagesHandler.CheckImageConfiguration(getStorageDomain().getStorageStaticData(), getImage(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDAO().getVmsListForDisk(getImage().getId());
    }
    return listVms;
}
#method_after
private List<VM> getVmsForDiskId() {
    if (cachedListVms == null) {
        cachedListVms = getVmDAO().getVmsListForDisk(getImage().getId());
    }
    return cachedListVms;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permsList == null) {
        permsList = new ArrayList<PermissionSubject>();
        DiskImage image = getImage();
        Guid diskId = image == null ? Guid.Empty : image.getId();
        permsList.add(new PermissionSubject(diskId, VdcObjectType.Disk, ActionGroup.CONFIGURE_DISK_STORAGE));
        permsList.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return permsList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (cachedPermsList == null) {
        cachedPermsList = new ArrayList<PermissionSubject>();
        DiskImage image = getImage();
        Guid diskId = image == null ? Guid.Empty : image.getId();
        cachedPermsList.add(new PermissionSubject(diskId, VdcObjectType.Disk, ActionGroup.CONFIGURE_DISK_STORAGE));
        cachedPermsList.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return cachedPermsList;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                if (createdSnapshot != null) {
                    getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
                    if (isLiveSnapshotApplicable()) {
                        performLiveSnapshot(createdSnapshot);
                    } else {
                        // they are not in use since no live snapshot was created
                        if (!createdSnapshot.getMemoryVolume().isEmpty()) {
                            logMemorySavingFailed();
                            if (!removeMemoryFromSnapshot(createdSnapshot, true)) {
                                log.errorFormat("Failed to remove unused memory {0} of snapshot {1}", createdSnapshot.getMemoryVolume(), createdSnapshot.getId());
                            }
                        }
                    }
                } else {
                    log.warnFormat("No snapshot was found for VM {0} which is in LOCKED status command will be failed", getVmId());
                }
            } else {
                if (createdSnapshot != null) {
                    revertToActiveSnapshot(createdSnapshot.getId());
                    // Note that the memory volumes might not have been created
                    if (!removeMemoryFromSnapshot(createdSnapshot, false)) {
                        log.warnFormat("Failed to remove memory {0} of snapshot {1}", createdSnapshot.getMemoryVolume(), createdSnapshot.getId());
                    }
                } else {
                    log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
                }
            }
            incrementVmGeneration();
            endActionOnDisks();
            setSucceeded(createdSnapshot == null ? false : taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#method_after
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            // handled as a failure
            if (createdSnapshot == null) {
                taskGroupSucceeded = false;
            }
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
                if (isLiveSnapshotApplicable()) {
                    performLiveSnapshot(createdSnapshot);
                } else {
                    // they are not in use since no live snapshot was created
                    if (!createdSnapshot.getMemoryVolume().isEmpty()) {
                        logMemorySavingFailed();
                        if (!removeMemoryFromSnapshot(createdSnapshot, true)) {
                            log.errorFormat("Failed to remove unused memory {0} of snapshot {1}", createdSnapshot.getMemoryVolume(), createdSnapshot.getId());
                        }
                    }
                }
            } else {
                if (createdSnapshot != null) {
                    revertToActiveSnapshot(createdSnapshot.getId());
                    // Note that the memory volumes might not have been created
                    if (!removeMemoryFromSnapshot(createdSnapshot, false)) {
                        log.warnFormat("Failed to remove memory {0} of snapshot {1}", createdSnapshot.getMemoryVolume(), createdSnapshot.getId());
                    }
                } else {
                    log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
                }
            }
            incrementVmGeneration();
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
private boolean isLiveSnapshotApplicable() {
    return getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isRunning() && getVm().getRunOnVds() != null;
}
#method_after
private boolean isLiveSnapshotApplicable() {
    return getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && (getVm().isRunning() || getVm().getStatus() == VMStatus.Paused) && getVm().getRunOnVds() != null;
}
#end_block

#method_before
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warnFormat("Wasn't able to live snpashot due to error: {0}. VM will still be configured to the new created snapshot", ExceptionUtils.getMessage(e));
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#method_after
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warnFormat("Wasn't able to live snapshot due to error: {0}. VM will still be configured to the new created snapshot", ExceptionUtils.getMessage(e));
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(disksList);
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(sdValidator.allDomainsExistAndActive()) && validate(sdValidator.allDomainsWithinThresholds()))) {
            return false;
        }
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(disksList);
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(sdValidator.allDomainsExistAndActive()) && validate(sdValidator.allDomainsWithinThresholds()))) {
            return false;
        }
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#end_block

#method_before
@Override
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "DocumentationPath.csv", documentationFileFetchedEvent);
}
#method_after
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "DocumentationPath.csv", documentationFileFetchedEvent);
}
#end_block

#method_before
public boolean isWebSocketProxyDefined() {
    String wsConfig = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.WebSocketProxy);
    // $NON-NLS-1$ //$NON-NLS-2$
    return wsConfig != null && !"".equals(wsConfig) && !"Off".equalsIgnoreCase(wsConfig);
}
#method_after
public boolean isWebSocketProxyDefined() {
    String wsConfig = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.WebSocketProxy);
    // $NON-NLS-1$ $NON-NLS-2$
    return wsConfig != null && !"".equals(wsConfig) && !"Off".equalsIgnoreCase(wsConfig);
}
#end_block

#method_before
public boolean isClientWindowsExplorer() {
    // $NON-NLS-1$
    return isClientWindows() && clientBrowserType().equalsIgnoreCase("Explorer");
}
#method_after
public boolean isClientWindowsExplorer() {
    // $NON-NLS-1$ //$NON-NLS-2$
    return isClientWindows() && clientBrowserType().equalsIgnoreCase("Explorer");
}
#end_block

#method_before
public static void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public static void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#end_block

#method_before
@Override
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "UserPortalDocumentationPath.csv", documentationFileFetchedEvent);
}
#method_after
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "UserPortalDocumentationPath.csv", documentationFileFetchedEvent);
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initImportExportSeverities() {
    severities.put(AuditLogType.IMPORTEXPORT_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_REMOVE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_REMOVE_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_GET_VMS_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_REMOVE_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_REMOVE_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_IMPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_IMPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_REMOVE_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_REMOVE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_FAILED_TO_IMPORT_VM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_FAILED_TO_IMPORT_TEMPLATE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_INVALID_INTERFACES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED, AuditLogSeverity.WARNING);
}
#method_after
private static void initImportExportSeverities() {
    severities.put(AuditLogType.IMPORTEXPORT_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_REMOVE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_REMOVE_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_GET_VMS_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_REMOVE_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_REMOVE_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_IMPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_IMPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_REMOVE_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_STARTING_REMOVE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_FAILED_TO_IMPORT_VM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_FAILED_TO_IMPORT_TEMPLATE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_INVALID_INTERFACES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#end_block

#method_before
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        if (allocatedMacs.containsKey(mac) || allocatedCustomMacs.containsKey(mac)) {
            return true;
        }
        for (String macAddress : allocatedMacs.keySet()) {
            if (StringUtils.equalsIgnoreCase(macAddress, mac)) {
                return true;
            }
        }
        for (String macAddress : allocatedCustomMacs.keySet()) {
            if (StringUtils.equalsIgnoreCase(macAddress, mac)) {
                return true;
            }
        }
        return false;
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        return allocatedMacs.containsKey(mac) || allocatedCustomMacs.containsKey(mac);
    } finally {
        lockObj.readLock().unlock();
    }
}
#end_block

#method_before
public boolean shouldAlertUpgrade(ArrayList<RpmVersion> isos, String[] hostOs) {
    boolean alert = false;
    // $NON-NLS-1$ //$NON-NLS-2$
    String[] version_host = hostOs[1].split("\\.");
    // $NON-NLS-1$ //$NON-NLS-2$
    String[] release_host = hostOs[2].split("\\.");
    for (RpmVersion iso : isos) {
        // Major check
        if (Integer.parseInt(version_host[0].trim()) == iso.getMajor()) {
            // Minor and Build
            if (iso.getMinor() > Integer.parseInt(version_host[1].trim()) || iso.getBuild() > Integer.parseInt(version_host[2].trim())) {
                alert = true;
                break;
            }
            // Check if release contain revision
            if (Integer.toString(iso.getRevision()).length() > release_host[0].length()) {
                alert = true;
                break;
            }
            // $NON-NLS-1$ //$NON-NLS-2$
            String[] releaseISO = Integer.toString(iso.getRevision()).split("\\.");
            for (int i = 0; i < release_host.length; i++) {
                try {
                    if (Integer.parseInt(releaseISO[i].trim()) > Integer.parseInt(release_host[i].trim())) {
                        alert = true;
                        break;
                    }
                } catch (NumberFormatException e) {
                    break;
                }
            }
        }
    }
    return alert;
}
#method_after
protected static boolean shouldAlertUpgrade(ArrayList<RpmVersion> isos, String[] hostOs) {
    // HhostOs holds the following components:
    // hostOs[0] holds prefix
    // hostOs[1] holds version
    // hostOs[2] holds release
    final int VERSION_FIELDS_NUMBER = 4;
    boolean alert = false;
    // Fix hostOs[1] to be format of major.minor.build.revision
    // Add ".0" for missing parts
    // $NON-NLS-1$
    String[] hostOsVersionParts = hostOs[1].split("\\.");
    for (int counter = 0; counter < VERSION_FIELDS_NUMBER - hostOsVersionParts.length; counter++) {
        // $NON-NLS-1$
        hostOs[1] = hostOs[1].trim() + ".0";
    }
    Version hostVersion = new Version(hostOs[1].trim());
    String releaseHost = hostOs[2].trim();
    for (RpmVersion iso : isos) {
        // Major check
        if (hostVersion.getMajor() == iso.getMajor()) {
            // Minor and Buildiso.getRpmName()
            if (iso.getMinor() > hostVersion.getMinor() || iso.getBuild() > hostVersion.getBuild()) {
                alert = true;
                break;
            }
            String rpmFromIso = iso.getRpmName();
            // Removes the ".iso" file extension , and get the release part from it
            // $NON-NLS-1$
            int isoIndex = rpmFromIso.indexOf(".iso");
            if (isoIndex != -1) {
                rpmFromIso = iso.getRpmName().substring(0, isoIndex);
            }
            if (RpmVersionUtils.compareRpmParts(RpmVersionUtils.splitRpmToParts(rpmFromIso)[2], releaseHost) > 0) {
                alert = true;
                break;
            }
        }
    }
    return alert;
}
#end_block

#method_before
public void onInstall() {
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = getEntity().getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(getEntity());
    param.setVdsId(getEntity().getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.RunAction(VdcActionType.UpdateVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), getEntity().getVdsGroupId());
}
#method_after
public void onInstall() {
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = getEntity().getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(getEntity());
    param.setVdsId(getEntity().getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.RunAction(VdcActionType.UpdateVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), getEntity().getVdsGroupId());
}
#end_block

#method_before
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getInstallCommand().setIsExecutionAllowed(true);
    getEditHostCommand().setIsExecutionAllowed(VdcActionUtils.CanExecute(new ArrayList<VDS>(Arrays.asList(new VDS[] { getEntity() })), VDS.class, VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty()));
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().getpm_enabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().getpm_enabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    } else if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                HostGeneralModel hostGeneralModel = (HostGeneralModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    VDS vds = hostGeneralModel.getEntity();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    String[] host = vds.getHostOs().split("-");
                    hostGeneralModel.setHasUpgradeAlert(shouldAlertUpgrade(isos, host));
                    boolean executionAllowed = vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        hostGeneralModel.getInstallCommand().getExecuteProhibitionReasons().add(constants.switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    hostGeneralModel.getInstallCommand().setIsExecutionAllowed(executionAllowed);
                }
            }
        }), getEntity().getId());
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert(getHasNICsAlert() || getHasUpgradeAlert() || getHasManualFenceAlert() || getHasNoPowerManagementAlert() || getHasReinstallAlertNonResponsive() || getHasReinstallAlertInstallFailed() || getHasReinstallAlertMaintenance());
}
#method_after
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getInstallCommand().setIsExecutionAllowed(true);
    getEditHostCommand().setIsExecutionAllowed(VdcActionUtils.CanExecute(new ArrayList<VDS>(Arrays.asList(new VDS[] { getEntity() })), VDS.class, VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty()));
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().getpm_enabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().getpm_enabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    } else if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                HostGeneralModel hostGeneralModel = (HostGeneralModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    VDS vds = hostGeneralModel.getEntity();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    String[] hostOsInfo = vds.getHostOs().split("-");
                    for (int counter = 0; counter < hostOsInfo.length; counter++) {
                        hostOsInfo[counter] = hostOsInfo[counter].trim();
                    }
                    hostGeneralModel.setHasUpgradeAlert(shouldAlertUpgrade(isos, hostOsInfo));
                    boolean executionAllowed = vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        hostGeneralModel.getInstallCommand().getExecuteProhibitionReasons().add(constants.switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    hostGeneralModel.getInstallCommand().setIsExecutionAllowed(executionAllowed);
                }
            }
        }), getEntity().getId());
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert(getHasNICsAlert() || getHasUpgradeAlert() || getHasManualFenceAlert() || getHasNoPowerManagementAlert() || getHasReinstallAlertNonResponsive() || getHasReinstallAlertInstallFailed() || getHasReinstallAlertMaintenance());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    RpmVersion vdsOsVersion = getOvirtOsVersion();
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    File directory = new File(Config.resolveOVirtISOsRepositoryPath());
    if (directory.isDirectory()) {
        List<String> listOfIsoFiles = getListOfIsoFiles(directory);
        if (!listOfIsoFiles.isEmpty()) {
            File[] ovirtVersionFiles = filterOvirtFiles(directory, isoVersionPattern);
            for (File versionFile : ovirtVersionFiles) {
                try {
                    IsoData isoData = new IsoData();
                    isoData.setVersion(readIsoVersion(versionFile));
                    String isoVersionText = isoData.getVersion();
                    isoData.setVdsmCompitibilityVersion(readVdsmCompatibiltyVersion((versionFile.getAbsolutePath().replace(OVIRT_ISO_VERSION_PREFIX, OVIRT_ISO_VDSM_COMPATIBILITY_PREFIX))));
                    if (StringUtils.isBlank(isoVersionText)) {
                        log.debugFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String[] versionParts = isoVersionText.split(",");
                    if (versionParts.length < 2) {
                        log.debugFormat("Iso version file {0} contains invalid content. Excpected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String majorVersionStr = versionParts[0];
                    String releaseStr = versionParts[1];
                    String isoFileName = getIsoFileNameByVersion(listOfIsoFiles, majorVersionStr, releaseStr);
                    if (isoFileName == null) {
                        log.debugFormat("Iso version file {0} has no matching iso file searched by version parts: {1} and {2}.", versionFile.getAbsolutePath(), majorVersionStr, releaseStr);
                        continue;
                    }
                    RpmVersion isoVersion = new RpmVersion(isoFileName, getOvirtIsoPrefix(), true);
                    isoVersion.setRpmName(isoFileName);
                    boolean shouldAdd = false;
                    String[] rpmParts = VersionUtils.splitRpmToParts(isoFileName);
                    if (isoVersion != null && isIsoVersionSupported(rpmParts[1]) != -1) {
                        if (isoData.getVdsmCompatibilityVersion() != null) {
                            shouldAdd = isIsoCompatibleForUpgradeByClusterVersion(isoData);
                        } else if (vdsOsVersion != null) {
                            if (VdsHandler.isIsoVersionCompatibleForUpgrade(vdsOsVersion, isoVersion)) {
                                shouldAdd = true;
                            }
                        } else {
                            shouldAdd = true;
                        }
                    }
                    if (shouldAdd) {
                        availableISOsList.add(isoVersion);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to parse ovirt iso version {0} with error {1}", versionFile.getAbsolutePath(), ExceptionUtils.getMessage(e));
                }
            }
        }
    } else {
        log.errorFormat("ovirt ISOs directory not found. Search in: {0}", directory.getPath());
    }
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#method_after
@Override
protected void executeQueryCommand() {
    RpmVersion vdsOsVersion = getOvirtOsVersion();
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    File directory = new File(Config.resolveOVirtISOsRepositoryPath());
    if (directory.isDirectory()) {
        List<String> listOfIsoFiles = getListOfIsoFiles(directory);
        if (!listOfIsoFiles.isEmpty()) {
            File[] ovirtVersionFiles = filterOvirtFiles(directory, isoVersionPattern);
            for (File versionFile : ovirtVersionFiles) {
                try {
                    IsoData isoData = new IsoData();
                    isoData.setVersion(readIsoVersion(versionFile));
                    String isoVersionText = isoData.getVersion();
                    isoData.setVdsmCompitibilityVersion(readVdsmCompatibiltyVersion((versionFile.getAbsolutePath().replace(OVIRT_ISO_VERSION_PREFIX, OVIRT_ISO_VDSM_COMPATIBILITY_PREFIX))));
                    if (StringUtils.isBlank(isoVersionText)) {
                        log.debugFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String[] versionParts = isoVersionText.split(",");
                    if (versionParts.length < 2) {
                        log.debugFormat("Iso version file {0} contains invalid content. Excpected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String majorVersionStr = versionParts[0];
                    String releaseStr = versionParts[1];
                    String isoFileName = getIsoFileNameByVersion(listOfIsoFiles, majorVersionStr, releaseStr);
                    if (isoFileName == null) {
                        log.debugFormat("Iso version file {0} has no matching iso file searched by version parts: {1} and {2}.", versionFile.getAbsolutePath(), majorVersionStr, releaseStr);
                        continue;
                    }
                    RpmVersion isoVersion = new RpmVersion(isoFileName, getOvirtIsoPrefix(), true);
                    boolean shouldAdd = false;
                    String[] rpmParts = RpmVersionUtils.splitRpmToParts(isoFileName);
                    if (isoVersion != null && isIsoVersionSupported(rpmParts[1])) {
                        if (isoData.getVdsmCompatibilityVersion() != null) {
                            shouldAdd = isIsoCompatibleForUpgradeByClusterVersion(isoData);
                        } else if (vdsOsVersion != null) {
                            if (VdsHandler.isIsoVersionCompatibleForUpgrade(vdsOsVersion, isoVersion)) {
                                shouldAdd = true;
                            }
                        } else {
                            shouldAdd = true;
                        }
                    }
                    if (shouldAdd) {
                        availableISOsList.add(isoVersion);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to parse ovirt iso version {0} with error {1}", versionFile.getAbsolutePath(), ExceptionUtils.getMessage(e));
                }
            }
        }
    } else {
        log.errorFormat("ovirt ISOs directory not found. Search in: {0}", directory.getPath());
    }
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#end_block

#method_before
private static int isIsoVersionSupported(String isoVersion) {
    String supported = Config.<String>GetValue(ConfigValues.OvirtInitialSupportedIsoVersion);
    return VersionUtils.compareRpmPart(isoVersion, supported);
}
#method_after
private boolean isIsoVersionSupported(String isoVersion) {
    String supported = Config.<String>GetValue(ConfigValues.OvirtInitialSupportedIsoVersion);
    return RpmVersionUtils.compareRpmParts(isoVersion, supported) >= 0;
}
#end_block

#method_before
public static String[] splitRpmToParts(String rpmName) {
    int lastDashIndex = rpmName.lastIndexOf('-');
    if (lastDashIndex == -1) {
        throw new IllegalArgumentException(INVALID_RPM_NAME_FORMAT);
    }
    char[] chars = rpmName.toCharArray();
    int beforeLastDashIndex = lastDashIndex - 1;
    for (; beforeLastDashIndex >= 0; beforeLastDashIndex--) {
        if (chars[beforeLastDashIndex] == '-') {
            break;
        }
    }
    if (beforeLastDashIndex == -1) {
        throw new IllegalArgumentException(INVALID_RPM_NAME_FORMAT);
    }
    String[] parts = new String[3];
    parts[0] = rpmName.substring(0, beforeLastDashIndex);
    parts[1] = rpmName.substring(beforeLastDashIndex + 1, lastDashIndex);
    parts[2] = rpmName.substring(lastDashIndex + 1);
    return parts;
}
#method_after
public static String[] splitRpmToParts(String rpmName) {
    int lastDashIndex = rpmName.lastIndexOf('-');
    if (lastDashIndex == -1) {
        throw new IllegalArgumentException(INVALID_RPM_NAME_FORMAT);
    }
    char[] chars = rpmName.toCharArray();
    int beforeLastDashIndex = lastDashIndex - 1;
    while (beforeLastDashIndex >= 0) {
        if (chars[beforeLastDashIndex] == '-') {
            break;
        }
        beforeLastDashIndex--;
    }
    if (beforeLastDashIndex == -1) {
        throw new IllegalArgumentException(INVALID_RPM_NAME_FORMAT);
    }
    String[] parts = new String[3];
    parts[0] = rpmName.substring(0, beforeLastDashIndex);
    parts[1] = rpmName.substring(beforeLastDashIndex + 1, lastDashIndex);
    parts[2] = rpmName.substring(lastDashIndex + 1);
    return parts;
}
#end_block

#method_before
@Test
public void testCompareRpmRelease() {
    assertEquals(-1, RpmVersionUtils.compareRpmPart("2.3.10.4.fc18.x86_64", "2.3.10.4.fc19.x86_64"));
    assertEquals(1, RpmVersionUtils.compareRpmPart("20130821.fc18.x86_64", "20130820.fc18.x86_64"));
    assertEquals(1, RpmVersionUtils.compareRpmPart("20130821.0.fc18.x86_64", "20130820.1.fc18.x86_64"));
}
#method_after
@Test
public void testCompareRpmRelease() {
    assertEquals(-1, RpmVersionUtils.compareRpmParts("2.3.10.4.fc18.x86_64", "2.3.10.4.fc19.x86_64"));
    assertEquals(1, RpmVersionUtils.compareRpmParts("20130821.fc18.x86_64", "20130820.fc18.x86_64"));
    assertEquals(-1, RpmVersionUtils.compareRpmParts("20130820.0.fc18.x86_64", "20130820.1.fc18.x86_64"));
    assertEquals(1, RpmVersionUtils.compareRpmParts("20130820.0.fc18.x86_64", "20130820.fc18.x86_64"));
    assertEquals(1, RpmVersionUtils.compareRpmParts("20130820.1.3.fc18.x86_64", "20130820.1.fc18.x86_64"));
}
#end_block

#method_before
private void perform() {
    getVm().setMigratingToVds(vdsDestinationId);
    getParameters().setStartTime(new Date());
    // Starting migration at src VDS
    boolean connectToLunDiskSuccess = connectLunDisks(vdsDestinationId);
    if (connectToLunDiskSuccess) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Migrate, getMigrateVDSCommandParameters(), this).getReturnValue());
    }
    if (!connectToLunDiskSuccess || getActionReturnValue() != VMStatus.MigratingFrom) {
        getVm().setMigreatingToPort(0);
        getVm().setMigreatingFromPort(0);
        getVm().setMigratingToVds(null);
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_MIGRATION_FAILED_AT_DST);
    }
    ExecutionHandler.setAsyncJob(getExecutionContext(), true);
}
#method_after
private void perform() {
    getVm().setMigratingToVds(vdsDestinationId);
    getParameters().setStartTime(new Date());
    // Starting migration at src VDS
    boolean connectToLunDiskSuccess = connectLunDisks(vdsDestinationId);
    if (connectToLunDiskSuccess) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Migrate, createMigrateVDSCommandParameters(), this).getReturnValue());
    }
    if (!connectToLunDiskSuccess || getActionReturnValue() != VMStatus.MigratingFrom) {
        getVm().setMigreatingToPort(0);
        getVm().setMigreatingFromPort(0);
        getVm().setMigratingToVds(null);
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_MIGRATION_FAILED_AT_DST);
    }
    ExecutionHandler.setAsyncJob(getExecutionContext(), true);
}
#end_block

#method_before
private void perform() {
    getVm().setMigratingToVds(vdsDestinationId);
    getParameters().setStartTime(new Date());
    // Starting migration at src VDS
    boolean connectToLunDiskSuccess = connectLunDisks(vdsDestinationId);
    if (connectToLunDiskSuccess) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Migrate, getMigrateVDSCommandParameters(), this).getReturnValue());
    }
    if (!connectToLunDiskSuccess || getActionReturnValue() != VMStatus.MigratingFrom) {
        getVm().setMigreatingToPort(0);
        getVm().setMigreatingFromPort(0);
        getVm().setMigratingToVds(null);
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_MIGRATION_FAILED_AT_DST);
    }
    ExecutionHandler.setAsyncJob(getExecutionContext(), true);
}
#method_after
private void perform() {
    getVm().setMigratingToVds(vdsDestinationId);
    getParameters().setStartTime(new Date());
    // Starting migration at src VDS
    boolean connectToLunDiskSuccess = connectLunDisks(vdsDestinationId);
    if (connectToLunDiskSuccess) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Migrate, createMigrateVDSCommandParameters(), this).getReturnValue());
    }
    if (!connectToLunDiskSuccess || getActionReturnValue() != VMStatus.MigratingFrom) {
        getVm().setMigreatingToPort(0);
        getVm().setMigreatingFromPort(0);
        getVm().setMigratingToVds(null);
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_MIGRATION_FAILED_AT_DST);
    }
    ExecutionHandler.setAsyncJob(getExecutionContext(), true);
}
#end_block

#method_before
@Override
protected CreateVmVDSCommandParameters initCreateVmParams() {
    getVm().setRunOnce(true);
    CreateVmVDSCommandParameters createVmParams = super.initCreateVmParams();
    RunVmOnceParams runOnceParams = getParameters();
    SysPrepParams sysPrepParams = new SysPrepParams();
    sysPrepParams.setSysPrepDomainName(runOnceParams.getSysPrepDomainName());
    sysPrepParams.setSysPrepUserName(runOnceParams.getSysPrepUserName());
    sysPrepParams.setSysPrepPassword(runOnceParams.getSysPrepPassword());
    createVmParams.setSysPrepParams(sysPrepParams);
    createVmParams.setCloudInitParameters(runOnceParams.getCloudInitParameters());
    return createVmParams;
}
#method_after
@Override
protected CreateVmVDSCommandParameters initCreateVmParams() {
    CreateVmVDSCommandParameters createVmParams = super.initCreateVmParams();
    createVmParams.getVm().setRunOnce(true);
    RunVmOnceParams runOnceParams = getParameters();
    SysPrepParams sysPrepParams = new SysPrepParams();
    sysPrepParams.setSysPrepDomainName(runOnceParams.getSysPrepDomainName());
    sysPrepParams.setSysPrepUserName(runOnceParams.getSysPrepUserName());
    sysPrepParams.setSysPrepPassword(runOnceParams.getSysPrepPassword());
    createVmParams.setSysPrepParams(sysPrepParams);
    createVmParams.setCloudInitParameters(runOnceParams.getCloudInitParameters());
    return createVmParams;
}
#end_block

#method_before
@NotNull(message = VmNic.VALIDATION_MESSAGE_NAME_NOT_NULL, groups = { CreateEntity.class, UpdateEntity.class })
@Pattern(regexp = ValidationUtils.NO_SPECIAL_CHARACTERS_WITH_DOT, message = "VALIDATION_NAME_INVALID_WITH_DOT", groups = { CreateEntity.class, UpdateEntity.class })
@Override
public String getName() {
    return super.getName();
}
#method_after
@NotNull(message = VmNic.VALIDATION_MESSAGE_NAME_NOT_NULL, groups = { CreateEntity.class, UpdateEntity.class })
@ValidNameWithDot(groups = { CreateEntity.class, UpdateEntity.class })
@Override
public String getName() {
    return super.getName();
}
#end_block

#method_before
@Override
public GlusterHooksResource getGlusterHooksResource() {
    return inject(new BackendGlusterHooksResource(this, id));
}
#method_after
@Override
public GlusterHooksResource getGlusterHooksResource() {
    return inject(new BackendGlusterHooksResource(this));
}
#end_block

#method_before
@Mapping(from = GlusterHook.class, to = GlusterHookEntity.class)
public static GlusterHookEntity map(GlusterHook hook, GlusterHookEntity entity) {
    GlusterHookEntity hookEntity = entity != null ? entity : new GlusterHookEntity();
    if (hook.isSetId()) {
        hookEntity.setId(Guid.createGuidFromStringDefaultEmpty(hook.getId()));
    }
    if (hook.isSetName()) {
        hookEntity.setName(hook.getName());
    }
    if (hook.isSetGlusterCommand()) {
        hookEntity.setGlusterCommand(hook.getGlusterCommand());
    }
    if (hook.isSetChecksum()) {
        hookEntity.setChecksum(hook.getChecksum());
    }
    if (hook.isSetContent()) {
        hookEntity.setContent(hook.getContent());
    }
    return hookEntity;
}
#method_after
@Mapping(from = GlusterHook.class, to = GlusterHookEntity.class)
public static GlusterHookEntity map(GlusterHook hook, GlusterHookEntity entity) {
    GlusterHookEntity hookEntity = entity != null ? entity : new GlusterHookEntity();
    if (hook.isSetId()) {
        hookEntity.setId(GuidUtils.asGuid(hook.getId()));
    }
    if (hook.isSetName()) {
        hookEntity.setName(hook.getName());
    }
    if (hook.isSetGlusterCommand()) {
        hookEntity.setGlusterCommand(hook.getGlusterCommand());
    }
    if (hook.isSetChecksum()) {
        hookEntity.setChecksum(hook.getChecksum());
    }
    if (hook.isSetContent()) {
        hookEntity.setContent(hook.getContent());
    }
    return hookEntity;
}
#end_block

#method_before
@Mapping(from = GlusterHookEntity.class, to = GlusterHook.class)
public static GlusterHook map(GlusterHookEntity entity, GlusterHook hook) {
    GlusterHook model = hook != null ? hook : new GlusterHook();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getClusterId() != null) {
        model.setCluster(new Cluster());
        model.getCluster().setId(entity.getClusterId().toString());
    }
    if (entity.getHookKey() != null) {
        model.setName(entity.getHookKey());
    }
    if (entity.getGlusterCommand() != null) {
        model.setGlusterCommand(entity.getGlusterCommand());
    }
    if (entity.getStage() != null) {
        model.setGlusterStage(map(entity.getStage(), null));
    }
    if (entity.getStatus() != null) {
        model.setHookStatus(map(entity.getStatus(), null));
    }
    if (entity.getContentType() != null) {
        model.setContentType(map(entity.getContentType(), null));
    }
    if (entity.getChecksum() != null) {
        model.setChecksum(entity.getChecksum());
    }
    if (entity.getContent() != null) {
        model.setContent(entity.getContent());
    }
    if (entity.getConflictStatus() != null) {
        model.setConflictStatus(entity.getConflictStatus());
        model.setConflicts(mapConflicts(entity));
    }
    if (entity.getServerHooks() != null && !entity.getServerHooks().isEmpty()) {
        model.setServerHooks(new GlusterServerHooks());
        for (GlusterServerHook serverHookEntity : entity.getServerHooks()) {
            model.getServerHooks().getGlusterServerHooks().add(map(serverHookEntity));
        }
    }
    return model;
}
#method_after
@Mapping(from = GlusterHookEntity.class, to = GlusterHook.class)
public static GlusterHook map(GlusterHookEntity entity, GlusterHook hook) {
    GlusterHook model = hook != null ? hook : new GlusterHook();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getClusterId() != null) {
        model.setCluster(new Cluster());
        model.getCluster().setId(entity.getClusterId().toString());
    }
    if (entity.getHookKey() != null) {
        model.setName(entity.getHookKey());
    }
    if (entity.getGlusterCommand() != null) {
        model.setGlusterCommand(entity.getGlusterCommand());
    }
    if (entity.getStage() != null) {
        model.setStage(map(entity.getStage(), null));
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getContentType() != null) {
        model.setContentType(map(entity.getContentType(), null));
    }
    if (entity.getChecksum() != null) {
        model.setChecksum(entity.getChecksum());
    }
    if (entity.getContent() != null) {
        model.setContent(entity.getContent());
    }
    if (entity.getConflictStatus() != null) {
        model.setConflictStatus(entity.getConflictStatus());
        model.setConflicts(mapConflicts(entity));
    }
    if (entity.getServerHooks() != null && !entity.getServerHooks().isEmpty()) {
        model.setServerHooks(new GlusterServerHooks());
        for (GlusterServerHook serverHookEntity : entity.getServerHooks()) {
            model.getServerHooks().getGlusterServerHooks().add(map(serverHookEntity));
        }
    }
    return model;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType hookContentType, String template) {
    switch(hookContentType) {
        case BINARY:
            return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType.BINARY.toString();
        case TEXT:
            return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType.TEXT.toString();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType hookContentType, String template) {
    switch(hookContentType) {
        case BINARY:
            return HookContentType.BINARY.toString();
        case TEXT:
            return HookContentType.TEXT.toString();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStage.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStage hookStage, String template) {
    switch(hookStage) {
        case POST:
            return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStage.POST.toString();
        case PRE:
            return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStage.PRE.toString();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStage.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStage hookStage, String template) {
    switch(hookStage) {
        case POST:
            return HookStage.POST.toString();
        case PRE:
            return HookStage.PRE.toString();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStatus.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStatus hookStatus, String template) {
    switch(hookStatus) {
        case DISABLED:
            return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStatus.DISABLED.toString();
        case ENABLED:
            return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStatus.ENABLED.toString();
        case MISSING:
            return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStatus.MISSING.toString();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStatus.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterHookStatus hookStatus, String template) {
    switch(hookStatus) {
        case DISABLED:
            return HookStatus.DISABLED.toString();
        case ENABLED:
            return HookStatus.ENABLED.toString();
        case MISSING:
            return HookStatus.MISSING.toString();
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public GlusterHooks list() {
    List<GlusterHookEntity> entities = getBackendCollection(VdcQueryType.GetGlusterHooks, new GlusterParameters(asGuid(clusterId)));
    return mapCollection(entities);
}
#method_after
@Override
public GlusterHooks list() {
    List<GlusterHookEntity> entities = getBackendCollection(VdcQueryType.GetGlusterHooks, new GlusterParameters(asGuid(parent.get().getId())));
    return mapCollection(entities);
}
#end_block

#method_before
@Override
protected GlusterHook addParents(GlusterHook hook) {
    hook.setCluster(new Cluster());
    hook.getCluster().setId(clusterId);
    return hook;
}
#method_after
@Override
protected GlusterHook addParents(GlusterHook hook) {
    hook.setCluster(parent.get());
    return hook;
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.DeleteGlusterVolume, new GlusterVolumeParameters(asGuid(id)));
}
#method_after
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.RemoveGlusterHook, new GlusterHookManageParameters(asGuid(id)));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    parentMock = control.createMock(BackendClusterResource.class);
    collection.setParent(parentMock);
    setupListExpectations();
}
#method_after
@Override
protected void init() {
    super.init();
    parentMock = control.createMock(BackendClusterResource.class);
    Cluster cluster = new Cluster();
    cluster.setId(clusterId.toString());
    expect(parentMock.get()).andReturn(cluster).anyTimes();
    collection.setParent(parentMock);
    setupListExpectations();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getAction() == null) {
        return failCanDoAction(VdcBllMessages.WATCHDOG_ACTION_REQUIRED);
    }
    if (getParameters().getModel() == null) {
        return failCanDoAction(VdcBllMessages.WATCHDOG_MODEL_REQUIRED);
    }
    VdcQueryReturnValue returnValue = getBackend().runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getId()));
    @SuppressWarnings("unchecked")
    Collection<VmWatchdog> watchdogs = (Collection<VmWatchdog>) returnValue.getReturnValue();
    if (!watchdogs.isEmpty()) {
        return failCanDoAction(VdcBllMessages.WATCHDOG_ALREADY_EXISTS);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getAction() == null) {
        return failCanDoAction(VdcBllMessages.WATCHDOG_ACTION_REQUIRED);
    }
    if (getParameters().getModel() == null) {
        return failCanDoAction(VdcBllMessages.WATCHDOG_MODEL_REQUIRED);
    }
    VdcQueryReturnValue returnValue = getBackend().runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getId()));
    Collection<VmWatchdog> watchdogs = returnValue.getReturnValue();
    if (!watchdogs.isEmpty()) {
        return failCanDoAction(VdcBllMessages.WATCHDOG_ALREADY_EXISTS);
    }
    return true;
}
#end_block

#method_before
@Override
@SingleEntityResource
public DeviceResource<WatchDog> getDeviceSubResource(String id) {
    return inject(new BackendWatchdogResource(asGuidOr404(id), this, updateType, getUpdateParametersProvider(), getRequiredUpdateFields()));
}
#method_after
@Override
@SingleEntityResource
public WatchdogResource getDeviceSubResource(String id) {
    return inject(new BackendWatchdogResource(asGuidOr404(id), this, updateType, getUpdateParametersProvider(), getRequiredUpdateFields()));
}
#end_block

#method_before
@Override
protected VdcActionParametersBase getAddParameters(VmWatchdog entity, WatchDog device) {
    WatchdogParameters watchdogParameters = new WatchdogParameters();
    watchdogParameters.setAction(getMapper(WatchdogAction.class, VmWatchdogAction.class).map(WatchdogAction.valueOf(StringUtils.upperCase(device.getAction())), null));
    watchdogParameters.setModel(getMapper(WatchdogModel.class, VmWatchdogType.class).map(WatchdogModel.valueOf(StringUtils.upperCase(device.getModel())), null));
    watchdogParameters.setId(parentId);
    watchdogParameters.setVm(isVm(parentId));
    return watchdogParameters;
}
#method_after
@Override
protected VdcActionParametersBase getAddParameters(VmWatchdog entity, WatchDog device) {
    WatchdogParameters watchdogParameters = new WatchdogParameters();
    validateEnums(WatchDog.class, device);
    watchdogParameters.setAction(getMapper(WatchdogAction.class, VmWatchdogAction.class).map(WatchdogAction.fromValue(device.getAction()), null));
    watchdogParameters.setModel(getMapper(WatchdogModel.class, VmWatchdogType.class).map(WatchdogModel.fromValue(device.getModel()), null));
    watchdogParameters.setId(parentId);
    watchdogParameters.setVm(isVm(parentId));
    return watchdogParameters;
}
#end_block

#method_before
@Override
protected ParametersProvider<WatchDog, VmWatchdog> getUpdateParametersProvider() {
    return new ParametersProvider<WatchDog, VmWatchdog>() {

        public VdcActionParametersBase getParameters(WatchDog model, VmWatchdog entity) {
            WatchdogParameters params = new WatchdogParameters();
            params.setModel(VmWatchdogType.getByName(model.getModel()));
            params.setAction(VmWatchdogAction.getByName(model.getAction()));
            params.setId(parentId);
            params.setVm(isVm(parentId));
            return params;
        }
    };
}
#method_after
@Override
protected ParametersProvider<WatchDog, VmWatchdog> getUpdateParametersProvider() {
    return new ParametersProvider<WatchDog, VmWatchdog>() {

        public VdcActionParametersBase getParameters(WatchDog model, VmWatchdog entity) {
            validateEnums(WatchDog.class, model);
            WatchdogParameters params = new WatchdogParameters();
            params.setModel(VmWatchdogType.getByName(model.getModel()));
            params.setAction(VmWatchdogAction.getByName(model.getAction()));
            params.setId(parentId);
            params.setVm(isVm(parentId));
            return params;
        }
    };
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(super.getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.REMOTE_VM, getVmIsBeingImportedMessage()));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(getParameters().getContainerId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.REMOTE_VM, getVmIsBeingImportedMessage()));
}
#end_block

#method_before
private void switchSuggestions() {
    if (!isEnabled()) {
        return;
    }
    if (isSuggestionListShowing()) {
        hideSuggestions();
        adjustSelectedValue();
    } else {
        // show all the suggestions even if there is already something filled
        // otherwise it is not obvious that there are more options
        suggestBox.setText(null);
        suggestBox.showSuggestionList();
        Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

            public void execute() {
                setFocus(true);
            }
        });
    }
}
#method_after
private void switchSuggestions() {
    if (!isEnabled()) {
        return;
    }
    if (isSuggestionListShowing()) {
        hideSuggestions();
        adjustSelectedValue();
    } else {
        // show all the suggestions even if there is already something filled
        // otherwise it is not obvious that there are more options
        suggestBox.setText(null);
        suggestBox.showSuggestionList();
        selectInMenu(getValue());
        Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

            public void execute() {
                setFocus(true);
            }
        });
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private Response addDomain(VdcActionType action, StorageDomain model, StorageDomainStatic entity, Guid hostId) {
    StorageServerConnections cnx = mapToCnx(model);
    entity.setStorage(addStorageServerConnection(cnx, hostId));
    if (action == VdcActionType.AddNFSStorageDomain) {
        org.ovirt.engine.core.common.businessentities.StorageDomain existing = getExistingStorageDomain(hostId, entity.getStorageType(), entity.getStorageDomainType(), cnx);
        if (existing != null) {
            entity = existing.getStorageStaticData();
            action = VdcActionType.AddExistingFileStorageDomain;
        }
    }
    if (action != VdcActionType.AddExistingFileStorageDomain) {
        validateParameters(model, 2, "name");
    }
    return performCreate(action, getAddParams(entity, hostId), ID_RESOLVER);
}
#method_after
private Response addDomain(VdcActionType action, StorageDomain model, StorageDomainStatic entity, Guid hostId, StorageServerConnections connection) {
    if (connection.getstorage_type().isFileDomain() && StringUtils.isEmpty(connection.getid())) {
        connection.setid(addStorageServerConnection(connection, hostId));
    }
    entity.setStorage(connection.getid());
    if (action == VdcActionType.AddNFSStorageDomain) {
        org.ovirt.engine.core.common.businessentities.StorageDomain existing = getExistingStorageDomain(hostId, entity.getStorageType(), entity.getStorageDomainType(), connection);
        if (existing != null) {
            entity = existing.getStorageStaticData();
            action = VdcActionType.AddExistingFileStorageDomain;
        }
    }
    if (action != VdcActionType.AddExistingFileStorageDomain) {
        validateParameters(model, 2, "name");
    }
    return performCreate(action, getAddParams(entity, hostId), ID_RESOLVER);
}
#end_block

#method_before
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "host.id|name", "type", "storage.type");
    validateEnums(StorageDomain.class, storageDomain);
    StorageDomainStatic entity = mapToStatic(storageDomain);
    Guid hostId = getHostId(storageDomain);
    Response resp = null;
    switch(entity.getStorageType()) {
        case ISCSI:
        case FCP:
            resp = addSAN(storageDomain, entity.getStorageType(), entity, hostId);
            break;
        case NFS:
            validateParameters(storageDomain.getStorage(), "address", "path");
            resp = addDomain(VdcActionType.AddNFSStorageDomain, storageDomain, entity, hostId);
            break;
        case LOCALFS:
            validateParameters(storageDomain.getStorage(), "path");
            resp = addDomain(VdcActionType.AddLocalStorageDomain, storageDomain, entity, hostId);
            break;
        case POSIXFS:
            validateParameters(storageDomain.getStorage(), "path", "vfsType");
            resp = addDomain(VdcActionType.AddPosixFsStorageDomain, storageDomain, entity, hostId);
            break;
        case GLUSTERFS:
            validateParameters(storageDomain.getStorage(), "path", "vfsType");
            resp = addDomain(VdcActionType.AddGlusterFsStorageDomain, storageDomain, entity, hostId);
            break;
        default:
            break;
    }
    if (resp != null) {
        addLinks(((StorageDomain) resp.getEntity()), getLinksToExclude(storageDomain));
    }
    return resp;
}
#method_after
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "host.id|name", "type", "storage");
    Storage storageConnectionFromUser = storageDomain.getStorage();
    validateEnums(StorageDomain.class, storageDomain);
    Guid hostId = getHostId(storageDomain);
    StorageServerConnections cnx = null;
    if (!storageConnectionFromUser.isSetId()) {
        validateParameters(storageDomain, "storage.type");
        cnx = mapToCnx(storageDomain);
        if (cnx.getstorage_type().isFileDomain()) {
            validateParameters(storageConnectionFromUser, "path");
        }
    } else {
        cnx = getStorageServerConnection(storageConnectionFromUser.getId());
        storageDomain.getStorage().setType(mapType(cnx.getstorage_type()));
    }
    StorageDomainStatic entity = mapToStatic(storageDomain);
    Response resp = null;
    switch(entity.getStorageType()) {
        case ISCSI:
        case FCP:
            resp = addSAN(storageDomain, entity.getStorageType(), entity, hostId);
            break;
        case NFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "address");
            }
            resp = addDomain(VdcActionType.AddNFSStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case LOCALFS:
            resp = addDomain(VdcActionType.AddLocalStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case POSIXFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "vfsType");
            }
            resp = addDomain(VdcActionType.AddPosixFsStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case GLUSTERFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "vfsType");
            }
            resp = addDomain(VdcActionType.AddGlusterFsStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        default:
            break;
    }
    if (resp != null) {
        addLinks(((StorageDomain) resp.getEntity()), getLinksToExclude(storageDomain));
    }
    return resp;
}
#end_block

#method_before
public static synchronized String[] getLinksToExclude(StorageDomain storageDomain) {
    return isIsoDomain(storageDomain) ? new String[] { "templates", "vms", "disks", "images" } : isExportDomain(storageDomain) ? new String[] { "files", "images" } : isImageDomain(storageDomain) ? new String[] { "templates", "vms", "files", "disks" } : new String[] { "templates", "vms", "files", "images" };
}
#method_after
public static synchronized String[] getLinksToExclude(StorageDomain storageDomain) {
    return isIsoDomain(storageDomain) ? new String[] { "templates", "vms", "disks", "storageconnections", "images" } : isExportDomain(storageDomain) ? new String[] { "files", "storageconnections", "images" } : isImageDomain(storageDomain) ? new String[] { "templates", "vms", "files", "disks", "storageconnections" } : new String[] { "templates", "vms", "files", "images" };
}
#end_block

#method_before
@Override
public ImagesResource getImagesResource() {
    return inject(new BackendStorageDomainImagesResource(guid));
}
#method_after
public ImagesResource getImagesResource() {
    return inject(new BackendStorageDomainImagesResource(guid));
}
#end_block

#method_before
public Guid getStorageDomainId() {
    return storageDomainId;
}
#method_after
public Guid getStorageDomainId() {
    return parent.getStorageDomainId();
}
#end_block

#method_before
@Override
public Response doImport(Action action) {
    validateParameters(action, "storageDomain.id|name");
    ImportRepoImageParameters importParameters = new ImportRepoImageParameters();
    importParameters.setSourceRepoImageId(id);
    importParameters.setSourceStorageDomainId(getStorageDomainId());
    importParameters.setStoragePoolId(getDataCenterId(getStorageDomainId(action)));
    importParameters.setStorageDomainId(getStorageDomainId(action));
    /* TODO:
        Quota selectedQuota = (Quota) getQuota().getSelectedItem();

        if (selectedQuota != null) {
            importParameters.setQuotaId(selectedQuota.getId());
        }
*/
    return doAction(VdcActionType.ImportRepoImage, importParameters, action);
}
#method_after
@Override
public Response doImport(Action action) {
    validateParameters(action, "storageDomain.id|name");
    ImportRepoImageParameters importParameters = new ImportRepoImageParameters();
    importParameters.setSourceRepoImageId(id);
    importParameters.setSourceStorageDomainId(getStorageDomainId());
    importParameters.setStoragePoolId(getDataCenterId(getStorageDomainId(action)));
    importParameters.setStorageDomainId(getStorageDomainId(action));
    return doAction(VdcActionType.ImportRepoImage, importParameters, action);
}
#end_block

#method_before
@Override
public ImageResource getDeviceSubResource(String id) {
    return inject(new BackendStorageDomainImageResource(id, this));
}
#method_after
@Override
@SingleEntityResource
public ImageResource getDeviceSubResource(String id) {
    return inject(new BackendStorageDomainImageResource(id, this));
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    // TODO: removal is not implemented yet
    return Response.serverError().build();
}
#method_after
@Override
protected Response performRemove(String id) {
    // TODO: removal is not implemented yet
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
protected void syncSearch() {
    super.syncSearch();
    final AsyncQuery dcQuery = new AsyncQuery();
    dcQuery.setModel(this);
    dcQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            final SystemTreeModel systemTreeModel = (SystemTreeModel) model;
            systemTreeModel.setDataCenters((ArrayList<StoragePool>) result);
            AsyncQuery clusterQuery = new AsyncQuery();
            clusterQuery.setModel(systemTreeModel);
            clusterQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    SystemTreeModel systemTreeModel1 = (SystemTreeModel) model1;
                    ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result1;
                    systemTreeModel1.setClusterMap(new HashMap<Guid, ArrayList<VDSGroup>>());
                    for (VDSGroup cluster : clusters) {
                        if (cluster.getStoragePoolId() != null) {
                            Guid key = cluster.getStoragePoolId().getValue();
                            if (!systemTreeModel1.getClusterMap().containsKey(key)) {
                                systemTreeModel1.getClusterMap().put(key, new ArrayList<VDSGroup>());
                            }
                            ArrayList<VDSGroup> list1 = systemTreeModel1.getClusterMap().get(key);
                            list1.add(cluster);
                        }
                    }
                    AsyncQuery hostQuery = new AsyncQuery();
                    hostQuery.setModel(systemTreeModel1);
                    hostQuery.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model2, Object result2) {
                            SystemTreeModel systemTreeModel2 = (SystemTreeModel) model2;
                            ArrayList<VDS> hosts = (ArrayList<VDS>) result2;
                            systemTreeModel2.setHostMap(new HashMap<Guid, ArrayList<VDS>>());
                            for (VDS host : hosts) {
                                Guid key = host.getVdsGroupId();
                                if (!systemTreeModel2.getHostMap().containsKey(key)) {
                                    systemTreeModel2.getHostMap().put(key, new ArrayList<VDS>());
                                }
                                ArrayList<VDS> list = systemTreeModel2.getHostMap().get(key);
                                list.add(host);
                            }
                            AsyncQuery volumeQuery = new AsyncQuery();
                            volumeQuery.setModel(systemTreeModel2);
                            volumeQuery.asyncCallback = new INewAsyncCallback() {

                                @Override
                                public void onSuccess(Object model3, Object result3) {
                                    SystemTreeModel systemTreeModel3 = (SystemTreeModel) model3;
                                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result3;
                                    systemTreeModel3.setVolumeMap(new HashMap<Guid, ArrayList<GlusterVolumeEntity>>());
                                    for (GlusterVolumeEntity volume : volumes) {
                                        Guid key = volume.getClusterId();
                                        if (!systemTreeModel3.getVolumeMap().containsKey(key)) {
                                            systemTreeModel3.getVolumeMap().put(key, new ArrayList<GlusterVolumeEntity>());
                                        }
                                        ArrayList<GlusterVolumeEntity> list = systemTreeModel3.getVolumeMap().get(key);
                                        list.add(volume);
                                    }
                                    // Networks
                                    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
                                    ArrayList<VdcQueryParametersBase> queryParamList = new ArrayList<VdcQueryParametersBase>();
                                    for (StoragePool dataCenter : systemTreeModel.getDataCenters()) {
                                        queryTypeList.add(VdcQueryType.GetAllNetworks);
                                        queryParamList.add(new IdQueryParameters(dataCenter.getId()));
                                    }
                                    Frontend.RunMultipleQueries(queryTypeList, queryParamList, new IFrontendMultipleQueryAsyncCallback() {

                                        @Override
                                        public void executed(FrontendMultipleQueryAsyncResult result) {
                                            systemTreeModel.setNetworkMap(new HashMap<Guid, List<Network>>());
                                            List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                                            List<Network> dcNetworkList;
                                            Guid dcId;
                                            for (int i = 0; i < returnValueList.size(); i++) {
                                                VdcQueryReturnValue returnValue = returnValueList.get(i);
                                                if (returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                                                    dcNetworkList = (List<Network>) returnValue.getReturnValue();
                                                    dcId = systemTreeModel.getDataCenters().get(i).getId();
                                                    systemTreeModel.getNetworkMap().put(dcId, dcNetworkList);
                                                }
                                            }
                                            // Storages
                                            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
                                            ArrayList<VdcQueryParametersBase> queryParamList = new ArrayList<VdcQueryParametersBase>();
                                            for (StoragePool dataCenter : systemTreeModel.getDataCenters()) {
                                                queryTypeList.add(VdcQueryType.GetStorageDomainsByStoragePoolId);
                                                queryParamList.add(new IdQueryParameters(dataCenter.getId()));
                                            }
                                            if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.VirtOnly.getValue()) == 0) {
                                                FrontendMultipleQueryAsyncResult dummyResult = new FrontendMultipleQueryAsyncResult();
                                                VdcQueryReturnValue value = new VdcQueryReturnValue();
                                                value.setSucceeded(true);
                                                dummyResult.getReturnValues().add(value);
                                                SystemTreeModel.this.executed(dummyResult);
                                            } else {
                                                Frontend.RunMultipleQueries(queryTypeList, queryParamList, systemTreeModel);
                                            }
                                        }
                                    });
                                }
                            };
                            AsyncDataProvider.getVolumeList(volumeQuery, null);
                        }
                    };
                    AsyncDataProvider.getHostList(hostQuery);
                }
            };
            AsyncDataProvider.getClusterList(clusterQuery);
        }
    };
    AsyncQuery providersQuery = new AsyncQuery();
    providersQuery.setModel(this);
    providersQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object returnValue) {
            setProviders((List<Provider>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            AsyncDataProvider.getDataCenterList(dcQuery);
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), providersQuery);
}
#method_after
@Override
protected void syncSearch() {
    super.syncSearch();
    final AsyncQuery dcQuery = new AsyncQuery();
    dcQuery.setModel(this);
    dcQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            final SystemTreeModel systemTreeModel = (SystemTreeModel) model;
            systemTreeModel.setDataCenters((ArrayList<StoragePool>) result);
            AsyncQuery clusterQuery = new AsyncQuery();
            clusterQuery.setModel(systemTreeModel);
            clusterQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    SystemTreeModel systemTreeModel1 = (SystemTreeModel) model1;
                    ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result1;
                    systemTreeModel1.setClusterMap(new HashMap<Guid, ArrayList<VDSGroup>>());
                    for (VDSGroup cluster : clusters) {
                        if (cluster.getStoragePoolId() != null) {
                            Guid key = cluster.getStoragePoolId();
                            if (!systemTreeModel1.getClusterMap().containsKey(key)) {
                                systemTreeModel1.getClusterMap().put(key, new ArrayList<VDSGroup>());
                            }
                            ArrayList<VDSGroup> list1 = systemTreeModel1.getClusterMap().get(key);
                            list1.add(cluster);
                        }
                    }
                    AsyncQuery hostQuery = new AsyncQuery();
                    hostQuery.setModel(systemTreeModel1);
                    hostQuery.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model2, Object result2) {
                            SystemTreeModel systemTreeModel2 = (SystemTreeModel) model2;
                            ArrayList<VDS> hosts = (ArrayList<VDS>) result2;
                            systemTreeModel2.setHostMap(new HashMap<Guid, ArrayList<VDS>>());
                            for (VDS host : hosts) {
                                Guid key = host.getVdsGroupId();
                                if (!systemTreeModel2.getHostMap().containsKey(key)) {
                                    systemTreeModel2.getHostMap().put(key, new ArrayList<VDS>());
                                }
                                ArrayList<VDS> list = systemTreeModel2.getHostMap().get(key);
                                list.add(host);
                            }
                            AsyncQuery volumeQuery = new AsyncQuery();
                            volumeQuery.setModel(systemTreeModel2);
                            volumeQuery.asyncCallback = new INewAsyncCallback() {

                                @Override
                                public void onSuccess(Object model3, Object result3) {
                                    SystemTreeModel systemTreeModel3 = (SystemTreeModel) model3;
                                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result3;
                                    systemTreeModel3.setVolumeMap(new HashMap<Guid, ArrayList<GlusterVolumeEntity>>());
                                    for (GlusterVolumeEntity volume : volumes) {
                                        Guid key = volume.getClusterId();
                                        if (!systemTreeModel3.getVolumeMap().containsKey(key)) {
                                            systemTreeModel3.getVolumeMap().put(key, new ArrayList<GlusterVolumeEntity>());
                                        }
                                        ArrayList<GlusterVolumeEntity> list = systemTreeModel3.getVolumeMap().get(key);
                                        list.add(volume);
                                    }
                                    // Networks
                                    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
                                    ArrayList<VdcQueryParametersBase> queryParamList = new ArrayList<VdcQueryParametersBase>();
                                    for (StoragePool dataCenter : systemTreeModel.getDataCenters()) {
                                        queryTypeList.add(VdcQueryType.GetAllNetworks);
                                        queryParamList.add(new IdQueryParameters(dataCenter.getId()));
                                    }
                                    Frontend.RunMultipleQueries(queryTypeList, queryParamList, new IFrontendMultipleQueryAsyncCallback() {

                                        @Override
                                        public void executed(FrontendMultipleQueryAsyncResult result) {
                                            systemTreeModel.setNetworkMap(new HashMap<Guid, List<Network>>());
                                            List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                                            List<Network> dcNetworkList;
                                            Guid dcId;
                                            for (int i = 0; i < returnValueList.size(); i++) {
                                                VdcQueryReturnValue returnValue = returnValueList.get(i);
                                                if (returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                                                    dcNetworkList = (List<Network>) returnValue.getReturnValue();
                                                    dcId = systemTreeModel.getDataCenters().get(i).getId();
                                                    systemTreeModel.getNetworkMap().put(dcId, dcNetworkList);
                                                }
                                            }
                                            // Storages
                                            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
                                            ArrayList<VdcQueryParametersBase> queryParamList = new ArrayList<VdcQueryParametersBase>();
                                            for (StoragePool dataCenter : systemTreeModel.getDataCenters()) {
                                                queryTypeList.add(VdcQueryType.GetStorageDomainsByStoragePoolId);
                                                queryParamList.add(new IdQueryParameters(dataCenter.getId()));
                                            }
                                            if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.VirtOnly.getValue()) == 0) {
                                                FrontendMultipleQueryAsyncResult dummyResult = new FrontendMultipleQueryAsyncResult();
                                                VdcQueryReturnValue value = new VdcQueryReturnValue();
                                                value.setSucceeded(true);
                                                dummyResult.getReturnValues().add(value);
                                                SystemTreeModel.this.executed(dummyResult);
                                            } else {
                                                Frontend.RunMultipleQueries(queryTypeList, queryParamList, systemTreeModel);
                                            }
                                        }
                                    });
                                }
                            };
                            AsyncDataProvider.getVolumeList(volumeQuery, null);
                        }
                    };
                    AsyncDataProvider.getHostList(hostQuery);
                }
            };
            AsyncDataProvider.getClusterList(clusterQuery);
        }
    };
    AsyncQuery providersQuery = new AsyncQuery();
    providersQuery.setModel(this);
    providersQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object returnValue) {
            setProviders((List<Provider>) returnValue);
            AsyncDataProvider.getDataCenterList(dcQuery);
        }
    };
    AsyncDataProvider.GetAllProviders(providersQuery);
}
#end_block

#method_before
@Override
public void executed(FrontendMultipleQueryAsyncResult result) {
    ArrayList<StorageDomain> storages = null;
    int count = -1;
    treeItemById = new HashMap<Guid, SystemTreeItemModel>();
    // Build tree items.
    SystemTreeItemModel systemItem = new SystemTreeItemModel();
    systemItem.setType(SystemTreeItemType.System);
    systemItem.setIsSelected(true);
    systemItem.setTitle(ConstantsManager.getInstance().getConstants().systemTitle());
    // Add Data Centers node under System
    SystemTreeItemModel dataCentersItem = new SystemTreeItemModel();
    dataCentersItem.setType(SystemTreeItemType.DataCenters);
    dataCentersItem.setApplicationMode(ApplicationMode.VirtOnly);
    dataCentersItem.setTitle(ConstantsManager.getInstance().getConstants().dataCentersTitle());
    systemItem.addChild(dataCentersItem);
    // Populate everything under Data Centers
    for (VdcQueryReturnValue returnValue : result.getReturnValues()) {
        ++count;
        if (!returnValue.getSucceeded()) {
            continue;
        }
        storages = (ArrayList<StorageDomain>) returnValue.getReturnValue();
        SystemTreeItemModel dataCenterItem = new SystemTreeItemModel();
        dataCenterItem.setType(SystemTreeItemType.DataCenter);
        dataCenterItem.setApplicationMode(ApplicationMode.VirtOnly);
        dataCenterItem.setTitle(getDataCenters().get(count).getname());
        dataCenterItem.setEntity(getDataCenters().get(count));
        dataCentersItem.addChild(dataCenterItem);
        SystemTreeItemModel storagesItem = new SystemTreeItemModel();
        storagesItem.setType(SystemTreeItemType.Storages);
        storagesItem.setApplicationMode(ApplicationMode.VirtOnly);
        storagesItem.setTitle(ConstantsManager.getInstance().getConstants().storageTitle());
        storagesItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(storagesItem);
        if (storages != null && storages.size() > 0) {
            for (StorageDomain storage : storages) {
                SystemTreeItemModel storageItem = new SystemTreeItemModel();
                storageItem.setType(SystemTreeItemType.Storage);
                storageItem.setApplicationMode(ApplicationMode.VirtOnly);
                storageItem.setTitle(storage.getStorageName());
                storageItem.setEntity(storage);
                storagesItem.addChild(storageItem);
            }
        }
        SystemTreeItemModel networksItem = new SystemTreeItemModel();
        networksItem.setType(SystemTreeItemType.Networks);
        networksItem.setApplicationMode(ApplicationMode.VirtOnly);
        networksItem.setTitle(ConstantsManager.getInstance().getConstants().networksTitle());
        networksItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(networksItem);
        List<Network> dcNetworks = getNetworkMap().get(getDataCenters().get(count).getId());
        if (dcNetworks != null) {
            for (Network network : dcNetworks) {
                SystemTreeItemModel networkItem = new SystemTreeItemModel();
                networkItem.setType(SystemTreeItemType.Network);
                networkItem.setApplicationMode(ApplicationMode.VirtOnly);
                networkItem.setTitle(network.getName());
                networkItem.setEntity(network);
                networksItem.addChild(networkItem);
                treeItemById.put(network.getId(), networkItem);
            }
        }
        SystemTreeItemModel templatesItem = new SystemTreeItemModel();
        templatesItem.setType(SystemTreeItemType.Templates);
        templatesItem.setApplicationMode(ApplicationMode.VirtOnly);
        templatesItem.setTitle(ConstantsManager.getInstance().getConstants().templatesTitle());
        templatesItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(templatesItem);
        SystemTreeItemModel clustersItem = new SystemTreeItemModel();
        clustersItem.setType(SystemTreeItemType.Clusters);
        clustersItem.setTitle(ConstantsManager.getInstance().getConstants().clustersTitle());
        clustersItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(clustersItem);
        if (getClusterMap().containsKey(getDataCenters().get(count).getId())) {
            for (VDSGroup cluster : getClusterMap().get(getDataCenters().get(count).getId())) {
                SystemTreeItemModel clusterItem = new SystemTreeItemModel();
                clusterItem.setType(cluster.supportsGlusterService() ? SystemTreeItemType.Cluster_Gluster : SystemTreeItemType.Cluster);
                clusterItem.setTitle(cluster.getname());
                clusterItem.setEntity(cluster);
                clustersItem.addChild(clusterItem);
                SystemTreeItemModel hostsItem = new SystemTreeItemModel();
                hostsItem.setType(SystemTreeItemType.Hosts);
                hostsItem.setTitle(ConstantsManager.getInstance().getConstants().hostsTitle());
                hostsItem.setEntity(cluster);
                clusterItem.addChild(hostsItem);
                if (getHostMap().containsKey(cluster.getId())) {
                    for (VDS host : getHostMap().get(cluster.getId())) {
                        SystemTreeItemModel hostItem = new SystemTreeItemModel();
                        hostItem.setType(SystemTreeItemType.Host);
                        hostItem.setTitle(host.getName());
                        hostItem.setEntity(host);
                        hostsItem.addChild(hostItem);
                    }
                }
                if (cluster.supportsGlusterService()) {
                    SystemTreeItemModel volumesItem = new SystemTreeItemModel();
                    volumesItem.setType(SystemTreeItemType.Volumes);
                    volumesItem.setApplicationMode(ApplicationMode.GlusterOnly);
                    volumesItem.setTitle(ConstantsManager.getInstance().getConstants().volumesTitle());
                    volumesItem.setEntity(cluster);
                    clusterItem.addChild(volumesItem);
                    if (getVolumeMap().containsKey(cluster.getId())) {
                        for (GlusterVolumeEntity volume : getVolumeMap().get(cluster.getId())) {
                            SystemTreeItemModel volumeItem = new SystemTreeItemModel();
                            volumeItem.setType(SystemTreeItemType.Volume);
                            volumeItem.setApplicationMode(ApplicationMode.GlusterOnly);
                            volumeItem.setTitle(volume.getName());
                            volumeItem.setEntity(volume);
                            volumesItem.addChild(volumeItem);
                        }
                    }
                }
                if (cluster.supportsVirtService()) {
                    SystemTreeItemModel vmsItem = new SystemTreeItemModel();
                    vmsItem.setType(SystemTreeItemType.VMs);
                    vmsItem.setApplicationMode(ApplicationMode.VirtOnly);
                    vmsItem.setTitle(ConstantsManager.getInstance().getConstants().vmsTitle());
                    vmsItem.setEntity(cluster);
                    clusterItem.addChild(vmsItem);
                }
            }
        }
    }
    // Add Providers node under System
    SystemTreeItemModel providersItem = new SystemTreeItemModel();
    providersItem.setType(SystemTreeItemType.Providers);
    providersItem.setApplicationMode(ApplicationMode.VirtOnly);
    providersItem.setTitle(ConstantsManager.getInstance().getConstants().externalProvidersTitle());
    systemItem.addChild(providersItem);
    // Populate with providers
    for (Provider provider : getProviders()) {
        SystemTreeItemModel providerItem = new SystemTreeItemModel();
        providerItem.setType(SystemTreeItemType.Provider);
        providerItem.setApplicationMode(ApplicationMode.VirtOnly);
        providerItem.setTitle(provider.getName());
        providerItem.setEntity(provider);
        providersItem.addChild(providerItem);
        treeItemById.put(provider.getId(), providerItem);
    }
    if (!ApplicationModeHelper.getUiMode().equals(ApplicationMode.AllModes)) {
        ApplicationModeHelper.filterSystemTreeByApplictionMode(systemItem);
    }
    setItems(new ArrayList<SystemTreeItemModel>(Arrays.asList(new SystemTreeItemModel[] { systemItem })));
}
#method_after
@Override
public void executed(FrontendMultipleQueryAsyncResult result) {
    ArrayList<StorageDomain> storages = null;
    int count = -1;
    treeItemById = new HashMap<Guid, SystemTreeItemModel>();
    // Build tree items.
    SystemTreeItemModel systemItem = new SystemTreeItemModel();
    systemItem.setType(SystemTreeItemType.System);
    systemItem.setIsSelected(true);
    systemItem.setTitle(ConstantsManager.getInstance().getConstants().systemTitle());
    // Add Data Centers node under System
    SystemTreeItemModel dataCentersItem = new SystemTreeItemModel();
    dataCentersItem.setType(SystemTreeItemType.DataCenters);
    dataCentersItem.setApplicationMode(ApplicationMode.VirtOnly);
    dataCentersItem.setTitle(ConstantsManager.getInstance().getConstants().dataCentersTitle());
    systemItem.addChild(dataCentersItem);
    // Populate everything under Data Centers
    for (VdcQueryReturnValue returnValue : result.getReturnValues()) {
        ++count;
        if (!returnValue.getSucceeded()) {
            continue;
        }
        storages = (ArrayList<StorageDomain>) returnValue.getReturnValue();
        SystemTreeItemModel dataCenterItem = new SystemTreeItemModel();
        dataCenterItem.setType(SystemTreeItemType.DataCenter);
        dataCenterItem.setApplicationMode(ApplicationMode.VirtOnly);
        dataCenterItem.setTitle(getDataCenters().get(count).getName());
        dataCenterItem.setEntity(getDataCenters().get(count));
        dataCentersItem.addChild(dataCenterItem);
        SystemTreeItemModel storagesItem = new SystemTreeItemModel();
        storagesItem.setType(SystemTreeItemType.Storages);
        storagesItem.setApplicationMode(ApplicationMode.VirtOnly);
        storagesItem.setTitle(ConstantsManager.getInstance().getConstants().storageTitle());
        storagesItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(storagesItem);
        if (storages != null && storages.size() > 0) {
            for (StorageDomain storage : storages) {
                SystemTreeItemModel storageItem = new SystemTreeItemModel();
                storageItem.setType(SystemTreeItemType.Storage);
                storageItem.setApplicationMode(ApplicationMode.VirtOnly);
                storageItem.setTitle(storage.getStorageName());
                storageItem.setEntity(storage);
                storagesItem.addChild(storageItem);
            }
        }
        SystemTreeItemModel networksItem = new SystemTreeItemModel();
        networksItem.setType(SystemTreeItemType.Networks);
        networksItem.setApplicationMode(ApplicationMode.VirtOnly);
        networksItem.setTitle(ConstantsManager.getInstance().getConstants().networksTitle());
        networksItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(networksItem);
        List<Network> dcNetworks = getNetworkMap().get(getDataCenters().get(count).getId());
        if (dcNetworks != null) {
            for (Network network : dcNetworks) {
                SystemTreeItemModel networkItem = new SystemTreeItemModel();
                networkItem.setType(SystemTreeItemType.Network);
                networkItem.setApplicationMode(ApplicationMode.VirtOnly);
                networkItem.setTitle(network.getName());
                networkItem.setEntity(network);
                networksItem.addChild(networkItem);
                treeItemById.put(network.getId(), networkItem);
            }
        }
        SystemTreeItemModel templatesItem = new SystemTreeItemModel();
        templatesItem.setType(SystemTreeItemType.Templates);
        templatesItem.setApplicationMode(ApplicationMode.VirtOnly);
        templatesItem.setTitle(ConstantsManager.getInstance().getConstants().templatesTitle());
        templatesItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(templatesItem);
        SystemTreeItemModel clustersItem = new SystemTreeItemModel();
        clustersItem.setType(SystemTreeItemType.Clusters);
        clustersItem.setTitle(ConstantsManager.getInstance().getConstants().clustersTitle());
        clustersItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(clustersItem);
        if (getClusterMap().containsKey(getDataCenters().get(count).getId())) {
            for (VDSGroup cluster : getClusterMap().get(getDataCenters().get(count).getId())) {
                SystemTreeItemModel clusterItem = new SystemTreeItemModel();
                clusterItem.setType(cluster.supportsGlusterService() ? SystemTreeItemType.Cluster_Gluster : SystemTreeItemType.Cluster);
                clusterItem.setTitle(cluster.getName());
                clusterItem.setEntity(cluster);
                clustersItem.addChild(clusterItem);
                SystemTreeItemModel hostsItem = new SystemTreeItemModel();
                hostsItem.setType(SystemTreeItemType.Hosts);
                hostsItem.setTitle(ConstantsManager.getInstance().getConstants().hostsTitle());
                hostsItem.setEntity(cluster);
                clusterItem.addChild(hostsItem);
                if (getHostMap().containsKey(cluster.getId())) {
                    for (VDS host : getHostMap().get(cluster.getId())) {
                        SystemTreeItemModel hostItem = new SystemTreeItemModel();
                        hostItem.setType(SystemTreeItemType.Host);
                        hostItem.setTitle(host.getName());
                        hostItem.setEntity(host);
                        hostsItem.addChild(hostItem);
                    }
                }
                if (cluster.supportsGlusterService()) {
                    SystemTreeItemModel volumesItem = new SystemTreeItemModel();
                    volumesItem.setType(SystemTreeItemType.Volumes);
                    volumesItem.setApplicationMode(ApplicationMode.GlusterOnly);
                    volumesItem.setTitle(ConstantsManager.getInstance().getConstants().volumesTitle());
                    volumesItem.setEntity(cluster);
                    clusterItem.addChild(volumesItem);
                    if (getVolumeMap().containsKey(cluster.getId())) {
                        for (GlusterVolumeEntity volume : getVolumeMap().get(cluster.getId())) {
                            SystemTreeItemModel volumeItem = new SystemTreeItemModel();
                            volumeItem.setType(SystemTreeItemType.Volume);
                            volumeItem.setApplicationMode(ApplicationMode.GlusterOnly);
                            volumeItem.setTitle(volume.getName());
                            volumeItem.setEntity(volume);
                            volumesItem.addChild(volumeItem);
                        }
                    }
                }
                if (cluster.supportsVirtService()) {
                    SystemTreeItemModel vmsItem = new SystemTreeItemModel();
                    vmsItem.setType(SystemTreeItemType.VMs);
                    vmsItem.setApplicationMode(ApplicationMode.VirtOnly);
                    vmsItem.setTitle(ConstantsManager.getInstance().getConstants().vmsTitle());
                    vmsItem.setEntity(cluster);
                    clusterItem.addChild(vmsItem);
                }
            }
        }
    }
    // Add Providers node under System
    SystemTreeItemModel providersItem = new SystemTreeItemModel();
    providersItem.setType(SystemTreeItemType.Providers);
    providersItem.setApplicationMode(ApplicationMode.VirtOnly);
    providersItem.setTitle(ConstantsManager.getInstance().getConstants().externalProvidersTitle());
    systemItem.addChild(providersItem);
    // Populate with providers
    for (Provider provider : getProviders()) {
        SystemTreeItemModel providerItem = new SystemTreeItemModel();
        providerItem.setType(SystemTreeItemType.Provider);
        providerItem.setApplicationMode(ApplicationMode.VirtOnly);
        providerItem.setTitle(provider.getName());
        providerItem.setEntity(provider);
        providersItem.addChild(providerItem);
        treeItemById.put(provider.getId(), providerItem);
    }
    if (!ApplicationModeHelper.getUiMode().equals(ApplicationMode.AllModes)) {
        ApplicationModeHelper.filterSystemTreeByApplictionMode(systemItem);
    }
    setItems(new ArrayList<SystemTreeItemModel>(Arrays.asList(new SystemTreeItemModel[] { systemItem })));
}
#end_block

#method_before
@TabInfo(container = ProviderSubTabPanelPresenter.class)
static TabData getTabData(ClientGinjector ginjector) {
    return new ModelBoundTabData(ginjector.getApplicationConstants().providerNetworksSubTabLabel(), 1, ginjector.getSubTabProviderNetworkModelProvider());
}
#method_after
@TabInfo(container = ProviderSubTabPanelPresenter.class)
static TabData getTabData(ApplicationConstants applicationConstants, SearchableDetailModelProvider<NetworkView, ProviderListModel, ProviderNetworkListModel> modelProvider) {
    return new ModelBoundTabData(applicationConstants.providerNetworksSubTabLabel(), 1, modelProvider);
}
#end_block

#method_before
@Override
protected PlaceRequest getMainTabRequest() {
    return new PlaceRequest(ApplicationPlaces.providerMainTabPlace);
}
#method_after
@Override
protected PlaceRequest getMainTabRequest() {
    return PlaceRequestFactory.get(ApplicationPlaces.providerMainTabPlace);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    getView().setNetworkClickHandler(new FieldUpdater<Network, String>() {

        @Override
        public void update(int index, Network network, String value) {
            systemTreeModelProvider.setSelectedItem(network.getId());
        }
    });
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    getView().setNetworkClickHandler(new FieldUpdater<NetworkView, String>() {

        @Override
        public void update(int index, NetworkView network, String value) {
            systemTreeModelProvider.setSelectedItem(network.getId());
        }
    });
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    nameColumn = new LinkColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    TextColumnWithTooltip<Network> externalIdColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getProvidedBy().getExternalId();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(externalIdColumn, constants.externalIdProviderNetwork(), "300px");
    getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.discoverProviderNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getDiscoverCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    nameColumn = new LinkColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    TextColumnWithTooltip<NetworkView> externalIdColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getProvidedBy().getExternalId();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(externalIdColumn, constants.externalIdProviderNetwork(), "300px");
    TextColumnWithTooltip<NetworkView> dcColumn = new TextColumnWithTooltip<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDataCenterName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dataCenterProviderNetwork(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getDiscoverCommand();
        }
    });
}
#end_block

#method_before
@Override
public void setNetworkClickHandler(FieldUpdater<Network, String> fieldUpdater) {
    nameColumn.setFieldUpdater(fieldUpdater);
}
#method_after
@Override
public void setNetworkClickHandler(FieldUpdater<NetworkView, String> fieldUpdater) {
    nameColumn.setFieldUpdater(fieldUpdater);
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getName().setInfo("Cannot edit Host's Name in this tree context");
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getCluster().setInfo("Cannot choose Host's Cluster in tree context");
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getHostPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(new ValueObjectMap(model.getPmSecondaryOptionsMap(), false));
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public Map<String, String> getPmSecondaryOptionsMap() {
    // by checking secondary PM fields.
    if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword())) {
        return getPmOptionsMapInternal(getPmSecondaryPort(), getPmSecondarySlot(), getPmSecondarySecure(), getPmSecondaryOptions());
    }
    return new HashMap<String, String>();
}
#method_after
public HashMap<String, String> getPmSecondaryOptionsMap() {
    // by checking secondary PM fields.
    if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword())) {
        return getPmOptionsMapInternal(getPmSecondaryPort(), getPmSecondarySlot(), getPmSecondarySecure(), getPmSecondaryOptions());
    }
    return new HashMap<String, String>();
}
#end_block

#method_before
public Map<String, String> getPmOptionsMap() {
    return getPmOptionsMapInternal(getPmPort(), getPmSlot(), getPmSecure(), getPmOptions());
}
#method_after
public HashMap<String, String> getPmOptionsMap() {
    return getPmOptionsMapInternal(getPmPort(), getPmSlot(), getPmSecure(), getPmOptions());
}
#end_block

#method_before
private Map<String, String> getPmOptionsMapInternal(EntityModel port, EntityModel slot, EntityModel secure, EntityModel options) {
    Map<String, String> dict = new HashMap<String, String>();
    if ((Boolean) getIsPm().getEntity()) {
        // Add well known pm options.
        if (port.getIsAvailable() && port.getEntity() != null) {
            dict.put(PmPortKey, (String) port.getEntity());
        }
        if (slot.getIsAvailable() && slot.getEntity() != null) {
            dict.put(PmSlotKey, (String) slot.getEntity());
        }
        if (secure.getIsAvailable()) {
            dict.put(PmSecureKey, secure.getEntity().toString());
        }
        // Add unknown pm options.
        // Assume Validate method was called before this getter.
        String pmOptions = (String) options.getEntity();
        if (!StringHelper.isNullOrEmpty(pmOptions)) {
            for (// $NON-NLS-1$
            String pair : // $NON-NLS-1$
            pmOptions.split("[,]", -1)) {
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                if (array.length == 2) {
                    dict.put(array[0], array[1]);
                } else if (array.length == 1) {
                    // $NON-NLS-1$
                    dict.put(array[0], "");
                }
            }
        }
    }
    return dict;
}
#method_after
private HashMap<String, String> getPmOptionsMapInternal(EntityModel port, EntityModel slot, EntityModel secure, EntityModel options) {
    HashMap<String, String> dict = new HashMap<String, String>();
    if ((Boolean) getIsPm().getEntity()) {
        // Add well known pm options.
        if (port.getIsAvailable() && port.getEntity() != null) {
            dict.put(PmPortKey, (String) port.getEntity());
        }
        if (slot.getIsAvailable() && slot.getEntity() != null) {
            dict.put(PmSlotKey, (String) slot.getEntity());
        }
        if (secure.getIsAvailable()) {
            dict.put(PmSecureKey, secure.getEntity().toString());
        }
        // Add unknown pm options.
        // Assume Validate method was called before this getter.
        String pmOptions = (String) options.getEntity();
        if (!StringHelper.isNullOrEmpty(pmOptions)) {
            for (// $NON-NLS-1$
            String pair : // $NON-NLS-1$
            pmOptions.split("[,]", -1)) {
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                if (array.length == 2) {
                    dict.put(array[0], array[1]);
                } else if (array.length == 1) {
                    // $NON-NLS-1$
                    dict.put(array[0], "");
                }
            }
        }
    }
    return dict;
}
#end_block

#method_before
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? (String) getManagementIp().getEntity() : (String) getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? (String) getPmType().getSelectedItem() : (String) getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? (String) getPmUserName().getEntity() : (String) getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? (String) getPmPassword().getEntity() : (String) getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(new ValueObjectMap(getPmOptionsMap(), false));
    param.setPmProxyPreferences(getPmProxyPreferences());
    Frontend.RunQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#method_after
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? (String) getManagementIp().getEntity() : (String) getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? (String) getPmType().getSelectedItem() : (String) getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? (String) getPmUserName().getEntity() : (String) getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? (String) getPmPassword().getEntity() : (String) getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    Frontend.RunQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    getHostPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if ((Boolean) getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if ((Boolean) getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if ((Boolean) getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if ((Boolean) getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    getNetworkProviderModel().validate();
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && getNetworkProviderModel().getIsValid();
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    setHostPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.PmOptionsStringToMap(vds.getPmOptions()).asMap());
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap().asMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                // $NON-NLS-1$
                getName().setInfo("Cannot edit Host's Name in this tree context");
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                // $NON-NLS-1$
                getCluster().setInfo("Cannot change Host's Cluster in tree context");
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.PmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    hostPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
}
#method_after
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
}
#end_block

#method_before
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    hostPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    fetchSshFingerprint.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    fetchSshFingerprint.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getName().setInfo("Cannot edit Host's Name in this tree context");
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getCluster().setInfo("Cannot choose Host's Cluster in tree context");
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getHostPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(new ValueObjectMap(model.getPmSecondaryOptionsMap(), false));
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider externalProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (externalProvider != null) {
            parameters.setProvider(externalProvider.getId());
            parameters.setNetworkMappings((String) model.getNeutronAgentModel().getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider externalProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (externalProvider != null) {
            parameters.setProvider(externalProvider.getId());
            parameters.setNetworkMappings((String) model.getNeutronAgentModel().getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public static NetworkInterface findInterfaceByName(ArrayList<NetworkInterface> items, String name) {
    for (NetworkInterface i : items) {
        if (StringHelper.stringsEqual(i.getName(), name)) {
            return i;
        }
    }
    return null;
}
#method_after
public static NetworkInterface findInterfaceByName(ArrayList<VdsNetworkInterface> items, String name) {
    for (NetworkInterface i : items) {
        if (StringHelper.stringsEqual(i.getName(), name)) {
            return i;
        }
    }
    return null;
}
#end_block

#method_before
public static NetworkInterface findInterfaceByNetworkName(ArrayList<NetworkInterface> items, String name) {
    for (NetworkInterface i : items) {
        if (StringHelper.stringsEqual(i.getNetworkName(), name)) {
            return i;
        }
    }
    return null;
}
#method_after
public static VdsNetworkInterface findInterfaceByNetworkName(ArrayList<VdsNetworkInterface> items, String name) {
    for (VdsNetworkInterface i : items) {
        if (StringHelper.stringsEqual(i.getNetworkName(), name)) {
            return i;
        }
    }
    return null;
}
#end_block

#method_before
public static NetworkInterface findInterfaceNetworkNameNotEmpty(ArrayList<NetworkInterface> items) {
    for (NetworkInterface i : items) {
        if (!StringHelper.isNullOrEmpty(i.getNetworkName())) {
            return i;
        }
    }
    return null;
}
#method_after
public static VdsNetworkInterface findInterfaceNetworkNameNotEmpty(ArrayList<VdsNetworkInterface> items) {
    for (VdsNetworkInterface i : items) {
        if (!StringHelper.isNullOrEmpty(i.getNetworkName())) {
            return i;
        }
    }
    return null;
}
#end_block

#method_before
public static ArrayList<NetworkInterface> findAllInterfaceNetworkNameNotEmpty(ArrayList<NetworkInterface> items) {
    ArrayList<NetworkInterface> ret = new ArrayList<NetworkInterface>();
    for (NetworkInterface i : items) {
        if (!StringHelper.isNullOrEmpty(i.getNetworkName())) {
            ret.add(i);
        }
    }
    return ret;
}
#method_after
public static ArrayList<VdsNetworkInterface> findAllInterfaceNetworkNameNotEmpty(ArrayList<VdsNetworkInterface> items) {
    ArrayList<VdsNetworkInterface> ret = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : items) {
        if (!StringHelper.isNullOrEmpty(i.getNetworkName())) {
            ret.add(i);
        }
    }
    return ret;
}
#end_block

#method_before
public Map<String, String> getPmSecondaryOptionsMap() {
    // by checking secondary PM fields.
    if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword())) {
        return getPmOptionsMapInternal(getPmSecondaryPort(), getPmSecondarySlot(), getPmSecondarySecure(), getPmSecondaryOptions());
    }
    return new HashMap<String, String>();
}
#method_after
public HashMap<String, String> getPmSecondaryOptionsMap() {
    // by checking secondary PM fields.
    if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword())) {
        return getPmOptionsMapInternal(getPmSecondaryPort(), getPmSecondarySlot(), getPmSecondarySecure(), getPmSecondaryOptions());
    }
    return new HashMap<String, String>();
}
#end_block

#method_before
public Map<String, String> getPmOptionsMap() {
    return getPmOptionsMapInternal(getPmPort(), getPmSlot(), getPmSecure(), getPmOptions());
}
#method_after
public HashMap<String, String> getPmOptionsMap() {
    return getPmOptionsMapInternal(getPmPort(), getPmSlot(), getPmSecure(), getPmOptions());
}
#end_block

#method_before
private Map<String, String> getPmOptionsMapInternal(EntityModel port, EntityModel slot, EntityModel secure, EntityModel options) {
    Map<String, String> dict = new HashMap<String, String>();
    if ((Boolean) getIsPm().getEntity()) {
        // Add well known pm options.
        if (port.getIsAvailable() && port.getEntity() != null) {
            dict.put(PmPortKey, (String) port.getEntity());
        }
        if (slot.getIsAvailable() && slot.getEntity() != null) {
            dict.put(PmSlotKey, (String) slot.getEntity());
        }
        if (secure.getIsAvailable()) {
            dict.put(PmSecureKey, secure.getEntity().toString());
        }
        // Add unknown pm options.
        // Assume Validate method was called before this getter.
        String pmOptions = (String) options.getEntity();
        if (!StringHelper.isNullOrEmpty(pmOptions)) {
            for (// $NON-NLS-1$
            String pair : // $NON-NLS-1$
            pmOptions.split("[,]", -1)) {
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                if (array.length == 2) {
                    dict.put(array[0], array[1]);
                } else if (array.length == 1) {
                    // $NON-NLS-1$
                    dict.put(array[0], "");
                }
            }
        }
    }
    return dict;
}
#method_after
private HashMap<String, String> getPmOptionsMapInternal(EntityModel port, EntityModel slot, EntityModel secure, EntityModel options) {
    HashMap<String, String> dict = new HashMap<String, String>();
    if ((Boolean) getIsPm().getEntity()) {
        // Add well known pm options.
        if (port.getIsAvailable() && port.getEntity() != null) {
            dict.put(PmPortKey, (String) port.getEntity());
        }
        if (slot.getIsAvailable() && slot.getEntity() != null) {
            dict.put(PmSlotKey, (String) slot.getEntity());
        }
        if (secure.getIsAvailable()) {
            dict.put(PmSecureKey, secure.getEntity().toString());
        }
        // Add unknown pm options.
        // Assume Validate method was called before this getter.
        String pmOptions = (String) options.getEntity();
        if (!StringHelper.isNullOrEmpty(pmOptions)) {
            for (// $NON-NLS-1$
            String pair : // $NON-NLS-1$
            pmOptions.split("[,]", -1)) {
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                if (array.length == 2) {
                    dict.put(array[0], array[1]);
                } else if (array.length == 1) {
                    // $NON-NLS-1$
                    dict.put(array[0], "");
                }
            }
        }
    }
    return dict;
}
#end_block

#method_before
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? (String) getManagementIp().getEntity() : (String) getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? (String) getPmType().getSelectedItem() : (String) getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? (String) getPmUserName().getEntity() : (String) getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? (String) getPmPassword().getEntity() : (String) getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(new ValueObjectMap(getPmOptionsMap(), false));
    param.setPmProxyPreferences(getPmProxyPreferences());
    Frontend.RunQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#method_after
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? (String) getManagementIp().getEntity() : (String) getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? (String) getPmType().getSelectedItem() : (String) getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? (String) getPmUserName().getEntity() : (String) getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? (String) getPmPassword().getEntity() : (String) getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    Frontend.RunQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = (FenceStatusReturnValue) response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    getHostPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if ((Boolean) getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if ((Boolean) getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    neutronAgentModel.validate();
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && neutronAgentModel.getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new HostnameValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getAuthSshPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if ((Boolean) getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if ((Boolean) getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getComment().getIsValid() && getHost().getIsValid() && getAuthSshPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    neutronAgentModel.validate();
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && neutronAgentModel.getIsValid();
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    setHostPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.PmOptionsStringToMap(vds.getPmOptions()).asMap());
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap().asMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                // $NON-NLS-1$
                getName().setInfo("Cannot edit Host's Name in this tree context");
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                // $NON-NLS-1$
                getCluster().setInfo("Cannot change Host's Cluster in tree context");
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.PmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new EntityModelTextAreaLabelEditor();
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmSecondaryTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    networkProviderLabel = new EntityModelLabel();
    networkProviderEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    networkProvider = new EntityModelWidgetWithInfo(networkProviderLabel, networkProviderEditor, resources);
    networkProviderTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    neutronAgentWidget = new NeutronAgentWidget(constants, resources, applicationTemplates);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
}
#method_after
private void initEditors() {
    publicKeyEditor = new EntityModelTextAreaLabelEditor();
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmSecondaryTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    networkProviderLabel = new EntityModelLabel();
    networkProviderEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    networkProvider = new EntityModelWidgetWithInfo(networkProviderLabel, networkProviderEditor);
    networkProviderTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    hostPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    networkProviderLabel.setText(constants.externalNetworkProviderLabel());
    networkProvider.setExplanation(applicationTemplates.italicText(constants.externalProviderExplanation()));
    networkProviderTypeEditor.setLabel(constants.typeProvider());
    providerPluginTypeEditor.setLabel(constants.pluginType());
}
#method_after
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    networkProviderLabel.setText(constants.externalNetworkProviderLabel());
    networkProvider.setExplanation(applicationTemplates.italicText(constants.externalProviderExplanation()));
    networkProviderTypeEditor.setLabel(constants.typeProvider());
    providerPluginTypeEditor.setLabel(constants.pluginType());
}
#end_block

#method_before
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    hostPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    fetchSshFingerprint.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    fetchSshFingerprint.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new EntityModelTextAreaLabelEditor();
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmSecondaryTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalProviderLabel = new EntityModelLabel();
    externalProviderEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    externalProvider = new EntityModelWidgetWithInfo(externalProviderLabel, externalProviderEditor, resources);
    providerTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    neutronAgentWidget = new NeutronAgentWidget(constants, resources, applicationTemplates);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
}
#method_after
private void initEditors() {
    publicKeyEditor = new EntityModelTextAreaLabelEditor();
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmSecondaryTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalProviderLabel = new EntityModelLabel();
    externalProviderEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    externalProvider = new EntityModelWidgetWithInfo(externalProviderLabel, externalProviderEditor);
    providerTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    neutronAgentWidget = new NeutronAgentWidget(constants, resources, applicationTemplates);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    hostPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalProviderLabel.setText(constants.externalProviderLabel());
    externalProvider.setExplanation(applicationTemplates.italicText(constants.externalProviderExplanation()));
    providerTypeEditor.setLabel(constants.typeProvider());
    providerPluginTypeEditor.setLabel(constants.pluginType());
}
#method_after
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalProviderLabel.setText(constants.externalProviderLabel());
    externalProvider.setExplanation(applicationTemplates.italicText(constants.externalProviderExplanation()));
    providerTypeEditor.setLabel(constants.typeProvider());
    providerPluginTypeEditor.setLabel(constants.pluginType());
}
#end_block

#method_before
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    hostPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    fetchSshFingerprint.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    fetchSshFingerprint.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public void updateItemsAvailability() {
    super.updateItemsAvailability();
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    for (IStorageModel item : Linq.<IStorageModel>cast(getModel().getItems())) {
        if (item.getRole() == StorageDomainType.ISO) {
            AsyncDataProvider.getIsoDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    ImportStorageModelBehavior behavior = (ImportStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(behavior, storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else if (item.getRole() == StorageDomainType.ImportExport) {
            AsyncDataProvider.getExportDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    ImportStorageModelBehavior behavior = (ImportStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(behavior, storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else {
            postUpdateItemsAvailability(this, item, false);
        }
    }
}
#method_after
@Override
public void updateItemsAvailability() {
    super.updateItemsAvailability();
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    for (IStorageModel item : Linq.<IStorageModel>cast(getModel().getItems())) {
        if (item.getRole() == StorageDomainType.ISO) {
            AsyncDataProvider.getIsoDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    ImportStorageModelBehavior behavior = (ImportStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else if (item.getRole() == StorageDomainType.ImportExport) {
            AsyncDataProvider.getExportDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    ImportStorageModelBehavior behavior = (ImportStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else {
            postUpdateItemsAvailability(item, false);
        }
    }
}
#end_block

#method_before
public void postUpdateItemsAvailability(ImportStorageModelBehavior behavior, IStorageModel item, boolean isNoStorageAttached) {
    Model model = (Model) item;
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    if (!isStorageDomainSelectableForDataCenter(dataCenter, item)) {
        model.setIsSelectable(false);
    } else {
        // available type/function items are:
        // all in case of Unassigned DC.
        // ISO in case the specified DC doesn't have an attached ISO domain.
        // Export in case the specified DC doesn't have an attached export domain.
        model.setIsSelectable((dataCenter.getId().equals(StorageModel.UnassignedDataCenterId) || (item.getRole() == StorageDomainType.ISO && isNoStorageAttached) || (item.getRole() == StorageDomainType.ImportExport && isNoStorageAttached)));
    }
    behavior.onStorageModelUpdated(item);
}
#method_after
public void postUpdateItemsAvailability(IStorageModel item, boolean isNoStorageAttached) {
    Model model = (Model) item;
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    boolean isItemSelectable = isItemSelectable(item, dataCenter, isNoStorageAttached);
    model.setIsSelectable(isItemSelectable);
    onStorageModelUpdated(item);
}
#end_block

#method_before
@Override
public void updateItemsAvailability() {
    super.updateItemsAvailability();
    // Allow Data storage type corresponding to the selected data-center type + ISO and Export that are NFS only:
    for (IStorageModel item : Linq.<IStorageModel>cast(getModel().getItems())) {
        Model model = (Model) item;
        StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
        if (dataCenter == null) {
            return;
        }
        if (item.getRole() == StorageDomainType.ISO) {
            AsyncDataProvider.getIsoDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    NewEditStorageModelBehavior behavior = (NewEditStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else if (item.getRole() == StorageDomainType.ImportExport) {
            AsyncDataProvider.getExportDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    NewEditStorageModelBehavior behavior = (NewEditStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else {
            postUpdateItemsAvailability(item, false);
        }
    }
}
#method_after
@Override
public void updateItemsAvailability() {
    super.updateItemsAvailability();
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    if (dataCenter == null) {
        return;
    }
    // Allow Data storage type corresponding to the selected data-center type + ISO and Export that are NFS only:
    for (IStorageModel item : Linq.<IStorageModel>cast(getModel().getItems())) {
        Model model = (Model) item;
        if (item.getRole() == StorageDomainType.ISO) {
            AsyncDataProvider.getIsoDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    NewEditStorageModelBehavior behavior = (NewEditStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else if (item.getRole() == StorageDomainType.ImportExport) {
            AsyncDataProvider.getExportDomainByDataCenterId(new AsyncQuery(new Object[] { this, item }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    NewEditStorageModelBehavior behavior = (NewEditStorageModelBehavior) array[0];
                    IStorageModel storageModelItem = (IStorageModel) array[1];
                    behavior.postUpdateItemsAvailability(storageModelItem, returnValue == null);
                }
            }, getHash()), dataCenter.getId());
        } else {
            postUpdateItemsAvailability(item, false);
        }
    }
}
#end_block

#method_before
public void postUpdateItemsAvailability(IStorageModel item, boolean isNoExportOrIsoStorageAttached) {
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    Model model = (Model) item;
    if (isStorageDomainSelectableForDataCenter(dataCenter, item)) {
        model.setIsSelectable(false);
    } else {
        boolean isExistingStorage = getModel().getStorage() != null && item.getType() == getModel().getStorage().getStorageType();
        boolean isNoneDataCenter = dataCenter != null && dataCenter.getId().equals(StorageModel.UnassignedDataCenterId);
        boolean isData = item.getRole() == StorageDomainType.Data;
        boolean isExportOrIso = item.getRole() == StorageDomainType.ImportExport || item.getRole() == StorageDomainType.ISO;
        boolean canAttachData = isData && item.getType() == dataCenter.getStorageType();
        boolean canAttachExportOrIso = isExportOrIso && isNoExportOrIsoStorageAttached && dataCenter.getstatus() != StoragePoolStatus.Uninitialized;
        model.setIsSelectable(isExistingStorage || (isNoneDataCenter && isData) || (!isNoneDataCenter && (canAttachData || canAttachExportOrIso)));
    }
    onStorageModelUpdated(item);
}
#method_after
public void postUpdateItemsAvailability(IStorageModel item, boolean isNoExportOrIsoStorageAttached) {
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    Model model = (Model) item;
    boolean isItemSelectable = isItemSelectable(item, dataCenter, isNoExportOrIsoStorageAttached);
    model.setIsSelectable(isItemSelectable);
    onStorageModelUpdated(item);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = super.canDoAction();
    if (retVal) {
        StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().getForVds(getParameters().getVdsId());
        if (storagePool == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_CLUSTER_HAVE_NOT_EXISTING_DATA_CENTER_NETWORK);
            retVal = false;
        } else {
            setStoragePool(storagePool);
        }
        if (retVal && (getStorageDomain().getStorageDomainType() == StorageDomainType.Data || getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) && storagePool.getStorageType() != StorageType.LOCALFS) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_IS_NOT_LOCAL);
            retVal = false;
        }
        if (retVal && storagePool.getstatus() != StoragePoolStatus.Uninitialized) {
            retVal = checkMasterDomainIsUp();
        }
        // we limit RHEV-H local storage to its persistence mount - /data/images/rhev/
        if (retVal && this.getVds().getVdsType() == VDSType.oVirtNode) {
            StorageServerConnections conn = DbFacade.getInstance().getStorageServerConnectionDao().get(getParameters().getStorageDomain().getStorage());
            String rhevhLocalFSPath = Config.<String>GetValue(ConfigValues.RhevhLocalFSPath);
            if (!conn.getconnection().equals(rhevhLocalFSPath)) {
                addCanDoActionMessage(VdcBllMessages.RHEVH_LOCALFS_WRONG_PATH_LOCATION);
                addCanDoActionMessage(String.format("$path %1$s", rhevhLocalFSPath));
                retVal = false;
            }
        }
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = super.canDoAction();
    if (retVal) {
        StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().getForVds(getParameters().getVdsId());
        if (storagePool == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_CLUSTER_HAVE_NOT_EXISTING_DATA_CENTER_NETWORK);
            retVal = false;
        } else {
            setStoragePool(storagePool);
        }
        if (retVal && getStorageDomain().getStorageType() == StorageType.LOCALFS && storagePool.getStorageType() != StorageType.LOCALFS) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_IS_NOT_LOCAL);
            retVal = false;
        }
        if (retVal && storagePool.getstatus() != StoragePoolStatus.Uninitialized) {
            retVal = checkMasterDomainIsUp();
        }
        // we limit RHEV-H local storage to its persistence mount - /data/images/rhev/
        if (retVal && this.getVds().getVdsType() == VDSType.oVirtNode) {
            StorageServerConnections conn = DbFacade.getInstance().getStorageServerConnectionDao().get(getParameters().getStorageDomain().getStorage());
            String rhevhLocalFSPath = Config.<String>GetValue(ConfigValues.RhevhLocalFSPath);
            if (!conn.getconnection().equals(rhevhLocalFSPath)) {
                addCanDoActionMessage(VdcBllMessages.RHEVH_LOCALFS_WRONG_PATH_LOCATION);
                addCanDoActionMessage(String.format("$path %1$s", rhevhLocalFSPath));
                retVal = false;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().createVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setInfo(ConstantsManager.getInstance().getConstants().cannotChooseVolumesDataCenterinTreeContect());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setInfo(ConstantsManager.getInstance().getConstants().cannotChooseVolumesClusterinTreeContect());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setInfo(ConstantsManager.getInstance().getConstants().cannotChooseVolumesDataCenterinTreeContect());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#method_after
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#end_block

#method_before
private void updateActionAvailability() {
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        getRemoveVolumeCommand().setIsExecutionAllowed(false);
        getStopCommand().setIsExecutionAllowed(false);
        getStartCommand().setIsExecutionAllowed(false);
        getRebalanceCommand().setIsExecutionAllowed(false);
        getOptimizeForVirtStoreCommand().setIsExecutionAllowed(false);
        return;
    }
    getRemoveVolumeCommand().setIsExecutionAllowed(true);
    getStopCommand().setIsExecutionAllowed(true);
    getStartCommand().setIsExecutionAllowed(true);
    getRebalanceCommand().setIsExecutionAllowed(true);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(true);
    for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        if (volume.getStatus() == GlusterStatus.UP) {
            getRemoveVolumeCommand().setIsExecutionAllowed(false);
            getStartCommand().setIsExecutionAllowed(false);
        } else if (volume.getStatus() == GlusterStatus.DOWN) {
            getStopCommand().setIsExecutionAllowed(false);
            getRebalanceCommand().setIsExecutionAllowed(false);
        }
    }
}
#method_after
private void updateActionAvailability() {
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        getRemoveVolumeCommand().setIsExecutionAllowed(false);
        getStopCommand().setIsExecutionAllowed(false);
        getStartCommand().setIsExecutionAllowed(false);
        getRebalanceCommand().setIsExecutionAllowed(false);
        getOptimizeForVirtStoreCommand().setIsExecutionAllowed(false);
    } else {
        getRemoveVolumeCommand().setIsExecutionAllowed(true);
        getStopCommand().setIsExecutionAllowed(true);
        getStartCommand().setIsExecutionAllowed(true);
        getRebalanceCommand().setIsExecutionAllowed(true);
        getOptimizeForVirtStoreCommand().setIsExecutionAllowed(true);
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                getRemoveVolumeCommand().setIsExecutionAllowed(false);
                getStartCommand().setIsExecutionAllowed(false);
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                getStopCommand().setIsExecutionAllowed(false);
                getRebalanceCommand().setIsExecutionAllowed(false);
            }
        }
    }
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getCreateVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getRebalanceCommand())) {
        rebalance();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getRebalanceCommand())) {
        rebalance();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = checkStoragePool() && CheckStoragePoolStatusNotEqual(StoragePoolStatus.Uninitialized, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL) && checkStorageDomain() && storageDomainStatusIsValid() && (getStorageDomain().getStorageDomainType() == StorageDomainType.Master || checkMasterDomainIsUp()) && checkActiveVdsInStoragePool();
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = checkStoragePool() && CheckStoragePoolStatusNotEqual(StoragePoolStatus.Uninitialized, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL) && checkStorageDomain() && storageDomainStatusIsValid() && (getStorageDomain().getStorageDomainType() == StorageDomainType.Master || checkMasterDomainIsUp()) && checkForActiveVds() != null;
    return returnValue;
}
#end_block

#method_before
public String getRpmRevision() {
    return this.rpmRevison;
}
#method_after
public String getRpmRevision() {
    return this.rpmRevision;
}
#end_block

#method_before
private void fetchClusterPolicies() {
    AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterPolicyListModel clusterPolicyListModel = (ClusterPolicyListModel) model;
            ArrayList<ClusterPolicy> list = (ArrayList<ClusterPolicy>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            sortClusterPolicyList(list);
            clusterPolicyListModel.setItems(list);
        }
    });
    VdcQueryParametersBase parametersBase = new VdcQueryParametersBase();
    parametersBase.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetClusterPolicies, parametersBase, asyncQuery);
    setIsQueryFirstTime(false);
}
#method_after
private void fetchClusterPolicies() {
    AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterPolicyListModel clusterPolicyListModel = (ClusterPolicyListModel) model;
            ArrayList<ClusterPolicy> list = (ArrayList<ClusterPolicy>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collections.sort(list, new Linq.ClusterPolicyComparator());
            clusterPolicyListModel.setItems(list);
        }
    });
    VdcQueryParametersBase parametersBase = new VdcQueryParametersBase();
    parametersBase.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetClusterPolicies, parametersBase, asyncQuery);
    setIsQueryFirstTime(false);
}
#end_block

#method_before
@Override
protected SimpleActionTable<UserPortalItemModel> createActionTable() {
    return new UserPortalSimpleActionTable<UserPortalItemModel>(modelProvider, getTableResources(), ClientGinjectorProvider.instance().getEventBus(), ClientGinjectorProvider.instance().getClientStorage(), new UserPortalRefreshManager(modelProvider, ClientGinjectorProvider.instance().getEventBus(), ClientGinjectorProvider.instance().getClientStorage()));
}
#method_after
@Override
protected SimpleActionTable<UserPortalItemModel> createActionTable() {
    return new UserPortalSimpleActionTable<UserPortalItemModel>(modelProvider, getTableResources(), ClientGinjectorProvider.getEventBus(), ClientGinjectorProvider.getClientStorage(), new UserPortalRefreshManager(modelProvider, ClientGinjectorProvider.getEventBus(), ClientGinjectorProvider.getClientStorage()));
}
#end_block

#method_before
void initTable(final ApplicationTemplates templates, final ConsoleUtils consoleUtils) {
    final String elementIdPrefix = getTable().getContentTableElementId();
    VmImageColumn<UserPortalItemModel> vmImageColumn = new VmImageColumn<UserPortalItemModel>(new OsTypeExtractor<UserPortalItemModel>() {

        @Override
        public int extractOsType(UserPortalItemModel item) {
            return item.getOsId();
        }
    });
    ImageMaskCell<UserPortalItemModel> vmImageColumnWithMask = new ImageMaskCell<UserPortalItemModel>(vmImageColumn, applicationResources.disabledSmallMask(), new ShowMask<UserPortalItemModel>() {

        @Override
        public boolean showMask(UserPortalItemModel value) {
            return !value.isVmUp();
        }
    });
    TooltipCell<UserPortalItemModel> vmImageColumnWithMaskAndTooltip = new TooltipCell<UserPortalItemModel>(new UserPortalItemSimpleColumn(vmImageColumnWithMask), new TooltipProvider<UserPortalItemModel>() {

        @Override
        public String getTooltip(UserPortalItemModel value) {
            return AsyncDataProvider.getOsName(value.getOsId());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(new UserPortalItemSimpleColumn(vmImageColumnWithMaskAndTooltip), constants.empty(), "77px");
    TooltipCell<UserPortalItemModel> statusColumn = new TooltipCell<UserPortalItemModel>(new VmStatusColumn(), new TooltipProvider<UserPortalItemModel>() {

        @Override
        public String getTooltip(UserPortalItemModel value) {
            return statusTranslator.translate(value.getStatus().name());
        }
    });
    statusColumn.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    statusColumn.setColumnId("status");
    // $NON-NLS-1$
    getTable().addColumn(new UserPortalItemSimpleColumn(statusColumn), constants.empty(), "55px");
    Cell<UserPortalItemModel> nameAndDescriptionCell = new AbstractCell<UserPortalItemModel>() {

        @Override
        public void render(Context context, UserPortalItemModel item, SafeHtmlBuilder sb) {
            sb.append(templates.vmNameCellItem(// $NON-NLS-1$
            ElementIdUtils.createTableCellElementId(elementIdPrefix, "name", context), item.getName()));
            String description = item.getDescription();
            if (description != null && !description.isEmpty()) {
                sb.append(templates.vmDescriptionCellItem(description));
            }
        }
    };
    Column<UserPortalItemModel, UserPortalItemModel> nameAndDescriptionColumn = new Column<UserPortalItemModel, UserPortalItemModel>(nameAndDescriptionCell) {

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel item) {
            return item;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameAndDescriptionColumn, constants.empty(), "400px");
    getTable().addColumn(new Column<UserPortalItemModel, UserPortalItemModel>(createActionsCompositeCell(elementIdPrefix)) {

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "130px");
    ConsoleButtonCell openConsoleCell = new ConsoleButtonCell(consoleUtils, applicationResources.sideTabExtendedVmStyle().enabledConsoleButton(), applicationResources.sideTabExtendedVmStyle().disabledConsoleButton(), constants.openConsoleLabel(), new ConsoleButtonCommand() {

        @Override
        public void execute(UserPortalItemModel model) {
            String message = consoleManager.connectToConsole(model);
            if (message != null) {
                errorPopupManager.show(message);
            }
        }
    });
    openConsoleCell.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    openConsoleCell.setColumnId("openConsoleButton");
    // $NON-NLS-1$
    getTable().addColumn(new UserPortalItemSimpleColumn(openConsoleCell), constants.empty(), "100px");
    ConsoleButtonCell consoleEditCell = new ConsoleButtonCell(consoleUtils, applicationResources.sideTabExtendedVmStyle().enabledEditConsoleButton(), applicationResources.sideTabExtendedVmStyle().disabledEditConsoleButton(), constants.editConsoleLabel(), new ConsoleButtonCommand() {

        @Override
        public void execute(UserPortalItemModel model) {
            getModel().getEditConsoleCommand().execute();
        }
    });
    consoleEditCell.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    consoleEditCell.setColumnId("editConsoleButton");
    getTable().addColumn(new UserPortalItemSimpleColumn(consoleEditCell), constants.empty());
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.changeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewTemplateCommand();
        }
    });
    getTable().setExtraRowStyles(new RowStyles<UserPortalItemModel>() {

        @Override
        public String getStyleNames(UserPortalItemModel row, int rowIndex) {
            if (row == null) {
                return null;
            }
            if (isSelectedRow(row)) {
                return null;
            }
            return row.isVmUp() ? applicationResources.sideTabExtendedVmStyle().vmUpRow() : applicationResources.sideTabExtendedVmStyle().vmDownRow();
        }

        protected boolean isSelectedRow(UserPortalItemModel row) {
            UserPortalItemModel selectedModel = (UserPortalItemModel) getModel().getSelectedItem();
            if (selectedModel != null) {
                if (modelProvider.getKey(selectedModel).equals(modelProvider.getKey(row))) {
                    return true;
                }
            }
            @SuppressWarnings("unchecked")
            List<UserPortalItemModel> selectedModels = getModel().getSelectedItems();
            if (selectedModels == null) {
                return false;
            }
            for (UserPortalItemModel model : selectedModels) {
                if (modelProvider.getKey(model).equals(modelProvider.getKey(row))) {
                    return true;
                }
            }
            return false;
        }
    });
}
#method_after
void initTable(final ApplicationTemplates templates, final ConsoleUtils consoleUtils) {
    final String elementIdPrefix = getTable().getContentTableElementId();
    VmImageColumn<UserPortalItemModel> vmImageColumn = new VmImageColumn<UserPortalItemModel>(new OsTypeExtractor<UserPortalItemModel>() {

        @Override
        public int extractOsType(UserPortalItemModel item) {
            return item.getOsId();
        }
    });
    ImageMaskCell<UserPortalItemModel> vmImageColumnWithMask = new ImageMaskCell<UserPortalItemModel>(vmImageColumn, applicationResources.disabledSmallMask(), new ShowMask<UserPortalItemModel>() {

        @Override
        public boolean showMask(UserPortalItemModel value) {
            return !value.isVmUp();
        }
    });
    TooltipCell<UserPortalItemModel> vmImageColumnWithMaskAndTooltip = new TooltipCell<UserPortalItemModel>(new UserPortalItemSimpleColumn(vmImageColumnWithMask), new TooltipProvider<UserPortalItemModel>() {

        @Override
        public String getTooltip(UserPortalItemModel value) {
            return AsyncDataProvider.getOsName(value.getOsId());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(new UserPortalItemSimpleColumn(vmImageColumnWithMaskAndTooltip), constants.empty(), "77px");
    TooltipCell<UserPortalItemModel> statusColumn = new TooltipCell<UserPortalItemModel>(new VmStatusColumn(), new TooltipProvider<UserPortalItemModel>() {

        @Override
        public String getTooltip(UserPortalItemModel value) {
            return statusTranslator.translate(value.getStatus().name());
        }
    });
    statusColumn.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    statusColumn.setColumnId("status");
    // $NON-NLS-1$
    getTable().addColumn(new UserPortalItemSimpleColumn(statusColumn), constants.empty(), "55px");
    Cell<UserPortalItemModel> nameAndDescriptionCell = new AbstractCell<UserPortalItemModel>() {

        @Override
        public void render(Context context, UserPortalItemModel item, SafeHtmlBuilder sb) {
            sb.append(templates.vmNameCellItem(// $NON-NLS-1$
            ElementIdUtils.createTableCellElementId(elementIdPrefix, "name", context), item.getName()));
            String description = item.getDescription();
            if (description != null && !description.isEmpty()) {
                sb.append(templates.vmDescriptionCellItem(description));
            }
        }
    };
    Column<UserPortalItemModel, UserPortalItemModel> nameAndDescriptionColumn = new Column<UserPortalItemModel, UserPortalItemModel>(nameAndDescriptionCell) {

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel item) {
            return item;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameAndDescriptionColumn, constants.empty(), "400px");
    getTable().addColumn(new Column<UserPortalItemModel, UserPortalItemModel>(createActionsCompositeCell(elementIdPrefix)) {

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "130px");
    ConsoleButtonCell openConsoleCell = new ConsoleButtonCell(consoleUtils, applicationResources.sideTabExtendedVmStyle().enabledConsoleButton(), applicationResources.sideTabExtendedVmStyle().disabledConsoleButton(), constants.openConsoleLabel(), new AbstractConsoleButtonCell.ConsoleButtonCommand() {

        @Override
        public void execute(UserPortalItemModel model) {
            String message = consoleManager.connectToConsole(model);
            if (message != null) {
                errorPopupManager.show(message);
            }
        }
    });
    openConsoleCell.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    openConsoleCell.setColumnId("openConsoleButton");
    // $NON-NLS-1$
    getTable().addColumn(new UserPortalItemSimpleColumn(openConsoleCell), constants.empty(), "100px");
    ConsoleEditButtonCell consoleEditCell = new ConsoleEditButtonCell(applicationResources.sideTabExtendedVmStyle().enabledEditConsoleButton(), applicationResources.sideTabExtendedVmStyle().disabledEditConsoleButton(), constants.editConsoleLabel(), new AbstractConsoleButtonCell.ConsoleButtonCommand() {

        @Override
        public void execute(UserPortalItemModel model) {
            getModel().getEditConsoleCommand().execute();
        }
    });
    consoleEditCell.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    consoleEditCell.setColumnId("editConsoleButton");
    getTable().addColumn(new UserPortalItemSimpleColumn(consoleEditCell), constants.empty());
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.changeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewTemplateCommand();
        }
    });
    getTable().setExtraRowStyles(new RowStyles<UserPortalItemModel>() {

        @Override
        public String getStyleNames(UserPortalItemModel row, int rowIndex) {
            if (row == null) {
                return null;
            }
            if (isSelectedRow(row)) {
                return null;
            }
            return row.isVmUp() ? applicationResources.sideTabExtendedVmStyle().vmUpRow() : applicationResources.sideTabExtendedVmStyle().vmDownRow();
        }

        protected boolean isSelectedRow(UserPortalItemModel row) {
            UserPortalItemModel selectedModel = (UserPortalItemModel) getModel().getSelectedItem();
            if (selectedModel != null) {
                if (modelProvider.getKey(selectedModel).equals(modelProvider.getKey(row))) {
                    return true;
                }
            }
            @SuppressWarnings("unchecked")
            List<UserPortalItemModel> selectedModels = getModel().getSelectedItems();
            if (selectedModels == null) {
                return false;
            }
            for (UserPortalItemModel model : selectedModels) {
                if (modelProvider.getKey(model).equals(modelProvider.getKey(row))) {
                    return true;
                }
            }
            return false;
        }
    });
}
#end_block

#method_before
void initTable() {
    // Set up table data provider
    getDataProvider().addDataDisplay(table);
    // Add default sort handler that delegates to the data provider
    AsyncHandler columnSortHandler = new AsyncHandler(table);
    table.addColumnSortHandler(columnSortHandler);
    // Set up table selection model
    table.setSelectionModel(selectionModel);
    // Enable keyboard selection
    table.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.ENABLED);
    // Add arrow key handler
    table.addDomHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            boolean shiftPageDown = event.isShiftKeyDown() && KeyCodes.KEY_PAGEDOWN == event.getNativeKeyCode();
            boolean shiftPageUp = event.isShiftKeyDown() && KeyCodes.KEY_PAGEUP == event.getNativeKeyCode();
            boolean ctrlA = event.isControlKeyDown() && ('a' == event.getNativeKeyCode() || 'A' == event.getNativeKeyCode());
            boolean arrow = KeyDownEvent.isArrow(event.getNativeKeyCode());
            if (shiftPageUp || shiftPageDown || ctrlA || arrow) {
                event.preventDefault();
                event.stopPropagation();
            } else {
                return;
            }
            if (shiftPageDown) {
                selectionModel.selectAllNext();
            } else if (shiftPageUp) {
                selectionModel.selectAllPrev();
            } else if (ctrlA) {
                selectionModel.selectAll();
            } else if (arrow) {
                selectionModel.setMultiSelectEnabled(event.isControlKeyDown() && !multiSelectionDisabled);
                selectionModel.setMultiRangeSelectEnabled(event.isShiftKeyDown() && !multiSelectionDisabled);
                if (event.isDownArrow()) {
                    selectionModel.selectNext();
                } else if (event.isUpArrow()) {
                    selectionModel.selectPrev();
                }
            }
        }
    }, KeyDownEvent.getType());
    // Add context menu handler for table widget
    addContextMenuHandler(tableContainer);
    // Use fixed table layout
    // $NON-NLS-1$
    setWidth("100%", true);
    // Attach table widget to the corresponding panel
    tableContainer.setWidget(table);
    tableHeaderContainer.setWidget(tableHeader);
    tableHeaderContainer.setVisible(!showDefaultHeader);
    // Use relative positioning for tableHeader, in order to align it with main table
    tableHeader.getElement().getStyle().setPosition(Position.RELATIVE);
    // Attach scroll event handler to main table container, so that the tableHeader widget
    // can have its position aligned with main table container's current scroll position
    tableContainer.addDomHandler(new ScrollHandler() {

        @Override
        public void onScroll(ScrollEvent event) {
            tableContainerHorizontalScrollPosition = tableContainer.getElement().getScrollLeft();
            updateTableHeaderPosition();
        }
    }, ScrollEvent.getType());
    // Reset main table container's scroll position
    enforceScrollPosition();
}
#method_after
void initTable() {
    // Set up table data provider
    getDataProvider().addDataDisplay(table);
    // Add default sort handler that delegates to the data provider
    AsyncHandler columnSortHandler = new AsyncHandler(table);
    table.addColumnSortHandler(columnSortHandler);
    // Set up table selection model
    table.setSelectionModel(selectionModel);
    // Enable keyboard selection
    table.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.ENABLED);
    // Add arrow key handler
    table.addDomHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            boolean shiftPageDown = event.isShiftKeyDown() && KeyCodes.KEY_PAGEDOWN == event.getNativeKeyCode();
            boolean shiftPageUp = event.isShiftKeyDown() && KeyCodes.KEY_PAGEUP == event.getNativeKeyCode();
            boolean ctrlA = event.isControlKeyDown() && ('a' == event.getNativeKeyCode() || 'A' == event.getNativeKeyCode());
            boolean arrow = KeyDownEvent.isArrow(event.getNativeKeyCode());
            if (shiftPageUp || shiftPageDown || ctrlA || arrow) {
                event.preventDefault();
                event.stopPropagation();
            } else {
                return;
            }
            if (shiftPageDown) {
                selectionModel.selectAllNext();
            } else if (shiftPageUp) {
                selectionModel.selectAllPrev();
            } else if (ctrlA) {
                selectionModel.selectAll();
            } else if (arrow) {
                selectionModel.setMultiSelectEnabled(event.isControlKeyDown() && !multiSelectionDisabled);
                selectionModel.setMultiRangeSelectEnabled(event.isShiftKeyDown() && !multiSelectionDisabled);
                if (event.isDownArrow()) {
                    selectionModel.selectNext();
                } else if (event.isUpArrow()) {
                    selectionModel.selectPrev();
                }
            }
        }
    }, KeyDownEvent.getType());
    // Add context menu handler for table widget
    addContextMenuHandler(tableContainer);
    // Use fixed table layout
    // $NON-NLS-1$
    setWidth("100%", true);
    // Attach table widget to the corresponding panel
    tableContainer.setWidget(table);
    tableHeaderContainer.setWidget(tableHeader);
    tableHeaderContainer.setVisible(isTableHeaderVisible());
    // Use relative positioning for tableHeader, in order to align it with main table
    tableHeader.getElement().getStyle().setPosition(Position.RELATIVE);
    // Attach scroll event handler to main table container, so that the tableHeader widget
    // can have its position aligned with main table container's current scroll position
    tableContainer.addDomHandler(new ScrollHandler() {

        @Override
        public void onScroll(ScrollEvent event) {
            tableContainerHorizontalScrollPosition = tableContainer.getElement().getScrollLeft();
            updateTableHeaderPosition();
        }
    }, ScrollEvent.getType());
    // Reset main table container's scroll position
    enforceScrollPosition();
}
#end_block

#method_before
public void enableColumnResizing() {
    // Column resizing is supported only when the tableHeader widget is visible
    if (!showDefaultHeader) {
        table.enableColumnResizing();
        tableHeader.enableColumnResizing();
    }
}
#method_after
public void enableColumnResizing() {
    // Column resizing is supported only when the tableHeader widget is visible
    if (isTableHeaderVisible()) {
        table.enableColumnResizing();
        tableHeader.enableColumnResizing();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!updateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN_UP);
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = null;
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && (!validate(macAddressValid()) || !validate(macAvailable()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!updateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN_UP);
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = null;
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && (!validate(macAddressValid()) || !validate(macAvailable()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getNumOfMonitors(), Collections.<VmNic>singletonList(getParameters().getInterface()), new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Version clusterCompatibilityVersion = getVdsGroup().getcompatibility_version();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion);
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getNumOfMonitors(), Collections.<VmNic>singletonList(getParameters().getInterface()), new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Version clusterCompatibilityVersion = getVdsGroup().getcompatibility_version();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    switch(getVmDynamicDao().get(getParameters().getVmId()).getStatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    if (!pciAndIdeWithinLimit(vm, Collections.<VmNic>singletonList(getInterface()))) {
        return false;
    }
    Version compatibilityVersion = getVm().getVdsGroupCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion);
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAddressValid()) || !validate(macAvailable())) {
            return false;
        }
    } else if (MacPoolManager.getInstance().getAvailableMacsCount() <= 0) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    switch(getVmDynamicDao().get(getParameters().getVmId()).getStatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    if (!pciAndIdeWithinLimit(vm, Collections.<VmNic>singletonList(getInterface()))) {
        return false;
    }
    Version compatibilityVersion = getVm().getVdsGroupCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAddressValid()) || !validate(macAvailable())) {
            return false;
        }
    } else if (MacPoolManager.getInstance().getAvailableMacsCount() <= 0) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!validate(linkedToTemplate())) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!validate(templateExists())) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNic oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    Version clusterCompatibilityVersion = getVdsGroup().getcompatibility_version();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion);
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId()))) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !interfaceNameUnique(interfaces)) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!validate(linkedToTemplate())) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!validate(templateExists())) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNic oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    Version clusterCompatibilityVersion = getVdsGroup().getcompatibility_version();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId()))) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !interfaceNameUnique(interfaces)) {
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult profileValid(Guid clusterId) {
    if (nic.getVnicProfileId() != null) {
        // Check that the profile exists
        VnicProfile vnicProfile = getDbFacade().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile == null) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VNIC_PROFILE_NOT_EXISTS);
        }
        // Check that the network exists in current cluster
        Network network = getNetworkByVnicProfile(vnicProfile);
        if (network == null || !isNetworkInCluster(network, clusterId)) {
            return new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        }
        // Check that if the profile contains QoS it is supported in the current cluster's version
        if (!FeatureSupported.networkQoS(version) && getDbFacade().getQosDao().get(vnicProfile.getNetworkQosId()) != null)
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWROK_QOS_IS_NOT_SUPPORTED, clusterVersion());
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult profileValid(Guid clusterId) {
    if (nic.getVnicProfileId() != null) {
        // Check that the profile exists
        VnicProfile vnicProfile = getDbFacade().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile == null) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VNIC_PROFILE_NOT_EXISTS);
        }
        // Check that the network exists in current cluster
        Network network = getNetworkByVnicProfile(vnicProfile);
        if (network == null || !isNetworkInCluster(network, clusterId)) {
            return new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        }
        // Check that if the profile contains QoS it is supported in the current cluster's version
        if (!FeatureSupported.networkQoS(version) && vnicProfile.getNetworkQosId() != null)
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWROK_QOS_IS_NOT_SUPPORTED, clusterVersion());
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void vnicProfileValidationTest(Matcher<ValidationResult> matcher, boolean profileExist, boolean networkExist, boolean qosExist, boolean qosSupported) {
    when(dbFacade.getVnicProfileDao()).thenReturn(vnicProfileDao);
    when(vnicProfileDao.get(any(Guid.class))).thenReturn(profileExist ? vnicProfile : null);
    when(vnicProfile.getNetworkId()).thenReturn(DEFAULT_GUID);
    doReturn(networkExist ? network : null).when(validator).getNetworkByVnicProfile(vnicProfile);
    doReturn(networkExist).when(validator).isNetworkInCluster(any(Network.class), any(Guid.class));
    when(dbFacade.getQosDao()).thenReturn(networkQosDao);
    when(networkQosDao.get(any(Guid.class))).thenReturn(qosExist ? networkQos : null);
    mockConfigRule.mockConfigValue(ConfigValues.NetworkQosSupported, version, qosSupported);
    when(nic.getVnicProfileId()).thenReturn(VNIC_PROFILE_ID);
    assertThat(validator.profileValid(OTHER_GUID), matcher);
}
#method_after
private void vnicProfileValidationTest(Matcher<ValidationResult> matcher, boolean profileExist, boolean networkExist, boolean qosNotNull, boolean qosSupported) {
    when(dbFacade.getVnicProfileDao()).thenReturn(vnicProfileDao);
    when(vnicProfileDao.get(any(Guid.class))).thenReturn(profileExist ? vnicProfile : null);
    when(vnicProfile.getNetworkId()).thenReturn(DEFAULT_GUID);
    doReturn(networkExist ? network : null).when(validator).getNetworkByVnicProfile(vnicProfile);
    doReturn(networkExist).when(validator).isNetworkInCluster(any(Network.class), any(Guid.class));
    mockConfigRule.mockConfigValue(ConfigValues.NetworkQosSupported, version, qosSupported);
    when(vnicProfile.getNetworkQosId()).thenReturn(qosNotNull ? DEFAULT_GUID : null);
    when(nic.getVnicProfileId()).thenReturn(VNIC_PROFILE_ID);
    assertThat(validator.profileValid(OTHER_GUID), matcher);
}
#end_block

#method_before
public void enableCifs() {
    accessProtocols.add(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_USER_CIFS, GlusterConstants.ON);
}
#method_after
public void enableCifs() {
    accessProtocols.add(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_USER_CIFS, GlusterConstants.ENABLE);
}
#end_block

#method_before
public void disableCifs() {
    accessProtocols.remove(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_USER_CIFS, GlusterConstants.OFF);
}
#method_after
public void disableCifs() {
    accessProtocols.remove(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_USER_CIFS, GlusterConstants.DISABLE);
}
#end_block

#method_before
public boolean isCifsEnabled() {
    String cifsEnabled = getOptionValue(GlusterConstants.OPTION_USER_CIFS);
    return (cifsEnabled == null || cifsEnabled.equalsIgnoreCase(GlusterConstants.ON));
}
#method_after
public boolean isCifsEnabled() {
    String cifsEnabled = getOptionValue(GlusterConstants.OPTION_USER_CIFS);
    return (cifsEnabled == null || cifsEnabled.equalsIgnoreCase(GlusterConstants.ENABLE));
}
#end_block

#method_before
@JsonIgnore
public HashMap<Guid, DiskImage> getDiskImageMap() {
    return diskMap;
}
#method_after
@JsonIgnore
public HashMap<Guid, DiskImage> getDiskImageMap() {
    return diskImageMap;
}
#end_block

#method_before
public void setDiskImageMap(HashMap<Guid, DiskImage> value) {
    diskMap = value;
}
#method_after
public void setDiskImageMap(HashMap<Guid, DiskImage> value) {
    diskImageMap = value;
}
#end_block

#method_before
public Map<String, String> getFiles() {
    return files;
}
#method_after
public HashMap<String, String> getFiles() {
    return files;
}
#end_block

#method_before
public Map<String, Object> getSpecParams() {
    // function produce something like that:
    // vmPayload={volumeId:volume-id,file:{filename:content,filename2:content2,...}}
    Map<String, Object> specParams = new HashMap<String, Object>();
    Map<String, Object> payload = new HashMap<String, Object>();
    specParams.put(SpecParamsPayload, payload);
    if (volumeId != null) {
        payload.put(SpecParamsVolumeIdType, volumeId);
    }
    payload.put(SpecParamsFileType, files);
    return specParams;
}
#method_after
@JsonIgnore
public Map<String, Object> getSpecParams() {
    // function produce something like that:
    // vmPayload={volumeId:volume-id,file:{filename:content,filename2:content2,...}}
    Map<String, Object> specParams = new HashMap<String, Object>();
    Map<String, Object> payload = new HashMap<String, Object>();
    specParams.put(SpecParamsPayload, payload);
    if (volumeId != null) {
        payload.put(SpecParamsVolumeIdType, volumeId);
    }
    payload.put(SpecParamsFileType, files);
    return specParams;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!updateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN_UP);
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isVersionCompatible()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible())) {
        return false;
    }
    Network network = null;
    if (getInterface().getVnicProfileId() != null) {
        network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
        // check that the network exists in current cluster
        if (network == null || !NetworkHelper.isNetworkInCluster(network, getVm().getVdsGroupId())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && (!validate(macAddressValid()) || !validate(macAvailable()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!updateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN_UP);
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible())) {
        return false;
    }
    Network network = null;
    if (getInterface().getVnicProfileId() != null) {
        network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
        // check that the network exists in current cluster
        if (network == null || !NetworkHelper.isNetworkInCluster(network, getVm().getVdsGroupId())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && (!validate(macAddressValid()) || !validate(macAvailable()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!validate(linkedToTemplate())) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!validate(templateExists())) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNic oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    Version clusterCompatibilityVersion = getVdsGroup().getcompatibility_version();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isVersionCompatible()) || !validate(nicValidator.emptyNetworkValid())) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !interfaceNameUnique(interfaces)) {
        return false;
    }
    if (getParameters().getInterface().getVnicProfileId() != null) {
        // check that the network exists in current cluster
        Network interfaceNetwork = NetworkHelper.getNetworkByVnicProfileId(getParameters().getInterface().getVnicProfileId());
        if (interfaceNetwork == null || !NetworkHelper.isNetworkInCluster(interfaceNetwork, getVmTemplate().getVdsGroupId())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!validate(linkedToTemplate())) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!validate(templateExists())) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNic oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    Version clusterCompatibilityVersion = getVdsGroup().getcompatibility_version();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid())) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !interfaceNameUnique(interfaces)) {
        return false;
    }
    if (getParameters().getInterface().getVnicProfileId() != null) {
        // check that the network exists in current cluster
        Network interfaceNetwork = NetworkHelper.getNetworkByVnicProfileId(getParameters().getInterface().getVnicProfileId());
        if (interfaceNetwork == null || !NetworkHelper.isNetworkInCluster(interfaceNetwork, getVmTemplate().getVdsGroupId())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    switch(getVmDynamicDao().get(getParameters().getVmId()).getStatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    if (!pciAndIdeWithinLimit(vm, Collections.<VmNic>singletonList(getInterface()))) {
        return false;
    }
    Version compatibilityVersion = getVm().getVdsGroupCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isVersionCompatible()) || !validate(nicValidator.emptyNetworkValid())) {
        return false;
    }
    if (getInterface().getVnicProfileId() != null) {
        // check that the network exists in current cluster
        Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
        if (network == null || !NetworkHelper.isNetworkInCluster(network, getVm().getVdsGroupId())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        } else if (!network.isVmNetwork()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
            addCanDoActionMessage(String.format("$networks %1$s", network.getName()));
            return false;
        }
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAddressValid()) || !validate(macAvailable())) {
            return false;
        }
    } else if (MacPoolManager.getInstance().getAvailableMacsCount() <= 0) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    switch(getVmDynamicDao().get(getParameters().getVmId()).getStatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    if (!pciAndIdeWithinLimit(vm, Collections.<VmNic>singletonList(getInterface()))) {
        return false;
    }
    Version compatibilityVersion = getVm().getVdsGroupCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid())) {
        return false;
    }
    if (getInterface().getVnicProfileId() != null) {
        // check that the network exists in current cluster
        Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
        if (network == null || !NetworkHelper.isNetworkInCluster(network, getVm().getVdsGroupId())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        } else if (!network.isVmNetwork()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
            addCanDoActionMessage(String.format("$networks %1$s", network.getName()));
            return false;
        }
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAddressValid()) || !validate(macAvailable())) {
            return false;
        }
    } else if (MacPoolManager.getInstance().getAvailableMacsCount() <= 0) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getNumOfMonitors(), Collections.<VmNic>singletonList(getParameters().getInterface()), new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Version clusterCompatibilityVersion = getVdsGroup().getcompatibility_version();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isVersionCompatible()) || !validate(nicValidator.emptyNetworkValid())) {
        return false;
    }
    if (getParameters().getInterface().getVnicProfileId() != null) {
        // check that the network exists in current cluster
        Network interfaceNetwork = NetworkHelper.getNetworkByVnicProfileId(getParameters().getInterface().getVnicProfileId());
        if (interfaceNetwork == null || !NetworkHelper.isNetworkInCluster(interfaceNetwork, getVmTemplate().getVdsGroupId())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getNumOfMonitors(), Collections.<VmNic>singletonList(getParameters().getInterface()), new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Version clusterCompatibilityVersion = getVdsGroup().getcompatibility_version();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid())) {
        return false;
    }
    if (getParameters().getInterface().getVnicProfileId() != null) {
        // check that the network exists in current cluster
        Network interfaceNetwork = NetworkHelper.getNetworkByVnicProfileId(getParameters().getInterface().getVnicProfileId());
        if (interfaceNetwork == null || !NetworkHelper.isNetworkInCluster(interfaceNetwork, getVmTemplate().getVdsGroupId())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public ValidationResult validateIsoPath(VM vm, String diskPath, String floppyPath) {
    if (vm.isAutoStartup() || (StringUtils.isEmpty(diskPath) && StringUtils.isEmpty(floppyPath))) {
        return ValidationResult.VALID;
    }
    Guid storageDomainId = getIsoDomainListSyncronizer().findActiveISODomain(vm.getStoragePoolId());
    if (storageDomainId == null) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (!StringUtils.isEmpty(diskPath) && !isDiskPathImageExists(diskPath, storageDomainId)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    if (!StringUtils.isEmpty(floppyPath) && !isFloppyPathImageExists(floppyPath, storageDomainId)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateIsoPath(VM vm, String diskPath, String floppyPath) {
    if (vm.isAutoStartup() || (StringUtils.isEmpty(diskPath) && StringUtils.isEmpty(floppyPath))) {
        return ValidationResult.VALID;
    }
    Guid storageDomainId = getIsoDomainListSyncronizer().findActiveISODomain(vm.getStoragePoolId());
    if (storageDomainId == null) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (!StringUtils.isEmpty(diskPath) && !isRepoImageExists(diskPath, storageDomainId, ImageFileType.ISO)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    if (!StringUtils.isEmpty(floppyPath) && !isRepoImageExists(floppyPath, storageDomainId, ImageFileType.Floppy)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public boolean canRunVm(VM vm, List<String> messages, List<Disk> vmDisks, BootSequence bootSequence, StoragePool storagePool, boolean isInternalExecution, String diskPath, String floppyPath, Boolean runAsStateless, List<Guid> vdsBlackList, Guid destVds, VDSGroup vdsGroup) {
    if (!validateVmProperties(vm, messages) || !validate(validateBootSequence(vm, bootSequence, vmDisks), messages) || !validate(new VmValidator(vm).vmNotLocked(), messages) || !validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) || !validate(validateVmStatusUsingMatrix(vm), messages) || !validate(new StoragePoolValidator(storagePool).isUp(), messages) || !validate(validateIsoPath(vm, diskPath, floppyPath), messages) || !validate(vmDuringInitialization(vm), messages) || !validate(validateVdsStatus(vm), messages) || !validate(validateStatelessVm(vm, vmDisks, runAsStateless), messages)) {
        return false;
    }
    List<DiskImage> images = ImagesHandler.filterImageDisks(vmDisks, true, false);
    if (!images.isEmpty() && (!validate(validateStorageDomains(vm, isInternalExecution, images), messages) || !validate(validateImagesForRunVm(images), messages))) {
        return false;
    }
    if (!SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, null, destVds, messages)) {
        return false;
    }
    return true;
}
#method_after
public boolean canRunVm(VM vm, List<String> messages, List<Disk> vmDisks, BootSequence bootSequence, StoragePool storagePool, boolean isInternalExecution, String diskPath, String floppyPath, Boolean runAsStateless, List<Guid> vdsBlackList, Guid destVds, VDSGroup vdsGroup) {
    if (!validateVmProperties(vm, messages) || !validate(validateBootSequence(vm, bootSequence, vmDisks), messages) || !validate(new VmValidator(vm).vmNotLocked(), messages) || !validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) || !validate(validateVmStatusUsingMatrix(vm), messages) || !validate(validateIsoPath(vm, diskPath, floppyPath), messages) || !validate(vmDuringInitialization(vm), messages) || !validate(validateVdsStatus(vm), messages) || !validate(validateStatelessVm(vm, vmDisks, runAsStateless), messages)) {
        return false;
    }
    List<DiskImage> images = ImagesHandler.filterImageDisks(vmDisks, true, false);
    if (!images.isEmpty() && (!validate(new StoragePoolValidator(storagePool).isUp(), messages) || !validate(validateStorageDomains(vm, isInternalExecution, images), messages) || !validate(validateImagesForRunVm(images), messages))) {
        return false;
    }
    if (!SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, null, destVds, messages)) {
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult validateIsoPath(VM vm, String diskPath, String floppyPath) {
    if (vm.isAutoStartup() || (StringUtils.isEmpty(diskPath) && StringUtils.isEmpty(floppyPath))) {
        return ValidationResult.VALID;
    }
    Guid storageDomainId = getIsoDomainListSyncronizer().findActiveISODomain(vm.getStoragePoolId());
    if (storageDomainId == null) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (!StringUtils.isEmpty(diskPath) && !isDiskPathImageExists(diskPath, storageDomainId)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    if (!StringUtils.isEmpty(floppyPath) && !isFloppyPathImageExists(floppyPath, storageDomainId)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateIsoPath(VM vm, String diskPath, String floppyPath) {
    if (vm.isAutoStartup() || (StringUtils.isEmpty(diskPath) && StringUtils.isEmpty(floppyPath))) {
        return ValidationResult.VALID;
    }
    Guid storageDomainId = getIsoDomainListSyncronizer().findActiveISODomain(vm.getStoragePoolId());
    if (storageDomainId == null) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (!StringUtils.isEmpty(diskPath) && !isRepoImageExists(diskPath, storageDomainId, ImageFileType.ISO)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    if (!StringUtils.isEmpty(floppyPath) && !isRepoImageExists(floppyPath, storageDomainId, ImageFileType.Floppy)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public boolean canRunVm(VM vm, List<String> messages, List<Disk> vmDisks, BootSequence bootSequence, StoragePool storagePool, boolean isInternalExecution, String diskPath, String floppyPath, Boolean runAsStateless, List<Guid> vdsBlackList, Guid destVds, VDSGroup vdsGroup) {
    if (!validateVmProperties(vm, messages) || !validate(validateBootSequence(vm, bootSequence, vmDisks), messages) || !validate(new VmValidator(vm).vmNotLocked(), messages) || !validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) || !validate(validateVmStatusUsingMatrix(vm), messages) || !validate(validateStoragePoolUp(vm, storagePool), messages) || !validate(validateIsoPath(vm, diskPath, floppyPath), messages) || !validate(vmDuringInitialization(vm), messages) || !validate(validateVdsStatus(vm), messages) || !validate(validateStatelessVm(vm, vmDisks, runAsStateless), messages)) {
        return false;
    }
    List<DiskImage> images = ImagesHandler.filterImageDisks(vmDisks, true, false);
    if (!images.isEmpty() && (!validate(validateStorageDomains(vm, isInternalExecution, images), messages) || !validate(validateImagesForRunVm(vm, images), messages))) {
        return false;
    }
    if (!SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, null, destVds, messages)) {
        return false;
    }
    return true;
}
#method_after
public boolean canRunVm(VM vm, List<String> messages, List<Disk> vmDisks, BootSequence bootSequence, StoragePool storagePool, boolean isInternalExecution, String diskPath, String floppyPath, Boolean runAsStateless, List<Guid> vdsBlackList, Guid destVds, VDSGroup vdsGroup) {
    if (!validateVmProperties(vm, messages) || !validate(validateBootSequence(vm, bootSequence, vmDisks), messages) || !validate(new VmValidator(vm).vmNotLocked(), messages) || !validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) || !validate(validateVmStatusUsingMatrix(vm), messages) || !validate(validateIsoPath(vm, diskPath, floppyPath), messages) || !validate(vmDuringInitialization(vm), messages) || !validate(validateVdsStatus(vm), messages) || !validate(validateStatelessVm(vm, vmDisks, runAsStateless), messages)) {
        return false;
    }
    List<DiskImage> images = ImagesHandler.filterImageDisks(vmDisks, true, false);
    if (!images.isEmpty() && (!validate(validateStoragePoolUp(vm, storagePool), messages) || !validate(validateStorageDomains(vm, isInternalExecution, images), messages) || !validate(validateImagesForRunVm(vm, images), messages))) {
        return false;
    }
    if (!SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, null, destVds, messages)) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean canRunVm(VM vm, List<String> messages, List<Disk> vmDisks, BootSequence bootSequence, StoragePool storagePool, boolean isInternalExecution, String diskPath, String floppyPath, Boolean runAsStateless, List<Guid> vdsBlackList, Guid destVds, VDSGroup vdsGroup) {
    if (!validateVmProperties(vm, messages) || !validate(validateBootSequence(vm, bootSequence, vmDisks), messages) || !validate(new VmValidator(vm).vmNotLocked(), messages) || !validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) || !validate(validateVmStatusUsingMatrix(vm), messages) || !validate(new StoragePoolValidator(storagePool).isUp(), messages) || !validate(validateIsoPath(vm.isAutoStartup(), vm.getStoragePoolId(), diskPath, floppyPath), messages) || !validate(vmDuringInitialization(vm), messages) || !validate(validateVdsStatus(vm), messages) || !validate(validateStatelessVm(vm, vmDisks, runAsStateless), messages)) {
        return false;
    }
    List<DiskImage> images = ImagesHandler.filterImageDisks(vmDisks, true, false);
    if (!images.isEmpty() && (!validate(validateStorageDomains(vm, isInternalExecution, images), messages) || !validate(validateImagesForRunVm(images), messages))) {
        return false;
    }
    if (!SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, null, destVds, messages)) {
        return false;
    }
    return true;
}
#method_after
public boolean canRunVm(VM vm, List<String> messages, List<Disk> vmDisks, BootSequence bootSequence, StoragePool storagePool, boolean isInternalExecution, String diskPath, String floppyPath, Boolean runAsStateless, List<Guid> vdsBlackList, Guid destVds, VDSGroup vdsGroup) {
    if (!validateVmProperties(vm, messages) || !validate(validateBootSequence(vm, bootSequence, vmDisks), messages) || !validate(new VmValidator(vm).vmNotLocked(), messages) || !validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) || !validate(validateVmStatusUsingMatrix(vm), messages) || !validate(validateIsoPath(vm.isAutoStartup(), vm.getStoragePoolId(), diskPath, floppyPath), messages) || !validate(vmDuringInitialization(vm), messages) || !validate(validateVdsStatus(vm), messages) || !validate(validateStatelessVm(vm, vmDisks, runAsStateless), messages)) {
        return false;
    }
    List<DiskImage> images = ImagesHandler.filterImageDisks(vmDisks, true, false);
    if (!images.isEmpty() && (!validate(new StoragePoolValidator(storagePool).isUp(), messages) || !validate(validateStorageDomains(vm, isInternalExecution, images), messages) || !validate(validateImagesForRunVm(images), messages))) {
        return false;
    }
    if (!SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, null, destVds, messages)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void createVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().createVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#method_after
private void createVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().createVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().cannotChooseVolumesDataCenterinTreeContect());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().cannotChooseVolumesClusterinTreeContect());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().cannotChooseVolumesDataCenterinTreeContect());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#end_block

#method_before
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStorageTypeList().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStorageTypeList().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStorageTypeList().setSelectedItem(dataCenter.getStorageType());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStorageTypeList().setChangeProhibitionReason(// $NON-NLS-1$
                "Cannot change Repository type with Storage Domains attached to it");
                model.getStorageTypeList().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStorageTypeList().setSelectedItem(dataCenter.getStorageType());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
protected void postInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            boolean provisioning = (Boolean) behavior.getModel().getProvisioning().getEntity();
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisks();
            Collections.sort(activeStorageDomains, new NameableComparator());
            for (DiskModel diskModel : disks) {
                ArrayList<StorageDomain> availableDiskStorageDomains;
                diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                ArrayList<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
                // Active storage domains that the disk resides on
                ArrayList<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
                // Set target storage domains
                availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
                Collections.sort(availableDiskStorageDomains, new NameableComparator());
                diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
                diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
                diskModel.getStorageDomain().setIsChangable(!availableDiskStorageDomains.isEmpty());
            }
        }
    }, getModel().getHash()), dataCenter.getId(), ActionGroup.CREATE_VM);
}
#method_after
protected void postInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    StoragePool dataCenter = (StoragePool) getModel().getSelectedDataCenter();
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            boolean provisioning = (Boolean) behavior.getModel().getProvisioning().getEntity();
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisks();
            Collections.sort(activeStorageDomains, new NameableComparator());
            for (DiskModel diskModel : disks) {
                ArrayList<StorageDomain> availableDiskStorageDomains;
                diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                ArrayList<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
                // Active storage domains that the disk resides on
                ArrayList<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
                // Set target storage domains
                availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
                Collections.sort(availableDiskStorageDomains, new NameableComparator());
                diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
                diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
                diskModel.getStorageDomain().setIsChangable(!availableDiskStorageDomains.isEmpty());
            }
        }
    }, getModel().getHash()), dataCenter.getId(), ActionGroup.CREATE_VM);
}
#end_block

#method_before
private void fetchSSHFingerprint() {
    // Cleaning up fields for initialization
    getFetchSshFingerprint().setEntity(ConstantsManager.getInstance().getConstants().empty());
    getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().empty());
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getFetchSshFingerprint().setEntity(result);
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().successLoadingFingerprint());
            } else {
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
            }
        }
    };
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (!getHost().getIsValid()) {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().fingerprintAddressError() + getHost().getInvalidityReasons().get(0));
    } else {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
        AsyncDataProvider.getHostFingerprint(aQuery, getHost().getEntity().toString());
    }
}
#method_after
private void fetchSSHFingerprint() {
    // Cleaning up fields for initialization
    getFetchSshFingerprint().setEntity(ConstantsManager.getInstance().getConstants().empty());
    getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().empty());
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getFetchSshFingerprint().setEntity(result);
                getFetchResult().setEntity((String) ConstantsManager.getInstance().getConstants().successLoadingFingerprint());
            } else {
                getFetchResult().setEntity((String) ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
            }
        }
    };
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (!getHost().getIsValid()) {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().fingerprintAddressError() + getHost().getInvalidityReasons().get(0));
    } else {
        getFetchResult().setEntity((String) ConstantsManager.getInstance().getConstants().loadingFingerprint());
        AsyncDataProvider.getHostFingerprint(aQuery, getHost().getEntity().toString());
    }
}
#end_block

#method_before
private void fillConnectionDetailsIfNeeded(StorageServerConnections connection) {
    if (connection.getid() == null) {
        List<StorageServerConnections> dbConnections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (!dbConnections.isEmpty()) {
            connection.setid(dbConnections.get(0).getid());
        }
    }
}
#method_after
private void fillConnectionDetailsIfNeeded(StorageServerConnections connection) {
    // it from the db by its details.
    if (connection.getid() == null) {
        List<StorageServerConnections> dbConnections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (!dbConnections.isEmpty()) {
            connection.setid(dbConnections.get(0).getid());
        }
    }
}
#end_block

#method_before
protected Response doAttachAction(Action action, VdcActionType actionType) {
    VdsNetworkInterface hostInterface = parent.lookupInterface(id);
    org.ovirt.engine.core.common.businessentities.network.Network network = action.getNetwork() == null ? null : parent.lookupNetwork(action.getNetwork());
    AttachNetworkToVdsParameters params = new AttachNetworkToVdsParameters(asGuid(parent.getHostId()), network, hostInterface);
    params.setBondingOptions(hostInterface.getBondOptions());
    if (network == null || network.getVlanId() == null) {
        params.setBootProtocol(hostInterface.getBootProtocol());
        params.setAddress(hostInterface.getAddress());
        params.setSubnet(hostInterface.getSubnet());
    }
    return doAction(actionType, params, action);
}
#method_after
protected Response doAttachAction(Action action, VdcActionType actionType) {
    VdsNetworkInterface hostInterface = parent.lookupInterface(id);
    org.ovirt.engine.core.common.businessentities.network.Network network = action.getNetwork() == null ? null : parent.lookupNetwork(action.getNetwork());
    AttachNetworkToVdsParameters params = new AttachNetworkToVdsParameters(asGuid(parent.getHostId()), network, hostInterface);
    params.setBondingOptions(hostInterface.getBondOptions());
    // TODO: Delete the next block since it misuses the nic parameters
    if (network == null || network.getVlanId() == null) {
        params.setBootProtocol(hostInterface.getBootProtocol());
        params.setAddress(hostInterface.getAddress());
        params.setSubnet(hostInterface.getSubnet());
    }
    return doAction(actionType, params, action);
}
#end_block

#method_before
@Test
public void testAttachVlan() throws Exception {
    testAction(VdcActionType.AttachNetworkToVdsInterface, null, NETWORK_NAME, new AttachNetworkToVdsParameters().getBootProtocol(), 100);
}
#method_after
@Test
public void testAttachVlan() throws Exception {
    testAction(VdcActionType.AttachNetworkToVdsInterface, null, NETWORK_NAME, 100);
}
#end_block

#method_before
protected void testAction(VdcActionType actionType, String networkId, String networkName) throws Exception {
    testAction(actionType, networkId, networkName, BOOT_PROTOCOL, null);
}
#method_after
protected void testAction(VdcActionType actionType, String networkId, String networkName) throws Exception {
    testAction(actionType, networkId, networkName, null);
}
#end_block

#method_before
protected void testAction(VdcActionType actionType, String networkId, String networkName, NetworkBootProtocol bootProtocol, Integer vlanId) throws Exception {
    Action action = new Action();
    action.setNetwork(new Network());
    if (networkId != null) {
        action.getNetwork().setId(networkId);
    } else {
        action.getNetwork().setName(networkName);
    }
    org.ovirt.engine.core.common.businessentities.network.Network network = getNetwork();
    network.setVlanId(vlanId);
    setUpEntityQueryExpectations(VdcQueryType.GetAllNetworks, IdQueryParameters.class, new String[] { "Id" }, new Object[] { Guid.Empty }, asList(network));
    setUpEntityQueryExpectations();
    setUriInfo(setUpActionExpectations(actionType, AttachNetworkToVdsParameters.class, new String[] { "VdsId", "BootProtocol" }, new Object[] { PARENT_GUID, bootProtocol }, true, true, null, null, true));
    if (actionType == VdcActionType.AttachNetworkToVdsInterface) {
        verifyActionResponse(resource.attach(action));
    } else {
        verifyActionResponse(resource.detach(action));
    }
}
#method_after
protected void testAction(VdcActionType actionType, String networkId, String networkName, Integer vlanId) throws Exception {
    Action action = new Action();
    action.setNetwork(new Network());
    if (networkId != null) {
        action.getNetwork().setId(networkId);
    } else {
        action.getNetwork().setName(networkName);
    }
    org.ovirt.engine.core.common.businessentities.network.Network network = getNetwork();
    network.setVlanId(vlanId);
    setUpEntityQueryExpectations(VdcQueryType.GetAllNetworks, IdQueryParameters.class, new String[] { "Id" }, new Object[] { Guid.Empty }, asList(network));
    setUpEntityQueryExpectations();
    List<String> parameterNames = new ArrayList<>();
    parameterNames.add("VdsId");
    List<Object> parameterValues = new ArrayList<>();
    parameterValues.add(PARENT_GUID);
    if (vlanId == null) {
        parameterNames.add("BootProtocol");
        parameterValues.add(BOOT_PROTOCOL);
    }
    setUriInfo(setUpActionExpectations(actionType, AttachNetworkToVdsParameters.class, parameterNames.toArray(new String[0]), parameterValues.toArray(), true, true, null, null, true));
    if (actionType == VdcActionType.AttachNetworkToVdsInterface) {
        verifyActionResponse(resource.attach(action));
    } else {
        verifyActionResponse(resource.detach(action));
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    // we don't run the VM
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (!getVm().isRunningOrPaused()) {
        setSucceeded(false);
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'mCdImagePath' means eject CD
        if (!StringUtils.isEmpty(mCdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if ((IsoDomainListSyncronizer.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(mCdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        setSucceeded(false);
        retValue = false;
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        retValue = false;
    }
    if (retValue && !canRunActionOnNonManagedVm()) {
        retValue = false;
    }
    if (retValue && !getVm().isRunningOrPaused()) {
        setSucceeded(false);
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'mCdImagePath' means eject CD
        if (!StringUtils.isEmpty(mCdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if ((IsoDomainListSyncronizer.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(mCdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        setSucceeded(false);
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
private String getIsoPrefix() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    synchronized (getLockObjForStoragePool(storagePoolId)) {
        if (!storagePoolId2IsoPrefix.containsKey(storagePoolId)) {
            try {
                StoragePoolInfoReturnForXmlRpc returnValue = getBroker().getStoragePoolInfo(storagePoolId.toString());
                storagePoolId2IsoPrefix.put(storagePoolId, returnValue.mStoragePoolInfo.containsKey(IrsProperties.isoPrefix) ? returnValue.mStoragePoolInfo.get(IrsProperties.isoPrefix).toString() : StringUtils.EMPTY);
            } catch (Exception ex) {
                log.errorFormat("IsoPrefix Failed to get storage pool info (vds {0}).", getParameters().getVdsId());
                return StringUtils.EMPTY;
            }
        }
        return storagePoolId2IsoPrefix.get(storagePoolId);
    }
}
#method_after
private String getIsoPrefix() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    String cachedIsoPrefix = storagePoolIdToIsoPrefix.get(storagePoolId);
    if (cachedIsoPrefix != null) {
        return cachedIsoPrefix;
    }
    synchronized (getLockObjForStoragePool(storagePoolId)) {
        cachedIsoPrefix = storagePoolIdToIsoPrefix.get(storagePoolId);
        if (cachedIsoPrefix != null) {
            return cachedIsoPrefix;
        }
        StoragePoolInfoReturnForXmlRpc retVal;
        try {
            retVal = getBroker().getStoragePoolInfo(storagePoolId.toString());
        } catch (Exception ex) {
            log.errorFormat("IsoPrefix Failed to get storage pool info (vds {0}, pool {1}).", getParameters().getVdsId(), storagePoolId);
            return StringUtils.EMPTY;
        }
        String isoPrefix = getIsoPrefixFromStoragePoolInfoReturnValue(retVal);
        storagePoolIdToIsoPrefix.put(storagePoolId, isoPrefix);
        return isoPrefix;
    }
}
#end_block

#method_before
static void clearCachedIsoPrefix(Guid storagePoolId) {
    synchronized (getLockObjForStoragePool(storagePoolId)) {
        storagePoolId2IsoPrefix.remove(storagePoolId);
    }
}
#method_after
static void clearCachedIsoPrefix(Guid storagePoolId) {
    storagePoolIdToIsoPrefix.remove(storagePoolId);
}
#end_block

#method_before
private static Object getLockObjForStoragePool(Guid storagePoolId) {
    Object result = storagePoolId2LockObj.get(storagePoolId);
    if (result == null) {
        final Object value = new Object();
        result = storagePoolId2LockObj.putIfAbsent(storagePoolId, value);
        if (result == null) {
            result = value;
        }
    }
    return result;
}
#method_after
private static Object getLockObjForStoragePool(Guid storagePoolId) {
    Object result = storagePoolIdToLockObj.get(storagePoolId);
    if (result == null) {
        final Object value = new Object();
        result = storagePoolIdToLockObj.putIfAbsent(storagePoolId, value);
        if (result == null) {
            result = value;
        }
    }
    return result;
}
#end_block

#method_before
public static void fillImagesMapBasedOnTemplate(VmTemplate template, List<StorageDomain> domains, Map<Guid, DiskImage> diskInfoDestinationMap, Map<Guid, StorageDomain> destStorages, boolean notCheckSize) {
    Map<Guid, StorageDomain> storageDomainsMap = new HashMap<Guid, StorageDomain>();
    for (StorageDomain storageDomain : domains) {
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (validator.isDomainExistAndActive().isValid() && validator.domainIsValidDestination().isValid() && (notCheckSize || validator.isDomainWithinThresholds().isValid())) {
            storageDomainsMap.put(storageDomain.getId(), storageDomain);
        }
    }
    for (DiskImage image : template.getDiskMap().values()) {
        for (Guid storageId : image.getStorageIds()) {
            if (storageDomainsMap.containsKey(storageId)) {
                ArrayList<Guid> storageIds = new ArrayList<Guid>();
                storageIds.add(storageId);
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
                break;
            }
        }
    }
    if (destStorages != null) {
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            Guid storageDomainId = diskImage.getStorageIds().get(0);
            destStorages.put(storageDomainId, storageDomainsMap.get(storageDomainId));
        }
    }
}
#method_after
public static void fillImagesMapBasedOnTemplate(VmTemplate template, List<StorageDomain> domains, Map<Guid, DiskImage> diskInfoDestinationMap, Map<Guid, StorageDomain> destStorages, boolean notCheckSize) {
    Map<Guid, StorageDomain> storageDomainsMap = new HashMap<Guid, StorageDomain>();
    for (StorageDomain storageDomain : domains) {
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (validator.isDomainExistAndActive().isValid() && validator.domainIsValidDestination().isValid() && (notCheckSize || validator.isDomainWithinThresholds().isValid())) {
            storageDomainsMap.put(storageDomain.getId(), storageDomain);
        }
    }
    for (DiskImage image : template.getDiskTemplateMap().values()) {
        for (Guid storageId : image.getStorageIds()) {
            if (storageDomainsMap.containsKey(storageId)) {
                ArrayList<Guid> storageIds = new ArrayList<Guid>();
                storageIds.add(storageId);
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
                break;
            }
        }
    }
    if (destStorages != null) {
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            Guid storageDomainId = diskImage.getStorageIds().get(0);
            destStorages.put(storageDomainId, storageDomainsMap.get(storageDomainId));
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    // we don't run the VM
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET_TICKET);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TICKET);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getStatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        return false;
    }
    // subjects:
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getStatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        return false;
    }
    // subjects:
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return AuditLogType.VM_SET_TICKET;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.VM_SET_TICKET : AuditLogType.VM_SET_TICKET_FAILED;
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // update for the AI.
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#end_block

#method_before
@Override
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        _vmInterfaces = vmFromConfiguration.getInterfaces();
    }
    return _vmInterfaces;
}
#method_after
@Override
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        _vmInterfaces = Entities.<VmNic, VmNetworkInterface>upcast(vmFromConfiguration.getInterfaces());
    }
    return _vmInterfaces;
}
#end_block

#method_before
@Override
protected void copyVmDevices() {
    List<VmDevice> devices = new ArrayList<VmDevice>(vmFromConfiguration.getVmUnamagedDeviceList());
    devices.addAll(vmFromConfiguration.getManagedVmDeviceMap().values());
    VmDeviceUtils.copyVmDevices(getVmIdFromSnapshot(), getVmId(), getVm(), getVm().getStaticData(), true, devices, srcDiskToTargetDiskMapping, _vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
}
#method_after
@Override
protected void copyVmDevices() {
    List<VmDevice> devices = new ArrayList<VmDevice>(vmFromConfiguration.getVmUnamagedDeviceList());
    devices.addAll(vmFromConfiguration.getManagedVmDeviceMap().values());
    VmDeviceUtils.copyVmDevices(getVmIdFromSnapshot(), getVmId(), getVm(), getVm().getStaticData(), true, devices, getSrcDiskIdToTargetDiskIdMapping(), _vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
}
#end_block

#method_before
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<Guid, DiskImage>();
    }
    sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getStorageIds().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setStorageIds(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#method_after
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<Guid, DiskImage>();
    }
    sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getStorageIds().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNetworkInterface> vmInterfaces = addVmInterfaces();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDiskToTargetDiskMapping, vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDiskToTargetDiskMapping, vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
            }
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNic> vmInterfaces = addVmInterfaces();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDiskToTargetDiskMapping, vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDiskToTargetDiskMapping, vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
            }
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
protected List<VmNetworkInterface> addVmInterfaces() {
    List<VmNetworkInterface> templateInterfaces = new ArrayList<VmNetworkInterface>();
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.newGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        templateInterfaces.add(iDynamic);
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
    }
    return templateInterfaces;
}
#method_after
protected List<VmNic> addVmInterfaces() {
    List<VmNic> templateInterfaces = new ArrayList<>();
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNic iface : interfaces) {
        VmNic iDynamic = new VmNic();
        iDynamic.setId(Guid.newGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setVnicProfileId(iface.getVnicProfileId());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        templateInterfaces.add(iDynamic);
        getVmNicDao().save(iDynamic);
    }
    return templateInterfaces;
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid vmSnapshotId = Guid.newGuid();
    for (DiskImage diskImage : mImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = executeChildCommand(diskImage.getImageId());
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDiskToTargetDiskMapping.put(diskImage.getId(), newImage.getId());
        newDiskImages.add((DiskImage) retValue.getActionReturnValue());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid vmSnapshotId = Guid.newGuid();
    for (DiskImage diskImage : mImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = executeChildCommand(diskImage.getImageId());
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDiskToTargetDiskMapping.put(diskImage.getId(), newImage.getId());
    }
}
#end_block

#method_before
private void addPermission() {
    addPermissionForTemplate(getCurrentUser().getUserId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions();
}
#method_after
private void addPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    addPermissionForTemplate(permissionsToAdd, getCurrentUser().getUserId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(permissionsToAdd, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    } else {
        addPermissionForTemplate(permissionsToAdd, getCurrentUser().getUserId(), PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions(permissionsToAdd);
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
    }
}
#end_block

#method_before
private void copyVmPermissions() {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> vmPermissions = dao.getAllForEntity(getVmId(), getCurrentUser().getUserId(), false);
    List<permissions> templatePermissions = new ArrayList<permissions>();
    for (permissions vmPermission : vmPermissions) {
        templatePermissions.add(new permissions(getCurrentUser().getUserId(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate));
    }
    if (templatePermissions.size() > 0) {
        MultiLevelAdministrationHandler.addPermission(templatePermissions.toArray(new permissions[templatePermissions.size()]));
    }
}
#method_after
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> vmPermissions = dao.getAllForEntity(getVmId(), getCurrentUser().getUserId(), false);
    for (permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#end_block

#method_before
private void addPermissionForTemplate(Guid userId, PredefinedRoles role) {
    permissions perms = new permissions();
    perms.setad_element_id(userId);
    perms.setObjectType(VdcObjectType.VmTemplate);
    perms.setObjectId(getParameters().getVmTemplateId());
    perms.setrole_id(role.getId());
    MultiLevelAdministrationHandler.addPermission(perms);
}
#method_after
private void addPermissionForTemplate(UniquePermissionsSet permissionsToAdd, Guid userId, PredefinedRoles role) {
    permissionsToAdd.addPermission(userId, role.getId(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
}
#end_block

#method_before
@Override
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        for (DiskImage disk : getVmTemplate().getDiskMap().values()) {
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateCloneOfTemplate, buildCreateCloneOfTemplateParameters(disk), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            // if couldnt create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskToTargetDiskMapping.put(disk.getId(), newImage.getId());
                newDiskImages.add(newImage);
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        for (DiskImage disk : getVmTemplate().getDiskMap().values()) {
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateCloneOfTemplate, buildCreateCloneOfTemplateParameters(disk), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            // if couldnt create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                getSrcDiskIdToTargetDiskIdMapping().put(disk.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
public static void updateAudioDevice(VmBase oldVm, VmBase newVmBase, Version compatibilityVersion, Boolean isSoundDeviceEnabled) {
    boolean removeDevice = false;
    boolean createDevice = false;
    Guid vmId = oldVm.getId();
    boolean osChanged = oldVm.getOsId() != newVmBase.getOsId();
    List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
    // recreate device only if previously existed and os has changed
    if (isSoundDeviceEnabled == null) {
        if (!list.isEmpty() && osChanged) {
            removeDevice = createDevice = true;
        }
    } else {
        // if soundeDevice disabled or os changed, and device exist, remove
        removeDevice = (!isSoundDeviceEnabled || osChanged) && !list.isEmpty();
        // if soundDevice enabled and missing or os changed, create
        createDevice = isSoundDeviceEnabled && (list.isEmpty() || osChanged);
    }
    if (removeDevice) {
        removeNumberOfDevices(list, list.size());
    }
    if (createDevice) {
        String soundDevice = OsRepositoryImpl.INSTANCE.getSoundDevice(newVmBase.getOsId(), compatibilityVersion);
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null);
    }
}
#method_after
public static void updateAudioDevice(VmBase oldVm, VmBase newVmBase, Version compatibilityVersion, Boolean isSoundDeviceEnabled) {
    boolean removeDevice = false;
    boolean createDevice = false;
    Guid vmId = oldVm.getId();
    boolean osChanged = oldVm.getOsId() != newVmBase.getOsId();
    List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
    // recreate device only if previously existed and os has changed
    if (isSoundDeviceEnabled == null) {
        if (!list.isEmpty() && osChanged) {
            removeDevice = createDevice = true;
        }
    } else {
        // if soundeDevice disabled or os changed, and device exist, remove
        removeDevice = (!isSoundDeviceEnabled || osChanged) && !list.isEmpty();
        // if soundDevice enabled and missing or os changed, create
        createDevice = isSoundDeviceEnabled && (list.isEmpty() || osChanged);
    }
    if (removeDevice) {
        removeNumberOfDevices(list, list.size());
    }
    if (createDevice) {
        String soundDevice = osRepository.getSoundDevice(newVmBase.getOsId(), compatibilityVersion);
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null);
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDiskToTargetDiskMapping, List<VmNetworkInterface> ifaces, boolean soundDeviceEnabled, boolean isConsoleEnabled) {
    VM vm = DbFacade.getInstance().getVmDao().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDao().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, vm, vmBase, isVm, devices, srcDiskToTargetDiskMapping, ifaces, soundDeviceEnabled, isConsoleEnabled);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDiskToTargetDiskMapping, List<VmNic> ifaces, boolean soundDeviceEnabled, boolean isConsoleEnabled) {
    Guid id;
    int ifaceCount = 0;
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    for (VmDevice device : devicesDataToUse) {
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase, vm.isBalloonEnabled());
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    id = srcDiskToTargetDiskMapping.get(device.getDeviceId());
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (ifaceCount < ifaces.size()) {
                    id = ifaces.get(ifaceCount++).getId();
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId());
            if (cluster != null) {
                addSoundCard(vmBase, cluster.getcompatibility_version());
            }
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = (vmBase.getDefaultDisplayType() == DisplayType.vnc) ? Math.max(1, vmBase.getNumOfMonitors()) : vmBase.getSingleQxlPci() ? 1 : vmBase.getNumOfMonitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
private static void addSoundCard(VmBase vmBase, Version vdsGroupCompatibilityVersion) {
    String soundDevice = OsRepositoryImpl.INSTANCE.getSoundDevice(vmBase.getOsId(), vdsGroupCompatibilityVersion);
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vmBase.getId()), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null);
}
#method_after
private static void addSoundCard(VmBase vmBase, Version vdsGroupCompatibilityVersion) {
    String soundDevice = osRepository.getSoundDevice(vmBase.getOsId(), vdsGroupCompatibilityVersion);
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vmBase.getId()), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null);
}
#end_block

#method_before
public static VmDevice addNetworkInterfaceDevice(VmDeviceId id, boolean plugged, Map<String, String> customProp) {
    return addManagedDevice(id, VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE, Collections.<String, Object>emptyMap(), plugged, false, customProp);
}
#method_after
public static VmDevice addNetworkInterfaceDevice(VmDeviceId id, boolean plugged) {
    return addManagedDevice(id, VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE, Collections.<String, Object>emptyMap(), plugged, false, null);
}
#end_block

#method_before
private static boolean canPlugInterface(VmNetworkInterface iface) {
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.existsPluggedInterfaceWithSameMac(iface)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface);
        return false;
    } else {
        return true;
    }
}
#method_after
private static boolean canPlugInterface(VmNic iface) {
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.existsPluggedInterfaceWithSameMac(iface)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface);
        return false;
    } else {
        return true;
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity, List<VmDevice> vmDeviceToUpdate) {
    final Guid id = entity.getId();
    for (VmNetworkInterface iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE, null, true, false, getAddress(entity, id), iface.getCustomProperties());
        VmDevice exportedDevice = entity.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            entity.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface));
        updateVmDevice(entity, vmDevice, deviceId, vmDeviceToUpdate);
    }
}
#method_after
private static <T extends VmBase> void addImportedInterfaces(T entity, List<VmDevice> vmDeviceToUpdate) {
    final Guid id = entity.getId();
    for (VmNic iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE, null, true, false, getAddress(entity, id), null);
        VmDevice exportedDevice = entity.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            entity.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface));
        updateVmDevice(entity, vmDevice, deviceId, vmDeviceToUpdate);
    }
}
#end_block

#method_before
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNetworkInterface> vmNetworkInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(getVmTemplate().getId());
        _vmInterfaces = (vmNetworkInterfaces != null) ? vmNetworkInterfaces : new ArrayList<VmNetworkInterface>();
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(getVmTemplate().getId());
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<VmNic>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions(newDiskImages);
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), srcDiskToTargetDiskMapping, _vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), srcDiskIdToTargetDiskIdMapping, _vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNetworkInterface iface : getVmInterfaces()) {
        iface.setId(Guid.newGuid());
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        iface.setId(Guid.newGuid());
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskToTargetDiskMapping.put(dit.getId(), newImage.getId());
                newDiskImages.add(newImage);
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void addVmPermission() {
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissions perms = new permissions(getCurrentUser().getUserId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
        MultiLevelAdministrationHandler.addPermission(perms);
        getCompensationContext().snapshotNewEntity(perms);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions();
    }
}
#method_after
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getUserId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#end_block

#method_before
private void copyTemplatePermissions() {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getUserId(), false);
    List<permissions> vmPermissions = new ArrayList<permissions>();
    for (permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        vmPermissions.add(new permissions(getCurrentUser().getUserId(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM));
    }
    if (vmPermissions.size() > 0) {
        MultiLevelAdministrationHandler.addPermission(vmPermissions.toArray(new permissions[vmPermissions.size()]));
        getCompensationContext().snapshotNewEntities(vmPermissions);
    }
}
#method_after
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getUserId(), false);
    for (permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#end_block

#method_before
protected void addDiskPermissions(List<DiskImage> newDiskImages) {
    permissions[] permsArray = new permissions[newDiskImages.size()];
    for (int i = 0; i < newDiskImages.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getUserId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImages.get(i).getId(), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    permissions[] permsArray = new permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getUserId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, VdcActionType parentCommandType) {
    DiskImage newDiskImage = cloneDiskImage(getVmId(), destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, parameters, result);
}
#method_after
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, VdcActionType parentCommandType) {
    DiskImage newDiskImage = cloneDiskImage(getVmId(), destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, result);
}
#end_block

#method_before
private void handleCopyResult(DiskImage srcDiskImage, DiskImage copiedDiskImage, VdcActionParametersBase parameters, VdcReturnValueBase result) {
    // If a copy cannot be made, abort
    if (!result.getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    } else {
        ImagesHandler.addDiskImageWithNoVmDevice(copiedDiskImage);
        getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        srcDiskToTargetDiskMapping.put(srcDiskImage.getId(), copiedDiskImage.getId());
        newDiskImages.add(copiedDiskImage);
    }
}
#method_after
private void handleCopyResult(DiskImage srcDiskImage, DiskImage copiedDiskImage, VdcReturnValueBase result) {
    // If a copy cannot be made, abort
    if (!result.getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    } else {
        ImagesHandler.addDiskImageWithNoVmDevice(copiedDiskImage);
        getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        getSrcDiskIdToTargetDiskIdMapping().put(srcDiskImage.getId(), copiedDiskImage.getId());
    }
}
#end_block

#method_before
private static void prepareQueryFormatters() {
    activeDirectorySearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "sAMAccountType=805306368");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "userPrincipalName");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "ObjectCategory=Group");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "name");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "samaccountname");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$SN, "SN");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$SAMACCOUNTNAME, "SAMACCOUNTNAME");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$DEPARTMENT, "DEPARTMENT");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$TITLE, "TITLE");
    ipaSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=posixAccount)(objectClass=krbPrincipalAux)");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "krbPrincipalName");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=ipaUserGroup");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    dsSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    // We put here a duplicate. Need to solve it in another way.
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "uid");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupOfUniqueNames");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    itdsSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "sn");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupOfUniqueNames");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    openLdapSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "uid");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupOfNames");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
}
#method_after
private static void prepareQueryFormatters() {
    activeDirectorySearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "sAMAccountType=805306368");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "userPrincipalName");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "ObjectCategory=Group");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "name");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "samaccountname");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$SN, "SN");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$SAMACCOUNTNAME, "SAMACCOUNTNAME");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$DEPARTMENT, "DEPARTMENT");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$TITLE, "TITLE");
    ipaSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=posixAccount)(objectClass=krbPrincipalAux)");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "krbPrincipalName");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=ipaUserGroup");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$SN, "SN");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$SAMACCOUNTNAME, "SAMACCOUNTNAME");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$DEPARTMENT, "DEPARTMENT");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$TITLE, "TITLE");
    dsSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    // We put here a duplicate. Need to solve it in another way.
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "uid");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupOfUniqueNames");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$SN, "SN");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$SAMACCOUNTNAME, "SAMACCOUNTNAME");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$DEPARTMENT, "DEPARTMENT");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$TITLE, "TITLE");
    itdsSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "sn");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupOfUniqueNames");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$SN, "SN");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$SAMACCOUNTNAME, "SAMACCOUNTNAME");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$DEPARTMENT, "DEPARTMENT");
    itdsSearchSyntaxMap.put(SearchLangageLDAPTokens.$TITLE, "TITLE");
    openLdapSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "uid");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupOfNames");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$SN, "SN");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$SAMACCOUNTNAME, "SAMACCOUNTNAME");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$DEPARTMENT, "DEPARTMENT");
    openLdapSearchSyntaxMap.put(SearchLangageLDAPTokens.$TITLE, "TITLE");
}
#end_block

#method_before
private boolean executeSshSoftFencingCommand(String version) {
    boolean result = true;
    EngineSSHClient sshClient = null;
    ByteArrayOutputStream cmdOut = null, cmdErr = null;
    try {
        sshClient = new EngineSSHClient();
        sshClient.setVds(getVds());
        sshClient.useDefaultKeyPair();
        sshClient.connect();
        sshClient.authenticate();
        cmdOut = new ByteArrayOutputStream();
        cmdErr = new ByteArrayOutputStream();
        sshClient.executeCommand(Config.<String>GetValue(ConfigValues.SshSoftFencingCommand, version), null, cmdOut, cmdErr);
        log.infoFormat("SSH Soft Fencing command executed on host {0}", getVds().getHostName());
    } catch (Exception ex) {
        log.errorFormat("SSH Soft Fencing command failed on host {0}: {1}", getVds().getHostName(), ex);
        logCommandOutput(cmdOut, "SSH Soft Fencing command standard output: {0}");
        logCommandOutput(cmdErr, "SSH Soft Fencing command error output: {0}");
        result = false;
    } finally {
        closeSshConnection(sshClient);
    }
    return result;
}
#method_after
private boolean executeSshSoftFencingCommand(String version) {
    boolean result = false;
    EngineSSHClient sshClient = null;
    try {
        sshClient = new EngineSSHClient();
        sshClient.setVds(getVds());
        sshClient.useDefaultKeyPair();
        sshClient.connect();
        sshClient.authenticate();
    } catch (Exception ex) {
        log.errorFormat("SSH connection to host {0} failed: {1}", getVds().getHostName(), ex);
        closeSshConnection(sshClient);
        return result;
    }
    ByteArrayOutputStream cmdOut = new ByteArrayOutputStream();
    ByteArrayOutputStream cmdErr = new ByteArrayOutputStream();
    try {
        log.infoFormat("Executing SSH Soft Fencing command on host {0}", getVds().getHostName());
        sshClient.executeCommand(Config.<String>GetValue(ConfigValues.SshSoftFencingCommand, version), null, cmdOut, cmdErr);
        result = true;
    } catch (Exception ex) {
        log.errorFormat("SSH Soft Fencing command failed on host {0}: {1}\nStdout: {2}\nStderr: {3}\nStacktrace: {4}", getVds().getHostName(), ex.getMessage(), cmdOut.toString(), cmdErr.toString(), ex);
    } finally {
        closeSshConnection(sshClient);
    }
    return result;
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateMinAllocatedMemory();
    updateNumOfSockets();
    if ((VmTemplate) getModel().getTemplate().getSelectedItem() != null) {
        VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    }
    updateMemoryBalloon();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateMinAllocatedMemory();
    updateNumOfSockets();
    if ((VmTemplate) getModel().getTemplate().getSelectedItem() != null) {
        VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    }
    updateMemoryBalloon();
    updateCpuSharesAvailability();
}
#end_block

#method_before
@Override
public boolean validate() {
    boolean isNew = getModel().getIsNew();
    int maxAllowedVms = getMaxVmsInPool();
    int assignedVms = getModel().getAssignedVms().asConvertible().integer();
    getModel().getNumOfDesktops().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) });
    getModel().getPrestartedVms().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) });
    getModel().getMaxAssignedVmsPerUser().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 1000000) });
    getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid());
    getModel().setIsPoolTabValid(true);
    return super.validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid();
}
#method_after
@Override
public boolean validate() {
    boolean isNew = getModel().getIsNew();
    int maxAllowedVms = getMaxVmsInPool();
    int assignedVms = getModel().getAssignedVms().asConvertible().integer();
    getModel().getNumOfDesktops().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) });
    getModel().getPrestartedVms().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) });
    getModel().getMaxAssignedVmsPerUser().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, Short.MAX_VALUE) });
    getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid());
    getModel().setIsPoolTabValid(true);
    return super.validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid() && getModel().getMaxAssignedVmsPerUser().getIsValid();
}
#end_block

#method_before
private static void addQosForDevice(Map<String, Object> specParams, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    if (FeatureSupported.networkQoS(vdsGroupCompatibilityVersion) && vnicProfile.getNetworkQosId() != null) {
        NetworkQoS networkQoS = DbFacade.getInstance().getQosDao().get(vnicProfile.getNetworkQosId());
        if (networkQoS != null) {
            if (specParams == null) {
                specParams = new HashMap<>();
            }
            if (networkQoS.getInboundAverage() > 0) {
                Map<String, String> inbound = new HashMap<>();
                inbound.put(VdsProperties.QOS_AVERAGE, String.valueOf(networkQoS.getInboundAverage()));
                inbound.put(VdsProperties.QOS_PEAK, String.valueOf(networkQoS.getInboundPeak()));
                inbound.put(VdsProperties.QOS_BURST, String.valueOf(networkQoS.getInboundBurst()));
                specParams.put(VdsProperties.QOS_INBOUND, inbound);
            }
            if (networkQoS.getOutboundAverage() > 0) {
                Map<String, String> outbound = new HashMap<>();
                outbound.put(VdsProperties.QOS_AVERAGE, String.valueOf(networkQoS.getOutboundAverage()));
                outbound.put(VdsProperties.QOS_PEAK, String.valueOf(networkQoS.getOutboundPeak()));
                outbound.put(VdsProperties.QOS_BURST, String.valueOf(networkQoS.getOutboundBurst()));
                specParams.put(VdsProperties.QOS_OUTBOUND, outbound);
            }
        }
    }
}
#method_after
private static void addQosForDevice(Map<String, Object> specParams, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    if (FeatureSupported.networkQoS(vdsGroupCompatibilityVersion) && vnicProfile.getNetworkQosId() != null) {
        NetworkQoS networkQoS = DbFacade.getInstance().getQosDao().get(vnicProfile.getNetworkQosId());
        if (networkQoS != null) {
            if (specParams == null) {
                specParams = new HashMap<>();
            }
            if (networkQoS.getInboundAverage() > 0) {
                Map<String, String> inbound = generateQoSData(networkQoS.getInboundAverage(), networkQoS.getInboundPeak(), networkQoS.getInboundBurst());
                specParams.put(VdsProperties.QOS_INBOUND, inbound);
            }
            if (networkQoS.getOutboundAverage() > 0) {
                Map<String, String> outbound = generateQoSData(networkQoS.getOutboundAverage(), networkQoS.getOutboundPeak(), networkQoS.getOutboundBurst());
                specParams.put(VdsProperties.QOS_OUTBOUND, outbound);
            }
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedDownVms();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.addCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void processExternallyManagedVms() {
    _externalVmsToAdd.clear();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                Map vmConfiguration = getVmInfo(vmId.toString())[0];
                VmStatic vmStatic = new VmStatic();
                vmStatic.setOrigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
                vmStatic.setId(vmId);
                vmStatic.setQuotaId(null);
                vmStatic.setCreationDate(new Date());
                vmStatic.setVdsGroupId(_vds.getVdsGroupId());
                String vmNameOnHost = (String) vmConfiguration.get(VdsProperties.vm_name);
                String vmName = "external-" + vmNameOnHost;
                vmStatic.setName(vmName);
                vmStatic.setNumOfSockets(Integer.parseInt((String) vmConfiguration.get(VdsProperties.num_of_cpus)));
                vmStatic.setMemSizeMb(Integer.parseInt((String) vmConfiguration.get(VdsProperties.mem_size_mb)));
                vmStatic.setExternallyManaged(true);
                _externalVmsToAdd.add(vmStatic);
                log.infoFormat("VDS::UpdateVmRunTimeInfo: Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmName);
            }
        }
    }
}
#method_after
private void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(Integer.parseInt((String) vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(Integer.parseInt((String) vmInfo.get(VdsProperties.mem_size_mb)));
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vmHost");
        props.remove("runOnVds");
        props.remove("disks");
        props.remove("bootSequence");
        props.remove("lastVdsRunOn");
        props.remove("hibernationVolHandle");
        props.remove("exitMessage");
        props.remove("lastStartTime");
        props.remove("consoleUserId");
        props.remove("consoleCurrentUserName");
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove("appList");
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vmHost");
        props.remove("runOnVds");
        props.remove("disks");
        props.remove("bootSequence");
        props.remove("lastVdsRunOn");
        props.remove("hibernationVolHandle");
        props.remove("exitMessage");
        props.remove("lastStartTime");
        props.remove("consoleUserId");
        props.remove("consoleCurrentUserName");
        props.remove("runOnce");
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove("appList");
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
public void addExternallyManagedVms(List<VmStatic> externalVmList) {
    for (VmStatic currVm : externalVmList) {
        AddVmFromScratchParameters params = new AddVmFromScratchParameters(currVm, null, null);
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmFromScratch, params, ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.debugFormat("Failed adding Externally managed VM {0}", params.getVm().getName());
        }
    }
}
#method_after
@Override
public void addExternallyManagedVms(List<VmStatic> externalVmList) {
    for (VmStatic currVm : externalVmList) {
        AddVmFromScratchParameters params = new AddVmFromScratchParameters(currVm, null, null);
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmFromScratch, params, ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.debugFormat("Failed adding Externally managed VM {0}", currVm.getName());
        }
    }
}
#end_block

#method_before
@Override
public VnicProfileView mapRow(ResultSet rs, int rowNum) throws SQLException {
    VnicProfileView entity = super.mapRow(rs, rowNum);
    entity.setNetworkName(rs.getString("network_name"));
    entity.setNetworkQoSName(rs.getString("network_qos_name"));
    entity.setDataCenterName(rs.getString("data_center_name"));
    entity.setCompatibilityVersion(new Version(rs.getString("compatibility_version")));
    return entity;
}
#method_after
@Override
public VnicProfileView mapRow(ResultSet rs, int rowNum) throws SQLException {
    VnicProfileView entity = super.mapRow(rs, rowNum);
    entity.setNetworkName(rs.getString("network_name"));
    entity.setNetworkQosName(rs.getString("network_qos_name"));
    entity.setDataCenterName(rs.getString("data_center_name"));
    entity.setCompatibilityVersion(new Version(rs.getString("compatibility_version")));
    return entity;
}
#end_block

#method_before
@Override
protected void initProfiles() {
    List<VnicProfileModel> profiles = new LinkedList<VnicProfileModel>();
    NewVnicProfileModel newModel = new NewVnicProfileModel(getSourceListModel(), getSelectedDc().getcompatibility_version(), false);
    newModel.initNetworkQoSList(getSelectedDc().getId(), null);
    profiles.add(newModel);
    getProfiles().setItems(profiles);
}
#method_after
@Override
protected void initProfiles() {
    List<VnicProfileModel> profiles = new LinkedList<VnicProfileModel>();
    NewVnicProfileModel newModel = new NewVnicProfileModel(getSourceListModel(), getSelectedDc().getcompatibility_version(), false, getSelectedDc().getId());
    profiles.add(newModel);
    getProfiles().setItems(profiles);
}
#end_block

#method_before
public void newProfile() {
    if (getWindow() != null) {
        return;
    }
    NewVnicProfileModel model = new NewVnicProfileModel(this, getEntity().getCompatibilityVersion());
    setWindow(model);
    initProfileNetwork(model);
    model.initNetworkQoSList(getEntity().getDataCenterId(), null);
}
#method_after
public void newProfile() {
    if (getWindow() != null) {
        return;
    }
    NewVnicProfileModel model = new NewVnicProfileModel(this, getEntity().getCompatibilityVersion(), getEntity().getDataCenterId());
    setWindow(model);
    initProfileNetwork(model);
}
#end_block

#method_before
public void newProfile() {
    if (getWindow() != null) {
        return;
    }
    StoragePool treeSelectedDc = getSelectedDc();
    final VnicProfileModel profileModel = new NewVnicProfileModel(this, treeSelectedDc.getcompatibility_version());
    setWindow(profileModel);
    initNetworkList(profileModel);
    if (treeSelectedDc != null) {
        profileModel.initNetworkQoSList(treeSelectedDc.getId(), null);
    }
}
#method_after
public void newProfile() {
    if (getWindow() != null) {
        return;
    }
    StoragePool treeSelectedDc = getSelectedDc();
    final VnicProfileModel profileModel = new NewVnicProfileModel(this, treeSelectedDc.getcompatibility_version(), treeSelectedDc.getId());
    setWindow(profileModel);
    initNetworkList(profileModel);
}
#end_block

#method_before
@Override
protected void initProfiles() {
    AsyncQuery profilesQuery = new AsyncQuery();
    profilesQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VnicProfileModel> profilesModels = new LinkedList<VnicProfileModel>();
            for (VnicProfileView profileView : (List<VnicProfileView>) returnValue) {
                VnicProfileModel editModel = new EditVnicProfileModel(getSourceListModel(), getSelectedDc().getcompatibility_version(), profileView, null, false);
                if (profileView.getNetworkQosName() != null && !profileView.getNetworkQosName().equals("")) {
                    // $NON-NLS-1$
                    NetworkQoS networkQoS = new NetworkQoS();
                    networkQoS.setName(profileView.getNetworkQosName());
                    editModel.getNetworkQoS().setSelectedItem(networkQoS);
                }
                editModel.getNetworkQoS().setIsChangable(false);
                profilesModels.add(editModel);
                editModel.getName().setIsChangable(false);
            }
            if (profilesModels.isEmpty()) {
                VnicProfileModel newProfileModel = new NewVnicProfileModel(getSourceListModel(), getSelectedDc().getcompatibility_version(), false);
                newProfileModel.initNetworkQoSList(getSelectedDc().getId(), null);
                profilesModels.add(newProfileModel);
            }
            getProfiles().setItems(profilesModels);
            originalProfileModels = profilesModels;
        }
    };
    AsyncDataProvider.getVnicProfilesByNetworkId(profilesQuery, getNetwork().getId());
}
#method_after
@Override
protected void initProfiles() {
    AsyncQuery profilesQuery = new AsyncQuery();
    profilesQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VnicProfileModel> profilesModels = new LinkedList<VnicProfileModel>();
            for (VnicProfileView profileView : (List<VnicProfileView>) returnValue) {
                VnicProfileModel editModel = new EditVnicProfileModel(getSourceListModel(), getSelectedDc().getcompatibility_version(), profileView, null, false);
                if (profileView.getNetworkQosName() != null && !profileView.getNetworkQosName().equals("")) {
                    // $NON-NLS-1$
                    NetworkQoS networkQoS = new NetworkQoS();
                    networkQoS.setName(profileView.getNetworkQosName());
                    editModel.getNetworkQoS().setSelectedItem(networkQoS);
                }
                editModel.getNetworkQoS().setIsChangable(false);
                profilesModels.add(editModel);
                editModel.getName().setIsChangable(false);
            }
            if (profilesModels.isEmpty()) {
                VnicProfileModel newProfileModel = new NewVnicProfileModel(getSourceListModel(), getSelectedDc().getcompatibility_version(), false, getSelectedDc().getId());
                profilesModels.add(newProfileModel);
            }
            getProfiles().setItems(profilesModels);
            originalProfileModels = profilesModels;
        }
    };
    AsyncDataProvider.getVnicProfilesByNetworkId(profilesQuery, getNetwork().getId());
}
#end_block

#method_before
@Override
public void setAcceptableValues(Collection<Object> values) {
    if (values == null) {
        return;
    }
    editors.clear();
    contentPanel.clear();
    int numOfProfiles = values.size();
    for (final Object value : values) {
        VnicProfileWidget vnicProfileWidget = new VnicProfileWidget();
        editors.add(vnicProfileWidget);
        vnicProfileWidget.edit((VnicProfileModel) value);
        final HorizontalPanel profilePanel = new HorizontalPanel();
        PushButton addButton = new PushButton(new Image(resources.increaseIcon()));
        PushButton remvoeButton = new PushButton(new Image(resources.decreaseIcon()));
        addButton.addStyleName(style.addButtonStyle());
        remvoeButton.addStyleName(style.removeButtonStyle());
        profilePanel.add(vnicProfileWidget);
        profilePanel.add(addButton);
        profilePanel.add(remvoeButton);
        addButton.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                List models = (List<VnicProfileModel>) getValue().getItems();
                VnicProfileModel existingProfileModel = (VnicProfileModel) value;
                VnicProfileModel newVnicProfileModel = new NewVnicProfileModel(existingProfileModel.getSourceModel(), existingProfileModel.getDcCompatibilityVersion());
                NetworkQoS networkQoS = (NetworkQoS) ((VnicProfileModel) value).getNetworkQoS().getSelectedItem();
                if (networkQoS != null) {
                    newVnicProfileModel.initNetworkQoSList(networkQoS.getStoragePoolId(), networkQoS.getId());
                }
                models.add(models.indexOf(existingProfileModel) + 1, newVnicProfileModel);
                setAcceptableValues(models);
            }
        });
        remvoeButton.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                List models = (List<VnicProfileModel>) getValue().getItems();
                models.remove(value);
                setAcceptableValues(models);
            }
        });
        profilePanel.addStyleName(style.profilePanel());
        contentPanel.add(profilePanel);
    }
}
#method_after
@Override
public void setAcceptableValues(Collection<Object> values) {
    if (values == null) {
        return;
    }
    editors.clear();
    contentPanel.clear();
    int numOfProfiles = values.size();
    for (final Object value : values) {
        final Guid dcId = ((VnicProfileModel) value).getDcId();
        VnicProfileWidget vnicProfileWidget = new VnicProfileWidget();
        editors.add(vnicProfileWidget);
        vnicProfileWidget.edit((VnicProfileModel) value);
        final HorizontalPanel profilePanel = new HorizontalPanel();
        PushButton addButton = new PushButton(new Image(resources.increaseIcon()));
        final PushButton remvoeButton = new PushButton(new Image(resources.decreaseIcon()));
        addButton.addStyleName(style.addButtonStyle());
        remvoeButton.addStyleName(style.removeButtonStyle());
        profilePanel.add(vnicProfileWidget);
        profilePanel.add(addButton);
        profilePanel.add(remvoeButton);
        addButton.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                List models = (List<VnicProfileModel>) getValue().getItems();
                VnicProfileModel existingProfileModel = (VnicProfileModel) value;
                VnicProfileModel newVnicProfileModel = new NewVnicProfileModel(existingProfileModel.getSourceModel(), existingProfileModel.getDcCompatibilityVersion(), dcId);
                models.add(models.indexOf(existingProfileModel) + 1, newVnicProfileModel);
                setAcceptableValues(models);
            }
        });
        remvoeButton.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                List models = (List<VnicProfileModel>) getValue().getItems();
                models.remove(value);
                setAcceptableValues(models);
            }
        });
        profilePanel.addStyleName(style.profilePanel());
        contentPanel.add(profilePanel);
    }
}
#end_block

#method_before
public void initNetworkQoSList(Guid dcId, final Guid selectedItemId) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(selectedItemId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(dcId);
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#method_after
public void initNetworkQoSList(final Guid selectedItemId) {
    if (getDcId() == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(selectedItemId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(getDcId());
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#end_block

