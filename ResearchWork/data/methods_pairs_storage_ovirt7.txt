582
#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandEntity commandEntity = CommandCoordinatorUtil.getCommandEntity(cmdId);
    StorageJobCommandParameters cmdParams = (StorageJobCommandParameters) commandEntity.getCommandParameters();
    Guid job = cmdParams.getStorageJobId();
    HostJobStatus jobStatus;
    try {
        jobStatus = pollStorageJob(cmdParams);
    } catch (Exception e) {
        log.error("Failed to poll job '{}' for command '{}' (id: '{}'), will retry soon", job, commandEntity.getCommandType(), cmdId);
        return;
    }
    if (jobStatus == null) {
        log.error("Job for command '{}' (id: '{}')  wasn't created, failing the operation", commandEntity.getCommandType(), cmdId);
    }
    if (jobStatus == HostJobStatus.running || jobStatus == HostJobStatus.pending) {
        log.info("Waiting on vdsm job: '{}' of '{}' (id: '{}') to complete", job, commandEntity.getCommandType(), cmdId);
        return;
    }
    log.info("Command '{}' id: '{}' job '{}' execution was completed with VDSM job status '{}'", commandEntity.getCommandType(), cmdId, job, jobStatus);
    CommandBase<?> command = getCommand(cmdId);
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    command.getParameters().setTaskGroupSuccess(status == CommandExecutionStatus.EXECUTED && jobStatus == HostJobStatus.done);
    command.setCommandStatus(command.getParameters().getTaskGroupSuccess() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED);
    log.info("Command '{}' (id: '{}') execution was completed, the command status is '{}'", command.getActionType(), command.getCommandId(), command.getCommandStatus());
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandEntity commandEntity = CommandCoordinatorUtil.getCommandEntity(cmdId);
    StorageJobCommandParameters cmdParams = (StorageJobCommandParameters) commandEntity.getCommandParameters();
    Guid job = cmdParams.getStorageJobId();
    HostJobStatus jobStatus;
    try {
        jobStatus = pollStorageJob(job, cmdParams.getVdsRunningOn());
    } catch (Exception e) {
        log.error("Failed to poll job '{}' for command '{}' (id: '{}'), will retry soon", job, commandEntity.getCommandType(), cmdId);
        return;
    }
    if (jobStatus == null) {
        log.error("Job for command '{}' (id: '{}')  wasn't created, failing the operation", commandEntity.getCommandType(), cmdId);
    } else if (jobStatus.isAlive()) {
        log.info("Waiting on vdsm job: '{}' of '{}' (id: '{}') to complete", job, commandEntity.getCommandType(), cmdId);
        return;
    }
    log.info("Command '{}' id: '{}' job '{}' execution was completed with VDSM job status '{}'", commandEntity.getCommandType(), cmdId, job, jobStatus);
    CommandBase<?> command = getCommand(cmdId);
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    command.getParameters().setTaskGroupSuccess(status == CommandExecutionStatus.EXECUTED && jobStatus == HostJobStatus.done);
    command.setCommandStatus(command.getParameters().getTaskGroupSuccess() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED);
    log.info("Command '{}' (id: '{}') execution was completed, the command status is '{}'", command.getActionType(), command.getCommandId(), command.getCommandStatus());
}
#end_block

#method_before
private HostJobStatus pollStorageJob(StorageJobCommandParameters cmdParams) {
    if (cmdParams.getStorageJobId() == null) {
        return null;
    }
    GetHostJobsVDSCommandParameters p = new GetHostJobsVDSCommandParameters(cmdParams.getVdsRunningOn(), Arrays.asList(cmdParams.getStorageJobId()), HostJobType.storage);
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.GetHostJobs, p);
    HostJobInfo jobInfo = ((Map<Guid, HostJobInfo>) returnValue.getReturnValue()).get(cmdParams.getStorageJobId());
    return jobInfo != null ? jobInfo.getStatus() : null;
}
#method_after
private HostJobStatus pollStorageJob(Guid jobId, Guid vdsId) {
    if (jobId == null) {
        return null;
    }
    GetHostJobsVDSCommandParameters p = new GetHostJobsVDSCommandParameters(vdsId, Collections.singletonList(jobId), HostJobType.storage);
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.GetHostJobs, p);
    HostJobInfo jobInfo = ((Map<Guid, HostJobInfo>) returnValue.getReturnValue()).get(jobId);
    return jobInfo != null ? jobInfo.getStatus() : null;
}
#end_block

#method_before
public String getImageId() {
    return imageId;
}
#method_after
public Guid getImageId() {
    return imageId;
}
#end_block

#method_before
public void setImageId(String imageId) {
    this.imageId = imageId;
}
#method_after
public void setImageId(Guid imageId) {
    this.imageId = imageId;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (getOkCommand().equals(command)) {
        validate();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (getOkCommand().equals(command)) {
        onUpload();
    }
}
#end_block

#method_before
private void onUpload() {
    if (getProgress() != null) {
        return;
    }
    if (!isResumeUpload) {
        initiateNewUpload();
    } else {
        initiateResumeUpload();
    }
}
#method_after
public void onUpload() {
    if (flush()) {
        if (getProgress() != null) {
            return;
        }
        if (!isResumeUpload) {
            initiateNewUpload();
        } else {
            initiateResumeUpload();
        }
    }
}
#end_block

#method_before
public void flush() {
    diskModel.flush();
    ((DiskImage) getDiskModel().getDisk()).setVolumeFormat(getVolumeFormat().getSelectedItem());
    ((DiskImage) getDiskModel().getDisk()).setActualSizeInBytes(getImageSize());
}
#method_after
public boolean flush() {
    if (validate()) {
        diskModel.flush();
        DiskImage diskImage = (DiskImage) getDiskModel().getDisk();
        diskImage.setActualSizeInBytes(getImageSize());
        diskImage.setVolumeFormat(getImageInfoModel().getFormat());
        diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(diskImage.getVolumeFormat(), getDiskModel().getStorageDomain().getSelectedItem().getStorageType()));
        return true;
    } else {
        setIsValid(false);
    }
    return false;
}
#end_block

#method_before
public void validate() {
    boolean uploadImageIsValid;
    if (getImageSourceLocalEnabled().getEntity()) {
        getImagePath().validateEntity(new IValidation[] { new IValidation() {

            @Override
            public ValidationResult validate(Object value) {
                ValidationResult result = new ValidationResult();
                if (value == null || StringHelper.isNullOrEmpty((String) value)) {
                    result.setSuccess(false);
                    result.getReasons().add(ConstantsManager.getInstance().getConstants().emptyImagePath());
                }
                return result;
            }
        } });
        uploadImageIsValid = getImagePath().getIsValid();
        getInvalidityReasons().addAll(getImagePath().getInvalidityReasons());
        if (uploadImageIsValid) {
            startProgress(null);
            new VolumeFormatValidation(getVolumeFormat().getSelectedItem()) {

                @Override
                protected void onValidation(ValidationResult result) {
                    if (!result.getSuccess()) {
                        getInvalidityReasons().addAll(result.getReasons());
                    }
                    stopProgress();
                    onValidate(result.getSuccess());
                }
            }.validate(getImageFileUploadElement());
        }
    } else {
        // TODO remote/download
        uploadImageIsValid = false;
    }
    onValidate(uploadImageIsValid && diskModel.validate());
}
#method_after
public boolean validate() {
    boolean uploadImageIsValid;
    setIsValid(true);
    getInvalidityReasons().clear();
    getImageInfoModel().getInvalidityReasons().clear();
    if (getImageSourceLocalEnabled().getEntity()) {
        getImagePath().validateEntity(new IValidation[] { new IValidation() {

            @Override
            public ValidationResult validate(Object value) {
                ValidationResult result = new ValidationResult();
                if (value == null || StringHelper.isNullOrEmpty((String) value)) {
                    result.setSuccess(false);
                    result.getReasons().add(constants.emptyImagePath());
                }
                return result;
            }
        } });
        if (getImagePath().getIsValid()) {
            getImageInfoModel().validateEntity(new IValidation[] { new IValidation() {

                @Override
                public ValidationResult validate(Object value) {
                    ValidationResult result = new ValidationResult();
                    ImageInfoModel.QemuCompat qcowCompat = getImageInfoModel().getQcowCompat();
                    if (qcowCompat != null && qcowCompat != ImageInfoModel.QemuCompat.V2) {
                        StorageFormatType storageFormatType = getDiskModel().getStorageDomain().getSelectedItem().getStorageFormat();
                        switch(storageFormatType) {
                            case V1:
                            case V2:
                            case V3:
                                result.setSuccess(false);
                                result.getReasons().add(messages.uploadImageQemuCompatUnsupported(qcowCompat.getValue(), storageFormatType.name()));
                                break;
                        }
                    }
                    return result;
                }
            } });
        }
        uploadImageIsValid = getImagePath().getIsValid() && getImageInfoModel().validate();
        getInvalidityReasons().addAll(getImagePath().getInvalidityReasons());
        getInvalidityReasons().addAll(getImageInfoModel().getInvalidityReasons());
    } else {
        // TODO remote/download
        uploadImageIsValid = false;
    }
    return uploadImageIsValid && diskModel.validate();
}
#end_block

#method_before
private void respondToPollStatus(FrontendActionAsyncResult result) {
    if (result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
        ImageTransfer rv = result.getReturnValue().getActionReturnValue();
        // $NON-NLS-1$
        log.info("Upload phase: " + rv.getPhase().toString());
        switch(rv.getPhase()) {
            case UNKNOWN:
                // The job may have failed and removed the entity
                pollingFailed();
                return;
            case INITIALIZING:
            case RESUMING:
                break;
            case TRANSFERRING:
                if (getUploadState() == UploadState.NEW) {
                    setVdsId(rv.getVdsId().toString());
                    setImageId(rv.getDiskId().toString());
                    setTransferToken(rv.getImagedTicketId().toString());
                    String proxyURI = rv.getProxyUri();
                    String signedTicket = rv.getSignedTicket();
                    int chunkSizeKB = AsyncDataProvider.getInstance().getUploadImageChunkSizeKB();
                    int xhrTimeoutSec = AsyncDataProvider.getInstance().getUploadImageXhrTimeoutInSeconds();
                    int xhrRetryIntervalSec = AsyncDataProvider.getInstance().getUploadImageXhrRetryIntervalInSeconds();
                    int maxRetries = AsyncDataProvider.getInstance().getUploadImageXhrMaxRetries();
                    // Start upload task
                    setUploadState(UploadState.INITIALIZING);
                    // $NON-NLS-1$
                    setProgressStr("Uploading from byte " + getBytesSent());
                    startUpload(getImageFileUploadElement(), proxyURI, getTransferToken(), getBytesSent(), signedTicket, chunkSizeKB, xhrTimeoutSec, xhrRetryIntervalSec, maxRetries);
                }
                break;
            case PAUSED_USER:
            case PAUSED_SYSTEM:
                setContinuePolling(false);
                setUploadState(UploadState.ENGINE_PAUSE);
                break;
            // In this case, the default case is reached which does largely the same thing.
            case CANCELLED:
            case FINALIZING_SUCCESS:
            case FINALIZING_FAILURE:
            case FINISHED_SUCCESS:
            case FINISHED_FAILURE:
                // $NON-NLS-1$
                log.info("Upload task terminating");
                setContinuePolling(false);
                stopJsUpload(UploadState.ENGINE_CANCEL);
                break;
            default:
                // $NON-NLS-1$
                log.info("Unknown upload status from backend, job is likely complete");
                setContinuePolling(false);
                stopJsUpload(UploadState.CLIENT_ERROR);
                break;
        }
        failedPollAttempts = 0;
    } else {
        // $NON-NLS-1$
        log.info("No poll result for upload status");
        pollingFailed();
    }
}
#method_after
private void respondToPollStatus(FrontendActionAsyncResult result) {
    if (result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
        ImageTransfer rv = result.getReturnValue().getActionReturnValue();
        // $NON-NLS-1$
        log.info("Upload phase: " + rv.getPhase().toString());
        switch(rv.getPhase()) {
            case UNKNOWN:
                // The job may have failed and removed the entity
                pollingFailed();
                return;
            case INITIALIZING:
            case RESUMING:
                break;
            case TRANSFERRING:
                if (getUploadState() == UploadState.NEW) {
                    setVdsId(rv.getVdsId().toString());
                    setImageId(rv.getDiskId());
                    setTransferToken(rv.getImagedTicketId().toString());
                    String proxyURI = rv.getProxyUri();
                    String signedTicket = rv.getSignedTicket();
                    int chunkSizeKB = AsyncDataProvider.getInstance().getUploadImageChunkSizeKB();
                    int xhrTimeoutSec = AsyncDataProvider.getInstance().getUploadImageXhrTimeoutInSeconds();
                    int xhrRetryIntervalSec = AsyncDataProvider.getInstance().getUploadImageXhrRetryIntervalInSeconds();
                    int maxRetries = AsyncDataProvider.getInstance().getUploadImageXhrMaxRetries();
                    // Start upload task
                    setUploadState(UploadState.INITIALIZING);
                    // $NON-NLS-1$
                    setProgressStr("Uploading from byte " + getBytesSent());
                    startUpload(getImageFileUploadElement(), proxyURI, getTransferToken(), getBytesSent(), signedTicket, chunkSizeKB, xhrTimeoutSec, xhrRetryIntervalSec, maxRetries);
                }
                break;
            case PAUSED_USER:
            case PAUSED_SYSTEM:
                setContinuePolling(false);
                setUploadState(UploadState.ENGINE_PAUSE);
                break;
            // In this case, the default case is reached which does largely the same thing.
            case CANCELLED:
            case FINALIZING_SUCCESS:
            case FINALIZING_FAILURE:
            case FINISHED_SUCCESS:
            case FINISHED_FAILURE:
                // $NON-NLS-1$
                log.info("Upload task terminating");
                setContinuePolling(false);
                stopJsUpload(UploadState.ENGINE_CANCEL);
                break;
            default:
                // $NON-NLS-1$
                log.info("Unknown upload status from backend, job is likely complete");
                setContinuePolling(false);
                stopJsUpload(UploadState.CLIENT_ERROR);
                break;
        }
        failedPollAttempts = 0;
    } else {
        // $NON-NLS-1$
        log.info("No poll result for upload status");
        pollingFailed();
    }
}
#end_block

#method_before
public static VdcReturnValueBase evaluateCorrelationId(VdcActionParametersBase parameters) {
    VdcReturnValueBase returnValue = null;
    String correlationId = parameters.getCorrelationId();
    if (StringUtils.isEmpty(correlationId)) {
        correlationId = CorrelationIdTracker.getCorrelationId();
        if (StringUtils.isEmpty(correlationId)) {
            correlationId = LoggedUtils.getObjectId(parameters);
        }
        parameters.setCorrelationId(correlationId);
    } else {
        List<Class<?>> validationGroups = Arrays.asList(new Class<?>[] { PreRun.class });
        List<String> messages = ValidationUtils.validateInputs(validationGroups, parameters);
        if (!messages.isEmpty()) {
            VdcReturnValueBase returnErrorValue = new VdcReturnValueBase();
            returnErrorValue.setValid(false);
            returnErrorValue.getValidationMessages().addAll(messages);
            return returnErrorValue;
        }
    }
    return returnValue;
}
#method_after
public static VdcReturnValueBase evaluateCorrelationId(VdcActionParametersBase parameters) {
    VdcReturnValueBase returnValue = null;
    String correlationId = parameters.getCorrelationId();
    if (StringUtils.isEmpty(correlationId)) {
        correlationId = CorrelationIdTracker.getCorrelationId();
        if (StringUtils.isEmpty(correlationId)) {
            correlationId = LoggedUtils.getObjectId(parameters);
        }
        parameters.setCorrelationId(correlationId);
    } else {
        List<String> messages = ValidationUtils.validateInputs(validationGroups, parameters);
        if (!messages.isEmpty()) {
            VdcReturnValueBase returnErrorValue = new VdcReturnValueBase();
            returnErrorValue.setValid(false);
            returnErrorValue.getValidationMessages().addAll(messages);
            return returnErrorValue;
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getVmPoolId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_POOL, getVmPoolIsBeingRemovedMessage()));
    for (VM vm : getCachedVmsInPool()) {
        addVmLocks(vm, locks);
    }
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getVmPoolId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_POOL, new LockMessage(EngineMessage.ACTION_TYPE_FAILED_VM_POOL_IS_BEING_REMOVED).withOptional("VmPoolName", getVmPool() != null ? getVmPool().getName() : null)));
    for (VM vm : getCachedVmsInPool()) {
        addVmLocks(vm, locks);
    }
    return locks;
}
#end_block

#method_before
private String getVmIsBeingRemovedMessage(VM vm) {
    StringBuilder builder = new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_VM_POOL_IS_BEING_REMOVED_WITH_VM.name());
    if (getVmPool() != null) {
        builder.append(String.format("$VmPoolName %1$s $VmName %2$s", getVmPool().getName(), vm.getName()));
    }
    return builder.toString();
}
#method_after
private LockMessage getVmIsBeingRemovedMessage(VM vm) {
    return new LockMessage(EngineMessage.ACTION_TYPE_FAILED_VM_POOL_IS_BEING_REMOVED_WITH_VM).withOptional("VmPoolName", getVmPool() != null ? getVmPool().getName() : null).withOptional("VmName", getVmPool() != null ? vm.getName() : null);
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandBase<?> rootCommand = CommandCoordinatorUtil.retrieveCommand(cmdId);
    // Evaluate the host upgrade process. If wasn't started,
    if (childCommandsExist(childCmdIds) && evaluateHostUpgradeInternalCommandProgress(childCmdIds, rootCommand)) {
        return;
    }
    if (Guid.isNullOrEmpty(getHostUpgradeInternalCmdId(childCmdIds))) {
        evaluateMaintenanceHostCommandProgress(childCmdIds, rootCommand);
    }
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandBase<?> rootCommand = CommandCoordinatorUtil.retrieveCommand(cmdId);
    // upgrade command.
    if (childCommandsExist(childCmdIds) && evaluateHostUpgradeInternalCommandProgress(childCmdIds, rootCommand)) {
        return;
    }
    // if the host upgrade command was not started check the status of maintenance command
    if (Guid.isNullOrEmpty(getHostUpgradeInternalCmdId(childCmdIds))) {
        evaluateMaintenanceHostCommandProgress(childCmdIds, rootCommand);
    }
}
#end_block

#method_before
private void evaluateMaintenanceHostCommandProgress(List<Guid> childCmdIds, CommandBase<?> rootCommand) {
    UpgradeHostParameters parameters = (UpgradeHostParameters) rootCommand.getParameters();
    VdsDynamic host = DbFacade.getInstance().getVdsDynamicDao().get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            log.info("Host '{}' is on maintenance mode. Proceeding with Upgrade process.", getHostName(parameters.getVdsId()));
            invokeHostUpgrade(rootCommand, parameters);
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(childCmdIds)) {
                log.info("Host '{}' failed to move to maintenance mode. Upgrade process is terminated.", getHostName(parameters.getVdsId()));
                rootCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#method_after
private void evaluateMaintenanceHostCommandProgress(List<Guid> childCmdIds, CommandBase<?> rootCommand) {
    UpgradeHostParameters parameters = (UpgradeHostParameters) rootCommand.getParameters();
    VdsDynamic host = DbFacade.getInstance().getVdsDynamicDao().get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            log.info("Host '{}' is on maintenance mode. Proceeding with Upgrade process.", getHostName(parameters.getVdsId()));
            invokeHostUpgrade(rootCommand, parameters);
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(childCmdIds)) {
                log.error("Host '{}' failed to move to maintenance mode. Upgrade process is terminated.", getHostName(parameters.getVdsId()));
                rootCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#end_block

#method_before
protected void createJob(VdcActionType actionType, boolean isExternal) {
    Job job = ExecutionHandler.createJob(actionType, this);
    job.setDescription(getParameters().getDescription());
    job.setAutoCleared(getParameters().isAutoCleared());
    Guid id = job.getId();
    job.setExternal(isExternal);
    jobRepository.saveJob(job);
    if (getJobDao().get(id) != null) {
        setActionReturnValue(id);
        setSucceeded(true);
    } else {
        setSucceeded(false);
    }
}
#method_after
protected void createJob(VdcActionType actionType, boolean isExternal) {
    Job job = ExecutionHandler.createJob(actionType, this);
    job.setDescription(getParameters().getDescription());
    job.setAutoCleared(getParameters().isAutoCleared());
    Guid id = job.getId();
    job.setExternal(isExternal);
    jobRepository.saveJob(job);
    if (jobDao.get(id) != null) {
        setActionReturnValue(id);
        setSucceeded(true);
    } else {
        setSucceeded(false);
    }
}
#end_block

#method_before
public void syncSearch(VdcQueryType vdcQueryType, VdcQueryParametersBase vdcQueryParametersBase) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            setItems((Collection<T>) ((VdcQueryReturnValue) ReturnValue).getReturnValue());
        }
    };
    vdcQueryParametersBase.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(vdcQueryType, vdcQueryParametersBase, _asyncQuery);
    setIsQueryFirstTime(false);
}
#method_after
public void syncSearch(VdcQueryType vdcQueryType, VdcQueryParametersBase vdcQueryParametersBase) {
    vdcQueryParametersBase.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(vdcQueryType, vdcQueryParametersBase, new SetItemsAsyncQuery());
    setIsQueryFirstTime(false);
}
#end_block

#method_before
@Override
protected void performBootstrap() {
    super.performBootstrap();
    Window.setTitle(dynamicMessages.applicationTitle());
    // Check for ApplicationMode configuration
    ApplicationMode uiMode = UiModeData.getUiMode();
    if (uiMode != null) {
        ApplicationModeHelper.setUiMode(uiMode);
    }
    // Initiate transition to requested application place
    placeManager.revealCurrentPlace();
}
#method_after
@Override
protected void performBootstrap() {
    super.performBootstrap();
    Window.setTitle(dynamicMessages.applicationTitle());
    // Check for ApplicationMode configuration
    ApplicationMode uiMode = UiModeData.getUiMode();
    if (uiMode != null) {
        ApplicationModeHelper.setUiMode(uiMode);
    }
}
#end_block

#method_before
protected ArrayNode getPluginDefinitionsArray(List<PluginData> pluginData) {
    ArrayNode arr = createArrayNode();
    for (PluginData data : pluginData) {
        ObjectNode dataObj = createObjectNode();
        // $NON-NLS-1$
        dataObj.put("name", data.getName());
        // $NON-NLS-1$
        dataObj.put("url", data.getUrl());
        // $NON-NLS-1$
        dataObj.put("config", data.mergeConfiguration());
        // $NON-NLS-1$
        dataObj.put("enabled", data.isEnabled());
        arr.add(dataObj);
    }
    return arr;
}
#method_after
protected ArrayNode getPluginDefinitionsArray(List<PluginData> pluginData) {
    ArrayNode arr = createArrayNode();
    for (PluginData data : pluginData) {
        ObjectNode dataObj = createObjectNode();
        // $NON-NLS-1$
        dataObj.put("name", data.getName());
        // $NON-NLS-1$
        dataObj.put("url", data.getUrl());
        // $NON-NLS-1$
        dataObj.put("config", data.mergeConfiguration());
        // $NON-NLS-1$
        dataObj.put("lazyLoad", data.isLazyLoad());
        // $NON-NLS-1$
        dataObj.put("enabled", data.isEnabled());
        arr.add(dataObj);
    }
    return arr;
}
#end_block

#method_before
public void storageNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    String name = model.getName().getEntity();
    model.getName().setIsValid(true);
    AsyncDataProvider.getInstance().isStorageDomainNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            String name1 = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            boolean isNameUnique = (Boolean) returnValue;
            if (!isNameUnique && name1.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
                storageListModel.postStorageNameValidation();
            } else {
                AsyncDataProvider.getInstance().getStorageDomainMaxNameLength(new AsyncQuery(storageListModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target1, Object returnValue1) {
                        StorageListModel storageListModel1 = (StorageListModel) target1;
                        StorageModel storageModel1 = (StorageModel) storageListModel1.getWindow();
                        int nameMaxLength = (Integer) returnValue1;
                        RegexValidation tempVar2 = new RegexValidation();
                        // $NON-NLS-1$ //$NON-NLS-2$
                        tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                        tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                        storageModel1.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                        storageListModel1.postStorageNameValidation();
                    }
                }));
            }
        }
    }), name);
}
#method_after
public void storageNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    String name = model.getName().getEntity();
    model.getName().setIsValid(true);
    AsyncDataProvider.getInstance().isStorageDomainNameUnique(new AsyncQuery<>(new AsyncCallback<Boolean>() {

        @Override
        public void onSuccess(Boolean isNameUnique) {
            final StorageModel storageModel = (StorageModel) getWindow();
            String name1 = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            if (!isNameUnique && name1.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
                postStorageNameValidation();
            } else {
                AsyncDataProvider.getInstance().getStorageDomainMaxNameLength(new AsyncQuery<>(new AsyncCallback<Integer>() {

                    @Override
                    public void onSuccess(Integer nameMaxLength) {
                        RegexValidation tempVar2 = new RegexValidation();
                        // $NON-NLS-1$ //$NON-NLS-2$
                        tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                        tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                        storageModel.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                        postStorageNameValidation();
                    }
                }));
            }
        }
    }), name);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            List<VDS> hosts = (List<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrNull(hosts));
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = UICommand.createDefaultOkUiCommand("OnRemove", StorageListModel.this);
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    final RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery<>(new AsyncCallback<List<VDS>>() {

        @Override
        public void onSuccess(List<VDS> hosts) {
            model.getHostList().setItems(hosts);
            model.getHostList().setSelectedItem(Linq.firstOrNull(hosts));
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                model.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = UICommand.createDefaultOkUiCommand("OnRemove", StorageListModel.this);
                model.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                model.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
    Model target = getWidgetModel() != null ? getWidgetModel() : sanStorageModel.getContainer();
    if (sanStorageModel.getAddedLuns().isEmpty()) {
        onSaveSanStorage();
        return;
    }
    List<String> unkownStatusLuns = new ArrayList<>();
    for (LunModel lunModel : sanStorageModel.getAddedLuns()) {
        unkownStatusLuns.add(lunModel.getLunId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response.getSucceeded()) {
                List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
            } else {
                sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
            }
        }
    }, true));
}
#method_after
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
    if (sanStorageModel.getAddedLuns().isEmpty()) {
        onSaveSanStorage();
        return;
    }
    List<String> unkownStatusLuns = new ArrayList<>();
    for (LunModel lunModel : sanStorageModel.getAddedLuns()) {
        unkownStatusLuns.add(lunModel.getLunId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue response) {
            if (response.getSucceeded()) {
                List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
            } else {
                sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
            }
        }
    }, true));
}
#end_block

#method_before
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

            @Override
            public void onSuccess(List<StorageDomain> storages) {
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storages);
                } else {
                    saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

            @Override
            public void onSuccess(List<StorageDomain> storages) {
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storages);
                } else {
                    saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

            @Override
            public void onSuccess(List<StorageDomain> storages) {
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storages);
                } else {
                    saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void handleDomainAlreadyExists(StorageListModel storageListModel, ArrayList<StorageDomain> storages) {
    String storageName = storages.get(0).getStorageName();
    onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
}
#method_after
private void handleDomainAlreadyExists(List<StorageDomain> storages) {
    String storageName = storages.get(0).getStorageName();
    onFinish(context, false, storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
}
#end_block

#method_before
public void importFileStoragePostInit() {
    Guid storagePoolId = null;
    StoragePool dataCenter = storageModel.getContainer().getDataCenter().getSelectedItem();
    if (dataCenter != null && !dataCenter.getId().equals(Guid.Empty)) {
        storagePoolId = dataCenter.getId();
    }
    // Check storage domain existence
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().importFailedDomainAlreadyExistStorageMsg(storageName));
            } else {
                StorageServerConnections tempVar = new StorageServerConnections();
                storageModel = storageListModel.storageModel;
                tempVar.setConnection(storageListModel.path);
                tempVar.setStorageType(storageListModel.storageType);
                if (storageModel instanceof NfsStorageModel) {
                    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
                    if (isConnectionOverriden()) {
                        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
                        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
                        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
                    }
                }
                if (storageModel instanceof PosixStorageModel) {
                    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
                    tempVar.setVfsType(posixModel.getVfsType().getEntity());
                    tempVar.setMountOptions(posixModel.getMountOptions().getEntity());
                }
                storageListModel.fileConnection = tempVar;
                importFileStorageConnect();
            }
        }
    }), storagePoolId, path);
}
#method_after
public void importFileStoragePostInit() {
    Guid storagePoolId = null;
    StoragePool dataCenter = storageModel.getContainer().getDataCenter().getSelectedItem();
    if (dataCenter != null && !dataCenter.getId().equals(Guid.Empty)) {
        storagePoolId = dataCenter.getId();
    }
    // Check storage domain existence
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> storages) {
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(context, false, storageModel, ConstantsManager.getInstance().getMessages().importFailedDomainAlreadyExistStorageMsg(storageName));
            } else {
                StorageServerConnections tempVar = new StorageServerConnections();
                tempVar.setConnection(path);
                tempVar.setStorageType(storageType);
                if (storageModel instanceof NfsStorageModel) {
                    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
                    if (isConnectionOverriden()) {
                        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
                        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
                        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
                    }
                }
                if (storageModel instanceof PosixStorageModel) {
                    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
                    tempVar.setVfsType(posixModel.getVfsType().getEntity());
                    tempVar.setMountOptions(posixModel.getMountOptions().getEntity());
                }
                fileConnection = tempVar;
                importFileStorageConnect();
            }
        }
    }), storagePoolId, path);
}
#end_block

#method_before
private void getExistingStorageDomainList() {
    AsyncDataProvider.getInstance().getExistingStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            ArrayList<StorageDomain> domains = (ArrayList<StorageDomain>) returnValue;
            if (domains != null && !domains.isEmpty()) {
                storageListModel.storageDomainsToAdd = domains;
                addExistingFileStorageDomain();
            } else {
                String errorMessage = domains == null ? ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg() : ConstantsManager.getInstance().getConstants().thereIsNoStorageDomainUnderTheSpecifiedPathMsg();
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, errorMessage);
                storageListModel.cleanConnection(storageListModel.fileConnection, storageListModel.hostId);
            }
        }
    }), hostId, domainType, storageType, path);
}
#method_after
private void getExistingStorageDomainList() {
    AsyncDataProvider.getInstance().getExistingStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> domains) {
            if (domains != null && !domains.isEmpty()) {
                storageDomainsToAdd = domains;
                addExistingFileStorageDomain();
            } else {
                String errorMessage = domains == null ? ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg() : ConstantsManager.getInstance().getConstants().thereIsNoStorageDomainUnderTheSpecifiedPathMsg();
                postImportFileStorage(context, false, storageModel, errorMessage);
                cleanConnection(fileConnection, hostId);
            }
        }
    }), hostId, domainType, storageType, path);
}
#end_block

#method_before
private void checkDomainAttachedToDc(String commandName, List<StorageDomain> storageDomains, StorageServerConnections storageServerConnections) {
    final StorageModel storageModel = (StorageModel) getWindow();
    StoragePool storagePool = storageModel.getDataCenter().getSelectedItem();
    final UICommand okCommand = UICommand.createDefaultOkUiCommand(commandName, this);
    if (storagePool.getId().equals(Guid.Empty)) {
        okCommand.execute();
        return;
    }
    VDS host = storageModel.getHost().getSelectedItem();
    AsyncDataProvider.getInstance().getStorageDomainsWithAttachedStoragePoolGuid(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomainStatic> attachedStorageDomains = (List<StorageDomainStatic>) returnValue;
            if (!attachedStorageDomains.isEmpty()) {
                ConfirmationModel model = new ConfirmationModel();
                setConfirmWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().storageDomainsAttachedToDataCenterWarningTitle());
                model.setMessage(ConstantsManager.getInstance().getConstants().storageDomainsAttachedToDataCenterWarningMessage());
                model.setHelpTag(HelpTag.import_storage_domain_confirmation);
                // $NON-NLS-1$
                model.setHashName("import_storage_domain_confirmation");
                List<String> stoageDomainNames = new ArrayList<>();
                for (StorageDomainStatic domain : attachedStorageDomains) {
                    stoageDomainNames.add(domain.getStorageName());
                }
                model.setItems(stoageDomainNames);
                // $NON-NLS-1$
                UICommand cancelCommand = createCancelCommand("CancelImportConfirm");
                model.getCommands().add(okCommand);
                model.getCommands().add(cancelCommand);
            } else {
                okCommand.execute();
            }
        }
    }), storagePool, storageDomains, storageServerConnections, host.getId());
}
#method_after
private void checkDomainAttachedToDc(String commandName, List<StorageDomain> storageDomains, StorageServerConnections storageServerConnections) {
    final StorageModel storageModel = (StorageModel) getWindow();
    StoragePool storagePool = storageModel.getDataCenter().getSelectedItem();
    final UICommand okCommand = UICommand.createDefaultOkUiCommand(commandName, this);
    if (storagePool.getId().equals(Guid.Empty)) {
        okCommand.execute();
        return;
    }
    VDS host = storageModel.getHost().getSelectedItem();
    AsyncDataProvider.getInstance().getStorageDomainsWithAttachedStoragePoolGuid(new AsyncQuery<>(new AsyncCallback<List<StorageDomainStatic>>() {

        @Override
        public void onSuccess(List<StorageDomainStatic> attachedStorageDomains) {
            if (!attachedStorageDomains.isEmpty()) {
                ConfirmationModel model = new ConfirmationModel();
                setConfirmWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().storageDomainsAttachedToDataCenterWarningTitle());
                model.setMessage(ConstantsManager.getInstance().getConstants().storageDomainsAttachedToDataCenterWarningMessage());
                model.setHelpTag(HelpTag.import_storage_domain_confirmation);
                // $NON-NLS-1$
                model.setHashName("import_storage_domain_confirmation");
                List<String> stoageDomainNames = new ArrayList<>();
                for (StorageDomainStatic domain : attachedStorageDomains) {
                    stoageDomainNames.add(domain.getStorageName());
                }
                model.setItems(stoageDomainNames);
                // $NON-NLS-1$
                UICommand cancelCommand = createCancelCommand("CancelImportConfirm");
                model.getCommands().add(okCommand);
                model.getCommands().add(cancelCommand);
            } else {
                okCommand.execute();
            }
        }
    }), storagePool, storageDomains, storageServerConnections, host.getId());
}
#end_block

#method_before
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    model.setHelpTag(HelpTag.new_data_center___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    model.setHelpTag(HelpTag.new_data_center___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery<>(new AsyncCallback<StoragePool>() {

        @Override
        public void onSuccess(StoragePool returnValue) {
            DataCenterGuideModel model = (DataCenterGuideModel) getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", DataCenterListModel.this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    windowModel.setHelpTag(HelpTag.data_center_re_initialize);
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangeable(true);
    windowModel.startProgress();
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = UICommand.createDefaultOkUiCommand("OnRecover", DataCenterListModel.this);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = UICommand.createCancelUiCommand("Cancel", DataCenterListModel.this);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#method_after
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    windowModel.setHelpTag(HelpTag.data_center_re_initialize);
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangeable(true);
    windowModel.startProgress();
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> storageDomainList) {
            windowModel.stopProgress();
            List<EntityModel> models = new ArrayList<>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = UICommand.createDefaultOkUiCommand("OnRecover", DataCenterListModel.this);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = UICommand.createCancelUiCommand("Cancel", DataCenterListModel.this);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#end_block

#method_before
public void onRecover() {
    final ConfirmationModel windowModel = (ConfirmationModel) getWindow();
    if (!windowModel.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Master) {
                    break;
                }
            }
            List<StorageDomain> items = new ArrayList<>();
            for (EntityModel a : Linq.<EntityModel>cast(windowModel.getItems())) {
                if (a.getIsSelected()) {
                    items.add((StorageDomain) a.getEntity());
                }
            }
            if (items.size() > 0) {
                if (windowModel.getProgress() != null) {
                    return;
                }
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
                for (StorageDomain a : items) {
                    parameters.add(new ReconstructMasterParameters(getSelectedItem().getId(), a.getId()));
                }
                windowModel.startProgress();
                Frontend.getInstance().runMultipleAction(VdcActionType.RecoveryStoragePool, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        ConfirmationModel localModel = (ConfirmationModel) result.getState();
                        localModel.stopProgress();
                        cancel();
                    }
                }, windowModel);
            } else {
                cancel();
            }
        }
    }), getSelectedItem().getId());
}
#method_after
public void onRecover() {
    final ConfirmationModel windowModel = (ConfirmationModel) getWindow();
    if (!windowModel.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> storageDomainList) {
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Master) {
                    break;
                }
            }
            List<StorageDomain> items = new ArrayList<>();
            for (EntityModel a : Linq.<EntityModel>cast(windowModel.getItems())) {
                if (a.getIsSelected()) {
                    items.add((StorageDomain) a.getEntity());
                }
            }
            if (items.size() > 0) {
                if (windowModel.getProgress() != null) {
                    return;
                }
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
                for (StorageDomain a : items) {
                    parameters.add(new ReconstructMasterParameters(getSelectedItem().getId(), a.getId()));
                }
                windowModel.startProgress();
                Frontend.getInstance().runMultipleAction(VdcActionType.RecoveryStoragePool, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        ConfirmationModel localModel = (ConfirmationModel) result.getState();
                        localModel.stopProgress();
                        cancel();
                    }
                }, windowModel);
            } else {
                cancel();
            }
        }
    }), getSelectedItem().getId());
}
#end_block

#method_before
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(getSelectedItem().getCompatibilityVersion())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        confirmModel.setHelpTag(HelpTag.change_data_center_compatibility_version);
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = getSelectedItem();
        startProgress();
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType().isDataDomain()) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getForVersion(dcModel.getVersion().getSelectedItem());
                    oldFormat = VersionStorageFormatUtil.getForVersion(sp.getCompatibilityVersion());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    Version v = VersionStorageFormatUtil.getEarliestVersionSupported(newFormat);
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg(v.getValue()));
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSaveInternal", this);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && getSelectedItem().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else if (dcModel.getIsNew()) {
        // New data center, check for name uniqueness.
        validateDataCenterName(dcModel);
    } else {
        onSaveInternal();
    }
}
#method_after
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(getSelectedItem().getCompatibilityVersion())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        confirmModel.setHelpTag(HelpTag.change_data_center_compatibility_version);
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = getSelectedItem();
        startProgress();
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                List<StorageDomain> storages = returnValue.getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType().isDataDomain()) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getForVersion(dcModel.getVersion().getSelectedItem());
                    oldFormat = VersionStorageFormatUtil.getForVersion(sp.getCompatibilityVersion());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    Version v = VersionStorageFormatUtil.getEarliestVersionSupported(newFormat);
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg(v.getValue()));
                }
                stopProgress();
            }
        }));
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSaveInternal", this);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && getSelectedItem().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else if (dcModel.getIsNew()) {
        // New data center, check for name uniqueness.
        validateDataCenterName(dcModel);
    } else {
        onSaveInternal();
    }
}
#end_block

#method_before
private void validateDataCenterName(final DataCenterModel dataCenter) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(dataCenter.getName().getEntity()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VdcQueryReturnValue result = (VdcQueryReturnValue) returnValue;
            if (!((Collection<?>) result.getReturnValue()).isEmpty()) {
                dataCenter.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                dataCenter.getName().setIsValid(false);
                dataCenter.setValidTab(TabName.GENERAL_TAB, false);
            } else {
                dataCenter.getName().getInvalidityReasons().clear();
                dataCenter.getName().setIsValid(true);
                dataCenter.setValidTab(TabName.GENERAL_TAB, true);
                onSaveInternal();
            }
        }
    }));
}
#method_after
private void validateDataCenterName(final DataCenterModel dataCenter) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(dataCenter.getName().getEntity()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (!((Collection<?>) returnValue.getReturnValue()).isEmpty()) {
                dataCenter.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                dataCenter.getName().setIsValid(false);
                dataCenter.setValidTab(TabName.GENERAL_TAB, false);
            } else {
                dataCenter.getName().getInvalidityReasons().clear();
                dataCenter.getName().setIsValid(true);
                dataCenter.setValidTab(TabName.GENERAL_TAB, true);
                onSaveInternal();
            }
        }
    }));
}
#end_block

#method_before
private void checkForQuotaInDC(StoragePool storage_pool, final ICommandTarget commandTarget) {
    IdQueryParameters parameters = new IdQueryParameters(storage_pool.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetQuotaByStoragePoolId, parameters, new AsyncQuery(quotaListModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (((ArrayList<Quota>) ((VdcQueryReturnValue) returnValue).getReturnValue()).size() == 0) {
                promptNoQuotaInDCMessage();
            } else {
                onSaveInternal();
            }
        }
    }));
}
#method_after
private void checkForQuotaInDC(StoragePool storage_pool, final ICommandTarget commandTarget) {
    IdQueryParameters parameters = new IdQueryParameters(storage_pool.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetQuotaByStoragePoolId, parameters, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (((ArrayList<Quota>) returnValue.getReturnValue()).size() == 0) {
                promptNoQuotaInDCMessage();
            } else {
                onSaveInternal();
            }
        }
    }));
}
#end_block

#method_before
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    AsyncDataProvider.getInstance().getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            boolean hasIscsiStorage = false;
            ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
            for (StorageServerConnections connection : connections) {
                if (connection.getStorageType() == StorageType.ISCSI) {
                    hasIscsiStorage = true;
                    break;
                }
            }
            iscsiBondListModel.setIsAvailable(hasIscsiStorage);
        }
    }), storagePool.getId(), StorageType.ISCSI);
}
#method_after
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    AsyncDataProvider.getInstance().getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery<>(new AsyncCallback<List<StorageServerConnections>>() {

        @Override
        public void onSuccess(List<StorageServerConnections> connections) {
            boolean hasIscsiStorage = false;
            for (StorageServerConnections connection : connections) {
                if (connection.getStorageType() == StorageType.ISCSI) {
                    hasIscsiStorage = true;
                    break;
                }
            }
            iscsiBondListModel.setIsAvailable(hasIscsiStorage);
        }
    }), storagePool.getId(), StorageType.ISCSI);
}
#end_block

#method_before
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        Cluster cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> clusterListModel = (ClusterListModel<Void>) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((Cluster) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        Cluster cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

        @Override
        public void onSuccess(Cluster returnValue) {
            ClusterGuideModel model = (ClusterGuideModel) getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", ClusterListModel.this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.setAddMacPoolCommand(addMacPoolCommand);
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    clusterModel.getMigrationBandwidthLimitType().setItems(Arrays.asList(MigrationBandwidthLimitType.values()));
    clusterModel.getMigrationBandwidthLimitType().setSelectedItem(MigrationBandwidthLimitType.DEFAULT);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel<Void> clModel = (ClusterListModel<Void>) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            List<StoragePool> dataCenters = (List<StoragePool>) result;
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                final StoragePool selectedDataCenter = Linq.firstOrNull(dataCenters, new Linq.IdPredicate<>(selectDataCenter.getId()));
                cModel.getDataCenter().setItems(dataCenters, selectedDataCenter);
                cModel.getDataCenter().setIsChangeable(false);
            } else {
                cModel.getDataCenter().setItems(dataCenters, Linq.firstOrNull(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", clModel);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clModel);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
    clusterModel.initMigrationPolicies(false);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.setAddMacPoolCommand(addMacPoolCommand);
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    clusterModel.getMigrationBandwidthLimitType().setItems(Arrays.asList(MigrationBandwidthLimitType.values()));
    clusterModel.getMigrationBandwidthLimitType().setSelectedItem(MigrationBandwidthLimitType.DEFAULT);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> dataCenters) {
            ClusterModel cModel = (ClusterModel) getWindow();
            // Strict data center as neccessary.
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                final StoragePool selectedDataCenter = Linq.firstOrNull(dataCenters, new Linq.IdPredicate<>(selectDataCenter.getId()));
                cModel.getDataCenter().setItems(dataCenters, selectedDataCenter);
                cModel.getDataCenter().setIsChangeable(false);
            } else {
                cModel.getDataCenter().setItems(dataCenters, Linq.firstOrNull(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", ClusterListModel.this);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", ClusterListModel.this);
            cModel.getCommands().add(tempVar2);
        }
    }));
    clusterModel.initMigrationPolicies(false);
}
#end_block

#method_before
public void edit() {
    final Cluster cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setAddMacPoolCommand(addMacPoolCommand);
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getSwitchType().setSelectedItem(cluster.getRequiredSwitchTypeForCluster());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangeable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangeable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.setKsmPolicyForNuma(cluster.isKsmMergeAcrossNumaNodes());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangeable(cluster.getClusterHostsAndVms().getHosts() == 0);
    clusterModel.getMigrationBandwidthLimitType().setItems(Arrays.asList(MigrationBandwidthLimitType.values()));
    clusterModel.getMigrationBandwidthLimitType().setSelectedItem(cluster.getMigrationBandwidthLimitType() != null ? cluster.getMigrationBandwidthLimitType() : MigrationBandwidthLimitType.DEFAULT);
    clusterModel.getCustomMigrationNetworkBandwidth().setEntity(cluster.getCustomMigrationNetworkBandwidth());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangeable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangeable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangeable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    List<GlusterVolumeEntity> volumes = (List<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangeable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangeable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getClusterHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangeable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangeable(false);
                }
            }
            if (cluster.getClusterHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangeable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    clusterModel.initMigrationPolicies(true);
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangeable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final Cluster cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setAddMacPoolCommand(addMacPoolCommand);
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getSwitchType().setSelectedItem(cluster.getRequiredSwitchTypeForCluster());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangeable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangeable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.setKsmPolicyForNuma(cluster.isKsmMergeAcrossNumaNodes());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangeable(cluster.getClusterHostsAndVms().getHosts() == 0);
    clusterModel.getMigrationBandwidthLimitType().setItems(Arrays.asList(MigrationBandwidthLimitType.values()));
    clusterModel.getMigrationBandwidthLimitType().setSelectedItem(cluster.getMigrationBandwidthLimitType() != null ? cluster.getMigrationBandwidthLimitType() : MigrationBandwidthLimitType.DEFAULT);
    clusterModel.getCustomMigrationNetworkBandwidth().setEntity(cluster.getCustomMigrationNetworkBandwidth());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangeable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangeable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangeable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery<>(new AsyncCallback<Boolean>() {

        @Override
        public void onSuccess(final Boolean isVirtGlusterAllowed) {
            AsyncDataProvider.getInstance().getVolumeList(clusterModel.asyncQuery(new AsyncCallback<List<GlusterVolumeEntity>>() {

                @Override
                public void onSuccess(List<GlusterVolumeEntity> volumes) {
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangeable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangeable(false);
                        }
                    }
                }
            }), cluster.getName());
            if (cluster.getClusterHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangeable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangeable(false);
                }
            }
            if (cluster.getClusterHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangeable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    clusterModel.initMigrationPolicies(true);
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangeable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void checkForActiveVms(ClusterModel model, final ConfirmationModel confirmModel) {
    Guid clusterId = model.getEntity().getId();
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInClusterByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Integer numOfActiveVms = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (numOfActiveVms != 0) {
                confirmModel.setMessage(constants.thereAreActiveVMsRequiringRestart());
            }
            checkForNonResponsiveHosts(confirmModel);
        }
    }));
}
#method_after
private void checkForActiveVms(ClusterModel model, final ConfirmationModel confirmModel) {
    Guid clusterId = model.getEntity().getId();
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInClusterByClusterId, new IdQueryParameters(clusterId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            Integer numOfActiveVms = returnValue.getReturnValue();
            if (numOfActiveVms != 0) {
                confirmModel.setMessage(messages.thereAreActiveVMsRequiringRestart(numOfActiveVms));
            }
            checkForNonResponsiveHosts(confirmModel);
        }
    }));
}
#end_block

#method_before
private void onSaveConfirmGenericWarnings() {
    ClusterModel model = (ClusterModel) getWindow();
    cancelConfirmation();
    Cluster cluster = buildCluster(model);
    AsyncDataProvider.getInstance().getClusterEditWarnings(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterEditWarnings warnings = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (!warnings.isEmpty()) {
                ClusterWarningsModel confirmWindow = new ClusterWarningsModel();
                confirmWindow.init(warnings);
                // $NON-NLS-1$
                confirmWindow.getCommands().add(UICommand.createDefaultOkUiCommand("OnSaveInternal", ClusterListModel.this));
                // $NON-NLS-1$
                confirmWindow.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", ClusterListModel.this));
                setConfirmWindow(confirmWindow);
            } else {
                onSaveInternal();
            }
        }
    }), model.getClusterId(), cluster);
}
#method_after
private void onSaveConfirmGenericWarnings() {
    ClusterModel model = (ClusterModel) getWindow();
    cancelConfirmation();
    Cluster cluster = buildCluster(model);
    AsyncDataProvider.getInstance().getClusterEditWarnings(new AsyncQuery<>(new AsyncCallback<ClusterEditWarnings>() {

        @Override
        public void onSuccess(ClusterEditWarnings warnings) {
            if (!warnings.isEmpty()) {
                ClusterWarningsModel confirmWindow = new ClusterWarningsModel();
                confirmWindow.init(warnings);
                // $NON-NLS-1$
                confirmWindow.getCommands().add(UICommand.createDefaultOkUiCommand("OnSaveInternal", ClusterListModel.this));
                // $NON-NLS-1$
                confirmWindow.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", ClusterListModel.this));
                setConfirmWindow(confirmWindow);
            } else {
                onSaveInternal();
            }
        }
    }), model.getClusterId(), cluster);
}
#end_block

#method_before
private Cluster buildCluster(ClusterModel model) {
    Cluster cluster = model.getIsNew() ? new Cluster() : (Cluster) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(true);
    cluster.setCompatibilityVersion(version);
    cluster.setRequiredSwitchTypeForCluster(model.getSwitchType().getSelectedItem());
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    if (model.getMigrationPolicies().getSelectedItem() != null) {
        cluster.setMigrationPolicyId(model.getMigrationPolicies().getSelectedItem().getId());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    cluster.setMigrationBandwidthLimitType(model.getMigrationBandwidthLimitType().getSelectedItem());
    cluster.setCustomMigrationNetworkBandwidth(MigrationBandwidthLimitType.CUSTOM.equals(model.getMigrationBandwidthLimitType().getSelectedItem()) ? model.getCustomMigrationNetworkBandwidth().getEntity() : null);
    cluster.setMacPoolId(model.getMacPoolListModel().getSelectedItem().getId());
    return cluster;
}
#method_after
private Cluster buildCluster(ClusterModel model) {
    Cluster cluster = model.getIsNew() ? new Cluster() : (Cluster) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(true);
    cluster.setCompatibilityVersion(version);
    cluster.setRequiredSwitchTypeForCluster(model.getSwitchType().getSelectedItem());
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    if (model.getMigrationPolicies().getSelectedItem() != null) {
        cluster.setMigrationPolicyId(model.getMigrationPolicies().getSelectedItem().getId());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.getFencingPolicy().setSkipFencingIfGlusterBricksUp(model.getSkipFencingIfGlusterBricksUp().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfGlusterQuorumNotMet(model.getSkipFencingIfGlusterQuorumNotMet().getEntity());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    cluster.setMigrationBandwidthLimitType(model.getMigrationBandwidthLimitType().getSelectedItem());
    cluster.setCustomMigrationNetworkBandwidth(MigrationBandwidthLimitType.CUSTOM.equals(model.getMigrationBandwidthLimitType().getSelectedItem()) ? model.getCustomMigrationNetworkBandwidth().getEntity() : null);
    cluster.setMacPoolId(model.getMacPoolListModel().getSelectedItem().getId());
    return cluster;
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress();
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (hostMap.containsValue(null) || hostMap.containsValue("")) {
                // $NON-NLS-1$
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel<HostDetailModel> entityModel = new EntityModel<>(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getInstance().getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress();
    AsyncQuery<VdcQueryReturnValue> aQuery = new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (hostMap.containsValue(null) || hostMap.containsValue("")) {
                // $NON-NLS-1$
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel<HostDetailModel> entityModel = new EntityModel<>(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    });
    aQuery.setHandleFailure(true);
    AsyncDataProvider.getInstance().getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress();
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(getSelectedItem().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> model = (ClusterListModel<Void>) target;
            List<VDS> hosts = null;
            if (returnValue instanceof List) {
                hosts = (List<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof List) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            }
            boolean foundNRHosts = false;
            if (hosts != null) {
                for (VDS host : hosts) {
                    if (VDSStatus.NonResponsive == host.getStatus()) {
                        foundNRHosts = true;
                        break;
                    }
                }
            }
            String existingMsg = confirmModel.getMessage() == null ? "" : confirmModel.getMessage();
            if (foundNRHosts) {
                confirmModel.setMessage(existingMsg + constants.youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(existingMsg + constants.youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#method_after
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress();
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(getSelectedItem().getId()), new AsyncQuery<>(new AsyncCallback<Object>() {

        @Override
        public void onSuccess(Object returnValue) {
            List<VDS> hosts = null;
            if (returnValue instanceof List) {
                hosts = (List<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof List) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            }
            boolean foundNRHosts = false;
            if (hosts != null) {
                for (VDS host : hosts) {
                    if (VDSStatus.NonResponsive == host.getStatus()) {
                        foundNRHosts = true;
                        break;
                    }
                }
            }
            String existingMsg = confirmModel.getMessage() == null ? "" : confirmModel.getMessage();
            if (foundNRHosts) {
                confirmModel.setMessage(existingMsg + constants.youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(existingMsg + constants.youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            stopProgress();
        }
    }));
}
#end_block

#method_before
private void getAttachedTagsToSelectedHosts(TagListModel model) {
    ArrayList<Guid> hostIds = new ArrayList<>();
    for (VDS vds : getSelectedItems()) {
        hostIds.add(vds.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid hostId : hostIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToHost(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                HostListModel<Void> hostListModel = (HostListModel<Void>) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                hostListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                hostListModel.selectedItemsCounter++;
                if (hostListModel.selectedItemsCounter == hostListModel.getSelectedItems().size()) {
                    postGetAttachedTags(hostListModel, tagListModel);
                }
            }
        }), hostId);
    }
}
#method_after
private void getAttachedTagsToSelectedHosts(final TagListModel model) {
    ArrayList<Guid> hostIds = new ArrayList<>();
    for (VDS vds : getSelectedItems()) {
        hostIds.add(vds.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid hostId : hostIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToHost(new AsyncQuery<>(new AsyncCallback<List<Tags>>() {

            @Override
            public void onSuccess(List<Tags> returnValue) {
                allAttachedTags.addAll(returnValue);
                selectedItemsCounter++;
                if (selectedItemsCounter == getSelectedItems().size()) {
                    postGetAttachedTags(model);
                }
            }
        }), hostId);
    }
}
#end_block

#method_before
private void postGetAttachedTags(HostListModel<Void> hostListModel, TagListModel tagListModel) {
    if (hostListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(hostListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : hostListModel.allAttachedTags) {
                if (tag2.getTagId().equals(tag.getTagId())) {
                    count++;
                }
            }
            hostListModel.attachedTagsToEntities.put(tag.getTagId(), count == hostListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(hostListModel.attachedTagsToEntities);
    } else if ("OnAssignTags".equals(hostListModel.getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        hostListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(TagListModel tagListModel) {
    if (getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : allAttachedTags) {
                if (tag2.getTagId().equals(tag.getTagId())) {
                    count++;
                }
            }
            attachedTagsToEntities.put(tag.getTagId(), count == getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(attachedTagsToEntities);
    } else if ("OnAssignTags".equals(getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                hostModel.getOverrideIpTables().setIsAvailable(true);
                hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                    hostModel.getProtocol().setIsAvailable(false);
                    hostModel.getProtocol().setIsChangeable(false);
                } else {
                    hostModel.getProtocol().setIsAvailable(true);
                    hostModel.getProtocol().setIsChangeable(true);
                }
                hostModel.getProtocol().setEntity(true);
                hostModel.getProtocol().setIsChangeable(true);
            }
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangeable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        Cluster cluster = (Cluster) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangeable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
            }
            innerHostModel.onDataInitialized();
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            innerHostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(cancelCommand);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(new AsyncCallback<String>() {

        @Override
        public void onSuccess(String returnValue) {
            hostModel.setPmProxyPreferences(returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                hostModel.getOverrideIpTables().setIsAvailable(true);
                hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                    hostModel.getProtocol().setIsAvailable(false);
                    hostModel.getProtocol().setIsChangeable(false);
                } else {
                    hostModel.getProtocol().setIsAvailable(true);
                    hostModel.getProtocol().setIsChangeable(true);
                }
                hostModel.getProtocol().setEntity(true);
                hostModel.getProtocol().setIsChangeable(true);
            }
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> dataCenters) {
            HostModel innerHostModel = (HostModel) getWindow();
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (getSystemTreeSelectedItem() != null) {
                switch(getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangeable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        Cluster cluster = (Cluster) getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangeable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
            }
            innerHostModel.onDataInitialized();
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
            innerHostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
            innerHostModel.getCommands().add(cancelCommand);
        }
    }));
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = hostListModel.getSelectedItem();
            final EditHostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setSelectedCluster(host);
            hostModel.onDataInitialized();
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            hostModel.setHelpTag(HelpTag.edit_host);
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
                hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
            } else {
                AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            hostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            hostModel.getCommands().add(cancelCommand);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangeable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> dataCenters) {
            VDS host = getSelectedItem();
            final EditHostModel hostModel = new EditHostModel();
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setSelectedCluster(host);
            hostModel.onDataInitialized();
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            hostModel.setHelpTag(HelpTag.edit_host);
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            setWindow(hostModel);
            if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
                hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
            } else {
                AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(new AsyncCallback<String>() {

                    @Override
                    public void onSuccess(String returnValue) {
                        hostModel.setPmProxyPreferences(returnValue);
                    }
                }));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
            hostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
            hostModel.getCommands().add(cancelCommand);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangeable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    }));
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<>();
    ArrayList<String> list = new ArrayList<>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getClusterId());
    }
    model.setItems(list);
    // - the cluster should have  gluster service enabled
    if (clusters.size() == 1) {
        model.startProgress();
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null && cluster.supportsGlusterService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<>();
    ArrayList<String> list = new ArrayList<>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getClusterId());
    }
    model.setItems(list);
    // - the cluster should have  gluster service enabled
    if (clusters.size() == 1) {
        model.startProgress();
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

            @Override
            public void onSuccess(Cluster cluster) {
                if (cluster != null && cluster.supportsGlusterService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null) {
                    maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService());
                }
            }
        }), clusterId);
    }
}
#method_after
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

            @Override
            public void onSuccess(Cluster cluster) {
                if (cluster != null) {
                    maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
public void approve() {
    HostModel hostModel = new EditHostModel();
    setWindow(hostModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = hostListModel.getSelectedItem();
            innerHostModel.updateModelFromVds(host, dataCenters, false, getSystemTreeSelectedItem());
            innerHostModel.setTitle(ConstantsManager.getInstance().getConstants().editAndApproveHostTitle());
            innerHostModel.setHelpTag(HelpTag.edit_and_approve_host);
            // $NON-NLS-1$
            innerHostModel.setHashName("edit_and_approve_host");
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnApprove", hostListModel);
            innerHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void approve() {
    HostModel hostModel = new EditHostModel();
    setWindow(hostModel);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> dataCenters) {
            HostModel innerHostModel = (HostModel) getWindow();
            VDS host = getSelectedItem();
            innerHostModel.updateModelFromVds(host, dataCenters, false, getSystemTreeSelectedItem());
            innerHostModel.setTitle(ConstantsManager.getInstance().getConstants().editAndApproveHostTitle());
            innerHostModel.setHelpTag(HelpTag.edit_and_approve_host);
            // $NON-NLS-1$
            innerHostModel.setHashName("edit_and_approve_host");
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnApprove", HostListModel.this);
            innerHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
            innerHostModel.getCommands().add(tempVar2);
        }
    }));
}
#end_block

#method_before
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    param.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getActions().getSelectedItem()));
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getClusterId());
}
#method_after
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    final UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    param.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getActions().getSelectedItem()));
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

        @Override
        public void onSuccess(Cluster returnValue) {
            Frontend.getInstance().runAction(VdcActionType.InstallVds, param, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getClusterId());
}
#end_block

#method_before
private void updateAvailableOvirtNodeUpgrades() {
    final VDS host = getSelectedItem();
    if (host == null) {
        return;
    }
    if (!host.isOvirtVintageNode()) {
        return;
    }
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
        }
    }), host.getId());
}
#method_after
private void updateAvailableOvirtNodeUpgrades() {
    final VDS host = getSelectedItem();
    if (host == null) {
        return;
    }
    if (!host.isOvirtVintageNode()) {
        return;
    }
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(), host.getId());
}
#end_block

#method_before
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        DbUser dbUser = Frontend.getInstance().getLoggedInUser();
        if (dbUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(dbUser.getId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<Permission> permissions = response.getReturnValue();
                    for (Permission permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#method_after
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        DbUser dbUser = Frontend.getInstance().getLoggedInUser();
        if (dbUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(dbUser.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue response) {
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<Permission> permissions = response.getReturnValue();
                    for (Permission permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#end_block

#method_before
protected void export() {
    T selectedEntity = getSelectedItem();
    if (selectedEntity == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    ExportVmModel model = new ExportVmModel();
    setWindow(model);
    model.startProgress();
    setupExportModel(model);
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmBaseListModel vmListModel = (VmBaseListModel) target;
            List<StorageDomain> storageDomains = (List<StorageDomain>) returnValue;
            List<StorageDomain> filteredStorageDomains = new ArrayList<>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() == StorageDomainType.ImportExport) {
                    filteredStorageDomains.add(a);
                }
            }
            vmListModel.postExportGetStorageDomainList(filteredStorageDomains);
        }
    }), extractStoragePoolIdNullSafe(selectedEntity));
    // check, if the VM has a disk which doesn't allow snapshot
    sendWarningForNonExportableDisks(selectedEntity);
}
#method_after
protected void export() {
    T selectedEntity = getSelectedItem();
    if (selectedEntity == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    ExportVmModel model = new ExportVmModel();
    setWindow(model);
    model.startProgress();
    setupExportModel(model);
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> storageDomains) {
            List<StorageDomain> filteredStorageDomains = new ArrayList<>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() == StorageDomainType.ImportExport) {
                    filteredStorageDomains.add(a);
                }
            }
            postExportGetStorageDomainList(filteredStorageDomains);
        }
    }), extractStoragePoolIdNullSafe(selectedEntity));
    // check, if the VM has a disk which doesn't allow snapshot
    sendWarningForNonExportableDisks(selectedEntity);
}
#end_block

#method_before
protected void showWarningOnExistingEntities(ExportVmModel model, final VdcQueryType getVmOrTemplateQuery) {
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            VmBaseListModel vmListModel = (VmBaseListModel) array[0];
            ExportVmModel exportVmModel = (ExportVmModel) array[1];
            List<StoragePool> storagePools = (List<StoragePool>) returnValue;
            vmListModel.postShowWarningOnExistingVms(exportVmModel, storagePools, getVmOrTemplateQuery);
        }
    }), storageDomainId);
}
#method_after
protected void showWarningOnExistingEntities(final ExportVmModel model, final VdcQueryType getVmOrTemplateQuery) {
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> storagePools) {
            postShowWarningOnExistingVms(model, storagePools, getVmOrTemplateQuery);
        }
    }), storageDomainId);
}
#end_block

#method_before
private void postShowWarningOnExistingVms(final ExportVmModel exportModel, List<StoragePool> storagePools, VdcQueryType getVmOrTemplateQuery) {
    StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
    if (storagePool != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ExportVmModel windowModel = (ExportVmModel) getWindow();
                List<T> foundVms = new ArrayList<>();
                if (result != null) {
                    VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
                    Iterable<T> iterableReturnValue = asIterableReturnValue(returnValue.getReturnValue());
                    for (T selectedItem : getSelectedItems()) {
                        for (T returnValueItem : iterableReturnValue) {
                            if (entititesEqualsNullSafe(returnValueItem, selectedItem)) {
                                foundVms.add(selectedItem);
                                break;
                            }
                        }
                    }
                }
                if (foundVms.size() != 0) {
                    windowModel.setMessage(composeEntityOnStorage(composeExistingVmsWarningMessage(foundVms)));
                }
                exportModel.stopProgress();
            }
        };
        Guid storageDomainId = exportModel.getStorage().getSelectedItem().getId();
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePool.getId(), storageDomainId);
        Frontend.getInstance().runQuery(getVmOrTemplateQuery, tempVar, _asyncQuery);
    } else {
        exportModel.stopProgress();
    }
}
#method_after
private void postShowWarningOnExistingVms(final ExportVmModel exportModel, List<StoragePool> storagePools, VdcQueryType getVmOrTemplateQuery) {
    StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
    if (storagePool != null) {
        Guid storageDomainId = exportModel.getStorage().getSelectedItem().getId();
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePool.getId(), storageDomainId);
        Frontend.getInstance().runQuery(getVmOrTemplateQuery, tempVar, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                ExportVmModel windowModel = (ExportVmModel) getWindow();
                List<T> foundVms = new ArrayList<>();
                if (returnValue != null) {
                    Iterable<T> iterableReturnValue = asIterableReturnValue(returnValue.getReturnValue());
                    for (T selectedItem1 : getSelectedItems()) {
                        for (T returnValueItem : iterableReturnValue) {
                            if (entititesEqualsNullSafe(returnValueItem, selectedItem1)) {
                                foundVms.add(selectedItem1);
                                break;
                            }
                        }
                    }
                }
                if (foundVms.size() != 0) {
                    windowModel.setMessage(composeEntityOnStorage(composeExistingVmsWarningMessage(foundVms)));
                }
                exportModel.stopProgress();
            }
        }));
    } else {
        exportModel.stopProgress();
    }
}
#end_block

#method_before
protected void validateVm(final UnitVmModel model, final String vmName) {
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && vmName.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
                model.fireValidationCompleteEvent();
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setValidTab(TabName.GENERAL_TAB, true);
                onSaveVM(model);
            }
        }
    }), vmName, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#method_after
protected void validateVm(final UnitVmModel model, final String vmName) {
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery<>(new AsyncCallback<Boolean>() {

        @Override
        public void onSuccess(Boolean returnValue) {
            if (!returnValue && vmName.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
                model.fireValidationCompleteEvent();
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setValidTab(TabName.GENERAL_TAB, true);
                onSaveVM(model);
            }
        }
    }), vmName, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#end_block

#method_before
private void InitSpmPriorities() {
    AsyncDataProvider.getInstance().getMaxSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            MainTabHostView view = (MainTabHostView) target;
            view.maxSpmPriority = (Integer) returnValue;
            InitSpmPriorities1();
        }
    }));
}
#method_after
private void InitSpmPriorities() {
    AsyncDataProvider.getInstance().getMaxSpmPriority(new AsyncQuery<>(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxSpmPriority = returnValue;
            InitSpmPriorities1();
        }
    }));
}
#end_block

#method_before
private void InitSpmPriorities1() {
    AsyncDataProvider.getInstance().getDefaultSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            MainTabHostView view = (MainTabHostView) target;
            view.defaultSpmPriority = (Integer) returnValue;
            InitSpmPriorities2();
        }
    }));
}
#method_after
private void InitSpmPriorities1() {
    AsyncDataProvider.getInstance().getDefaultSpmPriority(new AsyncQuery<>(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            defaultSpmPriority = returnValue;
            InitSpmPriorities2();
        }
    }));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setAuditCustomValues();
    Label label = new LabelBuilder(getParameters().getLabel()).build();
    labelDao.save(label);
    setSucceeded(true);
    setActionReturnValue(label.getId());
}
#method_after
@Override
protected void executeCommand() {
    Label label = new LabelBuilder(getParameters().getLabel()).build();
    labelDao.save(label);
    setSucceeded(true);
    setActionReturnValue(label.getId());
}
#end_block

#method_before
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return tsb.append("id", getId()).append("name", getName()).append("vdsId", getVdsId()).append("networkName", getNetworkName()).append("ipv4BootProtocol", getIpv4BootProtocol()).append("ipv4Address", getIpv4Address()).append("ipv4Subnet", getIpv4Subnet()).append("ipv4Gateway", getIpv4Gateway()).append("ipv6BootProtocol", getIpv6BootProtocol()).append("ipv6Address", getIpv6Address()).append("ipv6Prefix", getIpv6Prefix()).append("ipv6Gateway", getIpv6Gateway()).append("mtu", getMtu()).append("bridged", isBridged()).append("reportedSwitchType", getReportedSwitchType()).append("type", getType()).append("networkImplementationDetails", getNetworkImplementationDetails()).append("qos", getQos()).append("adPartnerMac", getAdPartnerMac());
}
#method_after
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return tsb.append("id", getId()).append("name", getName()).append("vdsId", getVdsId()).append("networkName", getNetworkName()).append("ipv4BootProtocol", getIpv4BootProtocol()).append("ipv4Address", getIpv4Address()).append("ipv4Subnet", getIpv4Subnet()).append("ipv4Gateway", getIpv4Gateway()).append("ipv6BootProtocol", getIpv6BootProtocol()).append("ipv6Address", getIpv6Address()).append("ipv6Prefix", getIpv6Prefix()).append("ipv6Gateway", getIpv6Gateway()).append("mtu", getMtu()).append("bridged", isBridged()).append("reportedSwitchType", getReportedSwitchType()).append("type", getType()).append("networkImplementationDetails", getNetworkImplementationDetails()).append("qos", getQos()).append("adPartnerMac", getAdPartnerMac()).append("adAggregatorId", adAggregatorId);
}
#end_block

#method_before
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#method_after
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                Guid domainId = Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DomainId));
                List<Guid> domainIds = Collections.singletonList(domainId);
                image.setStorageIds(new ArrayList<>(domainIds));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setElapsedTime(assignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setElapsedTime(assignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
}
#end_block

#method_before
private static void updatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(assignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(assignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(assignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(getPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = assignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(getPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.glusterfsCliPackageName)) {
            Map<String, Object> glusterfsCli = (Map<String, Object>) packages.get(VdsProperties.glusterfsCliPackageName);
            vds.setGlusterfsCliVersion(getPackageRpmVersion(VdsProperties.glusterfsCliPackageName, glusterfsCli));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#method_after
private static void updatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(assignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(assignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(assignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        Map<String, Object> hostOsMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os);
        vds.setHostOs(getPackageVersionFormated(hostOsMap, true));
        if (hostOsMap.containsKey(VdsProperties.pretty_name)) {
            vds.setPrettyName(assignStringValue(hostOsMap, VdsProperties.pretty_name));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = assignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(getPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.glusterfsCliPackageName)) {
            Map<String, Object> glusterfsCli = (Map<String, Object>) packages.get(VdsProperties.glusterfsCliPackageName);
            vds.setGlusterfsCliVersion(getPackageRpmVersion(VdsProperties.glusterfsCliPackageName, glusterfsCli));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#end_block

#method_before
private static void extractInterfaceStatistics(Map<String, Object> dict, NetworkInterface<?> iface) {
    NetworkStatistics stats = iface.getStatistics();
    stats.setReceiveRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_rate));
    stats.setReceiveDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_dropped));
    stats.setReceivedBytes(assignLongValue(dict, VdsProperties.rx_total));
    stats.setTransmitRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_rate));
    stats.setTransmitDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_dropped));
    stats.setTransmittedBytes(assignLongValue(dict, VdsProperties.tx_total));
    stats.setSampleTime(assignDoubleValue(dict, VdsProperties.sample_time));
    iface.setSpeed(assignIntValue(dict, VdsProperties.INTERFACE_SPEED));
}
#method_after
private static void extractInterfaceStatistics(Map<String, Object> dict, NetworkInterface<?> iface) {
    NetworkStatistics stats = iface.getStatistics();
    stats.setReceiveDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_dropped));
    stats.setReceivedBytes(assignLongValue(dict, VdsProperties.rx_total));
    stats.setTransmitDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_dropped));
    stats.setTransmittedBytes(assignLongValue(dict, VdsProperties.tx_total));
    stats.setSampleTime(assignDoubleValue(dict, VdsProperties.sample_time));
    iface.setSpeed(assignIntValue(dict, VdsProperties.INTERFACE_SPEED));
}
#end_block

#method_before
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        vds.setLocalDisksUsage(diskStats);
        for (Entry<String, Object> entry : diskStatsStruct.entrySet()) {
            Map<String, Object> pathStatsStruct = (Map<String, Object>) entry.getValue();
            diskStats.put(entry.getKey(), assignLongValue(pathStatsStruct, VdsProperties.DISK_STATS_FREE));
        }
    }
}
#method_after
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        // collect(Collectors.toMap(...)) will not work here as it uses merge() internally and
        // will fail on null values
        diskStatsStruct.entrySet().stream().forEach(e -> diskStats.put(e.getKey(), assignLongValue((Map<String, Object>) e.getValue(), VdsProperties.DISK_STATS_FREE)));
        vds.setLocalDisksUsage(diskStats);
    }
}
#end_block

#method_before
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    List<VdsNetworkInterface> interfaces = new ArrayList<>();
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        for (Object port : ports) {
            if (vdsInterfaces.containsKey(port.toString())) {
                interfaces.add(vdsInterfaces.get(port.toString()));
            }
        }
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        return Arrays.stream(ports).filter(port -> vdsInterfaces.containsKey(port.toString())).map(port -> vdsInterfaces.get(port.toString())).collect(Collectors.toList());
    }
    return new ArrayList<>();
}
#end_block

#method_before
// we check for old bonding options,
// if we had value for the bonding options, i.e. the user set it by the UI
// and we have host that is not returning it's bonding options(host below 2.2.4) we override
private static void setBondingOptions(VDS vds, List<VdsNetworkInterface> oldInterfaces) {
    for (VdsNetworkInterface iface : oldInterfaces) {
        if (iface.getBondOptions() != null) {
            for (VdsNetworkInterface newIface : vds.getInterfaces()) {
                if (iface.getName().equals(newIface.getName()) && newIface.getBondOptions() == null) {
                    newIface.setBondOptions(iface.getBondOptions());
                    break;
                }
            }
        }
    }
}
#method_after
// we check for old bonding options,
// if we had value for the bonding options, i.e. the user set it by the UI
// and we have host that is not returning it's bonding options(host below 2.2.4) we override
private static void setBondingOptions(VDS vds, List<VdsNetworkInterface> oldInterfaces) {
    oldInterfaces.stream().filter(iface -> iface.getBondOptions() != null).forEach(iface -> vds.getInterfaces().stream().filter(newIface -> iface.getName().equals(newIface.getName())).filter(newIface -> newIface.getBondOptions() == null).findFirst().ifPresent(newIface -> newIface.setBondOptions(iface.getBondOptions())));
}
#end_block

#method_before
private static void addBondDeviceToHost(VDS vds, VdsNetworkInterface iface, Object[] interfaces) {
    vds.getInterfaces().add(iface);
    if (interfaces != null) {
        for (Object name : interfaces) {
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(name.toString())) {
                    tempInterface.setBondName(iface.getName());
                    break;
                }
            }
        }
    }
}
#method_after
private static void addBondDeviceToHost(VDS vds, VdsNetworkInterface iface, Object[] interfaces) {
    vds.getInterfaces().add(iface);
    if (interfaces != null) {
        Arrays.stream(interfaces).forEach(name -> vds.getInterfaces().stream().filter(tempInterface -> tempInterface.getName().equals(name.toString())).findFirst().ifPresent(tempInterface -> tempInterface.setBondName(iface.getName())));
    }
}
#end_block

#method_before
public static List<VmGuestAgentInterface> buildVmGuestAgentInterfacesData(Guid vmId, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK_INTERFACES)) {
        return null;
    }
    List<VmGuestAgentInterface> interfaces = new ArrayList<>();
    for (Object ifaceStruct : (Object[]) xmlRpcStruct.get(VdsProperties.VM_NETWORK_INTERFACES)) {
        VmGuestAgentInterface nic = new VmGuestAgentInterface();
        Map ifaceMap = (Map) ifaceStruct;
        nic.setInterfaceName(assignStringValue(ifaceMap, VdsProperties.VM_INTERFACE_NAME));
        nic.setMacAddress(getMacAddress(ifaceMap));
        nic.setIpv4Addresses(extracStringtList(ifaceMap, VdsProperties.VM_IPV4_ADDRESSES));
        nic.setIpv6Addresses(extracStringtList(ifaceMap, VdsProperties.VM_IPV6_ADDRESSES));
        nic.setVmId(vmId);
        interfaces.add(nic);
    }
    return interfaces;
}
#method_after
public static List<VmGuestAgentInterface> buildVmGuestAgentInterfacesData(Guid vmId, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK_INTERFACES)) {
        return null;
    }
    List<VmGuestAgentInterface> interfaces = new ArrayList<>();
    for (Object ifaceStruct : (Object[]) xmlRpcStruct.get(VdsProperties.VM_NETWORK_INTERFACES)) {
        VmGuestAgentInterface nic = new VmGuestAgentInterface();
        Map ifaceMap = (Map) ifaceStruct;
        nic.setInterfaceName(assignStringValue(ifaceMap, VdsProperties.VM_INTERFACE_NAME));
        nic.setMacAddress(getMacAddress(ifaceMap));
        nic.setIpv4Addresses(extractList(ifaceMap, VdsProperties.VM_IPV4_ADDRESSES, true));
        nic.setIpv6Addresses(extractList(ifaceMap, VdsProperties.VM_IPV6_ADDRESSES, true));
        nic.setVmId(vmId);
        interfaces.add(nic);
    }
    return interfaces;
}
#end_block

#method_before
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(assignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.parseInt(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = assignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            Map<Integer, Integer> distanceMap = new HashMap<>();
            List<Integer> distances = Collections.emptyList();
            if (numaNodeDistanceMap != null) {
                // Save the received NUMA node distances
                distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
                for (int i = 0; i < distances.size(); i++) {
                    distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
                }
            }
            if (distances.isEmpty()) {
                // Save faked distances
                for (VdsNumaNode otherNumaNode : newNumaNodeList) {
                    // There is no distance if the node is the same one
                    if (otherNumaNode.getIndex() == vdsNumaNode.getIndex()) {
                        continue;
                    }
                    distanceMap.put(otherNumaNode.getIndex(), 0);
                }
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#method_after
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(assignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.parseInt(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST, false);
            long memTotal = assignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            Map<Integer, Integer> distanceMap = new HashMap<>();
            List<Integer> distances = Collections.emptyList();
            if (numaNodeDistanceMap != null) {
                // Save the received NUMA node distances
                distances = extractList(numaNodeDistanceMap, String.valueOf(index), false);
                for (int i = 0; i < distances.size(); i++) {
                    distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
                }
            }
            if (distances.isEmpty()) {
                // Save faked distances
                for (VdsNumaNode otherNumaNode : newNumaNodeList) {
                    // There is no distance if the node is the same one
                    if (otherNumaNode.getIndex() == vdsNumaNode.getIndex()) {
                        continue;
                    }
                    distanceMap.put(otherNumaNode.getIndex(), 0);
                }
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#end_block

#method_before
private static void updateV2VJobs(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.v2vJobs)) {
        return;
    }
    List<V2VJobInfo> v2vJobs = new ArrayList<>();
    for (Entry<String, Object> job : ((Map<String, Object>) xmlRpcStruct.get(VdsProperties.v2vJobs)).entrySet()) {
        v2vJobs.add(buildV2VJobData(job.getKey(), (Map<String, Object>) job.getValue()));
    }
    vds.getStatisticsData().setV2VJobs(v2vJobs);
}
#method_after
private static void updateV2VJobs(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.v2vJobs)) {
        return;
    }
    List<V2VJobInfo> v2vJobs = ((Map<String, Object>) xmlRpcStruct.get(VdsProperties.v2vJobs)).entrySet().stream().map(job -> buildV2VJobData(job.getKey(), (Map<String, Object>) job.getValue())).collect(Collectors.toList());
    vds.getStatisticsData().setV2VJobs(v2vJobs);
}
#end_block

#method_before
public void getVolumeList(AsyncQuery<List<GlusterVolumeEntity>> aQuery, String clusterName, boolean doRefresh) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.getDel().onSuccess(new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new ListConverter<>();
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    if (!doRefresh) {
        searchParameters.withoutRefresh();
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getVolumeList(AsyncQuery<List<GlusterVolumeEntity>> aQuery, String clusterName, boolean doRefresh) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.getAsyncCallback().onSuccess(new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new ListConverter<>();
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    if (!doRefresh) {
        searchParameters.withoutRefresh();
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public void getMaxSpmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    aQuery.getDel().onSuccess(10);
}
#method_after
public void getMaxSpmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    aQuery.getAsyncCallback().onSuccess(10);
}
#end_block

#method_before
public void getDefaultSpmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    aQuery.getDel().onSuccess(5);
}
#method_after
public void getDefaultSpmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    aQuery.getAsyncCallback().onSuccess(5);
}
#end_block

#method_before
public <T> void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery<T> aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<>(parameters.getConfigValue(), parameters.getVersion());
    T returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = (T) cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = (T) cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.convert(returnValue);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.getDel().onSuccess(returnValue);
}
#method_after
public <T> void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery<T> aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<>(parameters.getConfigValue(), parameters.getVersion());
    T returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = (T) cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = (T) cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.convert(returnValue);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.getAsyncCallback().onSuccess(returnValue);
}
#end_block

#method_before
public void setItems(final AsyncCallback callback, final List<VM> externalVms) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalVms), SearchType.VM), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<VM> vms = returnValue.getReturnValue();
            Set<String> existingNames = new HashSet<>();
            for (VM vm : vms) {
                if (vm.getStoragePoolId().equals(getStoragePool().getId())) {
                    existingNames.add(vm.getName());
                }
            }
            List<ImportVmData> vmDataList = new ArrayList<>();
            for (VM vm : externalVms) {
                ImportVmData vmData = new ImportVmData(vm);
                if (vms.contains(vm)) {
                    vmData.setExistsInSystem(true);
                    vmData.getClone().setEntity(true);
                    vmData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importVMThatExistsInSystemMustClone());
                    vmData.getClone().setIsChangeable(false);
                }
                vmData.setNameExistsInTheSystem(existingNames.contains(vm.getName()));
                vmDataList.add(vmData);
            }
            setItems(vmDataList);
            callback.onSuccess(returnValue);
        }
    }));
}
#method_after
public void setItems(final AsyncCallback<VdcQueryReturnValue> callback, final List<VM> externalVms) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalVms), SearchType.VM), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<VM> vms = returnValue.getReturnValue();
            Set<String> existingNames = new HashSet<>();
            for (VM vm : vms) {
                if (vm.getStoragePoolId().equals(getStoragePool().getId())) {
                    existingNames.add(vm.getName());
                }
            }
            List<ImportVmData> vmDataList = new ArrayList<>();
            for (VM vm : externalVms) {
                ImportVmData vmData = new ImportVmData(vm);
                if (vms.contains(vm)) {
                    vmData.setExistsInSystem(true);
                    vmData.getClone().setEntity(true);
                    vmData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importVMThatExistsInSystemMustClone());
                    vmData.getClone().setIsChangeable(false);
                }
                vmData.setNameExistsInTheSystem(existingNames.contains(vm.getName()));
                vmDataList.add(vmData);
            }
            setItems(vmDataList);
            callback.onSuccess(returnValue);
        }
    }));
}
#end_block

#method_before
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clearVms();
            exportDomain.setEntity(null);
            loadProviders();
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery<>(createGetStorageDomainsByStoragePoolIdCallback()));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery<>(new AsyncCallback<List<VDS>>() {

                @Override
                public void onSuccess(List<VDS> hosts) {
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    kvmProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            }), dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> dataCenters) {
            for (StoragePool a : dataCenters) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#method_after
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clearVms();
            exportDomain.setEntity(null);
            loadProviders();
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery<>(createGetStorageDomainsByStoragePoolIdCallback()));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery<>(new AsyncCallback<List<VDS>>() {

                @Override
                public void onSuccess(List<VDS> hosts) {
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    kvmProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            }), dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> returnValue) {
            List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#end_block

#method_before
@Test
public void testGetFetchAllQuotaInTheSetup() throws Exception {
    List<Quota> quotaList = dao.getQuotaByStoragePoolGuid(null);
    assertEquals(5, quotaList.size());
}
#method_after
@Test
public void testGetFetchAllQuotaInTheSetup() throws Exception {
    List<Quota> quotaList = dao.getQuotaByStoragePoolGuid(null);
    assertEquals(13, quotaList.size());
}
#end_block

#method_before
@Test
public void testGetFetchForSpecificStoragePool() throws Exception {
    List<Quota> quotaList = dao.getQuotaByStoragePoolGuid(FixturesTool.STORAGE_POOL_NFS);
    assertEquals(5, quotaList.size());
}
#method_after
@Test
public void testGetFetchForSpecificStoragePool() throws Exception {
    List<Quota> quotaList = dao.getQuotaByStoragePoolGuid(FixturesTool.STORAGE_POOL_NFS);
    assertEquals(6, quotaList.size());
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    log.debug("Entered WelcomeServlet");
    SsoUtils.createUniqueStateInSessionIfNotExists(request);
    String reauthenticate = (String) request.getSession(true).getAttribute(WelcomeUtils.REAUTHENTICATE);
    if (StringUtils.isEmpty(reauthenticate)) {
        Map<String, Object> deployedResponse = isSsoWebappDeployed();
        if (deployedResponse.containsKey(WelcomeUtils.ERROR)) {
            request.getSession(true).setAttribute(WelcomeUtils.ERROR, deployedResponse.get(WelcomeUtils.ERROR));
            request.getSession(true).setAttribute(WelcomeUtils.ERROR_CODE, deployedResponse.get(WelcomeUtils.ERROR_CODE));
        }
    }
    String authCode = (String) request.getSession(true).getAttribute(WelcomeUtils.AUTH_CODE);
    String token = (String) request.getSession(true).getAttribute(WelcomeUtils.TOKEN);
    String error = (String) request.getSession(true).getAttribute(WelcomeUtils.ERROR);
    if (StringUtils.isNotEmpty(token) && !isSessionValid(request, token)) {
        request.getSession(true).removeAttribute(WelcomeUtils.TOKEN);
        request.getSession(true).removeAttribute(WelcomeUtils.SSO_USER);
        request.getSession(true).removeAttribute(WelcomeUtils.CAPABILITY_CREDENTIALS_CHANGE);
        token = "";
    }
    if (authCode == null && StringUtils.isEmpty(error) && StringUtils.isEmpty(reauthenticate)) {
        if (StringUtils.isNotEmpty(request.getParameter(WelcomeUtils.ERROR_CODE)) && !WelcomeUtils.ERR_OVIRT_CODE_NOT_AUTHENTICATED.equals(request.getParameter(WelcomeUtils.ERROR_CODE))) {
            request.getSession(true).setAttribute(WelcomeUtils.ERROR, request.getParameter(WelcomeUtils.ERROR));
            request.getSession(true).setAttribute(WelcomeUtils.ERROR_CODE, request.getParameter(WelcomeUtils.ERROR_CODE));
        }
        String url = WelcomeUtils.getLoginUrl(engineUri, identityScope);
        log.debug("redirecting to {}", url);
        response.sendRedirect(url);
    } else {
        request.getSession(true).removeAttribute(WelcomeUtils.REAUTHENTICATE);
        log.debug("Displaying Welcome Page");
        try {
            setUserNameForMenu(request, token);
        } catch (Exception ex) {
            log.debug("Unable to set request attributed for user menu", ex);
            log.error("Unable to set request attributed for user menu: {}", ex.getMessage());
        }
        error = (String) request.getSession(true).getAttribute(WelcomeUtils.ERROR);
        if (StringUtils.isNotEmpty(error)) {
            response.sendRedirect(engineUri + WelcomeUtils.ERROR_PAGE_URI);
        } else {
            request.setAttribute(LOCALE_KEYS, UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()));
            String oVirtVersion = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
            request.setAttribute("sso_credential_change_url", new URLBuilder(FiltersHelper.getEngineSsoUrl(request), WelcomeUtils.CREDENTIALS_CHANGE_FORM_URI).build());
            request.setAttribute(VERSION, oVirtVersion != null ? oVirtVersion : "myVersion");
            request.setAttribute(SECTIONS, brandingManager.getWelcomeSections((Locale) request.getAttribute(LocaleFilter.LOCALE)));
            log.debug("Including to ovirt-engine.jsp");
            RequestDispatcher dispatcher = request.getRequestDispatcher(WelcomeUtils.WELCOME_PAGE_JSP_URI);
            response.setContentType("text/html;charset=UTF-8");
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    }
    log.debug("Exiting WelcomeServlet");
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    log.debug("Entered WelcomeServlet");
    SsoUtils.createUniqueStateInSessionIfNotExists(request);
    String reauthenticate = (String) request.getSession(true).getAttribute(WelcomeUtils.REAUTHENTICATE);
    if (StringUtils.isEmpty(reauthenticate)) {
        Map<String, Object> deployedResponse = isSsoWebappDeployed();
        if (deployedResponse.containsKey(WelcomeUtils.ERROR)) {
            request.getSession(true).setAttribute(WelcomeUtils.ERROR, deployedResponse.get(WelcomeUtils.ERROR));
            request.getSession(true).setAttribute(WelcomeUtils.ERROR_CODE, deployedResponse.get(WelcomeUtils.ERROR_CODE));
        }
    }
    String authCode = (String) request.getSession(true).getAttribute(WelcomeUtils.AUTH_CODE);
    String token = (String) request.getSession(true).getAttribute(WelcomeUtils.TOKEN);
    String error = (String) request.getSession(true).getAttribute(WelcomeUtils.ERROR);
    if (StringUtils.isNotEmpty(token) && !isSessionValid(request, token)) {
        request.getSession(true).removeAttribute(WelcomeUtils.TOKEN);
        request.getSession(true).removeAttribute(WelcomeUtils.SSO_USER);
        request.getSession(true).removeAttribute(WelcomeUtils.CAPABILITY_CREDENTIALS_CHANGE);
        token = "";
    }
    if (authCode == null && StringUtils.isEmpty(error) && StringUtils.isEmpty(reauthenticate)) {
        if (StringUtils.isNotEmpty(request.getParameter(WelcomeUtils.ERROR_CODE)) && !WelcomeUtils.ERR_OVIRT_CODE_NOT_AUTHENTICATED.equals(request.getParameter(WelcomeUtils.ERROR_CODE))) {
            request.getSession(true).setAttribute(WelcomeUtils.ERROR, request.getParameter(WelcomeUtils.ERROR));
            request.getSession(true).setAttribute(WelcomeUtils.ERROR_CODE, request.getParameter(WelcomeUtils.ERROR_CODE));
        }
        String url = WelcomeUtils.getLoginUrl(engineUri, identityScope);
        log.debug("redirecting to {}", url);
        response.sendRedirect(url);
    } else {
        request.getSession(true).removeAttribute(WelcomeUtils.REAUTHENTICATE);
        log.debug("Displaying Welcome Page");
        try {
            setUserNameForMenu(request, token);
        } catch (Exception ex) {
            log.debug("Unable to set request attributed for user menu", ex);
            log.error("Unable to set request attributed for user menu: {}", ex.getMessage());
        }
        error = (String) request.getSession(true).getAttribute(WelcomeUtils.ERROR);
        if (StringUtils.isNotEmpty(error)) {
            response.sendRedirect(engineUri + WelcomeUtils.ERROR_PAGE_URI);
        } else {
            request.setAttribute(LOCALE_KEYS, UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()));
            String oVirtVersion = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
            request.setAttribute("sso_credential_change_url", getCredentialsChangeUrl(request));
            request.setAttribute(VERSION, oVirtVersion != null ? oVirtVersion : "myVersion");
            request.setAttribute(SECTIONS, brandingManager.getWelcomeSections((Locale) request.getAttribute(LocaleFilter.LOCALE)));
            log.debug("Including to ovirt-engine.jsp");
            RequestDispatcher dispatcher = request.getRequestDispatcher(WelcomeUtils.WELCOME_PAGE_JSP_URI);
            response.setContentType("text/html;charset=UTF-8");
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    }
    log.debug("Exiting WelcomeServlet");
}
#end_block

#method_before
boolean validatePluginAction(String pluginName, boolean allowWhileLoading) {
    Plugin plugin = getPlugin(pluginName);
    if (plugin == null) {
        return false;
    }
    boolean isInitializingOrInUse = plugin.isInState(PluginState.INITIALIZING) || plugin.isInState(PluginState.IN_USE);
    boolean isLoading = plugin.isInState(PluginState.LOADING);
    return allowWhileLoading ? (isLoading || isInitializingOrInUse) : isInitializingOrInUse;
}
#method_after
boolean validatePluginAction(String pluginName, boolean allowWhileLoading) {
    Plugin plugin = getPlugin(pluginName);
    if (plugin == null) {
        return false;
    }
    boolean isInitializingOrInUse = plugin.isInState(PluginState.INITIALIZING) || plugin.isInState(PluginState.IN_USE);
    boolean isLoading = plugin.isInState(PluginState.LOADING);
    return isInitializingOrInUse || (allowWhileLoading && isLoading);
}
#end_block

#method_before
public static ConnectionBuilder connection() {
    Class<? extends ConnectionBuilder> clazz = null;
    try {
        clazz = (Class<ConnectionBuilder>) Class.forName("org.ovirt.engine.sdk4.internal.ConnectionBuilder45");
    } catch (ClassNotFoundException | LinkageError ex) {
        try {
            clazz = (Class<ConnectionBuilder>) Class.forName("org.ovirt.engine.sdk4.internal.ConnectionBuilder42");
        } catch (ClassNotFoundException | LinkageError e) {
            throw new Error("No connection implementation found", e);
        }
    }
    try {
        return clazz.newInstance();
    } catch (Exception e) {
        throw new Error("Failed to initialize connection implementation", e);
    }
}
#method_after
public static ConnectionBuilder connection() {
    Class<? extends ConnectionBuilder> clazz = null;
    try {
        clazz = (Class<ConnectionBuilder>) Class.forName("org.ovirt.engine.sdk4.internal.ConnectionBuilder45");
    } catch (Throwable ex) {
        try {
            clazz = (Class<ConnectionBuilder>) Class.forName("org.ovirt.engine.sdk4.internal.ConnectionBuilder42");
        } catch (Throwable e) {
            throw new Error("No connection implementation found", e);
        }
    }
    try {
        return clazz.newInstance();
    } catch (Exception e) {
        throw new Error("Failed to initialize connection implementation", e);
    }
}
#end_block

#method_before
public Connection build() {
    try {
        // Check the parameters:
        if (url == null) {
            throw new IllegalArgumentException("The 'url' parameter is mandatory");
        }
        if (trustStoreFile != null && !new File(trustStoreFile).exists()) {
            throw new IllegalArgumentException(String.format("The truststore file '%s' doesn't exist'", trustStoreFile));
        }
        urlobj = new URL(url);
        // If all the checks pass, then create the connection:
        HttpConnection connection = new HttpConnection();
        connection.setClient(createHttpClient());
        connection.setUrl(url);
        connection.setUser(user);
        connection.setPassword(password);
        connection.setKerberos(kerberos);
        connection.setSsoUrl(ssoUrl);
        connection.setSsoTokenName(ssoTokenName);
        connection.setSsoRevokeUrl(ssoRevokeUrl);
        return connection;
    } catch (Exception e) {
        throw new Error("Failed to build connection", e);
    }
}
#method_after
public Connection build() {
    try {
        // Check the parameters:
        if (url == null) {
            throw new IllegalArgumentException("The 'url' parameter is mandatory");
        }
        if (trustStoreFile != null && !new File(trustStoreFile).exists()) {
            throw new IllegalArgumentException(String.format("The truststore file '%s' doesn't exist'", trustStoreFile));
        }
        urlobj = new URL(url);
        // If all the checks pass, then create the connection:
        HttpConnection connection = new HttpConnection();
        connection.setClient(createHttpClient());
        connection.setUrl(url);
        connection.setUser(user);
        connection.setPassword(password);
        connection.setSsoToken(token);
        connection.setKerberos(kerberos);
        connection.setSsoUrl(ssoUrl);
        connection.setSsoTokenName(ssoTokenName);
        connection.setSsoRevokeUrl(ssoRevokeUrl);
        return connection;
    } catch (Exception e) {
        throw new Error("Failed to build connection", e);
    }
}
#end_block

#method_before
@Override
protected HttpClient createHttpClient() {
    int port = getPort();
    Credentials credentials = null;
    AuthSchemeRegistry schemeRegistry = new AuthSchemeRegistry();
    AuthScope authScope = new AuthScope(getHost(), port, AuthScope.ANY_REALM, AuthScope.ANY_SCHEME);
    // Create credentials:
    if (user != null && user.length() > 0) {
        schemeRegistry.register(AuthPolicy.BASIC, new BasicSchemeFactory());
        credentials = new UsernamePasswordCredentials(user, password);
    } else if (kerberos) {
        schemeRegistry.register(AuthPolicy.SPNEGO, new SPNegoSchemeFactory(true));
        credentials = new Credentials() {

            @Override
            public Principal getUserPrincipal() {
                return null;
            }

            @Override
            public String getPassword() {
                return null;
            }
        };
    }
    // Create http client:
    DefaultHttpClient client = new DefaultHttpClient(new BasicClientConnectionManager(createConnectionSocketFactoryRegistry()));
    client.setAuthSchemes(schemeRegistry);
    client.getCredentialsProvider().setCredentials(authScope, credentials);
    client.getParams().setParameter(ClientPNames.COOKIE_POLICY, CookiePolicy.IGNORE_COOKIES);
    if (timeout != -1) {
        HttpConnectionParams.setSoTimeout(client.getParams(), timeout);
    }
    if (compress) {
        return new HttpClient42(new DecompressingHttpClient(client));
    }
    return new HttpClient42(client);
}
#method_after
@Override
protected HttpClient createHttpClient() {
    int port = getPort();
    Credentials credentials = null;
    AuthSchemeRegistry schemeRegistry = new AuthSchemeRegistry();
    AuthScope authScope = new AuthScope(getHost(), port, AuthScope.ANY_REALM, AuthScope.ANY_SCHEME);
    // Create credentials:
    if (user != null && user.length() > 0) {
        schemeRegistry.register(AuthPolicy.BASIC, new BasicSchemeFactory());
        credentials = new UsernamePasswordCredentials(user, password);
    } else if (kerberos) {
        schemeRegistry.register(AuthPolicy.SPNEGO, new SPNegoSchemeFactory(true));
        credentials = new Credentials() {

            @Override
            public Principal getUserPrincipal() {
                return null;
            }

            @Override
            public String getPassword() {
                return null;
            }
        };
    }
    // Create http client:
    DefaultHttpClient client = new DefaultHttpClient(new BasicClientConnectionManager(createConnectionSocketFactoryRegistry()));
    client.setAuthSchemes(schemeRegistry);
    client.getCredentialsProvider().setCredentials(authScope, credentials);
    client.getParams().setParameter(ClientPNames.COOKIE_POLICY, CookiePolicy.IGNORE_COOKIES);
    // Set request timeout:
    if (timeout != -1) {
        HttpConnectionParams.setSoTimeout(client.getParams(), timeout);
    }
    // Compress/decompress entities if compressing enabled:
    if (compress) {
        return new HttpClient42(new DecompressingHttpClient(client));
    }
    return new HttpClient42(client);
}
#end_block

#method_before
protected Map<String, Object> convertFencingPolicy(VDS proxyHost) {
    Map<String, Object> map = null;
    if (fencingPolicy != null && FencingPolicyHelper.isFencingPolicySupported(proxyHost.getSupportedClusterVersionsSet())) {
        // fencing policy is entered and proxy supports passing fencing policy parameters
        map = new HashMap<>();
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // create map STORAGE_DOMAIN_GUID -> HOST_SPM_ID to pass to fence proxy
            map.put(VdsProperties.STORAGE_DOMAIN_HOST_ID_MAP, createStorageDomainHostIdMap());
        }
        if (fencedHost.getClusterSupportsGlusterService() && (fencingPolicy.isSkipFencingIfGlusterBricksUp() || fencingPolicy.isSkipFencingIfGlusterQuorumNotMet())) {
            GlusterServer glusterServer = getDbFacade().getGlusterServerDao().getByServerId(fencedHost.getId());
            if (glusterServer != null) {
                map.put(VdsProperties.GLUSTER_SERVER_UUID, glusterServer.getGlusterServerUuid());
                if (fencingPolicy.isSkipFencingIfGlusterBricksUp()) {
                    map.put(VdsProperties.SKIP_FENCING_IF_GLUSTER_BRICKS_ARE_UP, true);
                }
                if (fencingPolicy.isSkipFencingIfGlusterQuorumNotMet()) {
                    map.put(VdsProperties.SKIP_FENCING_IF_GLUSTER_QUORUM_NOT_MET, true);
                }
            }
        }
    }
    return map;
}
#method_after
protected Map<String, Object> convertFencingPolicy(VDS proxyHost) {
    Map<String, Object> map = null;
    if (fencingPolicy != null && FencingPolicyHelper.isFencingPolicySupported(proxyHost.getSupportedClusterVersionsSet())) {
        // fencing policy is entered and proxy supports passing fencing policy parameters
        map = new HashMap<>();
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // create map STORAGE_DOMAIN_GUID -> HOST_SPM_ID to pass to fence proxy
            map.put(VdsProperties.STORAGE_DOMAIN_HOST_ID_MAP, createStorageDomainHostIdMap());
        }
        if (fencedHost.getClusterSupportsGlusterService() && (fencingPolicy.isSkipFencingIfGlusterBricksUp() || fencingPolicy.isSkipFencingIfGlusterQuorumNotMet())) {
            GlusterServer glusterServer = getDbFacade().getGlusterServerDao().getByServerId(fencedHost.getId());
            if (glusterServer != null) {
                map.put(VdsProperties.GLUSTER_SERVER_UUID, glusterServer.getGlusterServerUuid().toString());
                if (fencingPolicy.isSkipFencingIfGlusterBricksUp()) {
                    map.put(VdsProperties.SKIP_FENCING_IF_GLUSTER_BRICKS_ARE_UP, true);
                }
                if (fencingPolicy.isSkipFencingIfGlusterQuorumNotMet()) {
                    map.put(VdsProperties.SKIP_FENCING_IF_GLUSTER_QUORUM_NOT_MET, true);
                }
            }
        }
    }
    return map;
}
#end_block

#method_before
protected void setDefaultVolumeInformationSelection(List<DiskModel> diskModels) {
    final Map<Guid, DiskModel> diskModelsMap = new HashMap<>();
    for (DiskModel diskModel : diskModels) {
        diskModelsMap.put(((DiskImage) diskModel.getDisk()).getImageId(), diskModel);
    }
    Model model = getContainer() != null ? getContainer() : this;
    AsyncDataProvider.getInstance().getAncestorImagesByImagesIds(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Guid, DiskImage> imagesAncestors = (Map<Guid, DiskImage>) returnValue;
            for (Map.Entry<Guid, DiskImage> entry : imagesAncestors.entrySet()) {
                DiskModel diskModel = diskModelsMap.get(entry.getKey());
                diskModel.getVolumeType().setSelectedItem(entry.getValue().getVolumeType());
                diskModel.getVolumeFormat().setSelectedItem(entry.getValue().getVolumeFormat());
                updateStorageDomainsAvailability();
            }
        }
    }), new ArrayList<>(diskModelsMap.keySet()));
}
#method_after
protected void setDefaultVolumeInformationSelection(List<DiskModel> diskModels) {
    final Map<Guid, DiskModel> diskModelsMap = new HashMap<>();
    for (DiskModel diskModel : diskModels) {
        diskModelsMap.put(((DiskImage) diskModel.getDisk()).getImageId(), diskModel);
    }
    AsyncDataProvider.getInstance().getAncestorImagesByImagesIds(new AsyncQuery<>(new AsyncCallback<Map<Guid, DiskImage>>() {

        @Override
        public void onSuccess(Map<Guid, DiskImage> imagesAncestors) {
            for (Map.Entry<Guid, DiskImage> entry : imagesAncestors.entrySet()) {
                DiskModel diskModel = diskModelsMap.get(entry.getKey());
                diskModel.getVolumeType().setSelectedItem(entry.getValue().getVolumeType());
                diskModel.getVolumeFormat().setSelectedItem(entry.getValue().getVolumeFormat());
                updateStorageDomainsAvailability();
            }
        }
    }), new ArrayList<>(diskModelsMap.keySet()));
}
#end_block

#method_before
private void updateQuota(Guid storageDomainId, final ListModel<Quota> isItem, final Guid diskQuotaId) {
    if (getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && storageDomainId != null) {
        AsyncDataProvider.getInstance().getAllRelevantQuotasForStorageSorted(new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<Quota> list = (List<Quota>) returnValue;
                if (list == null) {
                    return;
                }
                if (isItem == null) {
                    for (DiskModel diskModel : getDisks()) {
                        diskModel.getQuota().setItems(list);
                        if (diskModel.getDisk() instanceof DiskImage) {
                            DiskImage diskImage = (DiskImage) diskModel.getDisk();
                            for (Quota quota : list) {
                                if (quota.getId().equals(diskImage.getQuotaId())) {
                                    diskModel.getQuota().setSelectedItem(quota);
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    Guid selectedQuota = isItem.getSelectedItem() != null ? isItem.getSelectedItem().getId() : null;
                    selectedQuota = selectedQuota != null ? selectedQuota : diskQuotaId;
                    isItem.setItems(list);
                    if (selectedQuota != null && list.size() > 1) {
                        for (Quota quota : list) {
                            if (quota.getId().equals(selectedQuota)) {
                                isItem.setSelectedItem(quota);
                                break;
                            }
                        }
                    }
                }
            }
        }), storageDomainId, null);
    }
}
#method_after
private void updateQuota(Guid storageDomainId, final ListModel<Quota> isItem, final Guid diskQuotaId) {
    if (getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && storageDomainId != null) {
        AsyncDataProvider.getInstance().getAllRelevantQuotasForStorageSorted(new AsyncQuery<>(new AsyncCallback<List<Quota>>() {

            @Override
            public void onSuccess(List<Quota> list) {
                if (list == null) {
                    return;
                }
                if (isItem == null) {
                    for (DiskModel diskModel : getDisks()) {
                        diskModel.getQuota().setItems(list);
                        if (diskModel.getDisk() instanceof DiskImage) {
                            DiskImage diskImage = (DiskImage) diskModel.getDisk();
                            for (Quota quota : list) {
                                if (quota.getId().equals(diskImage.getQuotaId())) {
                                    diskModel.getQuota().setSelectedItem(quota);
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    Guid selectedQuota = isItem.getSelectedItem() != null ? isItem.getSelectedItem().getId() : null;
                    selectedQuota = selectedQuota != null ? selectedQuota : diskQuotaId;
                    isItem.setItems(list);
                    if (selectedQuota != null && list.size() > 1) {
                        for (Quota quota : list) {
                            if (quota.getId().equals(selectedQuota)) {
                                isItem.setSelectedItem(quota);
                                break;
                            }
                        }
                    }
                }
            }
        }), storageDomainId, null);
    }
}
#end_block

#method_before
private void updateDiskProfile(Guid storageDomainId, final ListModel<DiskProfile> diskProfiles) {
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<DiskProfile> fetchedDiskProfiles = ((VdcQueryReturnValue) returnValue).getReturnValue();
            DisksAllocationModel.this.setDiskProfilesList(diskProfiles, fetchedDiskProfiles);
        }
    }));
}
#method_after
private void updateDiskProfile(Guid storageDomainId, final ListModel<DiskProfile> diskProfiles) {
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<DiskProfile> fetchedDiskProfiles = returnValue.getReturnValue();
            DisksAllocationModel.this.setDiskProfilesList(diskProfiles, fetchedDiskProfiles);
        }
    }));
}
#end_block

#method_before
private void updateImageToDestinationDomainMap() {
    if (disks == null) {
        return;
    }
    for (DiskModel diskModel : disks) {
        StorageDomain storageDomain = diskModel.getStorageDomain().getSelectedItem();
        DiskImage diskImage = (DiskImage) diskModel.getDisk();
        diskImage.setStorageIds(new ArrayList<>(Arrays.asList(storageDomain.getId())));
        diskImage.setDiskAlias(diskModel.getAlias().getEntity());
        DiskProfile diskProfile = diskModel.getDiskProfile().getSelectedItem();
        diskImage.setDiskProfileId(diskProfile != null ? diskProfile.getId() : null);
        if (diskModel.getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(diskModel.getQuota().getSelectedItem().getId());
        }
        if (diskModel.getVolumeFormat().getIsAvailable()) {
            VolumeFormat volumeFormat = diskModel.getVolumeFormat().getSelectedItem();
            diskImage.setVolumeFormat(volumeFormat);
            diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeTypeByFormatAndStorage(volumeFormat, storageDomain.getStorageType()));
        } else if (diskModel.getVolumeType().getIsAvailable()) {
            VolumeType volumeType = diskModel.getVolumeType().getSelectedItem();
            diskImage.setVolumeType(volumeType);
            diskImage.setVolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(volumeType, storageDomain.getStorageType()));
        }
        imageToDestinationDomainMap.put(diskImage.getId(), diskImage);
    }
}
#method_after
private void updateImageToDestinationDomainMap() {
    if (disks == null) {
        return;
    }
    for (DiskModel diskModel : disks) {
        StorageDomain storageDomain = diskModel.getStorageDomain().getSelectedItem();
        DiskImage diskImage = (DiskImage) diskModel.getDisk();
        diskImage.setStorageIds(new ArrayList<>(Arrays.asList(storageDomain.getId())));
        diskImage.setDiskAlias(diskModel.getAlias().getEntity());
        DiskProfile diskProfile = diskModel.getDiskProfile().getSelectedItem();
        diskImage.setDiskProfileId(diskProfile != null ? diskProfile.getId() : null);
        if (diskModel.getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(diskModel.getQuota().getSelectedItem().getId());
        }
        if (diskModel.getVolumeFormat().getIsAvailable()) {
            VolumeFormat volumeFormat = diskModel.getVolumeFormat().getSelectedItem();
            diskImage.setVolumeFormat(volumeFormat);
            diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(volumeFormat, storageDomain.getStorageType()));
        } else if (diskModel.getVolumeType().getIsAvailable()) {
            VolumeType volumeType = diskModel.getVolumeType().getSelectedItem();
            diskImage.setVolumeType(volumeType);
            diskImage.setVolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(volumeType, storageDomain.getStorageType()));
        }
        imageToDestinationDomainMap.put(diskImage.getId(), diskImage);
    }
}
#end_block

#method_before
public boolean isSourceAvailable() {
    return isSourceAvailable;
}
#method_after
public boolean isSourceAvailable() {
    return isSourceStorageDomainAvailable || isSourceStorageDomainNameAvailable;
}
#end_block

#method_before
private void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private void getDefaultConfigurationVersion(final LoginModel loginModel) {
    AsyncQuery callback = new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#method_after
public void initCache(final LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery<>(new AsyncCallback<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>>() {

        @Override
        public void onSuccess(Map<KeyValuePairCompat<ConfigurationValues, String>, Object> returnValue) {
            getDefaultConfigurationVersion(loginModel);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#end_block

#method_before
private void initMigrationPolicies() {
    AsyncQuery aQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationPolicies = (List<MigrationPolicy>) returnValue;
        }
    });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<MigrationPolicy>();
            }
            Collections.sort((List<MigrationPolicy>) returnValue, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return returnValue;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void initMigrationPolicies() {
    AsyncQuery<List<MigrationPolicy>> aQuery = new AsyncQuery<>(new AsyncCallback<List<MigrationPolicy>>() {

        @Override
        public void onSuccess(List<MigrationPolicy> returnValue) {
            migrationPolicies = returnValue;
        }
    });
    aQuery.converterCallback = new Converter<List<MigrationPolicy>>() {

        @Override
        public List<MigrationPolicy> convert(Object returnValue) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<MigrationPolicy> policies = (List<MigrationPolicy>) returnValue;
            Collections.sort(policies, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return policies;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
private void initCustomPropertiesList() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            customPropertiesList = (Map<Version, Map<String, String>>) returnValue;
        }
    };
    callback.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return (source != null) ? (Map<Version, Map<String, String>>) source : new HashMap<Version, Map<String, String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#method_after
private void initCustomPropertiesList() {
    AsyncQuery<Map<Version, Map<String, String>>> callback = new AsyncQuery<>(new AsyncCallback<Map<Version, Map<String, String>>>() {

        @Override
        public void onSuccess(Map<Version, Map<String, String>> returnValue) {
            customPropertiesList = returnValue;
        }
    });
    callback.converterCallback = new MapConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#end_block

#method_before
public void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public void initDefaultOSes() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            defaultOSes = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void getStorageDomainsWithAttachedStoragePoolGuid(AsyncQuery aQuery, StoragePool storagePool, List<StorageDomain> storageDomains, StorageServerConnections storageServerConnection, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source == null ? new ArrayList<StorageDomain>() : (ArrayList<StorageDomain>) source;
        }
    };
    if (storageDomains != null) {
        // Get file storage domains
        StorageDomainsAndStoragePoolIdQueryParameters parameters = new StorageDomainsAndStoragePoolIdQueryParameters(storageDomains, storagePool.getId(), vdsId);
        Frontend.getInstance().runQuery(VdcQueryType.GetBlockStorageDomainsWithAttachedStoragePoolGuid, parameters, aQuery);
    } else {
        // Get block storage domains
        StorageDomainsAndStoragePoolIdQueryParameters parameters = new StorageDomainsAndStoragePoolIdQueryParameters(storageServerConnection, storagePool.getId(), vdsId);
        Frontend.getInstance().runQuery(VdcQueryType.GetFileStorageDomainsWithAttachedStoragePoolGuid, parameters, aQuery);
    }
}
#method_after
public void getStorageDomainsWithAttachedStoragePoolGuid(AsyncQuery<List<StorageDomainStatic>> aQuery, StoragePool storagePool, List<StorageDomain> storageDomains) {
    aQuery.converterCallback = new ListConverter<>();
    StorageDomainsAndStoragePoolIdQueryParameters parameters = new StorageDomainsAndStoragePoolIdQueryParameters(storageDomains, storagePool.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsWithAttachedStoragePoolGuid, parameters, aQuery);
}
#end_block

#method_before
private void initMigrationSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMigrationSupport), callback);
}
#method_after
private void initMigrationSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMigrationSupport), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            migrationSupport = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
private void initMemorySnapshotSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            memorySnapshotSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemorySnapshotSupport), callback);
}
#method_after
private void initMemorySnapshotSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemorySnapshotSupport), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            memorySnapshotSupport = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
private void initSuspendSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            suspendSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetSuspendSupport), callback);
}
#method_after
private void initSuspendSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetSuspendSupport), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            suspendSupport = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
private void initMemoryHotUnplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            memoryHotUnplugSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemoryHotUnplugSupport), callback);
}
#method_after
private void initMemoryHotUnplugSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemoryHotUnplugSupport), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            memoryHotUnplugSupport = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new AsyncCallback() {

        @Override
        public void onSuccess(Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public void initBalloonSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            balloonSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetBalloonSupportMap), callback);
}
#method_after
public void initBalloonSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetBalloonSupportMap), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            balloonSupportMap = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public void initDiskHotpluggableInterfacesMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            diskHotpluggableInterfacesMap = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initSoundDeviceSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetSoundDeviceSupportMap), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            soundDeviceSupportMap = ((VdcQueryReturnValue) result).getReturnValue();
        }
    }));
}
#method_after
public void initSoundDeviceSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetSoundDeviceSupportMap), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue result) {
            soundDeviceSupportMap = result.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void getUserProfile(AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetUserProfile, new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#method_after
public void getUserProfile(AsyncQuery<VdcQueryReturnValue> aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetUserProfile, new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getAAAProfilesListViaPublic(AsyncQuery aQuery, boolean passwordBasedOnly) {
    convertAAAProfilesResult(aQuery, passwordBasedOnly);
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesListViaPublic(AsyncQuery<List<String>> aQuery, boolean passwordBasedOnly) {
    convertAAAProfilesResult(aQuery, passwordBasedOnly);
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void isFloppySupported(AsyncQuery aQuery, Integer osId, Version version) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Boolean) source : Boolean.FALSE;
        }
    };
    OsQueryParameters params = new OsQueryParameters(OsRepositoryVerb.GetFloppySupport, osId, version);
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, params, aQuery);
}
#method_after
public static void isFloppySupported(AsyncQuery<Boolean> aQuery, Integer osId, Version version) {
    aQuery.converterCallback = new DefaultValueConverter<>(Boolean.FALSE);
    OsQueryParameters params = new OsQueryParameters(OsRepositoryVerb.GetFloppySupport, osId, version);
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, params, aQuery);
}
#end_block

#method_before
public void getIsoDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#method_after
public void getIsoDomainByDataCenterId(AsyncQuery<StorageDomain> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new Converter<StorageDomain>() {

        @Override
        public StorageDomain convert(Object source) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#end_block

#method_before
public void getExportDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#method_after
public void getExportDomainByDataCenterId(AsyncQuery<StorageDomain> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new Converter<StorageDomain>() {

        @Override
        public StorageDomain convert(Object source) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#end_block

#method_before
private void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh, ImageFileType imageFileType, IAsyncConverter converterCallBack) {
    aQuery.converterCallback = converterCallBack;
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, imageFileType);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery<List<String>> aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false);
}
#end_block

#method_before
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false, ImageFileType.Floppy);
}
#method_after
public void getFloppyImageList(AsyncQuery<List<String>> aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false, ImageFileType.Floppy);
}
#end_block

#method_before
public void getUnknownImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    getIrsImageList(aQuery, storagePoolId, forceRefresh, ImageFileType.All, new RepoImageToImageFileNameAsyncConverter() {

        @Override
        protected String transform(ArrayList<String> fileNameList, RepoImage repoImage) {
            return ISO_PREFIX + super.transform(fileNameList, repoImage);
        }

        @Override
        protected boolean desiredImage(RepoImage repoImage) {
            return ImageFileType.Unknown == repoImage.getFileType();
        }
    });
}
#method_after
public void getUnknownImageList(AsyncQuery<List<String>> aQuery, Guid storagePoolId, boolean forceRefresh) {
    getIrsImageList(aQuery, storagePoolId, forceRefresh, ImageFileType.All, new RepoImageToImageFileNameAsyncConverter() {

        @Override
        protected String transform(ArrayList<String> fileNameList, RepoImage repoImage) {
            return ISO_PREFIX + super.transform(fileNameList, repoImage);
        }

        @Override
        protected boolean desiredImage(RepoImage repoImage) {
            return ImageFileType.Unknown == repoImage.getFileType();
        }
    });
}
#end_block

#method_before
public void getDefaultManagementNetwork(AsyncQuery aQuery, Guid dataCenterId) {
    runQueryByIdParameter(VdcQueryType.GetDefaultManagementNetwork, aQuery, dataCenterId);
}
#method_after
public void getDefaultManagementNetwork(AsyncQuery<Network> aQuery, Guid dataCenterId) {
    runQueryByIdParameter(VdcQueryType.GetDefaultManagementNetwork, aQuery, dataCenterId);
}
#end_block

#method_before
public void getManagementNetwork(AsyncQuery aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.GetManagementNetwork, aQuery, clusterId);
}
#method_after
public void getManagementNetwork(AsyncQuery<Network> aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.GetManagementNetwork, aQuery, clusterId);
}
#end_block

#method_before
public void isManagementNetwork(AsyncQuery aQuery, Guid networkId) {
    runQueryByIdParameter(VdcQueryType.IsManagementNetwork, aQuery, networkId);
}
#method_after
public void isManagementNetwork(AsyncQuery<Boolean> aQuery, Guid networkId) {
    runQueryByIdParameter(VdcQueryType.IsManagementNetwork, aQuery, networkId);
}
#end_block

#method_before
public void isClusterEmpty(AsyncQuery aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.IsClusterEmpty, aQuery, clusterId);
}
#method_after
public void isClusterEmpty(AsyncQuery<Boolean> aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.IsClusterEmpty, aQuery, clusterId);
}
#end_block

#method_before
private void runQueryByIdParameter(VdcQueryType queryType, AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new AsIsAsyncConverter();
    Frontend.getInstance().runQuery(queryType, new IdQueryParameters(id), aQuery);
}
#method_after
private void runQueryByIdParameter(VdcQueryType queryType, AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new CastingConverter();
    Frontend.getInstance().runQuery(queryType, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getHostArchitecture(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<ArchitectureType>() {

        @Override
        public ArchitectureType convert(Object source, AsyncQuery _asyncQuery) {
            return (ArchitectureType) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostArchitecture(AsyncQuery<ArchitectureType> aQuery, Guid id) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterById, new IdQueryParameters(id), aQuery);
}
#method_after
public void getClusterById(AsyncQuery<Cluster> aQuery, Guid id) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterById, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Cluster>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#method_after
public void getClusterListByName(AsyncQuery<List<Cluster>> aQuery, String name) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#end_block

#method_before
public void getAuthzGroupsByUserId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter<List<AuthzGroup>>() {

        @Override
        public List<AuthzGroup> convert(Object source, AsyncQuery _asyncQuery) {
            return (List<AuthzGroup>) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAuthzGroupsByUserId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getAuthzGroupsByUserId(AsyncQuery<List<AuthzGroup>> aQuery, Guid userId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAuthzGroupsByUserId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public void getPoolById(AsyncQuery aQuery, Guid poolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#method_after
public void getPoolById(AsyncQuery<VmPool> aQuery, Guid poolId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#end_block

#method_before
public void getVmById(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmById(AsyncQuery<VM> aQuery, Guid vmId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void getVmNextRunConfiguration(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmNextRunConfiguration(AsyncQuery<VM> aQuery, Guid vmId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void getVmChangedFieldsForNextRun(VM original, VM updated, VmManagementParametersBase updateVmParameters, AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmChangedFieldsForNextRun, new GetVmChangedFieldsForNextRunParameters(original, updated, updateVmParameters), aQuery);
}
#method_after
public void getVmChangedFieldsForNextRun(VM original, VM updated, VmManagementParametersBase updateVmParameters, AsyncQuery<VdcQueryReturnValue> aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmChangedFieldsForNextRun, new GetVmChangedFieldsForNextRunParameters(original, updated, updateVmParameters), aQuery);
}
#end_block

#method_before
public void getDataCenterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    // $NON-NLS-1$
    SearchParameters params = new SearchParameters("DataCenter: sortby name", SearchType.StoragePool);
    Frontend.getInstance().runQuery(VdcQueryType.Search, doRefresh ? params : params.withoutRefresh(), aQuery);
}
#method_after
public void getDataCenterList(AsyncQuery<List<StoragePool>> aQuery) {
    getDataCenterList(aQuery, true);
}
#end_block

#method_before
public void getDataCenterByClusterServiceList(AsyncQuery aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            // sort data centers
            final ArrayList<StoragePool> storagePoolList = (ArrayList<StoragePool>) source;
            Collections.sort(storagePoolList, new NameableComparator());
            return source;
        }
    };
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#method_after
public void getDataCenterByClusterServiceList(AsyncQuery<List<StoragePool>> aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#end_block

#method_before
public void getDataCenterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterListByName(AsyncQuery<List<StoragePool>> aQuery, String name) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#end_block

#method_before
public void getSpiceUsbAutoShare(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source == null || (Boolean) source;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSpiceUsbAutoShare(AsyncQuery<Boolean> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(Boolean.TRUE);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getConfigurationValueBoolean(AsyncQuery aQuery, ConfigurationValues configVal) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(configVal, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getConfigurationValueBoolean(AsyncQuery<Boolean> aQuery, ConfigurationValues configVal) {
    aQuery.converterCallback = new DefaultValueConverter<>(Boolean.TRUE);
    getConfigFromCache(new GetConfigurationValueParameters(configVal, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getWANColorDepth(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? WanColorDepth.fromInt((Integer) source) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANColorDepth(AsyncQuery<WanColorDepth> aQuery) {
    aQuery.converterCallback = new Converter<WanColorDepth>() {

        @Override
        public WanColorDepth convert(Object source) {
            return source != null ? WanColorDepth.fromInt((Integer) source) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WanDisableEffects>();
            }
            List<WanDisableEffects> res = new ArrayList<>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WanDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANDisableEffects(AsyncQuery<List<WanDisableEffects>> aQuery) {
    aQuery.converterCallback = new Converter<List<WanDisableEffects>>() {

        @Override
        public List<WanDisableEffects> convert(Object source) {
            if (source == null) {
                return new ArrayList<>();
            }
            List<WanDisableEffects> res = new ArrayList<>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WanDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getMaxVmsInPool(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1000;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getMaxVmsInPool(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(1000);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getMaxNumOfVmSockets(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmSockets(AsyncQuery<Integer> aQuery, String version) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public void getMaxNumOfVmCpus(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmCpus(AsyncQuery<Integer> aQuery, String version) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public void getMaxNumOfCPUsPerSocket(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfCPUsPerSocket(AsyncQuery<Integer> aQuery, String version) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public void getMaxNumOfThreadsPerCpu(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfThreadsPerCpu);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfThreadsPerCpu(AsyncQuery<Integer> aQuery, String version) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfThreadsPerCpu);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery<List<Cluster>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public ArrayList<Cluster> getClusterByServiceList(List<Cluster> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<Cluster> filteredList = new ArrayList<>();
    for (Cluster cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#method_after
public void getClusterByServiceList(AsyncQuery<List<Cluster>> aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new Converter<List<Cluster>>() {

        @Override
        public List<Cluster> convert(Object source) {
            if (source == null) {
                return new ArrayList<>();
            }
            final ArrayList<Cluster> list = (ArrayList<Cluster>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isSoundcardEnabled(AsyncQuery<Boolean> aQuery, Guid vmId) {
    aQuery.converterCallback = new IsNonEmptyCollectionConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isVirtioScsiEnabledForVm(AsyncQuery<Boolean> aQuery, Guid vmId) {
    aQuery.converterCallback = new IsNonEmptyCollectionConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = getClusterByServiceList((ArrayList<Cluster>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterListByService(AsyncQuery<List<Cluster>> aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new Converter<List<Cluster>>() {

        @Override
        public List<Cluster> convert(Object source) {
            if (source != null) {
                ArrayList<Cluster> list = getClusterByServiceList((ArrayList<Cluster>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getLabelList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Label> list = (ArrayList<Label>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Label>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllLabels, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getLabelList(AsyncQuery<List<Label>> aQuery) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllLabels, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getLabelListByEntityId(AsyncQuery aQuery, Guid entityId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Label> list = (ArrayList<Label>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Label>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetLabelByEntityId, new IdQueryParameters(entityId), aQuery);
}
#method_after
public void getLabelListByEntityId(AsyncQuery<List<Label>> aQuery, Guid entityId) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetLabelByEntityId, new IdQueryParameters(entityId), aQuery);
}
#end_block

#method_before
public void getTemplateDiskList(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<DiskImage>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#method_after
public void getTemplateDiskList(AsyncQuery<List<DiskImage>> aQuery, Guid templateId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#end_block

#method_before
public void getTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getTemplateListByDataCenter(AsyncQuery<List<VmTemplate>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public void getTemplateListByStorage(AsyncQuery aQuery, Guid storageId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new GetVmTemplatesFromStorageDomainParameters(storageId, false), aQuery);
}
#method_after
public void getTemplateListByStorage(AsyncQuery<List<VmTemplate>> aQuery, Guid storageId) {
    aQuery.converterCallback = new Converter<List<VmTemplate>>() {

        @Override
        public List<VmTemplate> convert(Object source) {
            ArrayList<VmTemplate> list = new ArrayList<>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new GetVmTemplatesFromStorageDomainParameters(storageId, false), aQuery);
}
#end_block

#method_before
public void getNumOfMonitorList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Integer> nums = new ArrayList<>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNumOfMonitorList(AsyncQuery<List<Integer>> aQuery) {
    aQuery.converterCallback = new Converter<List<Integer>>() {

        @Override
        public List<Integer> convert(Object source) {
            ArrayList<Integer> nums = new ArrayList<>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getStorageDomainList(AsyncQuery<List<StorageDomain>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public int getMaxVmPriority() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion());
}
#method_after
public void getMaxVmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(100);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#method_after
public void getHostById(AsyncQuery<VDS> aQuery, Guid id) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((List<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#method_after
public void getHostListByCluster(AsyncQuery<List<VDS>> aQuery, String clusterName) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#end_block

#method_before
public void getHostListByClusterId(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getHostListByClusterId(AsyncQuery<List<VDS>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return Linq.<VDS>cast((List<?>) source);
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#method_after
public void getHostListByDataCenter(AsyncQuery<List<VDS>> aQuery, Guid spId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#end_block

#method_before
public void getHostDevicesByHostId(AsyncQuery aQuery, Guid hostId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetExtendedHostDevicesByHostId, new IdQueryParameters(hostId), aQuery);
}
#method_after
public void getHostDevicesByHostId(AsyncQuery<List<HostDeviceView>> aQuery, Guid hostId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetExtendedHostDevicesByHostId, new IdQueryParameters(hostId), aQuery);
}
#end_block

#method_before
public void getConfiguredVmHostDevices(AsyncQuery aQuery, Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmHostDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getConfiguredVmHostDevices(AsyncQuery<List<VmHostDevice>> aQuery, Guid vmId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmHostDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery<List<Disk>> aQuery, Guid vmId, boolean isRefresh) {
    aQuery.converterCallback = new ListConverter<>();
    IdQueryParameters params = new IdQueryParameters(vmId);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, params, aQuery);
}
#end_block

#method_before
public void getAAAProfilesList(AsyncQuery aQuery) {
    convertAAAProfilesResult(aQuery, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesList(AsyncQuery<List<String>> aQuery) {
    convertAAAProfilesResult(aQuery, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getAAANamespaces(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (HashMap<String, List<String>>) source : new HashMap<String, List<String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAANamespaces(AsyncQuery<Map<String, List<String>>> aQuery) {
    aQuery.converterCallback = new MapConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getAAAProfilesEntriesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Collection<ProfileEntry>) source : new ArrayList<ProfileEntry>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesEntriesList(AsyncQuery<List<ProfileEntry>> aQuery) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public void getRoleList(AsyncQuery<List<Role>> aQuery) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#end_block

#method_before
public void getStorageDomainById(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageDomain) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getStorageDomainById(AsyncQuery<StorageDomain> aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public void getStorageDomainByName(AsyncQuery aQuery, String storageDomainName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainByName, new NameQueryParameters(storageDomainName), aQuery);
}
#method_after
public void getStorageDomainByName(AsyncQuery<StorageDomainStatic> aQuery, String storageDomainName) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainByName, new NameQueryParameters(storageDomainName), aQuery);
}
#end_block

#method_before
public void getClusterNetworkList(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<Network>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getClusterNetworkList(AsyncQuery<List<Network>> aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new ListConverter<>();
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getAllNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<NetworkQoS>>() {

        @Override
        public List<NetworkQoS> convert(Object returnValue, AsyncQuery asyncQuery) {
            List<NetworkQoS> qosList = returnValue == null ? new ArrayList<NetworkQoS>() : (List<NetworkQoS>) returnValue;
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#method_after
public void getAllNetworkQos(Guid dcId, AsyncQuery<List<NetworkQoS>> query) {
    query.converterCallback = new ListConverter<NetworkQoS>() {

        @Override
        public List<NetworkQoS> convert(Object returnValue) {
            List<NetworkQoS> qosList = super.convert(returnValue);
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#end_block

#method_before
public void getAllHostNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<HostNetworkQos>>() {

        @Override
        public List<HostNetworkQos> convert(Object returnValue, AsyncQuery asyncQuery) {
            List<HostNetworkQos> qosList = (returnValue == null) ? new ArrayList<HostNetworkQos>() : (List<HostNetworkQos>) returnValue;
            qosList.add(0, NetworkModel.EMPTY_HOST_NETWORK_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(dcId, QosType.HOSTNETWORK), query);
}
#method_after
public void getAllHostNetworkQos(Guid dcId, AsyncQuery<List<HostNetworkQos>> query) {
    query.converterCallback = new ListConverter<HostNetworkQos>() {

        @Override
        public List<HostNetworkQos> convert(Object returnValue) {
            List<HostNetworkQos> qosList = super.convert(returnValue);
            qosList.add(0, NetworkModel.EMPTY_HOST_NETWORK_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(dcId, QosType.HOSTNETWORK), query);
}
#end_block

#method_before
public void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#method_after
public void getDataCenterById(AsyncQuery<StoragePool> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<SortedSet<String>>() {

        @Override
        public SortedSet<String> convert(Object returnValue, AsyncQuery asyncQuery) {
            SortedSet<String> sortedSet = new TreeSet<>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#method_after
public void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery<SortedSet<String>> query) {
    query.converterCallback = new Converter<SortedSet<String>>() {

        @Override
        public SortedSet<String> convert(Object returnValue) {
            SortedSet<String> sortedSet = new TreeSet<>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#end_block

#method_before
public void getTemplateById(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#method_after
public void getTemplateById(AsyncQuery<VmTemplate> aQuery, Guid templateId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#end_block

#method_before
public void countAllTemplates(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void countAllTemplates(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getHostList(AsyncQuery aQuery, boolean doRefresh) {
    getHostListByStatus(aQuery, null, doRefresh);
}
#method_after
public void getHostList(AsyncQuery<List<VDS>> aQuery) {
    getHostListByStatus(aQuery, null);
}
#end_block

#method_before
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, doRefresh ? searchParameters : searchParameters.withoutRefresh(), aQuery);
}
#method_after
public void getHostListByStatus(AsyncQuery<List<VDS>> aQuery, VDSStatus status) {
    getHostListByStatus(aQuery, status, true);
}
#end_block

#method_before
public void getHostsForStorageOperation(AsyncQuery aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#method_after
public void getHostsForStorageOperation(AsyncQuery<List<VDS>> aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#end_block

#method_before
public void getVolumeList(AsyncQuery aQuery, String clusterName, boolean doRefresh) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    if (!doRefresh) {
        searchParameters.withoutRefresh();
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getVolumeList(AsyncQuery<List<GlusterVolumeEntity>> aQuery, String clusterName) {
    getVolumeList(aQuery, clusterName, true);
}
#end_block

#method_before
public void getHostFingerprint(AsyncQuery aQuery, String hostAddress) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#method_after
public void getHostFingerprint(AsyncQuery<String> aQuery, String hostAddress) {
    aQuery.converterCallback = new StringConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#end_block

#method_before
public void getEngineSshPublicKey(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetEngineSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getEngineSshPublicKey(AsyncQuery<String> aQuery) {
    aQuery.converterCallback = new StringConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetEngineSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public void getClusterGlusterServices(AsyncQuery<GlusterVolumeAdvancedDetails> aQuery, Guid clusterId) {
    aQuery.converterCallback = new CastingConverter<>();
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public void getGlusterHostsNewlyAdded(AsyncQuery aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#method_after
public void getGlusterHostsNewlyAdded(AsyncQuery<Map<String, String>> aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#end_block

#method_before
public void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public void isAnyHostUpInCluster(AsyncQuery<Boolean> aQuery, String clusterName) {
    aQuery.converterCallback = new IsNonEmptyCollectionConverter();
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public void getGlusterHooks(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterHookEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#method_after
public void getGlusterHooks(AsyncQuery<List<GlusterHookEntity>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getGlusterBricksForServer(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterBrickEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#method_after
public void getGlusterBricksForServer(AsyncQuery<List<GlusterBrickEntity>> aQuery, Guid serverId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#end_block

#method_before
public void getGlusterVolumeGeoRepStatusForMasterVolume(AsyncQuery aQuery, Guid masterVolumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            return source != null ? source : new ArrayList<GlusterGeoRepSession>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepSessions, new IdQueryParameters(masterVolumeId), aQuery);
}
#method_after
public void getGlusterVolumeGeoRepStatusForMasterVolume(AsyncQuery<List<GlusterGeoRepSession>> aQuery, Guid masterVolumeId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepSessions, new IdQueryParameters(masterVolumeId), aQuery);
}
#end_block

#method_before
public void getGlusterVolumeGeoRepRecommendationViolations(AsyncQuery aQuery, Guid masterVolumeId, Guid slaveVolumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery asyncQuery) {
            return returnValue == null ? new ArrayList<GlusterGeoRepNonEligibilityReason>() : (List<GlusterGeoRepNonEligibilityReason>) returnValue;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNonEligibilityReasonsOfVolumeForGeoRepSession, new GlusterVolumeGeoRepEligibilityParameters(masterVolumeId, slaveVolumeId), aQuery);
}
#method_after
public void getGlusterVolumeGeoRepRecommendationViolations(AsyncQuery<List<GlusterGeoRepNonEligibilityReason>> aQuery, Guid masterVolumeId, Guid slaveVolumeId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetNonEligibilityReasonsOfVolumeForGeoRepSession, new GlusterVolumeGeoRepEligibilityParameters(masterVolumeId, slaveVolumeId), aQuery);
}
#end_block

#method_before
public void getGlusterVolumeSnapshotsForVolume(AsyncQuery aQuery, Guid volumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            return source != null ? source : new ArrayList<GlusterVolumeSnapshotEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotsByVolumeId, new IdQueryParameters(volumeId), aQuery);
}
#method_after
public void getGlusterVolumeSnapshotsForVolume(AsyncQuery<List<GlusterVolumeSnapshotEntity>> aQuery, Guid volumeId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotsByVolumeId, new IdQueryParameters(volumeId), aQuery);
}
#end_block

#method_before
public void getVolumeSnapshotSchedule(AsyncQuery aQuery, Guid volumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotScheduleByVolumeId, new IdQueryParameters(volumeId), aQuery);
}
#method_after
public void getVolumeSnapshotSchedule(AsyncQuery<GlusterVolumeSnapshotSchedule> aQuery, Guid volumeId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotScheduleByVolumeId, new IdQueryParameters(volumeId), aQuery);
}
#end_block

#method_before
public void getIsGlusterVolumeSnapshotCliScheduleEnabled(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotCliScheduleFlag, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getIsGlusterVolumeSnapshotCliScheduleEnabled(AsyncQuery<Boolean> aQuery, Guid clusterId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotCliScheduleFlag, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getGlusterHook(AsyncQuery aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#method_after
public void getGlusterHook(AsyncQuery<GlusterHookEntity> aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#end_block

#method_before
public void getGlusterHookContent(AsyncQuery aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? source : "";
        }
    };
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#method_after
public void getGlusterHookContent(AsyncQuery<String> aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new StringConverter();
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#end_block

#method_before
public void getGlusterSwiftServices(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServices(AsyncQuery<List<GlusterServerService>> aQuery, Guid serverId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public void getClusterGlusterSwiftService(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                List<GlusterClusterService> serviceList = (List<GlusterClusterService>) source;
                if (!serviceList.isEmpty()) {
                    return serviceList.get(0);
                }
                return null;
            } else {
                return source;
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getClusterGlusterSwiftService(AsyncQuery<GlusterClusterService> aQuery, Guid clusterId) {
    aQuery.converterCallback = new GetFirstConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public void getGlusterSwiftServerServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServerServices(AsyncQuery<List<GlusterServerService>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public void getGlusterRebalanceStatus(AsyncQuery<VdcQueryReturnValue> aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public void getGlusterSnapshotConfig(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotConfig, new GlusterVolumeQueriesParameters(clusterId, volumeId), aQuery);
}
#method_after
public void getGlusterSnapshotConfig(AsyncQuery<VdcQueryReturnValue> aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotConfig, new GlusterVolumeQueriesParameters(clusterId, volumeId), aQuery);
}
#end_block

#method_before
public void getGlusterRemoveBricksStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#method_after
public void getGlusterRemoveBricksStatus(AsyncQuery<VdcQueryReturnValue> aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#end_block

#method_before
public void getSearchResultsLimit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 100;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSearchResultsLimit(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(100);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permission>) source : new ArrayList<Permission>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getPermissionsByAdElementId(AsyncQuery<List<Permission>> aQuery, Guid userId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public void getRoleActionGroupsByRoleId(AsyncQuery aQuery, Guid roleId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ActionGroup>) source : new ArrayList<ActionGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#method_after
public void getRoleActionGroupsByRoleId(AsyncQuery<List<ActionGroup>> aQuery, Guid roleId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#end_block

#method_before
public void isTemplateNameUnique(AsyncQuery aQuery, String templateName, Guid datacenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null && !(Boolean) source;
        }
    };
    NameQueryParameters params = new NameQueryParameters(templateName);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, params, aQuery);
}
#method_after
public void isTemplateNameUnique(AsyncQuery<Boolean> aQuery, String templateName, Guid datacenterId) {
    aQuery.converterCallback = new Converter<Boolean>() {

        @Override
        public Boolean convert(Object source) {
            return source != null && !(Boolean) source;
        }
    };
    NameQueryParameters params = new NameQueryParameters(templateName);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, params, aQuery);
}
#end_block

#method_before
public void isVmNameUnique(AsyncQuery aQuery, String name, Guid datacenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null && !(Boolean) source;
        }
    };
    NameQueryParameters params = new NameQueryParameters(name);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, params, aQuery);
}
#method_after
public void isVmNameUnique(AsyncQuery<Boolean> aQuery, String name, Guid datacenterId) {
    aQuery.converterCallback = new Converter<Boolean>() {

        @Override
        public Boolean convert(Object source) {
            return source != null && !(Boolean) source;
        }
    };
    NameQueryParameters params = new NameQueryParameters(name);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, params, aQuery);
}
#end_block

#method_before
public void getDataCentersWithPermittedActionOnClusters(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#method_after
public void getDataCentersWithPermittedActionOnClusters(AsyncQuery<List<StoragePool>> aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new ListConverter<>();
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#end_block

#method_before
public void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<Cluster>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#method_after
public void getClustersWithPermittedAction(AsyncQuery<List<Cluster>> aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new Converter<List<Cluster>>() {

        @Override
        public List<Cluster> convert(Object source) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#end_block

#method_before
public void getClustersHavingHosts(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClustersHavingHosts, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClustersHavingHosts(AsyncQuery<List<Cluster>> aQuery) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClustersHavingHosts, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getAllVmTemplates(AsyncQuery aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#method_after
public void getAllVmTemplates(AsyncQuery<List<VmTemplate>> aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#end_block

#method_before
public void getStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#method_after
public void getStorageConnectionById(AsyncQuery<StorageServerConnections> aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new Converter<StorageServerConnections>() {

        @Override
        public StorageServerConnections convert(Object source) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#end_block

#method_before
public void getDataCentersByStorageDomain(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StoragePool>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getDataCentersByStorageDomain(AsyncQuery<List<StoragePool>> aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public void getDataCenterVersions(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Version>();
            } else {
                ArrayList<Version> list = (ArrayList<Version>) source;
                Collections.sort(list);
                return list;
            }
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#method_after
public void getDataCenterVersions(AsyncQuery<List<Version>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new SortListConverter<>();
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#end_block

#method_before
public void getDataCenterMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getDataCenterMaxNameLength(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getClusterServerMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterServerMemoryOverCommit(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getClusterDesktopMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterDesktopMemoryOverCommit(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getAllowClusterWithVirtGlusterEnabled(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Boolean.TRUE;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getAllowClusterWithVirtGlusterEnabled(AsyncQuery<Boolean> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(Boolean.TRUE);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getCPUList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ServerCpu>) source : new ArrayList<ServerCpu>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#method_after
public void getCPUList(AsyncQuery<List<ServerCpu>> aQuery, Version version) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#end_block

#method_before
public void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#method_after
public void getPmTypeList(AsyncQuery<List<String>> aQuery, Version version) {
    aQuery.converterCallback = new Converter<List<String>>() {

        @Override
        public List<String> convert(Object source) {
            ArrayList<String> list = new ArrayList<>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#end_block

#method_before
public void getPmOptions(AsyncQuery aQuery, final String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmType);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public void getPmOptions(AsyncQuery<List<String>> aQuery, final String pmType, String version) {
    aQuery.converterCallback = new Converter<List<String>>() {

        @Override
        public List<String> convert(Object source) {
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmType);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public void getNetworkList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getNetworkList(AsyncQuery<List<Network>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public void getISOStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getISOStorageDomainList(AsyncQuery<List<StorageDomain>> aQuery) {
    aQuery.converterCallback = new Converter<List<StorageDomain>>() {

        @Override
        public List<StorageDomain> convert(Object source) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (List<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#method_after
public void getLocalStorageHost(AsyncQuery<VDS> aQuery, String dataCenterName) {
    aQuery.converterCallback = new GetFirstConverter<>();
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#end_block

#method_before
public void getStorageDomainsByConnection(AsyncQuery aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#method_after
public void getStorageDomainsByConnection(AsyncQuery<List<StorageDomain>> aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new CastingConverter<>();
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#end_block

#method_before
public void getExistingStorageDomainList(AsyncQuery aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#method_after
public void getExistingStorageDomainList(AsyncQuery<List<StorageDomain>> aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#end_block

#method_before
public void getStorageDomainMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getStorageDomainMaxNameLength(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void isStorageDomainNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#method_after
public void isStorageDomainNameUnique(AsyncQuery<Boolean> aQuery, String name) {
    aQuery.converterCallback = new Converter<Boolean>() {

        @Override
        public Boolean convert(Object source) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#end_block

#method_before
public void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 120;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(120);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getMaxSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 0;
        }
    };
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 10);
}
#method_after
public void getMaxSpmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    aQuery.asyncCallback.onSuccess(10);
}
#end_block

#method_before
public void getDefaultSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 0;
        }
    };
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 5);
}
#method_after
public void getDefaultSpmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    aQuery.asyncCallback.onSuccess(5);
}
#end_block

#method_before
public void getDefaultPmProxyPreferences(AsyncQuery query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#method_after
public void getDefaultPmProxyPreferences(AsyncQuery<String> query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#end_block

#method_before
public void getRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getDescription(), tag.getParentId(), tag.getIsReadonly(), tag.getTagId(), tag.getTagName());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getRootTag(AsyncQuery<Tags> aQuery) {
    aQuery.converterCallback = new Converter<Tags>() {

        @Override
        public Tags convert(Object source) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getDescription(), tag.getParentId(), tag.getIsReadonly(), tag.getTagId(), tag.getTagName());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
private void setAttachedTagsConverter(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.getType() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new Tags();
        }
    };
}
#method_after
private void setAttachedTagsConverter(AsyncQuery<List<Tags>> aQuery) {
    aQuery.converterCallback = new Converter<List<Tags>>() {

        @Override
        public List<Tags> convert(Object source) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.getType() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new ArrayList<>();
        }
    };
}
#end_block

#method_before
public void getAttachedTagsToVm(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToVm(AsyncQuery<List<Tags>> aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public void getAttachedTagsToUser(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUser(AsyncQuery<List<Tags>> aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public void getAttachedTagsToUserGroup(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUserGroup(AsyncQuery<List<Tags>> aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public void getAttachedTagsToHost(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToHost(AsyncQuery<List<Tags>> aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new IdQueryParameters(id), aQuery);
}
#method_after
public void getoVirtISOsList(AsyncQuery<List<RpmVersion>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getLunsByVgId(AsyncQuery aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<LUNs>) source : new ArrayList<LUNs>();
        }
    };
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#method_after
public void getLunsByVgId(AsyncQuery<List<LUNs>> aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new ListConverter<>();
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#end_block

#method_before
public void getAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public void getAllTemplatesFromExportDomain(AsyncQuery<Map<VmTemplate, ArrayList<DiskImage>>> aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new MapConverter<>();
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName, Integer maxCount) {
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: cluster = " + clusterName + " and status = up", SearchType.VDS);
    if (maxCount != null) {
        searchParameters.setMaxCount(maxCount);
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getUpHostListByCluster(AsyncQuery<List<VDS>> aQuery, String clusterName) {
    aQuery.converterCallback = new ListConverter<>();
    getUpHostListByCluster(aQuery, clusterName, null);
}
#end_block

#method_before
public void getVmNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmNicList(AsyncQuery<List<VmNetworkInterface>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getTemplateNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplateInterfacesByTemplateId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getTemplateNicList(AsyncQuery<List<VmNetworkInterface>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplateInterfacesByTemplateId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getVmSnapshotList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Snapshot>) source : new ArrayList<Snapshot>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmSnapshotList(AsyncQuery<List<Snapshot>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getVmsRunningOnOrMigratingToVds(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmsRunningOnOrMigratingToVds(AsyncQuery<List<VM>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getVmsFromExternalServer(AsyncQuery aQuery, Guid dataCenterId, Guid vdsId, String url, String username, String password, OriginType originType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsFromExternalProvider, new GetVmsFromExternalProviderQueryParameters(url, username, password, originType, vdsId, dataCenterId), aQuery);
}
#method_after
public void getVmsFromExternalServer(AsyncQuery<List<VM>> aQuery, Guid dataCenterId, Guid vdsId, String url, String username, String password, OriginType originType) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsFromExternalProvider, new GetVmsFromExternalProviderQueryParameters(url, username, password, originType, vdsId, dataCenterId), aQuery);
}
#end_block

#method_before
public void getVmFromOva(AsyncQuery aQuery, Guid vdsId, String path) {
    aQuery.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmFromOva, new GetVmFromOvaQueryParameters(vdsId, path), aQuery);
}
#method_after
public void getVmFromOva(AsyncQuery<VdcQueryReturnValue> aQuery, Guid vdsId, String path) {
    aQuery.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmFromOva, new GetVmFromOvaQueryParameters(vdsId, path), aQuery);
}
#end_block

#method_before
public void getVmListByClusterName(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#method_after
public void getVmListByClusterName(AsyncQuery<List<VM>> aQuery, String clusterName) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#end_block

#method_before
public void getDiskList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<DiskImage>) source : new ArrayList<DiskImage>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getDiskList(AsyncQuery<List<DiskImage>> aQuery) {
    aQuery.converterCallback = new ListConverter<>();
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public void getNextAvailableDiskAliasNameByVMId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getNextAvailableDiskAliasNameByVMId(AsyncQuery<String> aQuery, Guid vmId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void isPoolNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#method_after
public void isPoolNameUnique(AsyncQuery<Boolean> aQuery, String name) {
    aQuery.converterCallback = new Converter<Boolean>() {

        @Override
        public Boolean convert(Object source) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#method_after
public void getVmConfigurationBySnapshot(AsyncQuery<VM> aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisksForVmQueryParameters params = new GetAllAttachableDisksForVmQueryParameters(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisksForVm, params, aQuery);
}
#method_after
public void getAllAttachableDisks(AsyncQuery<List<Disk>> aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new ListConverter<>();
    GetAllAttachableDisksForVmQueryParameters params = new GetAllAttachableDisksForVmQueryParameters(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisksForVm, params, aQuery);
}
#end_block

#method_before
public void getAncestorImagesByImagesIds(AsyncQuery aQuery, List<Guid> imagesIds) {
    aQuery.converterCallback = new IAsyncConverter<Map<Guid, DiskImage>>() {

        @Override
        public Map<Guid, DiskImage> convert(Object returnValue, AsyncQuery asyncQuery) {
            return (Map<Guid, DiskImage>) returnValue;
        }
    };
    IdsQueryParameters params = new IdsQueryParameters(imagesIds);
    Frontend.getInstance().runQuery(VdcQueryType.GetAncestorImagesByImagesIds, params, aQuery);
}
#method_after
public void getAncestorImagesByImagesIds(AsyncQuery<Map<Guid, DiskImage>> aQuery, List<Guid> imagesIds) {
    aQuery.converterCallback = new CastingConverter<>();
    IdsQueryParameters params = new IdsQueryParameters(imagesIds);
    Frontend.getInstance().runQuery(VdcQueryType.GetAncestorImagesByImagesIds, params, aQuery);
}
#end_block

#method_before
public void getPermittedStorageDomainsByStoragePoolId(AsyncQuery aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new java.util.ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#method_after
public void getPermittedStorageDomainsByStoragePoolId(AsyncQuery<List<StorageDomain>> aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new ListConverter<>();
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#end_block

#method_before
public void getStorageDomainDefaultWipeAfterDelete(AsyncQuery aQuery, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean convert(Object returnValue, AsyncQuery asyncQuery) {
            return (Boolean) returnValue;
        }
    };
    GetStorageDomainDefaultWipeAfterDeleteParameters params = new GetStorageDomainDefaultWipeAfterDeleteParameters(storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainDefaultWipeAfterDelete, params, aQuery);
}
#method_after
public void getStorageDomainDefaultWipeAfterDelete(AsyncQuery<Boolean> aQuery, StorageType storageType) {
    aQuery.converterCallback = new CastingConverter<>();
    GetStorageDomainDefaultWipeAfterDeleteParameters params = new GetStorageDomainDefaultWipeAfterDeleteParameters(storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainDefaultWipeAfterDelete, params, aQuery);
}
#end_block

#method_before
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListAsyncConverter();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public void getAllDataCenterNetworks(AsyncQuery<List<Network>> aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListConverter<>();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#end_block

#method_before
public void getManagementNetworkCandidates(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListAsyncConverter();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetManagementNetworkCandidates, params, aQuery);
}
#method_after
public void getManagementNetworkCandidates(AsyncQuery<List<Network>> aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListConverter<>();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetManagementNetworkCandidates, params, aQuery);
}
#end_block

#method_before
public void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#method_after
public void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery<List<StorageServerConnections>> aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new CastingConverter<>();
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#end_block

#method_before
private void cacheConfigValues(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void cacheConfigValues(AsyncQuery<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>> aQuery) {
    aQuery.converterCallback = new Converter<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>>() {

        @Override
        public Map<KeyValuePairCompat<ConfigurationValues, String>, Object> convert(Object returnValue) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<>(parameters.getConfigValue(), parameters.getVersion());
    Object returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.convert(returnValue, aQuery);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), returnValue);
}
#method_after
public <T> void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery<T> aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<>(parameters.getConfigValue(), parameters.getVersion());
    T returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = (T) cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = (T) cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.convert(returnValue);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(returnValue);
}
#end_block

#method_before
@Override
public Object convert(Object source, AsyncQuery asyncQuery) {
    List<VmTemplate> list = new ArrayList<>();
    if (source != null) {
        VmTemplate blankTemplate = null;
        for (VmTemplate template : (List<VmTemplate>) source) {
            if (template.getId().equals(Guid.Empty)) {
                blankTemplate = template;
            } else if (template.getStatus() == VmTemplateStatus.OK) {
                list.add(template);
            }
        }
        Collections.sort(list, new NameableComparator());
        if (blankTemplate != null) {
            list.add(0, blankTemplate);
        }
    }
    return list;
}
#method_after
@Override
public List<VmTemplate> convert(Object source) {
    List<VmTemplate> list = new ArrayList<>();
    if (source != null) {
        VmTemplate blankTemplate = null;
        for (VmTemplate template : (List<VmTemplate>) source) {
            if (template.getId().equals(Guid.Empty)) {
                blankTemplate = template;
            } else if (template.getStatus() == VmTemplateStatus.OK) {
                list.add(template);
            }
        }
        Collections.sort(list, new NameableComparator());
        if (blankTemplate != null) {
            list.add(0, blankTemplate);
        }
    }
    return list;
}
#end_block

#method_before
public void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDS>();
            }
            return source;
        }
    };
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new ListConverter<>();
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public void getExternalProviderDiscoveredHostList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalDiscoveredHost>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetDiscoveredHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderDiscoveredHostList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new ListConverter<>();
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetDiscoveredHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public void getExternalProviderHostGroupList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalHostGroup>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostGroupsFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostGroupList(AsyncQuery<List<ExternalHostGroup>> aQuery, Provider provider) {
    aQuery.converterCallback = new ListConverter<>();
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostGroupsFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public void getExternalProviderComputeResourceList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalComputeResource>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetComputeResourceFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderComputeResourceList(AsyncQuery<List<ExternalComputeResource>> aQuery, Provider provider) {
    aQuery.converterCallback = new ListConverter<>();
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetComputeResourceFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public void getAllProviders(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, doRefresh ? new GetAllProvidersParameters() : new GetAllProvidersParameters().withoutRefresh(), aQuery);
}
#method_after
public void getAllProviders(AsyncQuery<List<Provider<?>>> aQuery, boolean doRefresh) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, doRefresh ? new GetAllProvidersParameters() : new GetAllProvidersParameters().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new Converter<List<Provider>>() {

        @Override
        public List<Provider> convert(Object returnValue) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public void getAllNetworkProviders(AsyncQuery query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#method_after
public void getAllNetworkProviders(AsyncQuery<List<Provider<?>>> query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#end_block

#method_before
public void getAllProvidersByType(AsyncQuery aQuery, ProviderType providerType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#method_after
public void getAllProvidersByType(AsyncQuery<List<Provider<?>>> aQuery, ProviderType providerType) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#end_block

#method_before
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return Collections.<CertificateInfo>emptyList();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery<List<CertificateInfo>> aQuery, Provider provider) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
public void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public void getNicTypeList(final int osId, Version version, AsyncQuery<List<VmInterfaceType>> asyncQuery) {
    asyncQuery.converterCallback = new Converter<List<VmInterfaceType>>() {

        @Override
        public List<VmInterfaceType> convert(Object returnValue) {
            ArrayList<String> nics = (ArrayList<String>) returnValue;
            List<VmInterfaceType> interfaceTypes = new ArrayList<>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            return interfaceTypes;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public void getIsPasswordDelegationPossible(AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            chainedCallback.onSuccess(model, ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsPasswordDelegationPossible, new VdcQueryParametersBase(), asyncQuery);
}
#method_after
public void getIsPasswordDelegationPossible(AsyncQuery<Boolean> asyncQuery) {
    asyncQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.IsPasswordDelegationPossible, new VdcQueryParametersBase(), asyncQuery);
}
#end_block

#method_before
public ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#method_after
public void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery<List<DiskInterface>> asyncQuery) {
    asyncQuery.converterCallback = new Converter<List<DiskInterface>>() {

        @Override
        public List<DiskInterface> convert(Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) returnValue;
            List<DiskInterface> interfaceTypes = new ArrayList<>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            return interfaceTypes;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public void initWindowsOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowsOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), callback);
}
#method_after
public void initWindowsOsTypes() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            windowsOsIds = (ArrayList<Integer>) returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initLinuxOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            linuxOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), callback);
}
#method_after
public void initLinuxOsTypes() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            linuxOsIds = (ArrayList<Integer>) returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependencyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public void initUniqueOsNames() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            uniqueOsNames = returnValue.getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependencyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    }));
}
#end_block

#method_before
public void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public void initOsNames() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            osNames = returnValue.getReturnValue();
            initOsIds();
        }
    }));
}
#end_block

#method_before
private void initOsDefaultIconIds() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final Map<Integer, VmIconIdSizePair> returnMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (returnMap.get(DEFAULT_OS_ID) == null) {
                // $NON-NLS-1$
                throw new RuntimeException("Engine did not provide icon IDs of default OS.");
            }
            osIdToDefaultIconIdMap = Collections.unmodifiableMap(returnMap);
            initializeLargeToSmallIconMap();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmIconDefaults, new VdcQueryParametersBase(), callback);
}
#method_after
private void initOsDefaultIconIds() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmIconDefaults, new VdcQueryParametersBase(), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            final Map<Integer, VmIconIdSizePair> returnMap = returnValue.getReturnValue();
            if (returnMap.get(DEFAULT_OS_ID) == null) {
                // $NON-NLS-1$
                throw new RuntimeException("Engine did not provide icon IDs of default OS.");
            }
            osIdToDefaultIconIdMap = Collections.unmodifiableMap(returnMap);
            initializeLargeToSmallIconMap();
        }
    }));
}
#end_block

#method_before
public void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public void initOsArchitecture() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            osArchitectures = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
private void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            graphicsAndDisplays = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private void initDisplayTypes() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            graphicsAndDisplays = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId).withoutRefresh(), aQuery);
}
#method_after
public void getVmGuestAgentInterfacesByVmId(AsyncQuery<List<VmGuestAgentInterface>> aQuery, Guid vmId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getVnicProfilesByNetworkId(AsyncQuery aQuery, Guid networkId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VnicProfileView>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#method_after
public void getVnicProfilesByNetworkId(AsyncQuery<List<VnicProfileView>> aQuery, Guid networkId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#end_block

#method_before
public void getVnicProfilesByDcId(AsyncQuery aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<VnicProfileView>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#method_after
public void getVnicProfilesByDcId(AsyncQuery<List<VnicProfileView>> aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new ListConverter<>();
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#end_block

#method_before
public void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new HashMap<Network, Set<Guid>>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#method_after
public void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new MapConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#end_block

#method_before
private static void convertAAAProfilesResult(AsyncQuery aQuery, final boolean passwordBasedOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            List<String> results = new ArrayList<>();
            for (ProfileEntry profileEntry : (Collection<ProfileEntry>) source) {
                if (!passwordBasedOnly || profileEntry.getSupportsPasswordAuthenication()) {
                    results.add(profileEntry.getProfile());
                }
            }
            return results;
        }
    };
}
#method_after
private static void convertAAAProfilesResult(AsyncQuery<List<String>> aQuery, final boolean passwordBasedOnly) {
    aQuery.converterCallback = new Converter<List<String>>() {

        @Override
        public List<String> convert(Object source) {
            List<String> results = new ArrayList<>();
            for (ProfileEntry profileEntry : (Collection<ProfileEntry>) source) {
                if (!passwordBasedOnly || profileEntry.getSupportsPasswordAuthenication()) {
                    results.add(profileEntry.getProfile());
                }
            }
            return results;
        }
    };
}
#end_block

#method_before
public void getHostNumaTopologyByHostId(AsyncQuery asyncQuery, Guid hostId) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            if (source == null) {
                return new ArrayList<VdsNumaNode>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsNumaNodesByVdsId, new IdQueryParameters(hostId), asyncQuery);
}
#method_after
public void getHostNumaTopologyByHostId(AsyncQuery<List<VdsNumaNode>> asyncQuery, Guid hostId) {
    asyncQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsNumaNodesByVdsId, new IdQueryParameters(hostId), asyncQuery);
}
#end_block

#method_before
public void getVMsWithVNumaNodesByClusterId(AsyncQuery asyncQuery, Guid clusterId) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmsWithNumaByClusterId, new IdQueryParameters(clusterId), asyncQuery);
}
#method_after
public void getVMsWithVNumaNodesByClusterId(AsyncQuery<List<VM>> asyncQuery, Guid clusterId) {
    asyncQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmsWithNumaByClusterId, new IdQueryParameters(clusterId), asyncQuery);
}
#end_block

#method_before
public void getEmulatedMachinesByClusterID(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> vdsList = Linq.<VDS>cast((List<IVdcQueryable>) source);
                Set<String> emulatedMachineList = new HashSet<>();
                for (VDS host : vdsList) {
                    String hostSupportedMachines = host.getSupportedEmulatedMachines();
                    if (!StringHelper.isNullOrEmpty(hostSupportedMachines)) {
                        // $NON-NLS-1$
                        emulatedMachineList.addAll(Arrays.asList(hostSupportedMachines.split(",")));
                    }
                }
                return emulatedMachineList;
            }
            return null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getEmulatedMachinesByClusterID(AsyncQuery<Set<String>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new Converter<Set<String>>() {

        @Override
        public Set<String> convert(Object source) {
            if (source != null) {
                ArrayList<VDS> vdsList = Linq.cast((List<IVdcQueryable>) source);
                Set<String> emulatedMachineList = new HashSet<>();
                for (VDS host : vdsList) {
                    String hostSupportedMachines = host.getSupportedEmulatedMachines();
                    if (!StringHelper.isNullOrEmpty(hostSupportedMachines)) {
                        // $NON-NLS-1$
                        emulatedMachineList.addAll(Arrays.asList(hostSupportedMachines.split(",")));
                    }
                }
                return emulatedMachineList;
            }
            return null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getSupportedCpuList(AsyncQuery aQuery, String cpuName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<ServerCpu> cpuList = Linq.<ServerCpu>cast((ArrayList<ServerCpu>) source);
                return cpuList;
            }
            return null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSupportedCpuList, new GetSupportedCpuListParameters(cpuName), aQuery);
}
#method_after
public void getSupportedCpuList(AsyncQuery<List<ServerCpu>> aQuery, String cpuName) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetSupportedCpuList, new GetSupportedCpuListParameters(cpuName), aQuery);
}
#end_block

#method_before
public void getStorageDevices(AsyncQuery aQuery, Guid hostId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterStorageDevices, new IdQueryParameters(hostId), aQuery);
}
#method_after
public void getStorageDevices(AsyncQuery<List<StorageDevice>> aQuery, Guid hostId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterStorageDevices, new IdQueryParameters(hostId), aQuery);
}
#end_block

#method_before
public void getClusterEditWarnings(AsyncQuery aQuery, Guid clusterId, Cluster cluster) {
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterEditWarnings, new ClusterEditParameters(cluster), aQuery);
}
#method_after
public void getClusterEditWarnings(AsyncQuery<ClusterEditWarnings> aQuery, Guid clusterId, Cluster cluster) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterEditWarnings, new ClusterEditParameters(cluster), aQuery);
}
#end_block

#method_before
public void getUnusedBricksFromServer(AsyncQuery asyncQuery, Guid hostId) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    IdQueryParameters parameters = new IdQueryParameters(hostId);
    Frontend.getInstance().runQuery(VdcQueryType.GetUnusedGlusterBricks, parameters, asyncQuery);
}
#method_after
public void getUnusedBricksFromServer(AsyncQuery<List<StorageDevice>> asyncQuery, Guid hostId) {
    asyncQuery.converterCallback = new CastingConverter<>();
    IdQueryParameters parameters = new IdQueryParameters(hostId);
    Frontend.getInstance().runQuery(VdcQueryType.GetUnusedGlusterBricks, parameters, asyncQuery);
}
#end_block

#method_before
public void getCinderVolumeTypesList(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter<List<CinderVolumeType>>() {

        @Override
        public List<CinderVolumeType> convert(Object source, AsyncQuery _asyncQuery) {
            return (List<CinderVolumeType>) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetCinderVolumeTypesByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getCinderVolumeTypesList(AsyncQuery<List<CinderVolumeType>> aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetCinderVolumeTypesByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public void getClusterFeaturesByVersionAndCategory(AsyncQuery aQuery, Version version, ApplicationMode category) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Set<AdditionalFeature>) source : new HashSet<AdditionalFeature>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterFeaturesByVersionAndCategory, new GetClusterFeaturesByVersionAndCategoryParameters(version, category), aQuery);
}
#method_after
public void getClusterFeaturesByVersionAndCategory(AsyncQuery<Set<AdditionalFeature>> aQuery, Version version, ApplicationMode category) {
    aQuery.converterCallback = new SetConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterFeaturesByVersionAndCategory, new GetClusterFeaturesByVersionAndCategoryParameters(version, category), aQuery);
}
#end_block

#method_before
public void getClusterFeaturesByClusterId(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Set<SupportedAdditionalClusterFeature>) source : new HashSet<SupportedAdditionalClusterFeature>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterFeaturesByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getClusterFeaturesByClusterId(AsyncQuery<Set<SupportedAdditionalClusterFeature>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new SetConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterFeaturesByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
@Override
public Object convert(Object source, AsyncQuery _asyncQuery) {
    if (source != null) {
        ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
        ArrayList<String> fileNameList = new ArrayList<>();
        for (RepoImage repoImage : repoList) {
            if (desiredImage(repoImage)) {
                fileNameList.add(transform(fileNameList, repoImage));
            }
        }
        Collections.sort(fileNameList, new LexoNumericComparator());
        return fileNameList;
    }
    return new ArrayList<String>();
}
#method_after
@Override
public List<String> convert(Object source) {
    if (source != null) {
        ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
        ArrayList<String> fileNameList = new ArrayList<>();
        for (RepoImage repoImage : repoList) {
            if (desiredImage(repoImage)) {
                fileNameList.add(transform(fileNameList, repoImage));
            }
        }
        Collections.sort(fileNameList, new LexoNumericComparator());
        return fileNameList;
    }
    return new ArrayList<>();
}
#end_block

#method_before
public void getVmTemplatesByBaseTemplateId(AsyncQuery asyncQuery, Guid baseTemplate) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            if (source == null) {
                return new ArrayList<VmTemplate>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByBaseTemplateId, new GetVmTemplateParameters(baseTemplate), asyncQuery);
}
#method_after
public void getVmTemplatesByBaseTemplateId(AsyncQuery<List<VmTemplate>> asyncQuery, Guid baseTemplate) {
    asyncQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByBaseTemplateId, new GetVmTemplateParameters(baseTemplate), asyncQuery);
}
#end_block

#method_before
@Override
public List<Quota> convert(Object returnValue, AsyncQuery asyncQuery) {
    List<Quota> quotaList = (List<Quota>) returnValue;
    if (quotaList != null && !quotaList.isEmpty()) {
        Comparator<Quota> comparator = (topId == null) ? QuotaComparator.NAME : QuotaComparator.withTopId(topId, QuotaComparator.NAME);
        Collections.sort(quotaList, comparator);
    }
    return quotaList;
}
#method_after
@Override
public List<Quota> convert(Object returnValue) {
    List<Quota> quotaList = (List<Quota>) returnValue;
    if (quotaList != null && !quotaList.isEmpty()) {
        Comparator<Quota> comparator = (topId == null) ? QuotaComparator.NAME : QuotaComparator.withTopId(topId, QuotaComparator.NAME);
        Collections.sort(quotaList, comparator);
    }
    return quotaList;
}
#end_block

#method_before
public void getAllRelevantQuotasForStorageSorted(AsyncQuery asyncQuery, Guid storageId, Guid topQuotaId) {
    asyncQuery.converterCallback = new QuotaConverter(topQuotaId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForStorage, new IdQueryParameters(storageId), asyncQuery);
}
#method_after
public void getAllRelevantQuotasForStorageSorted(AsyncQuery<List<Quota>> asyncQuery, Guid storageId, Guid topQuotaId) {
    asyncQuery.converterCallback = new QuotaConverter(topQuotaId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForStorage, new IdQueryParameters(storageId), asyncQuery);
}
#end_block

#method_before
public void getAllRelevantQuotasForClusterSorted(AsyncQuery asyncQuery, Guid clusterId, Guid topQuotaId) {
    asyncQuery.converterCallback = new QuotaConverter(topQuotaId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForCluster, new IdQueryParameters(clusterId), asyncQuery);
}
#method_after
public void getAllRelevantQuotasForClusterSorted(AsyncQuery<List<Quota>> asyncQuery, Guid clusterId, Guid topQuotaId) {
    asyncQuery.converterCallback = new QuotaConverter(topQuotaId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForCluster, new IdQueryParameters(clusterId), asyncQuery);
}
#end_block

#method_before
public boolean flush() {
    if (validate()) {
        diskModel.flush();
        DiskImage diskImage = (DiskImage) getDiskModel().getDisk();
        diskImage.setVolumeFormat(getVolumeFormat().getSelectedItem());
        diskImage.setActualSizeInBytes(getImageSize());
        diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeTypeByFormatAndStorage(getVolumeFormat().getSelectedItem(), getDiskModel().getStorageDomain().getSelectedItem().getStorageType()));
        return true;
    } else {
        setIsValid(false);
    }
    return false;
}
#method_after
public boolean flush() {
    if (validate()) {
        diskModel.flush();
        DiskImage diskImage = (DiskImage) getDiskModel().getDisk();
        diskImage.setVolumeFormat(getVolumeFormat().getSelectedItem());
        diskImage.setActualSizeInBytes(getImageSize());
        diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(getVolumeFormat().getSelectedItem(), getDiskModel().getStorageDomain().getSelectedItem().getStorageType()));
        return true;
    } else {
        setIsValid(false);
    }
    return false;
}
#end_block

#method_before
public void invokeClient() {
    AsyncQuery signCallback = new AsyncQuery();
    signCallback.setModel(this);
    signCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue queryRetVal = (VdcQueryReturnValue) returnValue;
            String signedTicket = queryRetVal.getReturnValue();
            invokeClientNative(signedTicket);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.SignString, new SignStringParameters(createConnectionString(host, port, useSsl)), signCallback);
}
#method_after
public void invokeClient() {
    Frontend.getInstance().runQuery(VdcQueryType.SignString, new SignStringParameters(createConnectionString(host, port, useSsl)), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            String signedTicket = returnValue.getReturnValue();
            invokeClientNative(signedTicket);
        }
    }));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    // in the postConstruct phase.
    if (parameters.isImportAsNewEntity() && parameters.getVmId().equals(parameters.getVm().getId())) {
        parameters.getVm().setId(Guid.newGuid());
    }
    setClusterId(parameters.getClusterId());
    setVm(parameters.getVm());
    initEffectiveCompatibilityVersion();
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    setClusterId(parameters.getClusterId());
    final Guid dcId = getDcId();
    setStoragePoolId(dcId);
    final VM vm = parameters.getVm();
    if (vm != null) {
        // in the postConstruct phase.
        if (parameters.isImportAsNewEntity() && parameters.getVmId().equals(vm.getId())) {
            vm.setId(Guid.newGuid());
        }
        vm.setStoragePoolId(dcId);
        setVm(vm);
    }
    initEffectiveCompatibilityVersion();
}
#end_block

#method_before
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setCreationDate(new Date());
    getVm().getStaticData().setClusterId(getParameters().getClusterId());
    getVm().setStoragePoolId(getDcId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!VmHandler.validateDedicatedVdsExistOnSameCluster(getVm().getStaticData(), null)) {
        getVm().setDedicatedVmForVdsList(Collections.<Guid>emptyList());
    }
    if (getVm().getOriginalTemplateGuid() != null && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getOriginalTemplateGuid())) {
        // no need to check this for blank
        VmTemplate originalTemplate = getVmTemplateDao().get(getVm().getOriginalTemplateGuid());
        if (originalTemplate != null) {
            // in case the original template name has been changed in the meantime
            getVm().getStaticData().setOriginalTemplateName(originalTemplate.getName());
        }
    }
    if (getParameters().getCopyCollapse()) {
        getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    }
    getVmStaticDao().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#method_after
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setCreationDate(new Date());
    getVm().getStaticData().setClusterId(getParameters().getClusterId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!VmHandler.validateDedicatedVdsExistOnSameCluster(getVm().getStaticData(), null)) {
        getVm().setDedicatedVmForVdsList(Collections.<Guid>emptyList());
    }
    if (getVm().getOriginalTemplateGuid() != null && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getOriginalTemplateGuid())) {
        // no need to check this for blank
        VmTemplate originalTemplate = getVmTemplateDao().get(getVm().getOriginalTemplateGuid());
        if (originalTemplate != null) {
            // in case the original template name has been changed in the meantime
            getVm().getStaticData().setOriginalTemplateName(originalTemplate.getName());
        }
    }
    if (getParameters().getCopyCollapse()) {
        getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    }
    getVmStaticDao().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#end_block

#method_before
private Guid getDcId() {
    final Guid dcId = getParameters().getStoragePoolId();
    if (Guid.isNullOrEmpty(dcId)) {
        return getCluster().getStoragePoolId();
    } else {
        return dcId;
    }
}
#method_after
protected Guid getDcId() {
    final Guid dcId = getParameters().getStoragePoolId();
    if (Guid.isNullOrEmpty(dcId)) {
        return getCluster().getStoragePoolId();
    } else {
        return dcId;
    }
}
#end_block

#method_before
private void getAttachedTagsToSelectedHosts(TagListModel model) {
    ArrayList<Guid> hostIds = new ArrayList<>();
    for (VDS vds : getSelectedItems()) {
        hostIds.add(vds.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid hostId : hostIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToHost(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                HostListModel<Void> hostListModel = (HostListModel<Void>) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                hostListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                hostListModel.selectedItemsCounter++;
                if (hostListModel.selectedItemsCounter == hostListModel.getSelectedItems().size()) {
                    postGetAttachedTags(hostListModel, tagListModel);
                }
            }
        }), hostId);
    }
}
#method_after
private void getAttachedTagsToSelectedHosts(final TagListModel model) {
    ArrayList<Guid> hostIds = new ArrayList<>();
    for (VDS vds : getSelectedItems()) {
        hostIds.add(vds.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid hostId : hostIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToHost(new AsyncQuery<>(new AsyncCallback<List<Tags>>() {

            @Override
            public void onSuccess(List<Tags> returnValue) {
                allAttachedTags.addAll(returnValue);
                selectedItemsCounter++;
                if (selectedItemsCounter == getSelectedItems().size()) {
                    postGetAttachedTags(model);
                }
            }
        }), hostId);
    }
}
#end_block

#method_before
private void postGetAttachedTags(HostListModel<Void> hostListModel, TagListModel tagListModel) {
    if (hostListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(hostListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : hostListModel.allAttachedTags) {
                if (tag2.getTagId().equals(tag.getTagId())) {
                    count++;
                }
            }
            hostListModel.attachedTagsToEntities.put(tag.getTagId(), count == hostListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(hostListModel.attachedTagsToEntities);
    } else if ("OnAssignTags".equals(hostListModel.getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        hostListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(TagListModel tagListModel) {
    if (getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : allAttachedTags) {
                if (tag2.getTagId().equals(tag.getTagId())) {
                    count++;
                }
            }
            attachedTagsToEntities.put(tag.getTagId(), count == getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(attachedTagsToEntities);
    } else if ("OnAssignTags".equals(getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                hostModel.getOverrideIpTables().setIsAvailable(true);
                hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                    hostModel.getProtocol().setIsAvailable(false);
                    hostModel.getProtocol().setIsChangeable(false);
                } else {
                    hostModel.getProtocol().setIsAvailable(true);
                    hostModel.getProtocol().setIsChangeable(true);
                }
                hostModel.getProtocol().setEntity(true);
                hostModel.getProtocol().setIsChangeable(true);
            }
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangeable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        Cluster cluster = (Cluster) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangeable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
            }
            innerHostModel.onDataInitialized();
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            innerHostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(cancelCommand);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(new AsyncCallback<String>() {

        @Override
        public void onSuccess(String returnValue) {
            hostModel.setPmProxyPreferences(returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                hostModel.getOverrideIpTables().setIsAvailable(true);
                hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                    hostModel.getProtocol().setIsAvailable(false);
                    hostModel.getProtocol().setIsChangeable(false);
                } else {
                    hostModel.getProtocol().setIsAvailable(true);
                    hostModel.getProtocol().setIsChangeable(true);
                }
                hostModel.getProtocol().setEntity(true);
                hostModel.getProtocol().setIsChangeable(true);
            }
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> dataCenters) {
            HostModel innerHostModel = (HostModel) getWindow();
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (getSystemTreeSelectedItem() != null) {
                switch(getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangeable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        Cluster cluster = (Cluster) getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangeable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
            }
            innerHostModel.onDataInitialized();
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
            innerHostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
            innerHostModel.getCommands().add(cancelCommand);
        }
    }));
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = hostListModel.getSelectedItem();
            final EditHostModel hostModel = new EditHostModel();
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setSelectedCluster(host);
            hostModel.onDataInitialized();
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            hostModel.setHelpTag(HelpTag.edit_host);
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            hostListModel.setWindow(hostModel);
            if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
                hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
            } else {
                AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            hostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            hostModel.getCommands().add(cancelCommand);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangeable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> dataCenters) {
            VDS host = getSelectedItem();
            final EditHostModel hostModel = new EditHostModel();
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setSelectedCluster(host);
            hostModel.onDataInitialized();
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            hostModel.setHelpTag(HelpTag.edit_host);
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            setWindow(hostModel);
            if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
                hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
            } else {
                AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(new AsyncCallback<String>() {

                    @Override
                    public void onSuccess(String returnValue) {
                        hostModel.setPmProxyPreferences(returnValue);
                    }
                }));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
            hostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
            hostModel.getCommands().add(cancelCommand);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangeable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    }));
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<>();
    ArrayList<String> list = new ArrayList<>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getClusterId());
    }
    model.setItems(list);
    // - the cluster should have  gluster service enabled
    if (clusters.size() == 1) {
        model.startProgress();
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null && cluster.supportsGlusterService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<>();
    ArrayList<String> list = new ArrayList<>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getClusterId());
    }
    model.setItems(list);
    // - the cluster should have  gluster service enabled
    if (clusters.size() == 1) {
        model.startProgress();
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

            @Override
            public void onSuccess(Cluster cluster) {
                if (cluster != null && cluster.supportsGlusterService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null) {
                    maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService());
                }
            }
        }), clusterId);
    }
}
#method_after
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

            @Override
            public void onSuccess(Cluster cluster) {
                if (cluster != null) {
                    maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
public void approve() {
    HostModel hostModel = new EditHostModel();
    setWindow(hostModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = hostListModel.getSelectedItem();
            innerHostModel.updateModelFromVds(host, dataCenters, false, getSystemTreeSelectedItem());
            innerHostModel.setTitle(ConstantsManager.getInstance().getConstants().editAndApproveHostTitle());
            innerHostModel.setHelpTag(HelpTag.edit_and_approve_host);
            // $NON-NLS-1$
            innerHostModel.setHashName("edit_and_approve_host");
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnApprove", hostListModel);
            innerHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void approve() {
    HostModel hostModel = new EditHostModel();
    setWindow(hostModel);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> dataCenters) {
            HostModel innerHostModel = (HostModel) getWindow();
            VDS host = getSelectedItem();
            innerHostModel.updateModelFromVds(host, dataCenters, false, getSystemTreeSelectedItem());
            innerHostModel.setTitle(ConstantsManager.getInstance().getConstants().editAndApproveHostTitle());
            innerHostModel.setHelpTag(HelpTag.edit_and_approve_host);
            // $NON-NLS-1$
            innerHostModel.setHashName("edit_and_approve_host");
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnApprove", HostListModel.this);
            innerHostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
            innerHostModel.getCommands().add(tempVar2);
        }
    }));
}
#end_block

#method_before
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    param.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getActions().getSelectedItem()));
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getClusterId());
}
#method_after
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    final UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    param.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getActions().getSelectedItem()));
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

        @Override
        public void onSuccess(Cluster returnValue) {
            Frontend.getInstance().runAction(VdcActionType.InstallVds, param, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getClusterId());
}
#end_block

#method_before
private void updateAvailableOvirtNodeUpgrades() {
    final VDS host = getSelectedItem();
    if (host == null) {
        return;
    }
    if (!host.isOvirtVintageNode()) {
        return;
    }
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
        }
    }), host.getId());
}
#method_after
private void updateAvailableOvirtNodeUpgrades() {
    final VDS host = getSelectedItem();
    if (host == null) {
        return;
    }
    if (!host.isOvirtVintageNode()) {
        return;
    }
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(), host.getId());
}
#end_block

#method_before
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        DbUser dbUser = Frontend.getInstance().getLoggedInUser();
        if (dbUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(dbUser.getId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<Permission> permissions = response.getReturnValue();
                    for (Permission permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#method_after
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        DbUser dbUser = Frontend.getInstance().getLoggedInUser();
        if (dbUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(dbUser.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue response) {
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<Permission> permissions = response.getReturnValue();
                    for (Permission permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#end_block

#method_before
@Override
protected void performBootstrap() {
    super.performBootstrap();
    Window.setTitle(dynamicMessages.applicationTitle());
    // Initiate transition to requested application place
    placeManager.revealCurrentPlace();
}
#method_after
@Override
protected void performBootstrap() {
    super.performBootstrap();
    Window.setTitle(dynamicMessages.applicationTitle());
}
#end_block

#method_before
@Override
protected void beforeLogin(UserPortalLoginModel loginModel) {
    UserPortalModelInitEvent.fire(eventBus);
}
#method_after
@Override
protected void beforeLogin() {
    UserPortalModelInitEvent.fire(eventBus);
}
#end_block

#method_before
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            // Redirect to SSO Logout after the user has logged out successfully on backend.
            // $NON-NLS-1$
            Window.Location.assign(GWT.getModuleBaseURL() + "sso/logout");
        }
    };
    frontend.logoffAsync(query);
}
#method_after
@Override
public void onLogout() {
    AsyncQuery<VdcReturnValueBase> query = new AsyncQuery<>(new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(VdcReturnValueBase returnValue) {
            // Redirect to SSO Logout after the user has logged out successfully on backend.
            // $NON-NLS-1$
            Window.Location.assign(GWT.getModuleBaseURL() + "sso/logout");
        }
    });
    query.setHandleFailure(true);
    frontend.logoffAsync(query);
}
#end_block

#method_before
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = loginModel.getPassword().getEntity();
    beforeLogin(loginModel);
    // UiCommon login preparation
    frontend.initLoggedInUser(loggedUser, loginPassword);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#method_after
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    beforeLogin();
    // UiCommon login preparation
    frontend.initLoggedInUser(loggedUser);
    // UI login actions
    user.login(loggedUser);
    afterLogin();
    // Perform initial GWTP place transition
    performPlaceTransition();
}
#end_block

#method_before
@Override
protected void performBootstrap() {
    super.performBootstrap();
    Window.setTitle(dynamicMessages.applicationTitle());
    // Check for ApplicationMode configuration
    ApplicationMode uiMode = UiModeData.getUiMode();
    if (uiMode != null) {
        ApplicationModeHelper.setUiMode(uiMode);
    }
    // Initiate transition to requested application place
    placeManager.revealCurrentPlace();
}
#method_after
@Override
protected void performBootstrap() {
    super.performBootstrap();
    Window.setTitle(dynamicMessages.applicationTitle());
    // Check for ApplicationMode configuration
    ApplicationMode uiMode = UiModeData.getUiMode();
    if (uiMode != null) {
        ApplicationModeHelper.setUiMode(uiMode);
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    log.info("-- executeVdsBrokerCommand: calling 'copyVolumeData'");
    status = getBroker().copyData(getParameters().getJobId().toString(), buildLocationInfo(getParameters().getSrcInfo()), buildLocationInfo(getParameters().getDstInfo()));
    proceedProxyReturnValue();
// Map<String, Object> map = new HashMap<>();
// map.put("code", EngineError.Done.getValue());
// map.put("message", "done");
// status = new StatusOnlyReturnForXmlRpc(Collections.<String, Object>singletonMap("status", map));
// proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    log.info("-- executeVdsBrokerCommand: calling 'copyVolumeData'");
    status = getBroker().copyData(getParameters().getJobId().toString(), buildLocationInfo(getParameters().getSrcInfo()), buildLocationInfo(getParameters().getDstInfo()));
    proceedProxyReturnValue();
}
#end_block

#method_before
@Override
protected void init() {
    updateMigrateOnError();
}
#method_after
@Override
protected void init() {
    updateMigrateOnError();
    oldGroup = getClusterDao().get(getCluster().getId());
}
#end_block

#method_before
private boolean updateVms() {
    List<VM> vmList = getVmDao().getAllForCluster(getParameters().getCluster().getId());
    Cluster oldCluster = getClusterDao().get(getCluster().getId());
    for (VM vm : vmList) {
        if (!vm.isExternalVm() && !vm.isHostedEngine()) {
            VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
            if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
                updateParams.setClusterLevelChangeToVersion(getParameters().getCluster().getCompatibilityVersion());
            }
            VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
            if (!result.getSucceeded()) {
                getReturnValue().setFault(result.getFault());
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean updateVms() {
    for (VM vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeToVersion(getParameters().getCluster().getCompatibilityVersion());
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getClusterDao().get(getCluster().getId());
    if (oldGroup == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldGroup, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldGroup.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldGroup);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldGroup == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldGroup, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldGroup.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldGroup);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#end_block

#method_before
public void init(Map<String, String> paramMap) {
    constantDelay = Utils.getLong(paramMap.get("constantDelay"));
    randomDelay = Utils.getLong(paramMap.get("randomDelay"));
    networkLoad = Utils.splitString(paramMap.get("networkLoad"));
    cpuLoadList = Utils.splitString(paramMap.get("cpuLoad"));
    memLoad = Utils.splitString(paramMap.get("memLoad"));
    storageDelay = Utils.splitString(paramMap.get("storageDelay"));
    networkBridgeName = paramMap.get("networkBridgeName");
    cacheDir = paramMap.get("cacheDir");
    // Each run will store its logs sepa    rately
    logDir = paramMap.get("logDir") + "/" + System.currentTimeMillis();
    forwardVdsmServer = paramMap.get("forwardVdsmServer");
    vdsmPort = paramMap.get("vdsmPort");
    vmConfAndStatsConstants = paramMap.get("vmConfAndStatsConstants");
    vmConfAndStatsUpdateIntervals = paramMap.get("vmConfAndStatsUpdateIntervals");
    jsonHandlersThreadsPool = Integer.valueOf(paramMap.get("jsonHandlersThreadsPool"));
    architectureType = paramMap.get("architectureType");
    final String notLoggedMethods = paramMap.get("notLoggedMethods");
    if (notLoggedMethods != null && notLoggedMethods.trim().length() > 0) {
        final String[] methodNames = notLoggedMethods.split(",");
        for (String methodName : methodNames) {
            notLoggedMethodSet.add(methodName.trim());
        }
    }
    makeDir(cacheDir);
    makeDir(logDir);
    if (isProxyActive()) {
        targetServerUrl = getForwardVdsmServer() + ":" + getVdsmPort() + "/";
    }
}
#method_after
public void init(Map<String, String> paramMap) {
    constantDelay = Utils.getLong(paramMap.get("constantDelay"));
    randomDelay = Utils.getLong(paramMap.get("randomDelay"));
    networkLoad = Utils.splitString(paramMap.get("networkLoad"));
    cpuLoadList = Utils.splitString(paramMap.get("cpuLoad"));
    memLoad = Utils.splitString(paramMap.get("memLoad"));
    storageDelay = Utils.splitString(paramMap.get("storageDelay"));
    networkBridgeName = paramMap.get("networkBridgeName");
    cacheDir = paramMap.get("cacheDir");
    // Each run will store its logs separately
    logDir = paramMap.get("logDir") + "/" + System.currentTimeMillis();
    forwardVdsmServer = paramMap.get("forwardVdsmServer");
    vdsmPort = paramMap.get("vdsmPort");
    vmConfAndStatsConstants = paramMap.get("vmConfAndStatsConstants");
    vmConfAndStatsUpdateIntervals = paramMap.get("vmConfAndStatsUpdateIntervals");
    jsonHandlersThreadsPool = Integer.valueOf(paramMap.get("jsonHandlersThreadsPool"));
    architectureType = ArchitectureType.valueOf(paramMap.get("architectureType").toUpperCase());
    final String notLoggedMethods = paramMap.get("notLoggedMethods");
    if (notLoggedMethods != null && notLoggedMethods.trim().length() > 0) {
        final String[] methodNames = notLoggedMethods.split(",");
        for (String methodName : methodNames) {
            notLoggedMethodSet.add(methodName.trim());
        }
    }
    makeDir(cacheDir);
    makeDir(logDir);
    if (isProxyActive()) {
        targetServerUrl = getForwardVdsmServer() + ":" + getVdsmPort() + "/";
    }
}
#end_block

#method_before
public String getArchitectureType() {
    return architectureType;
}
#method_after
public ArchitectureType getArchitectureType() {
    return architectureType;
}
#end_block

#method_before
public Map getVdsCapabilities() {
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("HBAInventory", getHBAInventoryMap());
        infoMap.put("packages2", getPackages2Map());
        populateCpuModelAndFlags(infoMap);
        infoMap.put("hooks", map());
        infoMap.put("cpuSockets", "1");
        infoMap.put("vmTypes", getVmTypesList());
        infoMap.put("supportedProtocols", getSupportedProtocolsList());
        infoMap.put("networks", getNetworksMap(host));
        infoMap.put("bridges", getBridgesMap(host));
        // 018CE76D-8EFE-D511-B30D-80C16E727330_80:c1:6e:6c:51:54
        infoMap.put("uuid", host.getUuid() + "_80:" + host.getMacAddress());
        infoMap.put("lastClientIface", AppConfig.getInstance().getNetworkBridgeName());
        infoMap.put("nics", getNicsMap(host));
        infoMap.put("software_revision", "0.141");
        infoMap.put("clusterLevels", getClusterLevelsList());
        infoMap.put("ISCSIInitiatorName", "iqn.1994-05.com.example:ef52ec17bb0");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("supportedENGINEs", getSupportedENGINEsList());
        infoMap.put("reservedMem", "321");
        infoMap.put("bondings", getBondingsMap());
        infoMap.put("software_version", "4.10");
        infoMap.put("memSize", "7976");
        infoMap.put("cpuSpeed", "1200.000");
        infoMap.put("version_name", "Snow Man");
        infoMap.put("vlans", map());
        infoMap.put("cpuCores", "4");
        infoMap.put("kvmEnabled", "true");
        infoMap.put("guestOverhead", "65");
        // null
        infoMap.put("management_ip", "");
        infoMap.put("cpuThreads", "4");
        infoMap.put("emulatedMachines", getEmulatedMachinesList());
        infoMap.put("operatingSystem", getOperatingSystemMap());
        infoMap.put("lastClient", "10.36.6.76");
        infoMap.put("rngSources", Arrays.asList(new String[] { "RANDOM" }));
        infoMap.put("selinux", getSELinux());
        infoMap.put("kdumpStatus", "1");
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map getVdsCapabilities() {
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("HBAInventory", getHBAInventoryMap());
        infoMap.put("packages2", getPackages2Map());
        AppConfig.ArchitectureType architecture = AppConfig.getInstance().getArchitectureType();
        infoMap.put("cpuModel", architecture.getCpuModel());
        infoMap.put("cpuFlags", architecture.getCpuFlags());
        infoMap.put("hooks", map());
        infoMap.put("cpuSockets", "1");
        infoMap.put("vmTypes", getVmTypesList());
        infoMap.put("supportedProtocols", getSupportedProtocolsList());
        infoMap.put("networks", getNetworksMap(host));
        infoMap.put("bridges", getBridgesMap(host));
        // 018CE76D-8EFE-D511-B30D-80C16E727330_80:c1:6e:6c:51:54
        infoMap.put("uuid", host.getUuid() + "_80:" + host.getMacAddress());
        infoMap.put("lastClientIface", AppConfig.getInstance().getNetworkBridgeName());
        infoMap.put("nics", getNicsMap(host));
        infoMap.put("software_revision", "0.141");
        infoMap.put("clusterLevels", getClusterLevelsList());
        infoMap.put("ISCSIInitiatorName", "iqn.1994-05.com.example:ef52ec17bb0");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("supportedENGINEs", getSupportedENGINEsList());
        infoMap.put("reservedMem", "321");
        infoMap.put("bondings", getBondingsMap());
        infoMap.put("software_version", "4.10");
        infoMap.put("memSize", "7976");
        infoMap.put("cpuSpeed", "1200.000");
        infoMap.put("version_name", "Snow Man");
        infoMap.put("vlans", map());
        infoMap.put("cpuCores", "4");
        infoMap.put("kvmEnabled", "true");
        infoMap.put("guestOverhead", "65");
        // null
        infoMap.put("management_ip", "");
        infoMap.put("cpuThreads", "4");
        infoMap.put("emulatedMachines", getEmulatedMachinesList());
        infoMap.put("operatingSystem", getOperatingSystemMap());
        infoMap.put("lastClient", "10.36.6.76");
        infoMap.put("rngSources", Arrays.asList(new String[] { "RANDOM" }));
        infoMap.put("selinux", getSELinux());
        infoMap.put("kdumpStatus", "1");
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
public List getClusterLevelsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    return resultList;
}
#method_after
public List getClusterLevelsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    resultList.add("4.1");
    return resultList;
}
#end_block

#method_before
public List getSupportedENGINEsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    return resultList;
}
#method_after
public List getSupportedENGINEsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    resultList.add("4.1");
    return resultList;
}
#end_block

#method_before
public void getUserProfile(AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetUserProfile, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getUserProfile(AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetUserProfile, new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public void getPmOptions(AsyncQuery aQuery, final String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmType);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
protected List<? extends Comparator<StorageDomain>> getStorageDomainComparators(Collection<DiskImage> vmDisks) {
    return Arrays.asList(new StorageDomainNumberOfVmDisksComparator(vmDisks), new StorageTypeLocalLastComparator(), new StorageTypeBlockLastComparator(), new StorageDomainAvailableDiskSizeComparator());
}
#method_after
protected List<? extends Comparator<StorageDomain>> getStorageDomainComparators(Collection<DiskImage> vmDisks) {
    return Arrays.asList(new StorageDomainNumberOfVmDisksComparator(vmDisks), new StorageTypeSharedFirstComparator(), new StorageTypeFileFirstComparator(), new StorageDomainAvailableDiskSizeComparator());
}
#end_block

#method_before
protected List<? extends Comparator<StorageDomain>> getStorageDomainComparators(Collection<DiskImage> vmDisks) {
    return Arrays.asList(new StorageDomainNumberOfVmDisksComparator(vmDisks), LOCAL_LAST_COMPARATOR, BLOCK_LAST_COMPARATOR, AVAILABLE_SIZE_COMPARATOR);
}
#method_after
protected List<? extends Comparator<StorageDomain>> getStorageDomainComparators(Collection<DiskImage> vmDisks) {
    return Arrays.asList(new StorageDomainNumberOfVmDisksComparator(vmDisks), SHARED_FIRST_COMPARATOR, FILE_FIRST_COMPARATOR, AVAILABLE_SIZE_COMPARATOR);
}
#end_block

#method_before
protected void sortStorageDomains(List<StorageDomain> domainsInPool, Collection<DiskImage> vmDisks) {
    Comparator<StorageDomain> comp = null;
    // When there is more than one comparator, a nested sort is performed.
    for (Comparator<StorageDomain> comparator : getStorageDomainComparators(vmDisks)) {
        // A reversed sort will be performed to get the "biggest" storage domain first.
        comp = (comp == null) ? comparator : comp.thenComparing(comparator);
    }
    Collections.sort(domainsInPool, comp);
}
#method_after
protected void sortStorageDomains(List<StorageDomain> domainsInPool, Collection<DiskImage> vmDisks) {
    Comparator<StorageDomain> comp = null;
    // When there is more than one comparator, a nested sort is performed.
    for (Comparator<StorageDomain> comparator : getStorageDomainComparators(vmDisks)) {
        comp = (comp == null) ? comparator : comp.thenComparing(comparator);
    }
    Collections.sort(domainsInPool, comp);
}
#end_block

#method_before
protected List<Comparator<StorageDomain>> getStorageDomainComparators(Collection<DiskImage> vmDisks) {
    return Arrays.asList(new StorageDomainNumberOfVmDisksComparator(vmDisks), LOCAL_LAST_COMPARATOR, BLOCK_LAST_COMPARATOR, AVAILABLE_SIZE_COMPARATOR);
}
#method_after
protected List<Comparator<StorageDomain>> getStorageDomainComparators(Collection<DiskImage> vmDisks) {
    return Arrays.asList(new StorageDomainNumberOfVmDisksComparator(vmDisks), SHARED_FIRST_COMPARATOR, FILE_FIRST_COMPARATOR, AVAILABLE_SIZE_COMPARATOR);
}
#end_block

#method_before
protected List<Comparator<StorageDomain>> getStorageDomainComparators(Collection<DiskImage> vmDisks) {
    return Arrays.asList(new StorageDomainNumberOfVmDisksComparator(vmDisks), LOCAL_LAST_COMPARATOR, BLOCK_LAST_COMPARATOR, AVAILABLE_SIZE_COMPARATOR);
}
#method_after
protected List<Comparator<StorageDomain>> getStorageDomainComparators(Collection<DiskImage> vmDisks) {
    return Arrays.asList(new StorageDomainNumberOfVmDisksComparator(vmDisks), SHARED_FIRST_COMPARATOR, FILE_FIRST_COMPARATOR, AVAILABLE_SIZE_COMPARATOR);
}
#end_block

#method_before
public void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public void getPmOptions(AsyncQuery aQuery, final String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmType);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid qosId = getQosId();
    HostNetworkQos oldQos = getQosDao().get(qosId);
    HostNetworkQos newQos = getQos();
    super.executeCommand();
    if (networkUpdateRequired(oldQos, newQos)) {
        new RefreshNetworksHavingGivenQos(networkDao, vdsDao, networkAttachmentDao).refreshNetworks(getQosId());
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid qosId = getQosId();
    HostNetworkQos oldQos = getQosDao().get(qosId);
    HostNetworkQos newQos = getQos();
    super.executeCommand();
    if (networkUpdateRequired(oldQos, newQos)) {
        refreshNetworks(refreshNetworksParametersFactory.create(qosId));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<Network> networksHavingQosToBeRemoved = networkDao.getAllForQos(getQosId());
    // remove qos.
    super.executeCommand();
    new RefreshNetworksHavingGivenQos(networkDao, vdsDao, networkAttachmentDao).refreshNetworks(networksHavingQosToBeRemoved);
}
#method_after
@Override
protected void executeCommand() {
    List<Network> networksHavingQos = networkDao.getAllForQos(getQosId());
    // remove qos.
    super.executeCommand();
    refreshNetworks(refreshNetworksParametersFactory.create(networksHavingQos));
}
#end_block

#method_before
@Override
protected void postInitStorageDomains() {
    ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
    if (disks == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = ExistingPoolModelBehavior.this;
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisks();
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            DisksAllocationModel disksAllocationModel = behavior.getModel().getDisksAllocationModel();
            disksAllocationModel.setActiveStorageDomains(activeStorageDomains);
            behavior.getModel().getStorageDomain().setItems(activeStorageDomains);
            for (DiskModel diskModel : disks) {
                // Setting Quota
                diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                diskModel.getQuota().setIsChangeable(false);
                ArrayList<Guid> storageIds = null;
                for (DiskImage disk : pool.getDiskList()) {
                    if (diskModel.getDisk() instanceof DiskImage && ((DiskImage) diskModel.getDisk()).getImageId().equals(disk.getParentId())) {
                        storageIds = new ArrayList<>(disk.getStorageIds());
                        break;
                    }
                }
                // We only have one storage ID, as the object is a VM, not a template
                if (storageIds == null || storageIds.size() == 0) {
                    continue;
                }
                Guid storageId = storageIds.get(0);
                StorageDomain storageDomain = Linq.getStorageById(storageId, activeStorageDomains);
                List<StorageDomain> diskStorageDomains = new ArrayList<>();
                diskStorageDomains.add(storageDomain);
                diskModel.getStorageDomain().setItems(diskStorageDomains);
                diskModel.getStorageDomain().setIsChangeable(false);
            }
        }
    }), dataCenter.getId(), actionGroup);
}
#method_after
@Override
protected void postInitStorageDomains() {
    ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
    if (disks == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = ExistingPoolModelBehavior.this;
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisks();
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            DisksAllocationModel disksAllocationModel = behavior.getModel().getDisksAllocationModel();
            disksAllocationModel.setActiveStorageDomains(activeStorageDomains);
            behavior.getModel().getStorageDomain().setItems(activeStorageDomains);
            for (DiskModel diskModel : disks) {
                // Setting Quota
                diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                diskModel.getQuota().setIsChangeable(false);
                ArrayList<Guid> storageIds = null;
                for (DiskImage disk : pool.getDiskList()) {
                    if (diskModel.getDisk() instanceof DiskImage && ((DiskImage) diskModel.getDisk()).getImageId().equals(disk.getParentId())) {
                        storageIds = new ArrayList<>(disk.getStorageIds());
                        break;
                    }
                }
                if (storageIds == null || storageIds.size() == 0) {
                    continue;
                }
                Guid storageId = storageIds.get(0);
                StorageDomain storageDomain = Linq.getStorageById(storageId, activeStorageDomains);
                List<StorageDomain> diskStorageDomains = new ArrayList<>();
                diskStorageDomains.add(storageDomain);
                diskModel.getStorageDomain().setItems(diskStorageDomains);
                diskModel.getStorageDomain().setIsChangeable(false);
            }
        }
    }), dataCenter.getId(), actionGroup);
}
#end_block

#method_before
public int getNumOfCpus() {
    return this.getCpuPerSocket() * this.getNumOfSockets() * this.getThreadsPerCpu();
}
#method_after
public int getNumOfCpus(boolean countThreadsAsCPU) {
    return this.getCpuPerSocket() * this.getNumOfSockets() * (countThreadsAsCPU ? this.getThreadsPerCpu() : 1);
}
#end_block

#method_before
public int getNumOfCpus() {
    return this.getCpuPerSocket() * this.getNumOfSockets() * this.getThreadsPerCpu();
}
#method_after
public int getNumOfCpus() {
    return getNumOfCpus(true);
}
#end_block

#method_before
public void refreshVmsStorageQos(Map<Guid, List<DiskImage>> vmDiskMap, StorageQos newQos) {
    // No QoS means default QoS which means unlimited
    if (newQos == null) {
        newQos = new StorageQos();
    }
    for (Map.Entry<Guid, List<DiskImage>> entry : vmDiskMap.entrySet()) {
        VmSlaPolicyParameters cmdParams = new VmSlaPolicyParameters(entry.getKey());
        for (DiskImage img : entry.getValue()) {
            cmdParams.getStorageQos().put(img, newQos);
        }
        ThreadPoolUtil.execute(() -> backend.runInternalAction(VdcActionType.VmSlaPolicy, cmdParams));
    }
}
#method_after
public void refreshVmsStorageQos(Map<Guid, List<DiskImage>> vmDiskMap, StorageQos newQos) {
    for (Map.Entry<Guid, List<DiskImage>> entry : vmDiskMap.entrySet()) {
        VmSlaPolicyParameters cmdParams = new VmSlaPolicyParameters(entry.getKey());
        for (DiskImage img : entry.getValue()) {
            cmdParams.getStorageQos().put(img, newQos);
        }
        ThreadPoolUtil.execute(() -> backend.runInternalAction(VdcActionType.VmSlaPolicy, cmdParams));
    }
}
#end_block

#method_before
public void refreshRunningVmsWithDiskProfile(Guid diskProfileId) {
    refreshVmsStorageQos(getRunningVmDiskImageMapWithProfiles(Collections.singleton(diskProfileId)), storageQosDao.getQosByDiskProfileId(diskProfileId));
}
#method_after
public void refreshRunningVmsWithDiskProfile(Guid diskProfileId, StorageQos newQos) {
    refreshVmsStorageQos(getRunningVmDiskImageMapWithProfiles(Collections.singleton(diskProfileId)), newQos);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private void liveUpdateCpuProfile() {
    if (getVm().getStatus().isQualifiedForQosChange() && oldVm.getCpuProfileId().equals(newVmStatic.getCpuProfileId())) {
        vmSlaPolicyUtils.refreshCpuQosOfRunningVm(getVm());
    }
}
#method_after
private void liveUpdateCpuProfile() {
    if (getVm().getStatus().isQualifiedForQosChange() && !oldVm.getCpuProfileId().equals(newVmStatic.getCpuProfileId())) {
        vmSlaPolicyUtils.refreshCpuQosOfRunningVm(getVm());
    }
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), getVmDeviceUtils().getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<DiskVmElement> diskVmElements = getDbFacade().getDiskVmElementDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, diskVmElements, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<DiskVmElement> diskVmElements = getDbFacade().getDiskVmElementDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return validate(VmValidator.checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, diskVmElements, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled()));
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters()) || isClusterLevelChange();
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    // When updating, please also update UpdateClusterCommand#getExclusiveLocks
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
    }
    return null;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    // When updating, please also update UpdateClusterCommand#getSharedLocks
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
}
#end_block

#method_before
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#method_after
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.hasMemoryBalloon(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : getVmDeviceUtils().hasMemoryBalloon(getVmId());
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.hasSoundDevice(getVmId());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : getVmDeviceUtils().hasSoundDevice(getVmId());
}
#end_block

#method_before
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    Cluster cluster = model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getClusterId() != null && !host.getClusterId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) dataCenterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()), null, this);
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                dataCenterGuideModel.getWindow().stopProgress();
                dataCenterGuideModel.cancel();
                dataCenterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString((MoveHost) dataCenterGuideModel.getWindow());
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(dataCenterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#method_after
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    Cluster cluster = model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getClusterId() != null && !host.getClusterId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) dataCenterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()), null, this);
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                dataCenterGuideModel.getWindow().stopProgress();
                dataCenterGuideModel.cancel();
                dataCenterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString((MoveHost) dataCenterGuideModel.getWindow());
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#end_block

#method_before
public void addHost() {
    final HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host_guide_me);
    // $NON-NLS-1$
    model.setHashName("new_host_guide_me");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getDataCenter().setItems(Collections.singletonList(getEntity()), getEntity());
    model.getDataCenter().setIsChangeable(false);
    model.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = model.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (clusterModel.getSelectedItem() != null) {
                    if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                        model.getProtocol().setIsAvailable(false);
                    } else {
                        model.getProtocol().setIsAvailable(true);
                    }
                }
                model.getProtocol().setEntity(true);
            }
        }
    });
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void addHost() {
    final HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host_guide_me);
    // $NON-NLS-1$
    model.setHashName("new_host_guide_me");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getDataCenter().setItems(Collections.singletonList(getEntity()), getEntity());
    model.getDataCenter().setIsChangeable(false);
    model.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = model.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (clusterModel.getSelectedItem() != null) {
                    if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                        model.getProtocol().setIsAvailable(false);
                    } else {
                        model.getProtocol().setIsAvailable(true);
                    }
                }
                model.getProtocol().setEntity(true);
            }
        }
    });
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
protected void checkVdsClusterChangeSucceeded(final GuideModel guideModel, final String searchStr, final List<VdcActionParametersBase> changeVdsParameterList, final List<VdcActionParametersBase> activateVdsParameterList) {
    final Map<Guid, Guid> hostClusterIdMap = new HashMap<>();
    for (VdcActionParametersBase param : changeVdsParameterList) {
        hostClusterIdMap.put(((ChangeVDSClusterParameters) param).getVdsId(), ((ChangeVDSClusterParameters) param).getClusterId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(searchStr, SearchType.VDS), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean succeeded = true;
            for (VDS host : hosts) {
                if (!host.getClusterId().equals(hostClusterIdMap.get(host.getId()))) {
                    succeeded = false;
                }
            }
            if (!succeeded) {
                guideModel.getWindow().stopProgress();
                guideModel.cancel();
                errorPopupManager.show(ConstantsManager.getInstance().getConstants().hostChangeClusterTimeOut());
            } else {
                activateHostsAfterClusterChange(guideModel, searchStr, activateVdsParameterList);
            }
        }
    }));
}
#method_after
protected void checkVdsClusterChangeSucceeded(final String searchStr, final List<VdcActionParametersBase> changeVdsParameterList, final List<VdcActionParametersBase> activateVdsParameterList) {
    final Map<Guid, Guid> hostClusterIdMap = new HashMap<>();
    for (VdcActionParametersBase param : changeVdsParameterList) {
        hostClusterIdMap.put(((ChangeVDSClusterParameters) param).getVdsId(), ((ChangeVDSClusterParameters) param).getClusterId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(searchStr, SearchType.VDS), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean succeeded = true;
            for (VDS host : hosts) {
                if (!host.getClusterId().equals(hostClusterIdMap.get(host.getId()))) {
                    succeeded = false;
                }
            }
            if (!succeeded) {
                getWindow().stopProgress();
                cancel();
                errorPopupManager.show(ConstantsManager.getInstance().getConstants().hostChangeClusterTimeOut());
            } else {
                activateHostsAfterClusterChange(searchStr, activateVdsParameterList);
            }
        }
    }));
}
#end_block

#method_before
protected void activateHostsAfterClusterChange(final GuideModel guideModel, final String searchStr, final List<VdcActionParametersBase> activateVdsParameterList) {
    Frontend.getInstance().runMultipleAction(VdcActionType.ActivateVds, activateVdsParameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            Timer timer = new Timer() {

                public void run() {
                    checkVdsActivateSucceeded(guideModel, searchStr);
                }
            };
            // Execute the timer to expire 5 seconds in the future
            timer.schedule(5000);
        }
    }, this);
}
#method_after
protected void activateHostsAfterClusterChange(final String searchStr, final List<VdcActionParametersBase> activateVdsParameterList) {
    Frontend.getInstance().runMultipleAction(VdcActionType.ActivateVds, activateVdsParameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            Timer timer = new Timer() {

                public void run() {
                    checkVdsActivateSucceeded(searchStr);
                }
            };
            // Execute the timer to expire 5 seconds in the future
            timer.schedule(5000);
        }
    }, this);
}
#end_block

#method_before
protected void checkVdsActivateSucceeded(final GuideModel guideModel, final String searchStr) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(searchStr, SearchType.VDS), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean succeeded = true;
            for (VDS host : hosts) {
                if (host.getStatus() != VDSStatus.Up) {
                    succeeded = false;
                }
            }
            guideModel.getWindow().stopProgress();
            guideModel.cancel();
            if (succeeded) {
                guideModel.postAction();
            } else {
                errorPopupManager.show(ConstantsManager.getInstance().getConstants().hostActivationTimeOut());
            }
        }
    }));
}
#method_after
protected void checkVdsActivateSucceeded(final String searchStr) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(searchStr, SearchType.VDS), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean succeeded = true;
            for (VDS host : hosts) {
                if (host.getStatus() != VDSStatus.Up) {
                    succeeded = false;
                }
            }
            getWindow().stopProgress();
            cancel();
            if (succeeded) {
                postAction();
            } else {
                errorPopupManager.show(ConstantsManager.getInstance().getConstants().hostActivationTimeOut());
            }
        }
    }));
}
#end_block

#method_before
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    Cluster cluster = model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getClusterId() != null && !host.getClusterId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final ClusterGuideModel clusterGuideModel = (ClusterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) clusterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()));
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                clusterGuideModel.getWindow().stopProgress();
                clusterGuideModel.cancel();
                clusterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString((MoveHost) clusterGuideModel.getWindow());
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(clusterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#method_after
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    Cluster cluster = model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getClusterId() != null && !host.getClusterId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            List<MoveHostData> hosts = ((MoveHost) getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()));
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                getWindow().stopProgress();
                cancel();
                postAction();
            } else {
                final String searchString = getVdsSearchString((MoveHost) getWindow());
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#end_block

#method_before
@Override
public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(GuideModel source, UICommand lastExecutedCommand, Model windowModel) {
    String lastExecutedCommandName = lastExecutedCommand.getName();
    if (lastExecutedCommandName.equals("AddCluster")) {
        // $NON-NLS-1$
        return clusterPopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddHost")) {
        // $NON-NLS-1$
        return hostPopupProvider.get();
    } else if (lastExecutedCommandName.equals("SelectHost")) {
        // $NON-NLS-1$
        return moveHostPopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddDataStorage")) {
        // $NON-NLS-1$
        return storagePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddIsoStorage")) {
        // $NON-NLS-1$
        return storagePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddLocalStorage")) {
        // $NON-NLS-1$
        return storagePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AttachDataStorage")) {
        // $NON-NLS-1$
        return multiStoragePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AttachIsoStorage")) {
        // $NON-NLS-1$
        return singleStoragePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddNetwork")) {
        // $NON-NLS-1$
        return vmInterfacePopupProvider.get();
    } else if (lastExecutedCommandName.equals("NewDisk")) {
        // $NON-NLS-1$
        return vmDiskPopupPopupProvider.get();
    } else if (lastExecutedCommandName.equals("AttachDisk")) {
        // $NON-NLS-1$
        return vmDiskAttachPopupPopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddDataCenter")) {
        // $NON-NLS-1$
        return addDatacenterClusterPopupProvider.get();
    } else {
        return super.getModelPopup(source, lastExecutedCommand, windowModel);
    }
}
#method_after
@Override
public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(GuideModel<?> source, UICommand lastExecutedCommand, Model windowModel) {
    String lastExecutedCommandName = lastExecutedCommand.getName();
    if (lastExecutedCommandName.equals("AddCluster")) {
        // $NON-NLS-1$
        return clusterPopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddHost")) {
        // $NON-NLS-1$
        return hostPopupProvider.get();
    } else if (lastExecutedCommandName.equals("SelectHost")) {
        // $NON-NLS-1$
        return moveHostPopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddDataStorage")) {
        // $NON-NLS-1$
        return storagePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddIsoStorage")) {
        // $NON-NLS-1$
        return storagePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddLocalStorage")) {
        // $NON-NLS-1$
        return storagePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AttachDataStorage")) {
        // $NON-NLS-1$
        return multiStoragePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AttachIsoStorage")) {
        // $NON-NLS-1$
        return singleStoragePopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddNetwork")) {
        // $NON-NLS-1$
        return vmInterfacePopupProvider.get();
    } else if (lastExecutedCommandName.equals("NewDisk")) {
        // $NON-NLS-1$
        return vmDiskPopupPopupProvider.get();
    } else if (lastExecutedCommandName.equals("AttachDisk")) {
        // $NON-NLS-1$
        return vmDiskAttachPopupPopupProvider.get();
    } else if (lastExecutedCommandName.equals("AddDataCenter")) {
        // $NON-NLS-1$
        return addDatacenterClusterPopupProvider.get();
    } else {
        return super.getModelPopup(source, lastExecutedCommand, windowModel);
    }
}
#end_block

#method_before
@Override
public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(GuideModel source, UICommand lastExecutedCommand) {
    if (lastExecutedCommand.getName().equals("OnAddStorage")) {
        // $NON-NLS-1$
        return forceCreateConfirmPopupProvider.get();
    } else {
        return super.getConfirmModelPopup(source, lastExecutedCommand);
    }
}
#method_after
@Override
public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(GuideModel<?> source, UICommand lastExecutedCommand) {
    if (lastExecutedCommand.getName().equals("OnAddStorage")) {
        // $NON-NLS-1$
        return forceCreateConfirmPopupProvider.get();
    } else {
        return super.getConfirmModelPopup(source, lastExecutedCommand);
    }
}
#end_block

#method_before
private void updateCreatedLabel(GuideModel object) {
    if (object instanceof DataCenterGuideModel) {
        infoLabel.setText(datacenterCreated);
    } else if (object instanceof ClusterGuideModel) {
        infoLabel.setText(clusterCreated);
    } else if (object instanceof VmGuideModel) {
        infoLabel.setText(vmCreated);
    }
}
#method_after
private void updateCreatedLabel(GuideModel<?> object) {
    if (object instanceof DataCenterGuideModel) {
        infoLabel.setText(datacenterCreated);
    } else if (object instanceof ClusterGuideModel) {
        infoLabel.setText(clusterCreated);
    } else if (object instanceof VmGuideModel) {
        infoLabel.setText(vmCreated);
    }
}
#end_block

#method_before
@Override
public GuideModel flush() {
    return driver.flush();
}
#method_after
@Override
public GuideModel<?> flush() {
    return driver.flush();
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getImageSourceLocalEnabled() || sender == getImagePath() || sender == getImageUri()) {
            recalculateImageDerivedFields();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDiskModel().getStorageDomain() || sender == getDiskModel().getVolumeType()) {
            updateVolumeType();
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDiskModel().getStorageDomain() || sender == getDiskModel().getVolumeType()) {
            updateVolumeType();
        }
    }
}
#end_block

#method_before
private void init() {
    log.info("Initializing the DbFacade");
    dbFacadeLocator.configure(this);
    instance = this;
}
#method_after
private void init() {
    log.info("Initializing the DbFacade");
    instance = this;
}
#end_block

#method_before
public static DbFacade getInstance() {
    return instance;
}
#method_after
@Deprecated
public static // Static access to the instance is bug prone and couldn't be mocked.
DbFacade getInstance() {
    return instance;
}
#end_block

#method_before
private boolean updateVms() {
    final boolean compatibilityVersionUnchanged = Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion());
    if (compatibilityVersionUnchanged) {
        return true;
    }
    List<VM> vmList = getVmDao().getAllForCluster(getParameters().getCluster().getId());
    for (VM vm : vmList) {
        if (!vm.isExternalVm() && !vm.isHostedEngine()) {
            VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
            updateParams.setClusterLevelChangeToVersion(getParameters().getCluster().getCompatibilityVersion());
            VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
            if (!result.getSucceeded()) {
                getReturnValue().setFault(result.getFault());
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean updateVms() {
    for (VM vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeToVersion(getParameters().getCluster().getCompatibilityVersion());
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    final List<VM> migratingVms = vmList.stream().filter(vm -> VMStatus.MigratingFrom.equals(vm.getStatus()) || VMStatus.MigratingTo.equals(vm.getStatus())).collect(Collectors.toList());
    final boolean compatibilityVersionUnchanged = Objects.equals(getCluster().getCompatibilityVersion(), oldCluster.getCompatibilityVersion());
    if (!migratingVms.isEmpty() && compatibilityVersionUnchanged) {
        final String migratingVmNames = migratingVms.stream().map(VM::getName).collect(Collectors.joining(", "));
        return failValidation(EngineMessage.CLUSTER_VERSION_CANT_BE_CHANGED_BECAUSE_FOLLOWING_VMS_ARE_MIGRATING, String.format("$migratingVms %s", migratingVmNames));
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void buildVmVideoCards() {
    List<VmDevice> vmVideoDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.VIDEO);
    for (VmDevice vmVideoDevice : vmVideoDevices) {
        // skip unmanaged devices (handled separately)
        if (!vmVideoDevice.getIsManaged()) {
            continue;
        }
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmVideoDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmVideoDevice.getDevice());
        vmInfoBuildHelper.addAddress(vmVideoDevice, struct);
        struct.put(VdsProperties.SpecParams, vmVideoDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmVideoDevice.getId().getDeviceId()));
        addToManagedDevices(vmVideoDevice);
        devices.add(struct);
    }
}
#method_after
@Override
public void buildVmVideoCards() {
    List<VmDevice> vmVideoDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.VIDEO);
    for (VmDevice vmVideoDevice : vmVideoDevices) {
        // skip unmanaged devices (handled separately)
        if (!vmVideoDevice.getIsManaged()) {
            continue;
        }
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmVideoDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmVideoDevice.getDevice());
        vmInfoBuildUtils.addAddress(vmVideoDevice, struct);
        struct.put(VdsProperties.SpecParams, vmVideoDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmVideoDevice.getId().getDeviceId()));
        addToManagedDevices(vmVideoDevice);
        devices.add(struct);
    }
}
#end_block

#method_before
@Override
public void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildHelper.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
            vmInfoBuildHelper.addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#method_after
@Override
public void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#end_block

#method_before
@Override
public void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildHelper.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
public void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildHelper.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildHelper.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildHelper.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            vmInfoBuildHelper.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildHelper.loadStorageQos(diskImage));
                    }
                    vmInfoBuildHelper.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildHelper.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildHelper.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
public void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map<String, Object> struct = new HashMap<>();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildHelper.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildHelper.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
public void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map<String, Object> struct = new HashMap<>();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildUtils.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
public void buildUnmanagedDevices() {
    @SuppressWarnings("unchecked")
    Map<String, String> customMap = createInfo.containsKey(VdsProperties.Custom) ? (Map<String, String>) createInfo.get(VdsProperties.Custom) : new HashMap<>();
    List<VmDevice> vmDevices = vmDeviceDao.getUnmanagedDevicesByVmId(vm.getId());
    if (!vmDevices.isEmpty()) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            Map<String, Object> struct = new HashMap<>();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.put(VdsProperties.Type, vmDevice.getType().getValue());
                struct.put(VdsProperties.Device, vmDevice.getDevice());
                vmInfoBuildHelper.addAddress(vmDevice, struct);
                struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.put(VdsProperties.Custom, customMap);
    createInfo.put(DEVICES, devices);
}
#method_after
@Override
public void buildUnmanagedDevices() {
    @SuppressWarnings("unchecked")
    Map<String, String> customMap = createInfo.containsKey(VdsProperties.Custom) ? (Map<String, String>) createInfo.get(VdsProperties.Custom) : new HashMap<>();
    List<VmDevice> vmDevices = vmDeviceDao.getUnmanagedDevicesByVmId(vm.getId());
    if (!vmDevices.isEmpty()) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            Map<String, Object> struct = new HashMap<>();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.put(VdsProperties.Type, vmDevice.getType().getValue());
                struct.put(VdsProperties.Device, vmDevice.getDevice());
                vmInfoBuildUtils.addAddress(vmDevice, struct);
                struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.put(VdsProperties.Custom, customMap);
    createInfo.put(DEVICES, devices);
}
#end_block

#method_before
@Override
public void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(vmInfoBuildHelper.getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
public void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(vmInfoBuildUtils.getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
@Override
public void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
public void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
@Override
public void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        struct.put(VdsProperties.Index, Integer.toString(virtioScsiIndex));
        vmInfoBuildHelper.addAddress(vmDevice, struct);
        virtioScsiIndex++;
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
public void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        struct.put(VdsProperties.Index, Integer.toString(virtioScsiIndex));
        vmInfoBuildUtils.addAddress(vmDevice, struct);
        virtioScsiIndex++;
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
@Override
public void buildVmVirtioSerial() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSERIAL.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.VirtioSerial);
        vmInfoBuildHelper.addAddress(vmDevice, struct);
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
public void buildVmVirtioSerial() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSERIAL.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.VirtioSerial);
        vmInfoBuildUtils.addAddress(vmDevice, struct);
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
public void buildVmRngDevice() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.RNG.getValue());
        struct.put(VdsProperties.Device, VmDeviceType.VIRTIO.getName());
        struct.put(VdsProperties.Model, VdsProperties.Virtio);
        struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
public void buildVmRngDevice() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.RNG.getValue());
        struct.put(VdsProperties.Device, VmDeviceType.VIRTIO.getName());
        struct.put(VdsProperties.Model, VdsProperties.Virtio);
        struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
public void buildVmNumaProperties() {
    addNumaSetting();
}
#method_after
@Override
public void buildVmNumaProperties() {
    addNumaSetting();
}
#end_block

#method_before
@Override
public void buildVmHostDevices() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.HOSTDEV);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceType.HOST_DEVICE.getName());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        vmInfoBuildHelper.addAddress(vmDevice, struct);
        devices.add(struct);
    }
}
#method_after
@Override
public void buildVmHostDevices() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.HOSTDEV);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceType.HOST_DEVICE.getName());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        vmInfoBuildUtils.addAddress(vmDevice, struct);
        devices.add(struct);
    }
}
#end_block

#method_before
private void buildVmDevicesFromDb(VmDeviceGeneralType generalType, boolean addAddress, Map<String, Object> extraSpecParams) {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), generalType);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        Map<String, Object> specParams = vmDevice.getSpecParams();
        if (extraSpecParams != null) {
            specParams.putAll(extraSpecParams);
        }
        struct.put(VdsProperties.SpecParams, specParams);
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        if (addAddress) {
            vmInfoBuildHelper.addAddress(vmDevice, struct);
        }
        devices.add(struct);
    }
}
#method_after
private void buildVmDevicesFromDb(VmDeviceGeneralType generalType, boolean addAddress, Map<String, Object> extraSpecParams) {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), generalType);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        Map<String, Object> specParams = vmDevice.getSpecParams();
        if (extraSpecParams != null) {
            specParams.putAll(extraSpecParams);
        }
        struct.put(VdsProperties.SpecParams, specParams);
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        if (addAddress) {
            vmInfoBuildUtils.addAddress(vmDevice, struct);
        }
        devices.add(struct);
    }
}
#end_block

#method_before
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    vmInfoBuildHelper.addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    vmInfoBuildHelper.addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    vmInfoBuildHelper.addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    vmInfoBuildHelper.addNetworkFiltersToNic(struct, vmInterface);
}
#method_after
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    vmInfoBuildUtils.addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    vmInfoBuildUtils.addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    vmInfoBuildUtils.addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    vmInfoBuildUtils.addNetworkFiltersToNic(struct, vmInterface);
}
#end_block

#method_before
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        struct.put(VdsProperties.Index, Integer.toString(index));
        if ("scsi".equals(cdInterface)) {
            struct.put(VdsProperties.Address, vmInfoBuildHelper.createAddressForScsiDisk(0, index));
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    vmInfoBuildHelper.addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        struct.put(VdsProperties.Index, Integer.toString(index));
        if ("scsi".equals(cdInterface)) {
            struct.put(VdsProperties.Address, vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    vmInfoBuildUtils.addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#end_block

#method_before
private void buildVmUsbControllers() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        vmInfoBuildHelper.setVdsPropertiesFromSpecParams(vmDevice.getSpecParams(), struct);
        struct.put(VdsProperties.SpecParams, new HashMap<String, Object>());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        vmInfoBuildHelper.addAddress(vmDevice, struct);
        String model = (String) struct.get(VdsProperties.Model);
        // This is a workaround until libvirt will fix the requirement to order these controllers
        if (model != null && vmInfoBuildHelper.isFirstMasterController(model)) {
            devices.add(0, struct);
        } else {
            devices.add(struct);
        }
    }
}
#method_after
private void buildVmUsbControllers() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        vmInfoBuildUtils.setVdsPropertiesFromSpecParams(vmDevice.getSpecParams(), struct);
        struct.put(VdsProperties.SpecParams, new HashMap<String, Object>());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        vmInfoBuildUtils.addAddress(vmDevice, struct);
        String model = (String) struct.get(VdsProperties.Model);
        // This is a workaround until libvirt will fix the requirement to order these controllers
        if (model != null && vmInfoBuildUtils.isFirstMasterController(model)) {
            devices.add(0, struct);
        } else {
            devices.add(struct);
        }
    }
}
#end_block

#method_before
private void buildVmUsbSlots() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        struct.put(VdsProperties.Bus, USB_BUS);
        struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        vmInfoBuildHelper.addAddress(vmDevice, struct);
        devices.add(struct);
    }
}
#method_after
private void buildVmUsbSlots() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        struct.put(VdsProperties.Bus, USB_BUS);
        struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        vmInfoBuildUtils.addAddress(vmDevice, struct);
        devices.add(struct);
    }
}
#end_block

#method_before
private void addMemBalloonDevice(VmDevice vmDevice) {
    Map<String, Object> struct = new HashMap<>();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    Map<String, Object> specParams = vmDevice.getSpecParams();
    // validate & set spec params for balloon device
    if (specParams == null) {
        specParams = new HashMap<>();
        vmDevice.setSpecParams(specParams);
    }
    specParams.put(VdsProperties.Model, VdsProperties.Virtio);
    vmInfoBuildHelper.addAddress(vmDevice, struct);
    addDevice(struct, vmDevice, null);
}
#method_after
private void addMemBalloonDevice(VmDevice vmDevice) {
    Map<String, Object> struct = new HashMap<>();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    Map<String, Object> specParams = vmDevice.getSpecParams();
    // validate & set spec params for balloon device
    if (specParams == null) {
        specParams = new HashMap<>();
        vmDevice.setSpecParams(specParams);
    }
    specParams.put(VdsProperties.Model, VdsProperties.Virtio);
    vmInfoBuildUtils.addAddress(vmDevice, struct);
    addDevice(struct, vmDevice, null);
}
#end_block

#method_before
private Integer calcMaxVCpu() {
    Integer maxSockets = Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, vm.getCompatibilityVersion().getValue());
    Integer maxVCpus = Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getCompatibilityVersion().getValue());
    int threadsPerCore = vm.getThreadsPerCpu();
    int cpuPerSocket = vm.getCpuPerSocket();
    maxVCpus = cpuPerSocket * threadsPerCore * Math.min(maxSockets, maxVCpus / (cpuPerSocket * threadsPerCore));
    return maxVCpus;
}
#method_after
private Integer calcMaxVCpu() {
    return VmCpuCountHelper.calcMaxVCpu(vm.getStaticData(), vm.getClusterCompatibilityVersion());
}
#end_block

#method_before
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    VM vm = getParameters().getVm();
    if (!nic.isPassthrough()) {
        map.put(VdsProperties.Type, vmDevice.getType().getValue());
        map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
        map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
        map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
        addAddress(map, vmDevice.getAddress());
        map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        map.put(VdsProperties.NIC_TYPE, vmInfoBuildHelper.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), vm.getHasAgent()));
        map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        vmInfoBuildHelper.addProfileDataToNic(map, vm, vmDevice, nic);
        vmInfoBuildHelper.addNetworkFiltersToNic(map, nic);
    } else {
        vmInfoBuildHelper.addNetworkVirtualFunctionProperties(map, nic, vmDevice, vmDevice.getHostDevice(), vm);
    }
    return map;
}
#method_after
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    VM vm = getParameters().getVm();
    if (!nic.isPassthrough()) {
        map.put(VdsProperties.Type, vmDevice.getType().getValue());
        map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
        map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
        map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
        addAddress(map, vmDevice.getAddress());
        map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        map.put(VdsProperties.NIC_TYPE, vmInfoBuildUtils.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), vm.getHasAgent()));
        map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        vmInfoBuildUtils.addProfileDataToNic(map, vm, vmDevice, nic);
        vmInfoBuildUtils.addNetworkFiltersToNic(map, nic);
    } else {
        vmInfoBuildUtils.addNetworkVirtualFunctionProperties(map, nic, vmDevice, vmDevice.getHostDevice(), vm);
    }
    return map;
}
#end_block

#method_before
protected boolean isDiskPassPciAndIdeLimit() {
    List<VmNic> vmInterfaces = getVmNicDao().getAllForVm(getVmId());
    List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmId());
    diskVmElements.add(getDiskVmElement());
    return checkPciAndIdeLimit(getVm().getOs(), getVm().getCompatibilityVersion(), getVm().getNumOfMonitors(), vmInterfaces, diskVmElements, isVirtioScsiControllerAttached(getVmId()), hasWatchdog(getVmId()), isBalloonEnabled(getVmId()), isSoundDeviceEnabled(getVmId()), getReturnValue().getValidationMessages());
}
#method_after
protected boolean isDiskPassPciAndIdeLimit() {
    List<VmNic> vmInterfaces = getVmNicDao().getAllForVm(getVmId());
    List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmId());
    diskVmElements.add(getDiskVmElement());
    return validate(VmValidator.checkPciAndIdeLimit(getVm().getOs(), getVm().getCompatibilityVersion(), getVm().getNumOfMonitors(), vmInterfaces, diskVmElements, isVirtioScsiControllerAttached(getVmId()), hasWatchdog(getVmId()), isBalloonEnabled(getVmId()), isSoundDeviceEnabled(getVmId())));
}
#end_block

#method_before
public Map<String, String> getDiskAddressMap(VmDevice vmDevice, DiskInterface diskInterface) {
    String address = vmDevice.getAddress();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.SPAPR_VSCSI) {
        if (StringUtils.isNotBlank(address)) {
            return XmlRpcStringUtils.string2Map(address);
        }
    } else {
        EngineLock vmDiskHotPlugEngineLock = null;
        try {
            vmDiskHotPlugEngineLock = lockVmDiskHotPlugWithWait();
            VM vm = vmDao.get(getParameters().getVmId());
            Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
            int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
            int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
            if (diskInterface == DiskInterface.VirtIO_SCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForVirtioScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, virtioScsiIndex, false);
            } else if (diskInterface == DiskInterface.SPAPR_VSCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForSpaprScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, sPaprVscsiIndex, true);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(vmDiskHotPlugEngineLock);
        }
    }
    return null;
}
#method_after
public Map<String, String> getDiskAddressMap(VmDevice vmDevice, DiskInterface diskInterface) {
    String address = vmDevice.getAddress();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.SPAPR_VSCSI) {
        if (StringUtils.isNotBlank(address)) {
            return XmlRpcStringUtils.string2Map(address);
        }
    } else {
        EngineLock vmDiskHotPlugEngineLock = null;
        try {
            vmDiskHotPlugEngineLock = lockVmDiskHotPlugWithWait();
            VM vm = vmDao.get(getParameters().getVmId());
            Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
            int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
            int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
            if (diskInterface == DiskInterface.VirtIO_SCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, virtioScsiIndex, false);
            } else if (diskInterface == DiskInterface.SPAPR_VSCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, sPaprVscsiIndex, true);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(vmDiskHotPlugEngineLock);
        }
    }
    return null;
}
#end_block

#method_before
private Map<String, String> getAddressMapForScsiDisk(String address, Map<VmDevice, Integer> vmDeviceUnitMap, VmDevice vmDevice, int controllerIndex, boolean reserveFirstAddress) {
    Map<String, String> addressMap;
    int availableUnit = vmInfoBuildHelper.getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstAddress);
    // Otherwise, set address according to the next available unit.
    if (StringUtils.isNotBlank(address)) {
        addressMap = XmlRpcStringUtils.string2Map(address);
        int unit = Integer.parseInt(addressMap.get(VdsProperties.Unit));
        if (vmDeviceUnitMap.containsValue(unit)) {
            addressMap = vmInfoBuildHelper.createAddressForScsiDisk(controllerIndex, availableUnit);
        }
    } else {
        addressMap = vmInfoBuildHelper.createAddressForScsiDisk(controllerIndex, availableUnit);
    }
    // Updating device's address immediately (instead of waiting to VmsMonitoring)
    // to prevent a duplicate unit value (i.e. ensuring a unique unit value).
    updateVmDeviceAddress(addressMap.toString(), vmDevice);
    return addressMap;
}
#method_after
private Map<String, String> getAddressMapForScsiDisk(String address, Map<VmDevice, Integer> vmDeviceUnitMap, VmDevice vmDevice, int controllerIndex, boolean reserveFirstAddress) {
    Map<String, String> addressMap;
    int availableUnit = vmInfoBuildUtils.getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstAddress);
    // Otherwise, set address according to the next available unit.
    if (StringUtils.isNotBlank(address)) {
        addressMap = XmlRpcStringUtils.string2Map(address);
        int unit = Integer.parseInt(addressMap.get(VdsProperties.Unit));
        if (vmDeviceUnitMap.containsValue(unit)) {
            addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
        }
    } else {
        addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
    }
    // Updating device's address immediately (instead of waiting to VmsMonitoring)
    // to prevent a duplicate unit value (i.e. ensuring a unique unit value).
    updateVmDeviceAddress(addressMap.toString(), vmDevice);
    return addressMap;
}
#end_block

#method_before
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    drive.put(VdsProperties.Address, getParameters().getAddressMap() != null ? getParameters().getAddressMap() : StringUtils.EMPTY);
    drive.put(VdsProperties.INTERFACE, getParameters().getDiskInterface().getName());
    int numOfIoThreads = getParameters().getVm().getNumOfIoThreads();
    if (numOfIoThreads != 0 && getParameters().getDiskInterface() == DiskInterface.VirtIO) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<>());
        }
        List<DiskVmElement> diskVmElements = DbFacade.getInstance().getDiskVmElementDao().getAllPluggedToVm(getParameters().getVmId());
        int numOfAttachedVirtioInterfaces = 0;
        for (DiskVmElement dve : diskVmElements) {
            if (dve.getDiskInterface() == DiskInterface.VirtIO) {
                numOfAttachedVirtioInterfaces++;
            }
        }
        int pinToIoThread = numOfAttachedVirtioInterfaces % numOfIoThreads + 1;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinToIoThread);
    }
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
            drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
            drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
            drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
            drive.put(VdsProperties.ImageId, diskImage.getId().toString());
            drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            vmInfoBuildHelper.handleIoTune(vmDevice, vmInfoBuildHelper.loadStorageQos(diskImage));
            if (vmDevice.getSpecParams() != null) {
                drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            }
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
            // set device type as 'lun' (instead of 'disk') and set the specified SGIO
            boolean isVirtioScsi = getParameters().getDiskInterface() == DiskInterface.VirtIO_SCSI;
            boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
            if (isVirtioScsi) {
                if (isScsiPassthrough) {
                    drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
                } else {
                    drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
                }
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
            }
            drive.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
            drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            break;
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) disk;
            vmInfoBuildHelper.buildCinderDisk(cinderDisk, drive);
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            break;
    }
    return drive;
}
#method_after
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    drive.put(VdsProperties.Address, getParameters().getAddressMap() != null ? getParameters().getAddressMap() : StringUtils.EMPTY);
    drive.put(VdsProperties.INTERFACE, getParameters().getDiskInterface().getName());
    int numOfIoThreads = getParameters().getVm().getNumOfIoThreads();
    if (numOfIoThreads != 0 && getParameters().getDiskInterface() == DiskInterface.VirtIO) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<>());
        }
        List<DiskVmElement> diskVmElements = DbFacade.getInstance().getDiskVmElementDao().getAllPluggedToVm(getParameters().getVmId());
        int numOfAttachedVirtioInterfaces = 0;
        for (DiskVmElement dve : diskVmElements) {
            if (dve.getDiskInterface() == DiskInterface.VirtIO) {
                numOfAttachedVirtioInterfaces++;
            }
        }
        int pinToIoThread = numOfAttachedVirtioInterfaces % numOfIoThreads + 1;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinToIoThread);
    }
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
            drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
            drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
            drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
            drive.put(VdsProperties.ImageId, diskImage.getId().toString());
            drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            vmInfoBuildUtils.handleIoTune(vmDevice, vmInfoBuildUtils.loadStorageQos(diskImage));
            if (vmDevice.getSpecParams() != null) {
                drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            }
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
            // set device type as 'lun' (instead of 'disk') and set the specified SGIO
            boolean isVirtioScsi = getParameters().getDiskInterface() == DiskInterface.VirtIO_SCSI;
            boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
            if (isVirtioScsi) {
                if (isScsiPassthrough) {
                    drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
                } else {
                    drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
                }
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
            }
            drive.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
            drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            break;
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) disk;
            vmInfoBuildUtils.buildCinderDisk(cinderDisk, drive);
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            break;
    }
    return drive;
}
#end_block

#method_before
protected Map<String, Object> initDeviceStructure() {
    Map<String, Object> deviceStruct = new HashMap<>();
    deviceStruct.put(VdsProperties.DeviceType, getParameters().getVmDevice().getType().getValue());
    deviceStruct.put(VdsProperties.Alias, getParameters().getVmDevice().getAlias());
    VmNic nic = getParameters().getNic();
    deviceStruct.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
    VmDevice vmDevice = getParameters().getVmDevice();
    vmInfoBuildHelper.addProfileDataToNic(deviceStruct, getParameters().getVm(), vmDevice, nic);
    return deviceStruct;
}
#method_after
protected Map<String, Object> initDeviceStructure() {
    Map<String, Object> deviceStruct = new HashMap<>();
    deviceStruct.put(VdsProperties.DeviceType, getParameters().getVmDevice().getType().getValue());
    deviceStruct.put(VdsProperties.Alias, getParameters().getVmDevice().getAlias());
    VmNic nic = getParameters().getNic();
    deviceStruct.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
    VmDevice vmDevice = getParameters().getVmDevice();
    vmInfoBuildUtils.addProfileDataToNic(deviceStruct, getParameters().getVm(), vmDevice, nic);
    return deviceStruct;
}
#end_block

#method_before
public VmInfoBuilder createVmInfoBuilder(VM vm, Guid vdsId, Map<String, Object> createInfo) {
    return new VmInfoBuilderImpl(vm, vdsId, createInfo, clusterDao, networkClusterDao, networkDao, vdsNumaNodeDao, vmDeviceDao, vmNumaNodeDao, vmInfoBuildHelper);
}
#method_after
public VmInfoBuilder createVmInfoBuilder(VM vm, Guid vdsId, Map<String, Object> createInfo) {
    return new VmInfoBuilderImpl(vm, vdsId, createInfo, clusterDao, networkClusterDao, networkDao, vdsNumaNodeDao, vmDeviceDao, vmNumaNodeDao, vmInfoBuildUtils);
}
#end_block

#method_before
static Map<String, HostDevice> filterOrphanedDevices(Map<String, HostDevice> fetchedDevicesMap) {
    if (!fetchedDevicesMap.containsKey(VdsProperties.ROOT_HOST_DEVICE)) {
        // if there is no root, nothing can be reachable from root
        return Collections.EMPTY_MAP;
    }
    Map<String, List<String>> childrenDeviceMap = new HashMap<>();
    // aggregate inverse information: parent -> list of children
    for (Map.Entry<String, HostDevice> entry : fetchedDevicesMap.entrySet()) {
        String deviceName = entry.getKey();
        HostDevice device = entry.getValue();
        MultiValueMapUtils.addToMap(device.getParentDeviceName(), deviceName, childrenDeviceMap);
    }
    Stack<String> toTraverse = new Stack<>();
    toTraverse.push(VdsProperties.ROOT_HOST_DEVICE);
    Map<String, HostDevice> result = new HashMap<>();
    while (!toTraverse.empty()) {
        String deviceName = toTraverse.pop();
        result.put(deviceName, fetchedDevicesMap.get(deviceName));
        if (childrenDeviceMap.containsKey(deviceName)) {
            childrenDeviceMap.get(deviceName).stream().filter(child -> !VdsProperties.ROOT_HOST_DEVICE.equals(child)).forEach(toTraverse::push);
        }
    }
    return result;
}
#method_after
static Map<String, HostDevice> filterOrphanedDevices(Map<String, HostDevice> fetchedDevicesMap) {
    if (!fetchedDevicesMap.containsKey(VdsProperties.ROOT_HOST_DEVICE)) {
        // if there is no root, nothing can be reachable from root
        return Collections.emptyMap();
    }
    Map<String, List<String>> childrenDeviceMap = new HashMap<>();
    // aggregate inverse information: parent -> list of children
    for (Map.Entry<String, HostDevice> entry : fetchedDevicesMap.entrySet()) {
        String deviceName = entry.getKey();
        HostDevice device = entry.getValue();
        MultiValueMapUtils.addToMap(device.getParentDeviceName(), deviceName, childrenDeviceMap);
    }
    Stack<String> toTraverse = new Stack<>();
    toTraverse.push(VdsProperties.ROOT_HOST_DEVICE);
    Map<String, HostDevice> result = new HashMap<>();
    while (!toTraverse.empty()) {
        String deviceName = toTraverse.pop();
        result.put(deviceName, fetchedDevicesMap.get(deviceName));
        if (childrenDeviceMap.containsKey(deviceName)) {
            childrenDeviceMap.get(deviceName).stream().filter(child -> !VdsProperties.ROOT_HOST_DEVICE.equals(child)).forEach(toTraverse::push);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildHelper.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildHelper.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildHelper.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildHelper.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildHelper.loadStorageQos(diskImage));
                    }
                    vmInfoBuildHelper.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildHelper.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildHelper.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildHelper.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildHelper.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildUtils.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(vmInfoBuildHelper.getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(vmInfoBuildUtils.getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    vmInfoBuildHelper.addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    vmInfoBuildHelper.addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    vmInfoBuildHelper.addNetworkFiltersToNic(struct, vmInterface);
}
#method_after
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    vmInfoBuildUtils.addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    vmInfoBuildUtils.addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    vmInfoBuildUtils.addNetworkFiltersToNic(struct, vmInterface);
}
#end_block

#method_before
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        struct.put(VdsProperties.Index, Integer.toString(index));
        if ("scsi".equals(cdInterface)) {
            struct.put(VdsProperties.Address, vmInfoBuildHelper.createAddressForScsiDisk(0, index));
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    vmInfoBuildHelper.addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        struct.put(VdsProperties.Index, Integer.toString(index));
        if ("scsi".equals(cdInterface)) {
            struct.put(VdsProperties.Address, vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    vmInfoBuildUtils.addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#end_block

#method_before
private void buildVmUsbControllers() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map struct = new HashMap();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        vmInfoBuildHelper.setVdsPropertiesFromSpecParams(vmDevice.getSpecParams(), struct);
        struct.put(VdsProperties.SpecParams, new HashMap<String, Object>());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        addAddress(vmDevice, struct);
        String model = (String) struct.get(VdsProperties.Model);
        // This is a workaround until libvirt will fix the requirement to order these controllers
        if (model != null && vmInfoBuildHelper.isFirstMasterController(model)) {
            devices.add(0, struct);
        } else {
            devices.add(struct);
        }
    }
}
#method_after
private void buildVmUsbControllers() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map struct = new HashMap();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        vmInfoBuildUtils.setVdsPropertiesFromSpecParams(vmDevice.getSpecParams(), struct);
        struct.put(VdsProperties.SpecParams, new HashMap<String, Object>());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        addAddress(vmDevice, struct);
        String model = (String) struct.get(VdsProperties.Model);
        // This is a workaround until libvirt will fix the requirement to order these controllers
        if (model != null && vmInfoBuildUtils.isFirstMasterController(model)) {
            devices.add(0, struct);
        } else {
            devices.add(struct);
        }
    }
}
#end_block

#method_before
public VmInfoBuilder createVmInfoBuilder(VM vm, Guid vdsId, Map createInfo) {
    return new VmInfoBuilder(vm, vdsId, createInfo, vdsNumaNodeDao, vmDeviceDao, vmNumaNodeDao, vmInfoBuildHelper);
}
#method_after
public VmInfoBuilder createVmInfoBuilder(VM vm, Guid vdsId, Map createInfo) {
    return new VmInfoBuilder(vm, vdsId, createInfo, vdsNumaNodeDao, vmDeviceDao, vmNumaNodeDao, vmInfoBuildUtils);
}
#end_block

#method_before
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    drive.put(VdsProperties.Address, getParameters().getAddressMap() != null ? getParameters().getAddressMap() : StringUtils.EMPTY);
    drive.put(VdsProperties.INTERFACE, getParameters().getDiskInterface().getName());
    int numOfIoThreads = getParameters().getVm().getNumOfIoThreads();
    if (numOfIoThreads != 0 && getParameters().getDiskInterface() == DiskInterface.VirtIO) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<>());
        }
        List<DiskVmElement> diskVmElements = DbFacade.getInstance().getDiskVmElementDao().getAllPluggedToVm(getParameters().getVmId());
        int numOfAttachedVirtioInterfaces = 0;
        for (DiskVmElement dve : diskVmElements) {
            if (dve.getDiskInterface() == DiskInterface.VirtIO) {
                numOfAttachedVirtioInterfaces++;
            }
        }
        int pinToIoThread = numOfAttachedVirtioInterfaces % numOfIoThreads + 1;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinToIoThread);
    }
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
            drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
            drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
            drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
            drive.put(VdsProperties.ImageId, diskImage.getId().toString());
            drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            vmInfoBuildHelper.handleIoTune(vmDevice, vmInfoBuildHelper.loadStorageQos(diskImage));
            if (vmDevice.getSpecParams() != null) {
                drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            }
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
            // set device type as 'lun' (instead of 'disk') and set the specified SGIO
            boolean isVirtioScsi = getParameters().getDiskInterface() == DiskInterface.VirtIO_SCSI;
            boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
            if (isVirtioScsi) {
                if (isScsiPassthrough) {
                    drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
                } else {
                    drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
                }
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
            }
            drive.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
            drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            break;
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) disk;
            vmInfoBuildHelper.buildCinderDisk(cinderDisk, drive);
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            break;
    }
    return drive;
}
#method_after
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    drive.put(VdsProperties.Address, getParameters().getAddressMap() != null ? getParameters().getAddressMap() : StringUtils.EMPTY);
    drive.put(VdsProperties.INTERFACE, getParameters().getDiskInterface().getName());
    int numOfIoThreads = getParameters().getVm().getNumOfIoThreads();
    if (numOfIoThreads != 0 && getParameters().getDiskInterface() == DiskInterface.VirtIO) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<>());
        }
        List<DiskVmElement> diskVmElements = DbFacade.getInstance().getDiskVmElementDao().getAllPluggedToVm(getParameters().getVmId());
        int numOfAttachedVirtioInterfaces = 0;
        for (DiskVmElement dve : diskVmElements) {
            if (dve.getDiskInterface() == DiskInterface.VirtIO) {
                numOfAttachedVirtioInterfaces++;
            }
        }
        int pinToIoThread = numOfAttachedVirtioInterfaces % numOfIoThreads + 1;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinToIoThread);
    }
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
            drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
            drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
            drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
            drive.put(VdsProperties.ImageId, diskImage.getId().toString());
            drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            vmInfoBuildUtils.handleIoTune(vmDevice, vmInfoBuildUtils.loadStorageQos(diskImage));
            if (vmDevice.getSpecParams() != null) {
                drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            }
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
            // set device type as 'lun' (instead of 'disk') and set the specified SGIO
            boolean isVirtioScsi = getParameters().getDiskInterface() == DiskInterface.VirtIO_SCSI;
            boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
            if (isVirtioScsi) {
                if (isScsiPassthrough) {
                    drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
                } else {
                    drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
                }
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
            }
            drive.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
            drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            break;
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) disk;
            vmInfoBuildUtils.buildCinderDisk(cinderDisk, drive);
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            break;
    }
    return drive;
}
#end_block

#method_before
public VmInfoBuilder createVmInfoBuilder(VM vm, Guid vdsId, Map createInfo) {
    return new VmInfoBuilder(vm, vdsId, createInfo, dbFacade, vmInfoBuildHelper);
}
#method_after
public VmInfoBuilder createVmInfoBuilder(VM vm, Guid vdsId, Map createInfo) {
    return new VmInfoBuilder(vm, vdsId, createInfo, dbFacade, vmInfoBuildUtils);
}
#end_block

#method_before
protected boolean isDiskPassPciAndIdeLimit() {
    List<VmNic> vmInterfaces = getVmNicDao().getAllForVm(getVmId());
    List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmId());
    diskVmElements.add(getDiskVmElement());
    return checkPciAndIdeLimit(getVm().getOs(), getVm().getCompatibilityVersion(), getVm().getNumOfMonitors(), vmInterfaces, diskVmElements, isVirtioScsiControllerAttached(getVmId()), hasWatchdog(getVmId()), isBalloonEnabled(getVmId()), isSoundDeviceEnabled(getVmId()), getReturnValue().getValidationMessages());
}
#method_after
protected boolean isDiskPassPciAndIdeLimit() {
    List<VmNic> vmInterfaces = getVmNicDao().getAllForVm(getVmId());
    List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmId());
    diskVmElements.add(getDiskVmElement());
    return validate(VmValidator.checkPciAndIdeLimit(getVm().getOs(), getVm().getCompatibilityVersion(), getVm().getNumOfMonitors(), vmInterfaces, diskVmElements, isVirtioScsiControllerAttached(getVmId()), hasWatchdog(getVmId()), isBalloonEnabled(getVmId()), isSoundDeviceEnabled(getVmId())));
}
#end_block

#method_before
public Map<String, String> getDiskAddressMap(VmDevice vmDevice, DiskInterface diskInterface) {
    String address = vmDevice.getAddress();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.SPAPR_VSCSI) {
        if (StringUtils.isNotBlank(address)) {
            return XmlRpcStringUtils.string2Map(address);
        }
    } else {
        EngineLock vmDiskHotPlugEngineLock = null;
        try {
            vmDiskHotPlugEngineLock = lockVmDiskHotPlugWithWait();
            VM vm = vmDao.get(getParameters().getVmId());
            Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
            int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
            int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
            if (diskInterface == DiskInterface.VirtIO_SCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForVirtioScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, virtioScsiIndex, false);
            } else if (diskInterface == DiskInterface.SPAPR_VSCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForSpaprScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, sPaprVscsiIndex, true);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(vmDiskHotPlugEngineLock);
        }
    }
    return null;
}
#method_after
public Map<String, String> getDiskAddressMap(VmDevice vmDevice, DiskInterface diskInterface) {
    String address = vmDevice.getAddress();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.SPAPR_VSCSI) {
        if (StringUtils.isNotBlank(address)) {
            return XmlRpcStringUtils.string2Map(address);
        }
    } else {
        EngineLock vmDiskHotPlugEngineLock = null;
        try {
            vmDiskHotPlugEngineLock = lockVmDiskHotPlugWithWait();
            VM vm = vmDao.get(getParameters().getVmId());
            Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
            int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
            int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
            if (diskInterface == DiskInterface.VirtIO_SCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, virtioScsiIndex, false);
            } else if (diskInterface == DiskInterface.SPAPR_VSCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, sPaprVscsiIndex, true);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(vmDiskHotPlugEngineLock);
        }
    }
    return null;
}
#end_block

#method_before
private Map<String, String> getAddressMapForScsiDisk(String address, Map<VmDevice, Integer> vmDeviceUnitMap, VmDevice vmDevice, int controllerIndex, boolean reserveFirstAddress) {
    Map<String, String> addressMap;
    int availableUnit = vmInfoBuildHelper.getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstAddress);
    // Otherwise, set address according to the next available unit.
    if (StringUtils.isNotBlank(address)) {
        addressMap = XmlRpcStringUtils.string2Map(address);
        int unit = Integer.parseInt(addressMap.get(VdsProperties.Unit));
        if (vmDeviceUnitMap.containsValue(unit)) {
            addressMap = vmInfoBuildHelper.createAddressForScsiDisk(controllerIndex, availableUnit);
        }
    } else {
        addressMap = vmInfoBuildHelper.createAddressForScsiDisk(controllerIndex, availableUnit);
    }
    // Updating device's address immediately (instead of waiting to VmsMonitoring)
    // to prevent a duplicate unit value (i.e. ensuring a unique unit value).
    updateVmDeviceAddress(addressMap.toString(), vmDevice);
    return addressMap;
}
#method_after
private Map<String, String> getAddressMapForScsiDisk(String address, Map<VmDevice, Integer> vmDeviceUnitMap, VmDevice vmDevice, int controllerIndex, boolean reserveFirstAddress) {
    Map<String, String> addressMap;
    int availableUnit = vmInfoBuildUtils.getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstAddress);
    // Otherwise, set address according to the next available unit.
    if (StringUtils.isNotBlank(address)) {
        addressMap = XmlRpcStringUtils.string2Map(address);
        int unit = Integer.parseInt(addressMap.get(VdsProperties.Unit));
        if (vmDeviceUnitMap.containsValue(unit)) {
            addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
        }
    } else {
        addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
    }
    // Updating device's address immediately (instead of waiting to VmsMonitoring)
    // to prevent a duplicate unit value (i.e. ensuring a unique unit value).
    updateVmDeviceAddress(addressMap.toString(), vmDevice);
    return addressMap;
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildHelper.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildHelper.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildHelper.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildHelper.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildHelper.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildHelper.loadStorageQos(diskImage));
                    }
                    vmInfoBuildHelper.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildHelper.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildHelper.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildHelper.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildHelper.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildUtils.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(vmInfoBuildHelper.getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildHelper.addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(vmInfoBuildUtils.getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildHelper.addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    vmInfoBuildHelper.addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    vmInfoBuildHelper.addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    vmInfoBuildHelper.addNetworkFiltersToNic(struct, vmInterface);
}
#method_after
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    vmInfoBuildUtils.addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    vmInfoBuildUtils.addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    vmInfoBuildUtils.addNetworkFiltersToNic(struct, vmInterface);
}
#end_block

#method_before
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        struct.put(VdsProperties.Index, Integer.toString(index));
        if ("scsi".equals(cdInterface)) {
            struct.put(VdsProperties.Address, vmInfoBuildHelper.createAddressForScsiDisk(0, index));
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    vmInfoBuildHelper.addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        struct.put(VdsProperties.Index, Integer.toString(index));
        if ("scsi".equals(cdInterface)) {
            struct.put(VdsProperties.Address, vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    vmInfoBuildUtils.addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#end_block

#method_before
private void buildVmUsbControllers() {
    List<VmDevice> vmDevices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map struct = new HashMap();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        vmInfoBuildHelper.setVdsPropertiesFromSpecParams(vmDevice.getSpecParams(), struct);
        struct.put(VdsProperties.SpecParams, new HashMap<String, Object>());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        addAddress(vmDevice, struct);
        String model = (String) struct.get(VdsProperties.Model);
        // This is a workaround until libvirt will fix the requirement to order these controllers
        if (model != null && vmInfoBuildHelper.isFirstMasterController(model)) {
            devices.add(0, struct);
        } else {
            devices.add(struct);
        }
    }
}
#method_after
private void buildVmUsbControllers() {
    List<VmDevice> vmDevices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map struct = new HashMap();
        struct.put(VdsProperties.Type, vmDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmDevice.getDevice());
        vmInfoBuildUtils.setVdsPropertiesFromSpecParams(vmDevice.getSpecParams(), struct);
        struct.put(VdsProperties.SpecParams, new HashMap<String, Object>());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        addAddress(vmDevice, struct);
        String model = (String) struct.get(VdsProperties.Model);
        // This is a workaround until libvirt will fix the requirement to order these controllers
        if (model != null && vmInfoBuildUtils.isFirstMasterController(model)) {
            devices.add(0, struct);
        } else {
            devices.add(struct);
        }
    }
}
#end_block

#method_before
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    VM vm = getParameters().getVm();
    if (!nic.isPassthrough()) {
        map.put(VdsProperties.Type, vmDevice.getType().getValue());
        map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
        map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
        map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
        addAddress(map, vmDevice.getAddress());
        map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        map.put(VdsProperties.NIC_TYPE, vmInfoBuildHelper.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), vm.getHasAgent()));
        map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        vmInfoBuildHelper.addProfileDataToNic(map, vm, vmDevice, nic);
        vmInfoBuildHelper.addNetworkFiltersToNic(map, nic);
    } else {
        vmInfoBuildHelper.addNetworkVirtualFunctionProperties(map, nic, vmDevice, vmDevice.getHostDevice(), vm);
    }
    return map;
}
#method_after
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    VM vm = getParameters().getVm();
    if (!nic.isPassthrough()) {
        map.put(VdsProperties.Type, vmDevice.getType().getValue());
        map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
        map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
        map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
        addAddress(map, vmDevice.getAddress());
        map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        map.put(VdsProperties.NIC_TYPE, vmInfoBuildUtils.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), vm.getHasAgent()));
        map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        vmInfoBuildUtils.addProfileDataToNic(map, vm, vmDevice, nic);
        vmInfoBuildUtils.addNetworkFiltersToNic(map, nic);
    } else {
        vmInfoBuildUtils.addNetworkVirtualFunctionProperties(map, nic, vmDevice, vmDevice.getHostDevice(), vm);
    }
    return map;
}
#end_block

#method_before
protected Map<String, Object> initDeviceStructure() {
    Map<String, Object> deviceStruct = new HashMap<>();
    deviceStruct.put(VdsProperties.DeviceType, getParameters().getVmDevice().getType().getValue());
    deviceStruct.put(VdsProperties.Alias, getParameters().getVmDevice().getAlias());
    VmNic nic = getParameters().getNic();
    deviceStruct.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
    VmDevice vmDevice = getParameters().getVmDevice();
    vmInfoBuildHelper.addProfileDataToNic(deviceStruct, getParameters().getVm(), vmDevice, nic);
    return deviceStruct;
}
#method_after
protected Map<String, Object> initDeviceStructure() {
    Map<String, Object> deviceStruct = new HashMap<>();
    deviceStruct.put(VdsProperties.DeviceType, getParameters().getVmDevice().getType().getValue());
    deviceStruct.put(VdsProperties.Alias, getParameters().getVmDevice().getAlias());
    VmNic nic = getParameters().getNic();
    deviceStruct.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
    VmDevice vmDevice = getParameters().getVmDevice();
    vmInfoBuildUtils.addProfileDataToNic(deviceStruct, getParameters().getVm(), vmDevice, nic);
    return deviceStruct;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<DiskVmElement> diskVmElements = getDbFacade().getDiskVmElementDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, diskVmElements, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<DiskVmElement> diskVmElements = getDbFacade().getDiskVmElementDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return validate(VmValidator.checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, diskVmElements, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled()));
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters()) || isClusterLevelChange();
}
#end_block

#method_before
private void assertValidationFailure(ValidationResult validationResult, EngineMessage engineMessage) {
    assertFalse(validationResult.isValid());
    assertTrue(String.format("Expected %s but got %s", engineMessage.name(), validationResult.getMessage().name()), validationResult.getMessage() == engineMessage);
}
#method_after
private void assertValidationFailure(ValidationResult validationResult, EngineMessage engineMessage) {
    assertThat(validationResult, failsWith(engineMessage));
}
#end_block

#method_before
protected boolean validateAddVmCommand() {
    return areParametersLegal(getReturnValue().getValidationMessages()) && checkNumberOfMonitors() && checkSingleQxlDisplay() && checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getDiskVmElements(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages()) && canAddVm(getReturnValue().getValidationMessages(), destStorages.values()) && hostToRunExist();
}
#method_after
protected boolean validateAddVmCommand() {
    return areParametersLegal(getReturnValue().getValidationMessages()) && checkNumberOfMonitors() && checkSingleQxlDisplay() && validate(VmValidator.checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getDiskVmElements(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled())) && canAddVm(getReturnValue().getValidationMessages(), destStorages.values()) && hostToRunExist();
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, false, true, true, storageToDisksMap.get(storage.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, false, true, true, storageToDisksMap.get(storage.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
void addVmStatistics() {
    VmStatistics stats = new VmStatistics();
    stats.setId(getVmId());
    DbFacade.getInstance().getVmStatisticsDao().save(stats);
    getCompensationContext().snapshotNewEntity(stats);
}
#method_after
void addVmStatistics() {
    VmStatistics stats = new VmStatistics(getVmId());
    DbFacade.getInstance().getVmStatisticsDao().save(stats);
    getCompensationContext().snapshotNewEntity(stats);
}
#end_block

#method_before
@Test
public void isConnectionNotExists() {
    validator = new StorageConnectionValidator(null);
    assertEquals(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST, validator.isConnectionExists().getMessage());
}
#method_after
@Test
public void isConnectionNotExists() {
    validator = new StorageConnectionValidator(null);
    assertThat(validator.isConnectionExists(), failsWith(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST));
}
#end_block

#method_before
@Test
public void isNotSameStorageType() {
    domain.setStorageType(StorageType.NFS);
    assertEquals(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_NOT_SAME_STORAGE_TYPE, validator.isSameStorageType(domain).getMessage());
}
#method_after
@Test
public void isNotSameStorageType() {
    domain.setStorageType(StorageType.NFS);
    assertThat(validator.isSameStorageType(domain), failsWith(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_NOT_SAME_STORAGE_TYPE));
}
#end_block

#method_before
@Test
public void isNotISCSIConnectionAndDomain() {
    connection.setStorageType(StorageType.NFS);
    domain.setStorageType(StorageType.NFS);
    assertEquals(EngineMessage.ACTION_TYPE_FAILED_ACTION_IS_SUPPORTED_ONLY_FOR_ISCSI_DOMAINS, validator.isISCSIConnectionAndDomain(domain).getMessage());
}
#method_after
@Test
public void isNotISCSIConnectionAndDomain() {
    connection.setStorageType(StorageType.NFS);
    domain.setStorageType(StorageType.NFS);
    assertThat(validator.isISCSIConnectionAndDomain(domain), failsWith(EngineMessage.ACTION_TYPE_FAILED_ACTION_IS_SUPPORTED_ONLY_FOR_ISCSI_DOMAINS));
}
#end_block

#method_before
private List<StorageServerConnections> getConnections() {
    List<StorageServerConnections> connectionsList = new ArrayList<>();
    for (int i = 0; i == NUMBER_OF_EXISTING_CONNECTIONS; i++) {
        StorageServerConnections conn = new StorageServerConnections();
        conn.setId(Guid.newGuid().toString());
        connectionsList.add(conn);
    }
    return connectionsList;
}
#method_after
private List<StorageServerConnections> getConnections() {
    List<StorageServerConnections> connectionsList = new ArrayList<>();
    for (int i = 0; i < NUMBER_OF_EXISTING_CONNECTIONS; i++) {
        StorageServerConnections conn = new StorageServerConnections();
        conn.setId(Guid.newGuid().toString());
        connectionsList.add(conn);
    }
    return connectionsList;
}
#end_block

#method_before
private void logResultOfPrestartVms(int prestartedVmsCounter, int numOfVmsToPrestart, Guid vmPoolId, Map<String, Set<Guid>> failureReasonsForVms) {
    if (prestartedVmsCounter > 0) {
        log.info("Prestarted {} VMs out of the {} required, in VmPool '{}'", prestartedVmsCounter, numOfVmsToPrestart, vmPoolId);
    } else {
        log.error("Failed to prestart any VMs for VmPool '{}'", vmPoolId);
    }
    if (prestartedVmsCounter < numOfVmsToPrestart) {
        for (Map.Entry<String, Set<Guid>> entry : failureReasonsForVms.entrySet()) {
            log.error("Failed to prestart {} VMs with reason {}", entry.getValue(), entry.getKey());
        }
    }
}
#method_after
private void logResultOfPrestartVms(int prestartedVmsCounter, int numOfVmsToPrestart, Guid vmPoolId, Map<String, Set<Guid>> failureReasonsForVms) {
    if (prestartedVmsCounter > 0) {
        log.info("Prestarted {} VMs out of the {} required, in VmPool '{}'", prestartedVmsCounter, numOfVmsToPrestart, vmPoolId);
    } else {
        log.warn("Failed to prestart any VMs for VmPool '{}'", vmPoolId);
    }
    if (prestartedVmsCounter < numOfVmsToPrestart) {
        for (Map.Entry<String, Set<Guid>> entry : failureReasonsForVms.entrySet()) {
            log.warn("Failed to prestart VMs {} with reason {}", entry.getValue(), entry.getKey());
        }
    }
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
            CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        persistCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        updateCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (shouldPersistCommand()) {
        persistCommandIfNeeded();
        CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
    }
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessage(validationResult.getMessage());
        validationResult.getVariableReplacements().forEach(this::addValidationMessage);
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessages(validationResult.getMessages());
        validationResult.getVariableReplacements().forEach(this::addValidationMessage);
    }
    return validationResult.isValid();
}
#end_block

#method_before
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    addValidationMessage(message);
    for (String variableReplacement : variableReplacements) {
        addValidationMessage(variableReplacement);
    }
    return false;
}
#method_after
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    return failValidation(Collections.singletonList(message), variableReplacements);
}
#end_block

#method_before
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    addValidationMessage(message);
    for (String variableReplacement : variableReplacements) {
        addValidationMessage(variableReplacement);
    }
    return false;
}
#method_after
protected final boolean failValidation(List<EngineMessage> messages, String... variableReplacements) {
    addValidationMessages(messages);
    for (String variableReplacement : variableReplacements) {
        addValidationMessage(variableReplacement);
    }
    return false;
}
#end_block

#method_before
protected void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#method_after
protected void persistCommandIfNeeded() {
    if (shouldPersistCommand()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#end_block

#method_before
private void doTestValidModifiedBonds(CreateOrUpdateBond createOrUpdateBond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(CreateOrUpdateBond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessages().get(0), expectedValidationResult.getVariableReplacements()));
    }
}
#method_after
private void doTestValidModifiedBonds(CreateOrUpdateBond createOrUpdateBond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(CreateOrUpdateBond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessages(), expectedValidationResult.getVariableReplacements()));
    }
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
            CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        persistCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        updateCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (shouldPersistCommand()) {
        persistCommandIfNeeded();
        CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
    }
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
public Map<String, String> getJobMessageProperties() {
    jobProperties = new HashMap<>();
    List<PermissionSubject> subjects = getPermissionCheckSubjects();
    if (!subjects.isEmpty()) {
        VdcObjectType entityType;
        Guid entityId;
        String value;
        for (PermissionSubject permSubject : subjects) {
            entityType = permSubject.getObjectType();
            entityId = permSubject.getObjectId();
            if (entityType != null && entityId != null) {
                value = DbFacade.getInstance().getEntityNameByIdAndType(entityId, entityType);
                if (value == null) {
                    value = entityId.toString();
                }
                jobProperties.put(entityType.name().toLowerCase(), value);
            }
        }
    }
    return jobProperties;
}
#method_after
public Map<String, String> getJobMessageProperties() {
    jobProperties = new HashMap<>();
    List<PermissionSubject> subjects = getPermissionCheckSubjects();
    if (!subjects.isEmpty()) {
        VdcObjectType entityType;
        Guid entityId;
        String value;
        for (PermissionSubject permSubject : subjects) {
            entityType = permSubject.getObjectType();
            entityId = permSubject.getObjectId();
            if (entityType != null && entityId != null) {
                value = entityDao.getEntityNameByIdAndType(entityId, entityType);
                if (value == null) {
                    value = entityId.toString();
                }
                jobProperties.put(entityType.name().toLowerCase(), value);
            }
        }
    }
    return jobProperties;
}
#end_block

#method_before
protected void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#method_after
protected void persistCommandIfNeeded() {
    if (shouldPersistCommand()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#end_block

#method_before
private void assertFailsWith(ValidationResult validationResult, EngineMessage engineMessage) {
    Assert.assertThat(validationResult, failsWith(engineMessage));
}
#method_after
private void assertFailsWith(ValidationResult validationResult, EngineMessage engineMessage) {
    assertThat(validationResult, failsWith(engineMessage));
}
#end_block

#method_before
private void assertFailsWith(String errorMessage, ValidationResult validationResult, EngineMessage engineMessage) {
    Assert.assertThat(errorMessage, validationResult, failsWith(engineMessage));
}
#method_after
private void assertFailsWith(String errorMessage, ValidationResult validationResult, EngineMessage engineMessage) {
    assertThat(errorMessage, validationResult, failsWith(engineMessage));
}
#end_block

#method_before
protected boolean isVirtioScsiControllerAttached(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#method_after
protected boolean isVirtioScsiControllerAttached(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean isBalloonEnabled(Guid vmId) {
    return VmDeviceUtils.hasMemoryBalloon(vmId);
}
#method_after
protected boolean isBalloonEnabled(Guid vmId) {
    return getVmDeviceUtils().hasMemoryBalloon(vmId);
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled(Guid vmId) {
    return VmDeviceUtils.hasSoundDevice(vmId);
}
#method_after
protected boolean isSoundDeviceEnabled(Guid vmId) {
    return getVmDeviceUtils().hasSoundDevice(vmId);
}
#end_block

#method_before
protected boolean hasWatchdog(Guid vmId) {
    return VmDeviceUtils.hasWatchdog(vmId);
}
#method_after
protected boolean hasWatchdog(Guid vmId) {
    return getVmDeviceUtils().hasWatchdog(vmId);
}
#end_block

#method_before
protected DiskValidator getDiskValidator(Disk disk) {
    return new DiskValidator(disk);
}
#method_after
protected DiskValidator getDiskValidator(Disk disk) {
    return new DiskValidator(disk, getVmDeviceUtils());
}
#end_block

#method_before
public static ValidationResult checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<? extends VmNic> interfaces, List<DiskVmElement> diskVmElements, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled) {
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += diskVmElements.stream().filter(dve -> dve.getDiskInterface() == DiskInterface.VirtIO).count();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    ArrayList<EngineMessage> messages = new ArrayList<>();
    if (pciInUse > maxPciSlots) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
    } else if (MAX_IDE_SLOTS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.IDE).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
    } else if (MAX_VIRTIO_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO_SCSI).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS);
    } else if (MAX_SPAPR_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.SPAPR_VSCSI).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS);
    }
    if (!messages.isEmpty()) {
    // return new ValidationResult(messages);
    }
    return null;
}
#method_after
public static ValidationResult checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<? extends VmNic> interfaces, List<DiskVmElement> diskVmElements, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled) {
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += diskVmElements.stream().filter(dve -> dve.getDiskInterface() == DiskInterface.VirtIO).count();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    ArrayList<EngineMessage> messages = new ArrayList<>();
    if (pciInUse > maxPciSlots) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
    } else if (VmCommand.MAX_IDE_SLOTS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.IDE).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
    } else if (VmCommand.MAX_VIRTIO_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO_SCSI).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS);
    } else if (VmCommand.MAX_SPAPR_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.SPAPR_VSCSI).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS);
    }
    if (!messages.isEmpty()) {
        return new ValidationResult(messages);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmId());
    return validate(VmValidator.checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, diskVmElements, VmDeviceUtils.hasVirtioScsiController(getVmId()), VmDeviceUtils.hasWatchdog(getVmId()), VmDeviceUtils.hasMemoryBalloon(getVmId()), VmDeviceUtils.hasSoundDevice(getVmId())));
}
#method_after
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmId());
    return validate(VmValidator.checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, diskVmElements, getVmDeviceUtils().hasVirtioScsiController(getVmId()), getVmDeviceUtils().hasWatchdog(getVmId()), getVmDeviceUtils().hasMemoryBalloon(getVmId()), getVmDeviceUtils().hasSoundDevice(getVmId())));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, false, true, true, storageToDisksMap.get(storage.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, false, true, true, storageToDisksMap.get(storage.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void updateSmartCardDevices() {
    // if vm smartcard settings is different from device source's
    // add or remove the smartcard according to user request
    boolean smartcardOnDeviceSource = getInstanceTypeId() != null ? getInstanceType().isSmartcardEnabled() : getVmTemplate().isSmartcardEnabled();
    if (getVm().isSmartcardEnabled() != smartcardOnDeviceSource) {
        VmDeviceUtils.updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
    }
}
#method_after
private void updateSmartCardDevices() {
    // if vm smartcard settings is different from device source's
    // add or remove the smartcard according to user request
    boolean smartcardOnDeviceSource = getInstanceTypeId() != null ? getInstanceType().isSmartcardEnabled() : getVmTemplate().isSmartcardEnabled();
    if (getVm().isSmartcardEnabled() != smartcardOnDeviceSource) {
        getVmDeviceUtils().updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
    }
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = VmDeviceUtils.hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#method_after
protected void copyVmDevices() {
    getVmDeviceUtils().copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    VmDeviceUtils.copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    getVmDeviceUtils().copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#end_block

#method_before
protected boolean isVirtioScsiControllerAttached(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#method_after
protected boolean isVirtioScsiControllerAttached(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getValidationMessages());
}
#method_after
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getValidationMessages());
}
#end_block

#method_before
private boolean checkPciAndIdeLimit(VmNic oldIface, List<VmNic> interfaces, Version clusterCompatibilityVersion) {
    interfaces.remove(oldIface);
    interfaces.add(getParameters().getInterface());
    return validate(VmValidator.checkPciAndIdeLimit(getVmTemplate().getOsId(), clusterCompatibilityVersion, getVmTemplate().getNumOfMonitors(), interfaces, getTemplateDiskVmElements(), VmDeviceUtils.hasVirtioScsiController(getVmTemplate().getId()), VmDeviceUtils.hasWatchdog(getVmTemplate().getId()), VmDeviceUtils.hasMemoryBalloon(getVmTemplate().getId()), VmDeviceUtils.hasSoundDevice(getVmTemplate().getId())));
}
#method_after
private boolean checkPciAndIdeLimit(VmNic oldIface, List<VmNic> interfaces, Version clusterCompatibilityVersion) {
    interfaces.remove(oldIface);
    interfaces.add(getParameters().getInterface());
    return validate(VmValidator.checkPciAndIdeLimit(getVmTemplate().getOsId(), clusterCompatibilityVersion, getVmTemplate().getNumOfMonitors(), interfaces, getTemplateDiskVmElements(), getVmDeviceUtils().hasVirtioScsiController(getVmTemplate().getId()), getVmDeviceUtils().hasWatchdog(getVmTemplate().getId()), getVmDeviceUtils().hasMemoryBalloon(getVmTemplate().getId()), getVmDeviceUtils().hasSoundDevice(getVmTemplate().getId())));
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion()).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getParameters().getVmTemplateData().getThreadsPerCpu(), getVmTemplate().getCompatibilityVersion().toString(), getReturnValue().getValidationMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmTemplateId());
        if (!validate(VmValidator.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, diskVmElements, VmDeviceUtils.hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled()))) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
            return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion()).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getParameters().getVmTemplateData().getThreadsPerCpu(), getVmTemplate().getCompatibilityVersion().toString(), getReturnValue().getValidationMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmTemplateId());
        if (!validate(VmValidator.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, diskVmElements, getVmDeviceUtils().hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), getVmDeviceUtils().hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled()))) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
            return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.hasSoundDevice(getParameters().getVmTemplateData().getId());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : getVmDeviceUtils().hasSoundDevice(getParameters().getVmTemplateData().getId());
}
#end_block

#method_before
private void updateVmTemplate() {
    VmHandler.updateVmInitToDB(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    VmDeviceUtils.updateSoundDevice(oldTemplate, getVmTemplate(), getVmTemplate().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled());
    VmDeviceUtils.updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    VmDeviceUtils.updateVirtioScsiController(getVmTemplateId(), getParameters().isVirtioScsiEnabled());
    if (getParameters().isBalloonEnabled() != null) {
        VmDeviceUtils.updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
    }
}
#method_after
private void updateVmTemplate() {
    VmHandler.updateVmInitToDB(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    getVmDeviceUtils().updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    getVmDeviceUtils().updateSoundDevice(oldTemplate, getVmTemplate(), getVmTemplate().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled());
    getVmDeviceUtils().updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    getVmDeviceUtils().updateVirtioScsiController(getVmTemplateId(), getParameters().isVirtioScsiEnabled());
    if (getParameters().isBalloonEnabled() != null) {
        getVmDeviceUtils().updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), getVmDeviceUtils().getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters()) || isClusterLevelChange();
}
#end_block

#method_before
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#method_after
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.hasMemoryBalloon(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : getVmDeviceUtils().hasMemoryBalloon(getVmId());
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.hasSoundDevice(getVmId());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : getVmDeviceUtils().hasSoundDevice(getVmId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().getInterface().setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().getInterface().setId(Guid.newGuid());
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getVmNicDao().save(getParameters().getInterface());
    VmDeviceUtils.addInterface(getParameters().getVmTemplateId(), getParameters().getInterface().getId(), getParameters().getInterface().isPlugged(), getParameters().getInterface().isPassthrough());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getParameters().getInterface().setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().getInterface().setId(Guid.newGuid());
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getVmNicDao().save(getParameters().getInterface());
    getVmDeviceUtils().addInterface(getParameters().getVmTemplateId(), getParameters().getInterface().getId(), getParameters().getInterface().isPlugged(), getParameters().getInterface().isPassthrough());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    VmTemplateHandler.updateDisksFromDb(getVmTemplate());
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!updateVnicForBackwardCompatibility()) {
            return false;
        }
        List<VmNic> interfacesForCheckPciLimit = new ArrayList<>(interfaces);
        interfacesForCheckPciLimit.add(getParameters().getInterface());
        if (!validate(VmValidator.checkPciAndIdeLimit(getVmTemplate().getOsId(), getCluster().getCompatibilityVersion(), getVmTemplate().getNumOfMonitors(), interfacesForCheckPciLimit, getTemplateDiskVmElements(), VmDeviceUtils.hasVirtioScsiController(getVmTemplate().getId()), VmDeviceUtils.hasWatchdog(getVmTemplate().getId()), VmDeviceUtils.hasMemoryBalloon(getVmTemplate().getId()), VmDeviceUtils.hasSoundDevice(getVmTemplate().getId())))) {
            return false;
        }
        Version clusterCompatibilityVersion = getCluster().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        return validate(nicValidator.isCompatibleWithOs()) && validate(nicValidator.profileValid(getVmTemplate().getClusterId())) && validate(nicValidator.typeMatchesProfile()) && validate(nicValidator.passthroughIsLinked());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    VmTemplateHandler.updateDisksFromDb(getVmTemplate());
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!updateVnicForBackwardCompatibility()) {
            return false;
        }
        List<VmNic> interfacesForCheckPciLimit = new ArrayList<>(interfaces);
        interfacesForCheckPciLimit.add(getParameters().getInterface());
        if (!validate(VmValidator.checkPciAndIdeLimit(getVmTemplate().getOsId(), getCluster().getCompatibilityVersion(), getVmTemplate().getNumOfMonitors(), interfacesForCheckPciLimit, getTemplateDiskVmElements(), getVmDeviceUtils().hasVirtioScsiController(getVmTemplate().getId()), getVmDeviceUtils().hasWatchdog(getVmTemplate().getId()), getVmDeviceUtils().hasMemoryBalloon(getVmTemplate().getId()), getVmDeviceUtils().hasSoundDevice(getVmTemplate().getId())))) {
            return false;
        }
        Version clusterCompatibilityVersion = getCluster().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        return validate(nicValidator.isCompatibleWithOs()) && validate(nicValidator.profileValid(getVmTemplate().getClusterId())) && validate(nicValidator.typeMatchesProfile()) && validate(nicValidator.passthroughIsLinked());
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
        if (template != null) {
            if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) == null) {
                appendCustomValueSeparatedByComma("TemplatesNames", template.getName());
                TagsTemplateMap map = new TagsTemplateMap(getTagId(), templateGuid);
                DbFacade.getInstance().getTagDao().attachTemplateToTag(map);
                noActionDone = false;
            } else {
                appendCustomValueSeparatedByComma("TemplatesNamesExists", template.getName());
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
        if (template != null) {
            if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) == null) {
                appendCustomCommaSeparatedValue("TemplatesNames", template.getName());
                TagsTemplateMap map = new TagsTemplateMap(getTagId(), templateGuid);
                DbFacade.getInstance().getTagDao().attachTemplateToTag(map);
                noActionDone = false;
            } else {
                appendCustomCommaSeparatedValue("TemplatesNamesExists", template.getName());
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<ActionGroup> groupsToDetach = getParameters().getActionGroups();
    for (ActionGroup group : groupsToDetach) {
        getRoleGroupMapDao().remove(group, getParameters().getRoleId());
        appendCustomValueSeparatedByComma("ActionGroup", group.toString());
    }
    // If the role didn't allow viewing children in the first place, removing action groups won't change that
    Role role = getRole();
    if (role.allowsViewingChildren()) {
        boolean shouldAllowViewingChildren = false;
        // Go over all the REMAINING action groups
        List<ActionGroup> groups = getActionGroupsByRoleId(role.getId());
        for (ActionGroup group : groups) {
            if (group.allowsViewingChildren()) {
                shouldAllowViewingChildren = true;
                break;
            }
        }
        if (!shouldAllowViewingChildren) {
            role.setAllowsViewingChildren(false);
            getRoleDao().update(role);
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<ActionGroup> groupsToDetach = getParameters().getActionGroups();
    for (ActionGroup group : groupsToDetach) {
        getRoleGroupMapDao().remove(group, getParameters().getRoleId());
        appendCustomCommaSeparatedValue("ActionGroup", group.toString());
    }
    // If the role didn't allow viewing children in the first place, removing action groups won't change that
    Role role = getRole();
    if (role.allowsViewingChildren()) {
        boolean shouldAllowViewingChildren = false;
        // Go over all the REMAINING action groups
        List<ActionGroup> groups = getActionGroupsByRoleId(role.getId());
        for (ActionGroup group : groups) {
            if (group.allowsViewingChildren()) {
                shouldAllowViewingChildren = true;
                break;
            }
        }
        if (!shouldAllowViewingChildren) {
            role.setAllowsViewingChildren(false);
            getRoleDao().update(role);
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            DbGroup group = DbFacade.getInstance().getDbGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) != null) {
                if (group != null) {
                    appendCustomValueSeparatedByComma("DetachGroupsNames", group.getName());
                }
                DbFacade.getInstance().getTagDao().detachUserGroupFromTag(getTagId(), groupGuid);
                noActionDone = false;
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            DbGroup group = DbFacade.getInstance().getDbGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) != null) {
                if (group != null) {
                    appendCustomCommaSeparatedValue("DetachGroupsNames", group.getName());
                }
                DbFacade.getInstance().getTagDao().detachUserGroupFromTag(getTagId(), groupGuid);
                noActionDone = false;
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean addedGroupThatAllowsViewingChildren = false;
    List<ActionGroup> groups = getParameters().getActionGroups();
    for (ActionGroup group : groups) {
        addedGroupThatAllowsViewingChildren |= group.allowsViewingChildren();
        getRoleGroupMapDao().save(new RoleGroupMap(group, getParameters().getRoleId()));
        appendCustomValueSeparatedByComma("ActionGroup", group.toString());
    }
    // Only adding groups that allow viewing children could make a role allow viewing its children
    if (addedGroupThatAllowsViewingChildren) {
        Role role = getRole();
        // The role should be updated only if it didn't allow viewing children in the first place
        if (!role.allowsViewingChildren()) {
            role.setAllowsViewingChildren(true);
            getRoleDao().update(role);
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    boolean addedGroupThatAllowsViewingChildren = false;
    List<ActionGroup> groups = getParameters().getActionGroups();
    for (ActionGroup group : groups) {
        addedGroupThatAllowsViewingChildren |= group.allowsViewingChildren();
        getRoleGroupMapDao().save(new RoleGroupMap(group, getParameters().getRoleId()));
        appendCustomCommaSeparatedValue("ActionGroup", group.toString());
    }
    // Only adding groups that allow viewing children could make a role allow viewing its children
    if (addedGroupThatAllowsViewingChildren) {
        Role role = getRole();
        // The role should be updated only if it didn't allow viewing children in the first place
        if (!role.allowsViewingChildren()) {
            role.setAllowsViewingChildren(true);
            getRoleDao().update(role);
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TagsUserMap map;
    if (getTagId() != null) {
        for (Guid userGuid : getUserList()) {
            DbUser user = DbFacade.getInstance().getDbUserDao().get(userGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserByTagIdAndByuserId(getTagId(), userGuid) == null) {
                map = new TagsUserMap(getTagId(), userGuid);
                DbFacade.getInstance().getTagDao().attachUserToTag(map);
                noActionDone = false;
                if (user != null) {
                    appendCustomValueSeparatedByComma("AttachUsersNames", user.getLoginName());
                }
            } else {
                if (user != null) {
                    appendCustomValueSeparatedByComma("AttachUsersNamesExists", user.getLoginName());
                }
            }
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    TagsUserMap map;
    if (getTagId() != null) {
        for (Guid userGuid : getUserList()) {
            DbUser user = DbFacade.getInstance().getDbUserDao().get(userGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserByTagIdAndByuserId(getTagId(), userGuid) == null) {
                map = new TagsUserMap(getTagId(), userGuid);
                DbFacade.getInstance().getTagDao().attachUserToTag(map);
                noActionDone = false;
                if (user != null) {
                    appendCustomCommaSeparatedValue("AttachUsersNames", user.getLoginName());
                }
            } else {
                if (user != null) {
                    appendCustomCommaSeparatedValue("AttachUsersNamesExists", user.getLoginName());
                }
            }
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    for (Guid vdsId : getVdsList()) {
        if (getTagId() != null && DbFacade.getInstance().getTagDao().getTagVdsByTagIdAndByVdsId(getTagId(), vdsId) != null) {
            VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
            if (vds != null) {
                appendCustomValueSeparatedByComma("VdsNames", vds.getName());
            }
            DbFacade.getInstance().getTagDao().detachVdsFromTag(getTagId(), vdsId);
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    for (Guid vdsId : getVdsList()) {
        if (getTagId() != null && DbFacade.getInstance().getTagDao().getTagVdsByTagIdAndByVdsId(getTagId(), vdsId) != null) {
            VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
            if (vds != null) {
                appendCustomCommaSeparatedValue("VdsNames", vds.getName());
            }
            DbFacade.getInstance().getTagDao().detachVdsFromTag(getTagId(), vdsId);
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid userGuid : getUserList()) {
            DbUser user = DbFacade.getInstance().getDbUserDao().get(userGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserByTagIdAndByuserId(getTagId(), userGuid) != null) {
                if (user != null) {
                    appendCustomValueSeparatedByComma("DetachUsersNames", user.getLoginName());
                }
                DbFacade.getInstance().getTagDao().detachUserFromTag(getTagId(), userGuid);
                noActionDone = false;
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid userGuid : getUserList()) {
            DbUser user = DbFacade.getInstance().getDbUserDao().get(userGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserByTagIdAndByuserId(getTagId(), userGuid) != null) {
                if (user != null) {
                    appendCustomCommaSeparatedValue("DetachUsersNames", user.getLoginName());
                }
                DbFacade.getInstance().getTagDao().detachUserFromTag(getTagId(), userGuid);
                noActionDone = false;
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TagsVdsMap map;
    if (getTagId() != null) {
        for (Guid vdsId : getVdsList()) {
            VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
            if (DbFacade.getInstance().getTagDao().getTagVdsByTagIdAndByVdsId(getTagId(), vdsId) == null) {
                if (vds != null) {
                    appendCustomValueSeparatedByComma("VdsNames", vds.getName());
                }
                map = new TagsVdsMap(getTagId(), vdsId);
                DbFacade.getInstance().getTagDao().attachVdsToTag(map);
                noActionDone = false;
            } else {
                if (vds != null) {
                    appendCustomValueSeparatedByComma("VdsNamesExists", vds.getName());
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TagsVdsMap map;
    if (getTagId() != null) {
        for (Guid vdsId : getVdsList()) {
            VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
            if (DbFacade.getInstance().getTagDao().getTagVdsByTagIdAndByVdsId(getTagId(), vdsId) == null) {
                if (vds != null) {
                    appendCustomCommaSeparatedValue("VdsNames", vds.getName());
                }
                map = new TagsVdsMap(getTagId(), vdsId);
                DbFacade.getInstance().getTagDao().attachVdsToTag(map);
                noActionDone = false;
            } else {
                if (vds != null) {
                    appendCustomCommaSeparatedValue("VdsNamesExists", vds.getName());
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            DbGroup group = DbFacade.getInstance().getDbGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) == null) {
                TagsUserGroupMap map = new TagsUserGroupMap(groupGuid, getTagId());
                DbFacade.getInstance().getTagDao().attachUserGroupToTag(map);
                noActionDone = false;
                if (group != null) {
                    appendCustomValueSeparatedByComma("AttachGroupsNames", group.getName());
                }
            } else {
                if (group != null) {
                    appendCustomValueSeparatedByComma("AttachGroupsNamesExists", group.getName());
                }
            }
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            DbGroup group = DbFacade.getInstance().getDbGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) == null) {
                TagsUserGroupMap map = new TagsUserGroupMap(groupGuid, getTagId());
                DbFacade.getInstance().getTagDao().attachUserGroupToTag(map);
                noActionDone = false;
                if (group != null) {
                    appendCustomCommaSeparatedValue("AttachGroupsNames", group.getName());
                }
            } else {
                if (group != null) {
                    appendCustomCommaSeparatedValue("AttachGroupsNamesExists", group.getName());
                }
            }
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    for (Guid vmGuid : getVmsList()) {
        if (getTagId() != null && DbFacade.getInstance().getTagDao().getTagVmByTagIdAndByVmId(getTagId(), vmGuid) != null) {
            VM vm = DbFacade.getInstance().getVmDao().get(vmGuid);
            if (vm != null) {
                appendCustomValueSeparatedByComma("VmsNames", vm.getName());
            }
            DbFacade.getInstance().getTagDao().detachVmFromTag(getTagId(), vmGuid);
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    for (Guid vmGuid : getVmsList()) {
        if (getTagId() != null && DbFacade.getInstance().getTagDao().getTagVmByTagIdAndByVmId(getTagId(), vmGuid) != null) {
            VM vm = DbFacade.getInstance().getVmDao().get(vmGuid);
            if (vm != null) {
                appendCustomCommaSeparatedValue("VmsNames", vm.getName());
            }
            DbFacade.getInstance().getTagDao().detachVmFromTag(getTagId(), vmGuid);
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) != null) {
            VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
            if (template != null) {
                appendCustomValueSeparatedByComma("TemplatesNames", template.getName());
                DbFacade.getInstance().getTagDao().detachTemplateFromTag(getTagId(), templateGuid);
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) != null) {
            VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
            if (template != null) {
                appendCustomCommaSeparatedValue("TemplatesNames", template.getName());
                DbFacade.getInstance().getTagDao().detachTemplateFromTag(getTagId(), templateGuid);
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid vmGuid : getVmsList()) {
            VM vm = DbFacade.getInstance().getVmDao().get(vmGuid);
            if (DbFacade.getInstance().getTagDao().getTagVmByTagIdAndByVmId(getTagId(), vmGuid) == null) {
                if (vm != null) {
                    appendCustomValueSeparatedByComma("VmsNames", vm.getName());
                }
                TagsVmMap map = new TagsVmMap(getTagId(), vmGuid);
                DbFacade.getInstance().getTagDao().attachVmToTag(map);
                noActionDone = false;
            } else {
                if (vm != null) {
                    appendCustomValueSeparatedByComma("VmsNamesExists", vm.getName());
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid vmGuid : getVmsList()) {
            VM vm = DbFacade.getInstance().getVmDao().get(vmGuid);
            if (DbFacade.getInstance().getTagDao().getTagVmByTagIdAndByVmId(getTagId(), vmGuid) == null) {
                if (vm != null) {
                    appendCustomCommaSeparatedValue("VmsNames", vm.getName());
                }
                TagsVmMap map = new TagsVmMap(getTagId(), vmGuid);
                DbFacade.getInstance().getTagDao().attachVmToTag(map);
                noActionDone = false;
            } else {
                if (vm != null) {
                    appendCustomCommaSeparatedValue("VmsNamesExists", vm.getName());
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
protected boolean migrateAllVms(ExecutionContext parentContext, boolean HAOnly) {
    boolean succeeded = true;
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // check if there is host which can be used for HE
            if (!canScheduleVm(vm)) {
                succeeded = false;
                appendCustomValueSeparatedByComma("failedVms", vm.getName());
                log.error("There is no host capable of running the hosted engine VM");
            }
            // The Hosted Engine vm is migrated by the HA agent
            continue;
        }
        // if HAOnly is true check that vm is HA (auto_startup should be true)
        if (vm.getStatus() != VMStatus.MigratingFrom && (!HAOnly || vm.isAutoStartup())) {
            if (!migrateVm(vm, parentContext)) {
                succeeded = false;
                appendCustomValueSeparatedByComma("failedVms", vm.getName());
                log.error("Failed to migrate VM '{}'", vm.getName());
            }
        }
    }
    return succeeded;
}
#method_after
protected boolean migrateAllVms(ExecutionContext parentContext, boolean HAOnly) {
    boolean succeeded = true;
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // check if there is host which can be used for HE
            if (!canScheduleVm(vm)) {
                succeeded = false;
                appendCustomCommaSeparatedValue("failedVms", vm.getName());
                log.error("There is no host capable of running the hosted engine VM");
            }
            // The Hosted Engine vm is migrated by the HA agent
            continue;
        }
        // if HAOnly is true check that vm is HA (auto_startup should be true)
        if (vm.getStatus() != VMStatus.MigratingFrom && (!HAOnly || vm.isAutoStartup())) {
            if (!migrateVm(vm, parentContext)) {
                succeeded = false;
                appendCustomCommaSeparatedValue("failedVms", vm.getName());
                log.error("Failed to migrate VM '{}'", vm.getName());
            }
        }
    }
    return succeeded;
}
#end_block

#method_before
@Test
public void appendCustomValue() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = "foo";
    final String value = NAME;
    final String sep = "_";
    b.appendCustomValueUsingCustomSeparator(key, value, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value, s);
}
#method_after
@Test
public void appendCustomValue() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = "foo";
    final String value = NAME;
    final String sep = "_";
    b.appendCustomValue(key, value, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value, s);
}
#end_block

#method_before
@Test
public void appendCustomValueAppend() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = "foo";
    final String value = NAME;
    final String newVal = "bar";
    final String sep = "_";
    b.addCustomValue(key, value);
    b.appendCustomValueUsingCustomSeparator(key, newVal, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value + sep + newVal, s);
}
#method_after
@Test
public void appendCustomValueAppend() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = "foo";
    final String value = NAME;
    final String newVal = "bar";
    final String sep = "_";
    b.addCustomValue(key, value);
    b.appendCustomValue(key, newVal, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value + sep + newVal, s);
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void appendCustomValueDoesntHandleNullKeys() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = null;
    final String value = NAME;
    final String sep = "_";
    b.appendCustomValueUsingCustomSeparator(key, value, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value, s);
}
#method_after
@Test(expected = NullPointerException.class)
public void appendCustomValueDoesntHandleNullKeys() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = null;
    final String value = NAME;
    final String sep = "_";
    b.appendCustomValue(key, value, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value, s);
}
#end_block

#method_before
@Test
public void appendCustomValueAppendsWithNull() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = "foo";
    final String value = null;
    final String newVal = "bar";
    final String sep = "_";
    b.addCustomValue(key, value);
    b.appendCustomValueUsingCustomSeparator(key, newVal, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value + sep + newVal, s);
}
#method_after
@Test
public void appendCustomValueAppendsWithNull() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = "foo";
    final String value = null;
    final String newVal = "bar";
    final String sep = "_";
    b.addCustomValue(key, value);
    b.appendCustomValue(key, newVal, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value + sep + newVal, s);
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void appendCustomValueUsesNullSeparator() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = "foo";
    final String value = NAME;
    final String newVal = "bar";
    final String sep = null;
    b.addCustomValue(key, value);
    b.appendCustomValueUsingCustomSeparator(key, newVal, sep);
}
#method_after
@Test
public void appendCustomValueUsesNullSeparator() {
    final AuditLogableBase b = new TestAuditLogableBase();
    final String key = "foo";
    final String value = NAME;
    final String newVal = "bar";
    final String sep = null;
    b.addCustomValue(key, value);
    b.appendCustomValue(key, newVal, sep);
    final String s = b.getCustomValue(key);
    assertEquals(value + sep + newVal, s);
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    reportExternalMacs();
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    return true;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(macPool);
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getClusterId(), getStoragePoolId(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = macPool.allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getEffectiveCompatibilityVersion());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(macPool);
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getClusterId(), getStoragePoolId(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = macPool.allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    } else {
        reportExternalMacs();
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getEffectiveCompatibilityVersion());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
@Before
public void setUp() {
    // init the injector with the osRepository instance
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(null, Collections.singletonList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#method_after
@Before
public void setUp() {
    injectorRule.bind(VmDeviceUtils.class, vmDeviceUtils);
    // init the injector with the osRepository instance
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(null, Collections.singletonList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#end_block

#method_before
private void initCommand(OvfEntityData resultOvfEntityData) {
    ImportVmParameters parameters = createParametersWhenImagesExistOnTargetStorageDomain();
    initUnregisteredOVFData(resultOvfEntityData);
    cmd = spy(new ImportVmParametersImportVmFromConfigurationCommandStub(parameters, macPoolPerCluster, externalVmMacsFinder));
    cmd.init();
    doReturn(mock(MacPool.class)).when(cmd).getMacPool();
    validator = spy(new ImportValidator(parameters));
    doReturn(validator).when(cmd).getImportValidator();
    mockStoragePool();
    doReturn(storagePool).when(validator).getStoragePool();
}
#method_after
private void initCommand(OvfEntityData resultOvfEntityData) {
    ImportVmParameters parameters = createParametersWhenImagesExistOnTargetStorageDomain();
    initUnregisteredOVFData(resultOvfEntityData);
    injectorRule.bind(VmDeviceUtils.class, vmDeviceUtils);
    cmd = spy(new ImportVmParametersImportVmFromConfigurationCommandStub(parameters, macPoolPerCluster, externalVmMacsFinder));
    cmd.init();
    doReturn(mock(MacPool.class)).when(cmd).getMacPool();
    validator = spy(new ImportValidator(parameters));
    doReturn(validator).when(cmd).getImportValidator();
    mockStoragePool();
    doReturn(storagePool).when(validator).getStoragePool();
}
#end_block

#method_before
public void addToCallbackMap(CommandEntity cmdEntity) {
    if (!commandContainers.containsKey(cmdEntity.getId())) {
        CommandBase<?> cmd = retrieveCommand(cmdEntity.getId());
        if (cmd != null && cmd.getCallback() != null) {
            addToCallbackMap(cmdEntity.getId(), new CommandContainer(cmd.getCallback(), pollingRate));
        }
    }
}
#method_after
public void addToCallbackMap(CommandEntity cmdEntity) {
    if (!callbacksTiming.containsKey(cmdEntity.getId())) {
        CommandBase<?> cmd = retrieveCommand(cmdEntity.getId());
        if (cmd != null && cmd.getCallback() != null) {
            CallbackTiming callbackTiming = new CallbackTiming(cmd.getCallback(), pollingRate);
            if (cmdEntity.isWaitingForEvent()) {
                long waitOnEventEndTime = System.currentTimeMillis() + TimeUnit.MINUTES.toMillis(Config.<Integer>getValue(ConfigValues.CoCoWaitForEventInMinutes));
                callbackTiming.setWaitOnEventEndTime(waitOnEventEndTime);
            }
            addToCallbackMap(cmdEntity.getId(), callbackTiming);
        }
    }
}
#end_block

#method_before
@PostConstruct
private void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
}
#method_after
@PostConstruct
private void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
    // active commands managed by callbacks and not managed by async task manager need to reacquire locks
    // on engine restart
    getCommands(false).stream().filter(x -> x.isCallbackEnabled()).filter(x -> !x.isCallbackNotified()).filter(x -> x.getCommandStatus().isDuringExecution()).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> retrieveCommand(x.getId()).reacquireLocks());
}
#end_block

#method_before
public void addToCallbackMap(Guid commandId, CommandContainer commandContainer) {
    commandContainers.put(commandId, commandContainer);
}
#method_after
public void addToCallbackMap(Guid commandId, CallbackTiming callbackTiming) {
    callbacksTiming.put(commandId, callbackTiming);
}
#end_block

#method_before
private CommandBase<?> retrieveCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        if (cmdContext.getLock() == null) {
            cmdContext.withLock(new EngineLock((Map<String, Pair<String, String>>) cmdEntity.getData().get(EXCLUSIVE_LOCKS), (Map<String, Pair<String, String>>) cmdEntity.getData().get(SHARED_LOCKS)));
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        command.setCommandStatus(cmdEntity.getCommandStatus(), false);
        command.setCommandData(cmdEntity.getData());
        command.setReturnValue(cmdEntity.getReturnValue());
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#method_after
private CommandBase<?> retrieveCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        command.setCommandStatus(cmdEntity.getCommandStatus(), false);
        command.setCommandData(cmdEntity.getData());
        command.setReturnValue(cmdEntity.getReturnValue());
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#end_block

#method_before
public void markExpiredCommandsAsFailure() {
    for (Guid commandId : commandContainers.keySet()) {
        List<Guid> childCmdIds = getChildCommandIds(commandId);
        if (childCmdIds.isEmpty()) {
            markExpiredCommandAsFailure(commandId);
        } else {
            childCmdIds.forEach(this::markExpiredCommandAsFailure);
        }
    }
}
#method_after
public void markExpiredCommandsAsFailure() {
    for (Guid commandId : callbacksTiming.keySet()) {
        List<Guid> childCmdIds = getChildCommandIds(commandId);
        if (childCmdIds.isEmpty()) {
            markExpiredCommandAsFailure(commandId);
        } else {
            childCmdIds.forEach(this::markExpiredCommandAsFailure);
        }
    }
}
#end_block

#method_before
private CompensationContext createCompensationContext(TransactionScopeOption transactionScopeOption, boolean forceCompensation) {
    if (transactionScopeOption == TransactionScopeOption.Suppress && !forceCompensation) {
        return NoOpCompensationContext.getInstance();
    }
    return createDefaultCompensationContext(commandId);
}
#method_after
private CompensationContext createCompensationContext(TransactionScopeOption transactionScopeOption, boolean forceCompensation) {
    if (transactionScopeOption == TransactionScopeOption.Suppress && !forceCompensation) {
        return NoOpCompensationContext.getInstance();
    }
    return createDefaultCompensationContext();
}
#end_block

#method_before
protected DefaultCompensationContext createDefaultCompensationContext(Guid commandId) {
    DefaultCompensationContext defaultContext = new DefaultCompensationContext();
    defaultContext.setCommandId(commandId);
    defaultContext.setCommandType(getClass().getName());
    defaultContext.setBusinessEntitySnapshotDao(getBusinessEntitySnapshotDao());
    defaultContext.setSnapshotSerializer(SerializationFactory.getSerializer());
    return defaultContext;
}
#method_after
protected DefaultCompensationContext createDefaultCompensationContext() {
    DefaultCompensationContext defaultContext = new DefaultCompensationContext();
    defaultContext.setCommandId(commandId);
    defaultContext.setCommandType(getClass().getName());
    defaultContext.setBusinessEntitySnapshotDao(getBusinessEntitySnapshotDao());
    defaultContext.setSnapshotSerializer(SerializationFactory.getSerializer());
    return defaultContext;
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand(), getCallback() != null);
            CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        persistCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        updateCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
private void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) getDaoForEntity(entityClass)).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    deletedOrUpdateEntity(entityClass, (BusinessEntity<Serializable>) snapshotData);
                    break;
                case UPDATED_ONLY_ENTITY:
                    getDaoForEntity(entityClass).update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    getDaoForEntity(entityClass).remove(snapshotData);
                    break;
                case TRANSIENT_ENTITY:
                    objectCompensation.compensate(CommandBase.this, (TransientCompensationBusinessEntity) snapshotData);
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Unknown %s value, unable to compensate value %s.", SnapshotType.class.getName(), snapshot.getSnapshotType()));
            }
        }
        getCompensationContext().afterCompensationCleanup();
        return null;
    });
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            // NOTE: this update persists updates made during the endSuccessfully()/endWithFailure() execution.
            // The update is done intentionally after the freeLock() call, change with care.
            persistCommandIfNeeded();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
public void handleChildCommands() {
    if (getCallback() != null) {
        List<Guid> childCommands = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
        List<VdcActionParametersBase> parameters = new LinkedList<>();
        for (Guid id : childCommands) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(id);
            if (command.getParameters().getShouldBeEndedByParent()) {
                command.getParameters().setShouldBeEndedByParent(false);
                command.getParameters().setCommandType(command.getActionType());
                parameters.add(command.getParameters());
            }
        }
        getParameters().setImagesParameters(parameters);
    }
}
#method_after
public void handleChildCommands() {
    if (getCallback() != null) {
        List<Guid> childCommands = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
        List<VdcActionParametersBase> parameters = new LinkedList<>();
        for (Guid id : childCommands) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(id);
            if (command.getParameters().getEndProcedure() == EndProcedure.PARENT_MANAGED || command.getParameters().getEndProcedure() == EndProcedure.FLOW_MANAGED) {
                command.getParameters().setEndProcedure(EndProcedure.FLOW_MANAGED);
                command.getParameters().setCommandType(command.getActionType());
                parameters.add(command.getParameters());
            }
        }
        getParameters().setImagesParameters(parameters);
    }
}
#end_block

#method_before
private boolean handleCommandExecutionEnded() {
    boolean shouldEndAction = parentHasCallback() ? !getParameters().getShouldBeEndedByParent() : true;
    CommandStatus newStatus = isEndSuccessfully() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED;
    if (getCallback() == null) {
        setCommandStatus(newStatus);
        if (!shouldEndAction) {
            logEndWillBeExecutedByParent(newStatus);
        }
    }
    return shouldEndAction;
}
#method_after
private boolean handleCommandExecutionEnded() {
    boolean shouldEndAction = parentHasCallback() ? isEndProcedureApplicableToEndAction() : true;
    CommandStatus newStatus = isEndSuccessfully() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED;
    if (getCallback() == null) {
        setCommandStatus(newStatus);
        if (!shouldEndAction) {
            logEndWillBeExecutedByParent(newStatus);
        }
    }
    return shouldEndAction;
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
        persistCommandIfNeeded();
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            try {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            log.info("No permission found for user '{}' or one of the groups he is member of," + " when running action '{}', Required permissions are: Action type: '{}' Action group: '{}'" + " Object type: '{}'  Object ID: '{}'.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            logMissingPermission(permSubject);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            setCommandStatus(CommandStatus.FAILED);
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            setCommandStatus(CommandStatus.FAILED);
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (shouldPersistCommand()) {
        persistCommandIfNeeded();
        CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
    }
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    taskIds.forEach(CommandCoordinatorUtil::startPollingTask);
}
#method_after
public void startPollingAsyncTasks(Collection<Guid> taskIds) {
    taskIds.forEach(CommandCoordinatorUtil::startPollingTask);
}
#end_block

#method_before
protected void addValidationMessageVariable(String varName, Object varValue) {
    getReturnValue().getValidationMessages().add(String.format("$%s %s", varName, varValue));
}
#method_after
protected void addValidationMessageVariable(String varName, Object varValue) {
    getReturnValue().getValidationMessages().add(ReplacementUtils.createSetVariableString(varName, varValue));
}
#end_block

#method_before
public Map<String, String> getJobMessageProperties() {
    jobProperties = new HashMap<>();
    List<PermissionSubject> subjects = getPermissionCheckSubjects();
    if (!subjects.isEmpty()) {
        VdcObjectType entityType;
        Guid entityId;
        String value;
        for (PermissionSubject permSubject : subjects) {
            entityType = permSubject.getObjectType();
            entityId = permSubject.getObjectId();
            if (entityType != null && entityId != null) {
                value = DbFacade.getInstance().getEntityNameByIdAndType(entityId, entityType);
                if (value == null) {
                    value = entityId.toString();
                }
                jobProperties.put(entityType.name().toLowerCase(), value);
            }
        }
    }
    return jobProperties;
}
#method_after
public Map<String, String> getJobMessageProperties() {
    jobProperties = new HashMap<>();
    List<PermissionSubject> subjects = getPermissionCheckSubjects();
    if (!subjects.isEmpty()) {
        VdcObjectType entityType;
        Guid entityId;
        String value;
        for (PermissionSubject permSubject : subjects) {
            entityType = permSubject.getObjectType();
            entityId = permSubject.getObjectId();
            if (entityType != null && entityId != null) {
                value = entityDao.getEntityNameByIdAndType(entityId, entityType);
                if (value == null) {
                    value = entityId.toString();
                }
                jobProperties.put(entityType.name().toLowerCase(), value);
            }
        }
    }
    return jobProperties;
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), false);
}
#method_after
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), getCallback() != null, callbackTriggeredByEvent());
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback);
}
#method_after
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback, callbackTriggeredByEvent());
}
#end_block

#method_before
private void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand(), getContext(), getCallback() != null);
    }
}
#method_after
protected void persistCommandIfNeeded() {
    if (shouldPersistCommand()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback, boolean callbackWaitingForEvent) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        commandEntity.setWaitingForEvent(callbackWaitingForEvent);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getSessionSeqId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getContext().getLock() == null ? getCommandData() : getCommandDataWithLocks(getContext().getLock()));
}
#method_after
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getSessionSeqId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#end_block

#method_before
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandCoordinatorUtil.persistCommand(buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled()), getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandEntity executedCmdEntity = buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled());
            executedCmdEntity.setWaitingForEvent(cmdEntity.isCallbackEnabled() ? callbackTriggeredByEvent() : false);
            CommandCoordinatorUtil.persistCommand(executedCmdEntity, getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
protected VdcReturnValueBase runInternalActionWithTasksContext(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runInternalActionWithTasksContext(actionType, parameters, null);
}
#method_after
public VdcReturnValueBase runInternalActionWithTasksContext(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runInternalActionWithTasksContext(actionType, parameters, null);
}
#end_block

#method_before
public static String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final StringBuilder builder = new StringBuilder();
    compose(builder, "type", logType.toString());
    compose(builder, "sd", nullToEmptyString(logable.getStorageDomainId()));
    compose(builder, "dc", nullToEmptyString(logable.getStoragePoolId()));
    compose(builder, "user", nullToEmptyString(logable.getUserId()));
    compose(builder, "cluster", logable.getClusterId().toString());
    compose(builder, "vds", logable.getVdsId().toString());
    compose(builder, "vm", emptyGuidToEmptyString(logable.getVmId()));
    compose(builder, "template", emptyGuidToEmptyString(logable.getVmTemplateId()));
    compose(builder, "customId", StringUtils.defaultString(logable.getCustomId()));
    return builder.toString();
}
#method_after
private String composeObjectId(AuditLogableBase logable, AuditLogType logType, Guid userId) {
    final StringBuilder builder = new StringBuilder();
    compose(builder, "type", logType.toString());
    compose(builder, "sd", nullToEmptyString(logable.getStorageDomainId()));
    compose(builder, "dc", nullToEmptyString(logable.getStoragePoolId()));
    compose(builder, "user", nullToEmptyString(userId));
    compose(builder, "cluster", logable.getClusterId().toString());
    compose(builder, "vds", logable.getVdsId().toString());
    compose(builder, "vm", emptyGuidToEmptyString(logable.getVmId()));
    compose(builder, "template", emptyGuidToEmptyString(logable.getVmTemplateId()));
    compose(builder, "customId", StringUtils.defaultString(logable.getCustomId()));
    return builder.toString();
}
#end_block

#method_before
public static String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final StringBuilder builder = new StringBuilder();
    compose(builder, "type", logType.toString());
    compose(builder, "sd", nullToEmptyString(logable.getStorageDomainId()));
    compose(builder, "dc", nullToEmptyString(logable.getStoragePoolId()));
    compose(builder, "user", nullToEmptyString(logable.getUserId()));
    compose(builder, "cluster", logable.getClusterId().toString());
    compose(builder, "vds", logable.getVdsId().toString());
    compose(builder, "vm", emptyGuidToEmptyString(logable.getVmId()));
    compose(builder, "template", emptyGuidToEmptyString(logable.getVmTemplateId()));
    compose(builder, "customId", StringUtils.defaultString(logable.getCustomId()));
    return builder.toString();
}
#method_after
private String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    return composeObjectId(logable, logType, logable.getUserId());
}
#end_block

#method_before
public static String composeSystemObjectId(AuditLogableBase logable, AuditLogType logType) {
    final StringBuilder builder = new StringBuilder();
    compose(builder, "type", logType.toString());
    compose(builder, "sd", nullToEmptyString(logable.getStorageDomainId()));
    compose(builder, "dc", nullToEmptyString(logable.getStoragePoolId()));
    compose(builder, "user", Guid.Empty.toString());
    compose(builder, "cluster", logable.getClusterId().toString());
    compose(builder, "vds", logable.getVdsId().toString());
    compose(builder, "vm", emptyGuidToEmptyString(logable.getVmId()));
    compose(builder, "template", emptyGuidToEmptyString(logable.getVmTemplateId()));
    compose(builder, "customId", StringUtils.defaultString(logable.getCustomId()));
    return builder.toString();
}
#method_after
public String composeSystemObjectId(AuditLogableBase logable, AuditLogType logType) {
    return composeObjectId(logable, logType, Guid.Empty);
}
#end_block

#method_before
private static void compose(StringBuilder builder, String key, String value) {
    final char DELIMITER = ',';
    final char NAME_VALUE_SEPARATOR = '=';
    if (builder.length() > 0) {
        builder.append(DELIMITER);
    }
    builder.append(key).append(NAME_VALUE_SEPARATOR).append(value);
}
#method_after
private void compose(StringBuilder builder, String key, String value) {
    final char DELIMITER = ',';
    final char NAME_VALUE_SEPARATOR = '=';
    if (builder.length() > 0) {
        builder.append(DELIMITER);
    }
    builder.append(key).append(NAME_VALUE_SEPARATOR).append(value);
}
#end_block

#method_before
private static String emptyGuidToEmptyString(Guid guid) {
    return guid.equals(Guid.Empty) ? "" : guid.toString();
}
#method_after
private String emptyGuidToEmptyString(Guid guid) {
    return guid.equals(Guid.Empty) ? "" : guid.toString();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AuditLog auditLog = getAuditLogDao().get(getParameters().getAuditLogId());
    getAuditLogDao().remove(getParameters().getAuditLogId());
    setAuditLogDetails(auditLog);
    // clean cache manager entry (if exists)
    evict(AuditLogDirector.composeSystemObjectId(this, auditLog.getLogType()));
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    AuditLog auditLog = getAuditLogDao().get(getParameters().getAuditLogId());
    getAuditLogDao().remove(getParameters().getAuditLogId());
    setAuditLogDetails(auditLog);
    // clean cache manager entry (if exists)
    evict(auditLogDirector.composeSystemObjectId(this, auditLog.getLogType()));
    setSucceeded(true);
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (_returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (_returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    // original state (before the merge-attempt).
    if (getDestinationDiskImage() != null) {
        DiskImage curr = getDestinationDiskImage();
        while (!curr.getParentId().equals(getDiskImage().getParentId())) {
            curr = getDiskImageDao().getSnapshotById(curr.getParentId());
            getImageDao().remove(curr.getImageId());
        }
        getDestinationDiskImage().setvolumeFormat(curr.getVolumeFormat());
        getDestinationDiskImage().setVolumeType(curr.getVolumeType());
        getDestinationDiskImage().setParentId(getDiskImage().getParentId());
        getBaseDiskDao().update(curr);
        getImageDao().update(getDestinationDiskImage().getImage());
        updateDiskImageDynamic(getDestinationDiskImage());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    // original state (before the merge-attempt).
    if (getDestinationDiskImage() != null) {
        DiskImage curr = getDestinationDiskImage();
        while (!curr.getParentId().equals(getDiskImage().getParentId())) {
            curr = getDiskImageDao().getSnapshotById(curr.getParentId());
            getImageDao().remove(curr.getImageId());
        }
        getDestinationDiskImage().setvolumeFormat(curr.getVolumeFormat());
        getDestinationDiskImage().setVolumeType(curr.getVolumeType());
        getDestinationDiskImage().setParentId(getDiskImage().getParentId());
        getBaseDiskDao().update(curr);
        getImageDao().update(getDestinationDiskImage().getImage());
        updateDiskImageDynamic(getImageInfoFromVdsm(getDestinationDiskImage()), getDestinationDiskImage());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void hasMultipleClustersForLocalDC() {
    spyCommand(new StoragePoolManagementParameter(createDefaultStoragePool()));
    when(spDao.get(any(Guid.class))).thenReturn(createNewStoragePool());
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Collections.emptyList());
    List<Cluster> clusterList = createClusterList();
    // Create new supported cluster.
    Cluster secondCluster = new Cluster();
    secondCluster.setCompatibilityVersion(VERSION_1_2);
    secondCluster.setName("secondCluster");
    clusterList.add(secondCluster);
    when(clusterDao.getAllForStoragePool(any(Guid.class))).thenReturn(clusterList);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
}
#method_after
@Test
public void hasMultipleClustersForLocalDC() {
    spyCommand(new StoragePoolManagementParameter(createDefaultStoragePool()));
    when(spDao.get(any(Guid.class))).thenReturn(createNewStoragePool());
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Collections.emptyList());
    List<Cluster> clusters = Arrays.asList(new Cluster(), new Cluster());
    when(clusterDao.getAllForStoragePool(any(Guid.class))).thenReturn(clusters);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
}
#end_block

#method_before
@Test
public void hasMultipleHostsForLocalDC() {
    spyCommand(new StoragePoolManagementParameter(createDefaultStoragePool()));
    when(spDao.get(any(Guid.class))).thenReturn(createNewStoragePool());
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Collections.emptyList());
    VDS host = new VDS();
    VDS host2 = new VDS();
    List<VDS> hosts = new ArrayList<>();
    hosts.add(host);
    hosts.add(host2);
    when(vdsDao.getAllForStoragePool(any(Guid.class))).thenReturn(hosts);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
}
#method_after
@Test
public void hasMultipleHostsForLocalDC() {
    spyCommand(new StoragePoolManagementParameter(createDefaultStoragePool()));
    when(spDao.get(any(Guid.class))).thenReturn(createNewStoragePool());
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Collections.emptyList());
    List<VDS> hosts = Arrays.asList(new VDS(), new VDS());
    when(vdsDao.getAllForStoragePool(any(Guid.class))).thenReturn(hosts);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
}
#end_block

#method_before
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warn("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warn("Cannot elect new master, no storage domains found for pool {}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, Comparator.comparing(StorageDomain::getLastTimeUsedAsMaster).thenComparing(Comparator.comparing(StorageDomain::isShared)));
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if (hostedEngineHelper.isHostedEngineStorageDomain(dbStorageDomain)) {
            continue;
        }
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#method_after
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warn("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warn("Cannot elect new master, no storage domains found for pool {}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, Comparator.comparing(StorageDomain::getLastTimeUsedAsMaster).thenComparing(Comparator.comparing(StorageDomain::isLocal)));
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if (hostedEngineHelper.isHostedEngineStorageDomain(dbStorageDomain)) {
            continue;
        }
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getItems() != null ? Linq.<StorageDomain>cast(getItems()) : new ArrayList<StorageDomain>();
    ArrayList<StorageDomain> selectedItems = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    if (getEntity() != null) {
        getAttachStorageCommand().setIsExecutionAllowed(true);
    }
    boolean isMasterPresent = false;
    boolean isISOPresent = false;
    boolean isBackupPresent = false;
    for (StorageDomain domain : items) {
        if (isDomainMasterAndActive(domain)) {
            isMasterPresent = true;
        } else if (domain.getStorageDomainType() == StorageDomainType.ISO) {
            isISOPresent = true;
        } else if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
            isBackupPresent = true;
        }
        if (isMasterPresent && isISOPresent && isBackupPresent) {
            break;
        }
    }
    getAttachISOCommand().setIsExecutionAllowed(false);
    getAttachISOCommand().setIsExecutionAllowed(items.size() > 0 && isMasterPresent && !isISOPresent);
    getAttachBackupCommand().setIsExecutionAllowed(items.size() > 0 && isMasterPresent && !isBackupPresent);
    getDetachCommand().setIsExecutionAllowed(selectedItems.size() > 0 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.DetachStorageDomainFromPool));
    getActivateCommand().setIsExecutionAllowed(selectedItems.size() == 1 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.ActivateStorageDomain));
    getMaintenanceCommand().setIsExecutionAllowed(selectedItems.size() == 1 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.DeactivateStorageDomainWithOvfUpdate));
}
#method_after
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getItems() != null ? Linq.<StorageDomain>cast(getItems()) : new ArrayList<StorageDomain>();
    ArrayList<StorageDomain> selectedItems = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    getAttachStorageCommand().setIsExecutionAllowed(true);
    boolean isMasterPresent = false;
    boolean isISOPresent = false;
    boolean isBackupPresent = false;
    for (StorageDomain domain : items) {
        if (isDomainMasterAndActive(domain)) {
            isMasterPresent = true;
        } else if (domain.getStorageDomainType() == StorageDomainType.ISO) {
            isISOPresent = true;
        } else if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
            isBackupPresent = true;
        }
        if (isMasterPresent && isISOPresent && isBackupPresent) {
            break;
        }
    }
    getAttachISOCommand().setIsExecutionAllowed(false);
    getAttachISOCommand().setIsExecutionAllowed(items.size() > 0 && isMasterPresent && !isISOPresent);
    getAttachBackupCommand().setIsExecutionAllowed(items.size() > 0 && isMasterPresent && !isBackupPresent);
    getDetachCommand().setIsExecutionAllowed(selectedItems.size() > 0 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.DetachStorageDomainFromPool));
    getActivateCommand().setIsExecutionAllowed(selectedItems.size() == 1 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.ActivateStorageDomain));
    getMaintenanceCommand().setIsExecutionAllowed(selectedItems.size() == 1 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.DeactivateStorageDomainWithOvfUpdate));
}
#end_block

#method_before
@Test
public void hasNoStorageDomains() {
    when(spDao.get(any(Guid.class))).thenReturn(createDefaultStoragePool());
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Collections.EMPTY_LIST);
    ValidateTestUtils.runAndAssertValidateSuccess(cmd);
}
#method_after
@Test
public void hasNoStorageDomains() {
    when(spDao.get(any(Guid.class))).thenReturn(createDefaultStoragePool());
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Collections.emptyList());
    ValidateTestUtils.runAndAssertValidateSuccess(cmd);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!previousHostedEngineHost.isPreviousHostId(getVds().getId()) && !new FenceValidator().isStartupTimeoutPassed() || !isQuietTimeFromLastActionPassed()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped(RESTART, null);
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (getVds().getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    RestartVdsReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal;
        retVal = runInternalAction(VdcActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getClusterDao().get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            restartVdsResult = (RestartVdsReturnValue) runInternalAction(VdcActionType.RestartVds, getParameters());
            this.setExecutionContext(ec);
        } else {
            restartVdsResult = (RestartVdsReturnValue) runInternalAction(VdcActionType.RestartVds, getParameters());
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogableBase alb = new AuditLogableBase(getVds().getId());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (!previousHostedEngineHost.isPreviousHostId(getVds().getId()) && !new FenceValidator().isStartupTimeoutPassed()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped(RESTART, null);
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (getVds().getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    RestartVdsReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal;
        retVal = runInternalAction(VdcActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getClusterDao().get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = (RestartVdsReturnValue) runInternalAction(VdcActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogableBase alb = new AuditLogableBase(getVds().getId());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
@Override
public RestartVdsReturnValue getReturnValue() {
    return (RestartVdsReturnValue) (super.getReturnValue());
}
#method_after
@Override
public RestartVdsReturnValue getReturnValue() {
    return (RestartVdsReturnValue) super.getReturnValue();
}
#end_block

#method_before
@Override
public TemplateDiskAttachmentResource getAttachmentResource(@PathParam("id") String id) {
    return inject(new BackendTemplateDiskAttachmentResource(templateId, id));
}
#method_after
@Override
public TemplateDiskAttachmentResource getAttachmentResource(String id) {
    return inject(new BackendTemplateDiskAttachmentResource(templateId, id));
}
#end_block

#method_before
@Override
public Response remove() {
    return null;
}
#method_after
@Override
public Response remove() {
    return getTemplateDiskResource().remove();
}
#end_block

#method_before
private String getUsageLink(UriInfo uriInfo, String httpMethod) {
    String link = uriInfo.getBaseUri().toString() + "model.html#services/";
    List<PathSegment> pathSegments = uriInfo.getPathSegments();
    Node node = ResourceTree.getTree();
    for (PathSegment pathSegment : pathSegments) {
        node = step(node, pathSegment);
    }
    PathSegment lastPathSegment = pathSegments.get(pathSegments.size() - 1);
    if (node.containsAction(lastPathSegment.getPath())) {
        link += processNodeName(node) + "s/methods/";
        link += lastPathSegment.getPath();
    } else {
        // add 's' because section in model.html contains the plural name of the entity:
        // ".../api/model.html#services/vms/methods/start
        link += processNodeName(node) + "/methods/";
        link += getMethodName(httpMethod);
    }
    return link;
}
#method_after
private String getUsageLink(UriInfo uriInfo, String httpMethod) {
    List<PathSegment> pathSegments = uriInfo.getPathSegments();
    ServiceTreeNode node = ServiceTree.getTree();
    // step into the Service tree according to the URL.
    for (PathSegment pathSegment : pathSegments) {
        node = step(node, pathSegment);
    }
    // check whether the last step in the URL represent an 'action'.
    PathSegment lastPathSegment = pathSegments.get(pathSegments.size() - 1);
    // Get the prefix of the link, with or without 's' appended to the
    // entity name, according to whether this action is on a single entity
    // or on the collection context, e.g:
    // .../api/model.html#services/vm/methods/start    //action on *vm*
    // .../api/model.html#services/vms/methods/add     //action on *vms*
    // .../api/model.html#services/vm/methods/update   //action on *vm*
    // .../api/model.html#services/vm/methods/remove   //action on *vm*
    String link = getLinkPrefix(uriInfo, node, lastPathSegment.getPath(), httpMethod);
    if (isAction(node, lastPathSegment.getPath())) {
        link += camelCaseToDash(getAction(node, lastPathSegment.getPath()));
    } else {
        link += getMethodName(httpMethod);
    }
    return link;
}
#end_block

#method_before
private String processNodeName(Node node) {
    String name = node.getName().substring(0, node.getName().indexOf("Resource"));
    String[] parts = name.split(CAMEL_CASE_REGEX);
    name = "";
    for (String part : parts) {
        name += part.toLowerCase() + "-";
    }
    return name.substring(0, name.length() - 1);
}
#method_after
private String processNodeName(ServiceTreeNode node) {
    String[] parts = node.getName().replaceAll("Resource$", "").split(CAMEL_CASE_REGEX);
    StringBuilder builder = new StringBuilder("");
    for (String part : parts) {
        builder.append(part.toLowerCase()).append("-");
    }
    String name = builder.toString();
    return name.substring(0, name.length() - 1);
}
#end_block

#method_before
private String getMethodName(String httpMethod) {
    if (httpMethod.equals("POST")) {
        return "add";
    }
    if (httpMethod.equals("PUT")) {
        return "update";
    }
    if (httpMethod.equals("GET")) {
        return "get";
    }
    if (httpMethod.equals("DELETE")) {
        return "remove";
    }
    // shouldn't reach here.
    return "";
}
#method_after
private String getMethodName(String httpMethod) {
    switch(httpMethod) {
        case "POST":
            return "add";
        case "PUT":
            return "update";
        case "GET":
            return "get";
        case "DELETE":
            return "remove";
        default:
            // shouldn't reach here.
            return "";
    }
}
#end_block

#method_before
private Node step(Node node, PathSegment pathSegment) {
    if (isUUID(pathSegment.getPath())) {
        return node.getSubResource("{id}");
    } else {
        if (node.containsSubResource(pathSegment.getPath())) {
            return node.getSubResource(pathSegment.getPath());
        } else {
            return node;
        }
    }
}
#method_after
private ServiceTreeNode step(ServiceTreeNode node, PathSegment pathSegment) {
    if (isID(pathSegment.getPath(), node)) {
        return node.getSubService("{id}");
    } else {
        if (node.containsSubService(pathSegment.getPath())) {
            return node.getSubService(pathSegment.getPath());
        } else {
            return node;
        }
    }
}
#end_block

#method_before
@Test
public void testAdd() {
    try {
        UriInfo uriInfo = mockUri("vms", "00000001-0001-0001-0001-000000000011", "disks");
        Request request = mockRequest();
        control.replay();
        Fault fault = usageFinder.getUsageMessage(uriInfo, request);
        assertEquals(fault.getDetail(), "For correct usage, see: http://localhost:8080/ovirt-engine/api/model.html#services/vm-disks/methods/add");
    } catch (ClassNotFoundException | IOException | URISyntaxException e) {
        fail();
    }
}
#method_after
@Test
public void testAdd() {
    try {
        UriInfo uriInfo = mockUri("vms", "00000001-0001-0001-0001-000000000011", "disks");
        Request request = mockRequest("POST");
        control.replay();
        Fault fault = usageFinder.getUsageMessage(uriInfo, request);
        assertEquals("For correct usage, see: http://localhost:8080/ovirt-engine/api/model#services/vm-disks/methods/add", fault.getDetail());
    } catch (ClassNotFoundException | IOException | URISyntaxException e) {
        fail();
    }
}
#end_block

#method_before
private Request mockRequest() {
    Request requestMock = control.createMock(Request.class);
    expect(requestMock.getMethod()).andReturn("POST");
    return requestMock;
}
#method_after
private Request mockRequest(String httpMethod) {
    Request requestMock = control.createMock(Request.class);
    expect(requestMock.getMethod()).andReturn(httpMethod);
    return requestMock;
}
#end_block

#method_before
private UriInfo mockUri(String s1, String s2, String s3) throws URISyntaxException {
    UriInfo uriInfoMock = control.createMock(UriInfo.class);
    expect(uriInfoMock.getBaseUri()).andReturn(new URI("http://localhost:8080/ovirt-engine/api/"));
    PathSegment segment1 = control.createMock(PathSegment.class);
    expect(segment1.getPath()).andReturn(s1).anyTimes();
    PathSegment segment2 = control.createMock(PathSegment.class);
    expect(segment2.getPath()).andReturn(s2).anyTimes();
    PathSegment segment3 = control.createMock(PathSegment.class);
    expect(segment3.getPath()).andReturn(s3).anyTimes();
    List<PathSegment> pathSegments = Arrays.asList(new PathSegment[] { segment1, segment2, segment3 });
    expect(uriInfoMock.getPathSegments()).andReturn(pathSegments);
    return uriInfoMock;
}
#method_after
private UriInfo mockUri(String... strings) throws URISyntaxException {
    UriInfo uriInfoMock = control.createMock(UriInfo.class);
    expect(uriInfoMock.getBaseUri()).andReturn(new URI("http://localhost:8080/ovirt-engine/api/"));
    List<PathSegment> pathSegments = new ArrayList<>();
    for (String s : strings) {
        PathSegment segment = control.createMock(PathSegment.class);
        expect(segment.getPath()).andReturn(s).anyTimes();
        pathSegments.add(segment);
    }
    expect(uriInfoMock.getPathSegments()).andReturn(pathSegments);
    return uriInfoMock;
}
#end_block

#method_before
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    Cluster cluster = getCluster(pool);
    pool.getCluster().setId(cluster.getId().toString());
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    org.ovirt.engine.core.common.businessentities.VmPool entity = map(pool);
    VM vm = mapToVM(pool, template, cluster);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    AddVmPoolWithVmsParameters params = new AddVmPoolWithVmsParameters(entity, vm, size, -1);
    params.setConsoleEnabled(!getConsoleDevicesForEntity(template.getId()).isEmpty());
    params.setVirtioScsiEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, template.getId()).isEmpty());
    params.setSoundDeviceEnabled(pool.isSetSoundcardEnabled() ? pool.isSoundcardEnabled() : !VmHelper.getSoundDevicesForEntity(this, template.getId()).isEmpty());
    return performCreate(VdcActionType.AddVmPoolWithVms, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    Cluster cluster = getCluster(pool);
    pool.getCluster().setId(cluster.getId().toString());
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    org.ovirt.engine.core.common.businessentities.VmPool entity = map(pool);
    VM vm = mapToVM(pool, template, cluster);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    AddVmPoolParameters params = new AddVmPoolParameters(entity, vm, size);
    params.setConsoleEnabled(!getConsoleDevicesForEntity(template.getId()).isEmpty());
    params.setVirtioScsiEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, template.getId()).isEmpty());
    params.setSoundDeviceEnabled(pool.isSetSoundcardEnabled() ? pool.isSoundcardEnabled() : !VmHelper.getSoundDevicesForEntity(this, template.getId()).isEmpty());
    return performCreate(VdcActionType.AddVmPool, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
protected VmPool deprecatedPopulate(VmPool model, org.ovirt.engine.core.common.businessentities.VmPool entity) {
    if (model.isSetSize() && model.getSize() > 0) {
        VM vm = getVM(model);
        model.setTemplate(new Template());
        model.getTemplate().setId(vm.getVmtGuid().toString());
        model = getMapper(VM.class, VmPool.class).map(vm, model);
        DisplayHelper.adjustDisplayData(this, model.getVm());
        if (vm.getInstanceTypeId() != null) {
            model.setInstanceType(new org.ovirt.engine.api.model.InstanceType());
            model.getInstanceType().setId(vm.getInstanceTypeId().toString());
        }
    }
    return model;
}
#method_after
@Override
protected VmPool deprecatedPopulate(VmPool model, org.ovirt.engine.core.common.businessentities.VmPool entity) {
    if (model.isSetSize() && model.getSize() > 0) {
        VM vm = getVM(model);
        model.setTemplate(new Template());
        model.getTemplate().setId(vm.getVmtGuid().toString());
        model = getMapper(VM.class, VmPool.class).map(vm, model);
        DisplayHelper.adjustDisplayData(this, model.getVm());
        if (vm.getInstanceTypeId() != null) {
            model.setInstanceType(new InstanceType());
            model.getInstanceType().setId(vm.getInstanceTypeId().toString());
        }
    }
    return model;
}
#end_block

#method_before
protected VM mapToVM(VmPool model, VmTemplate template, Cluster cluster) {
    // apply template
    VmStatic fromTemplate = getMapper(VmTemplate.class, VmStatic.class).map(template, null);
    VmStatic fromInstanceType = null;
    if (model.isSetInstanceType()) {
        InstanceType instanceType = loadInstanceType(model);
        fromTemplate.setInstanceTypeId(instanceType.getId());
        fromInstanceType = VmMapper.map(instanceType, fromTemplate, cluster.getCompatibilityVersion());
        fromInstanceType.setInstanceTypeId(instanceType.getId());
    }
    // override with client-provided data
    VM vm = new VM(getMapper(VmPool.class, VmStatic.class).map(model, fromInstanceType != null ? fromInstanceType : fromTemplate), new VmDynamic(), new VmStatistics());
    return vm;
}
#method_after
protected VM mapToVM(VmPool model, VmTemplate template, Cluster cluster) {
    // apply template
    VmStatic fromTemplate = getMapper(VmTemplate.class, VmStatic.class).map(template, null);
    VmStatic fromInstanceType = null;
    if (model.isSetInstanceType()) {
        org.ovirt.engine.core.common.businessentities.InstanceType instanceType = loadInstanceType(model);
        fromTemplate.setInstanceTypeId(instanceType.getId());
        fromInstanceType = VmMapper.map(instanceType, fromTemplate, cluster.getCompatibilityVersion());
        fromInstanceType.setInstanceTypeId(instanceType.getId());
    }
    // override with client-provided data
    VM vm = new VM(getMapper(VmPool.class, VmStatic.class).map(model, fromInstanceType != null ? fromInstanceType : fromTemplate), new VmDynamic(), new VmStatistics());
    return vm;
}
#end_block

#method_before
private InstanceType loadInstanceType(VmPool pool) {
    validateParameters(pool.getInstanceType(), "id|name");
    GetVmTemplateParameters params;
    String identifier;
    org.ovirt.engine.api.model.InstanceType instanceType = pool.getInstanceType();
    if (instanceType.isSetId()) {
        params = new GetVmTemplateParameters(asGuid(instanceType.getId()));
        identifier = "InstanceType: id=" + instanceType.getId();
    } else {
        params = new GetVmTemplateParameters(instanceType.getName());
        identifier = "InstanceType: name=" + instanceType.getName();
    }
    return getEntity(VmTemplate.class, VdcQueryType.GetInstanceType, params, identifier);
}
#method_after
private org.ovirt.engine.core.common.businessentities.InstanceType loadInstanceType(VmPool pool) {
    validateParameters(pool.getInstanceType(), "id|name");
    GetVmTemplateParameters params;
    String identifier;
    InstanceType instanceType = pool.getInstanceType();
    if (instanceType.isSetId()) {
        params = new GetVmTemplateParameters(asGuid(instanceType.getId()));
        identifier = "InstanceType: id=" + instanceType.getId();
    } else {
        params = new GetVmTemplateParameters(instanceType.getName());
        identifier = "InstanceType: name=" + instanceType.getName();
    }
    return getEntity(VmTemplate.class, VdcQueryType.GetInstanceType, params, identifier);
}
#end_block

#method_before
@Test
public void testVmElementDiskPluggedStatus() {
    DiskVmElement dvePlugged = dao.get(new VmDeviceId(PLUGGED_DISK_ID, FixturesTool.VM_RHEL5_POOL_57));
    assertTrue(dvePlugged.isPlugged());
    DiskVmElement dveUnlugged = dao.get(new VmDeviceId(UNPLUGGED_DISK_ID, FixturesTool.VM_RHEL5_POOL_57));
    assertFalse(dveUnlugged.isPlugged());
}
#method_after
@Test
public void testVmElementDiskPluggedStatus() {
    DiskVmElement dvePlugged = dao.get(new VmDeviceId(PLUGGED_DISK_ID, FixturesTool.VM_RHEL5_POOL_57));
    assertTrue(dvePlugged.isPlugged());
}
#end_block

#method_before
public static VM buildVmsDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(xmlRpcStruct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(xmlRpcStruct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(xmlRpcStruct));
    } catch (IllegalArgumentException ex) {
        log.error("Illegal architecture type: %s, replacing with x86_64", xmlRpcStruct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    } catch (NullPointerException ex) {
        log.error("null architecture type, replacing with x86_64, %s", vm);
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#method_after
public static VM buildVmsDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(xmlRpcStruct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(xmlRpcStruct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(xmlRpcStruct));
    } catch (IllegalArgumentException ex) {
        log.warn("Illegal architecture type: %s, replacing with x86_64", xmlRpcStruct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    } catch (NullPointerException ex) {
        log.warn("null architecture type, replacing with x86_64, %s", vm);
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#end_block

#method_before
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#method_after
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                Guid domainId = Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DomainId));
                List<Guid> domainIds = Collections.singletonList(domainId);
                image.setStorageIds(new ArrayList<>(domainIds));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setElapsedTime(assignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setElapsedTime(assignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
private static void updatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(assignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(assignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(assignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(getPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = assignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(getPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.glusterfsCliPackageName)) {
            Map<String, Object> glusterfsCli = (Map<String, Object>) packages.get(VdsProperties.glusterfsCliPackageName);
            vds.setGlusterfsCliVersion(getPackageRpmVersion(VdsProperties.glusterfsCliPackageName, glusterfsCli));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#method_after
private static void updatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(assignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(assignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(assignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        Map<String, Object> hostOsMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os);
        vds.setHostOs(getPackageVersionFormated(hostOsMap, true));
        if (hostOsMap.containsKey(VdsProperties.pretty_name)) {
            vds.setPrettyName(assignStringValue(hostOsMap, VdsProperties.pretty_name));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = assignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(getPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.glusterfsCliPackageName)) {
            Map<String, Object> glusterfsCli = (Map<String, Object>) packages.get(VdsProperties.glusterfsCliPackageName);
            vds.setGlusterfsCliVersion(getPackageRpmVersion(VdsProperties.glusterfsCliPackageName, glusterfsCli));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#end_block

#method_before
private static void extractInterfaceStatistics(Map<String, Object> dict, NetworkInterface<?> iface) {
    NetworkStatistics stats = iface.getStatistics();
    stats.setReceiveRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_rate));
    stats.setReceiveDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_dropped));
    stats.setReceivedBytes(assignLongValue(dict, VdsProperties.rx_total));
    stats.setTransmitRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_rate));
    stats.setTransmitDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_dropped));
    stats.setTransmittedBytes(assignLongValue(dict, VdsProperties.tx_total));
    stats.setSampleTime(assignDoubleValue(dict, VdsProperties.sample_time));
    iface.setSpeed(assignIntValue(dict, VdsProperties.INTERFACE_SPEED));
}
#method_after
private static void extractInterfaceStatistics(Map<String, Object> dict, NetworkInterface<?> iface) {
    NetworkStatistics stats = iface.getStatistics();
    stats.setReceiveDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_dropped));
    stats.setReceivedBytes(assignLongValue(dict, VdsProperties.rx_total));
    stats.setTransmitDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_dropped));
    stats.setTransmittedBytes(assignLongValue(dict, VdsProperties.tx_total));
    stats.setSampleTime(assignDoubleValue(dict, VdsProperties.sample_time));
    iface.setSpeed(assignIntValue(dict, VdsProperties.INTERFACE_SPEED));
}
#end_block

#method_before
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        vds.setLocalDisksUsage(diskStats);
        diskStatsStruct.entrySet().stream().forEach(entry -> diskStats.put(entry.getKey(), assignLongValue((Map<String, Object>) entry.getValue(), VdsProperties.DISK_STATS_FREE)));
    }
}
#method_after
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        // collect(Collectors.toMap(...)) will not work here as it uses merge() internally and
        // will fail on null values
        diskStatsStruct.entrySet().stream().forEach(e -> diskStats.put(e.getKey(), assignLongValue((Map<String, Object>) e.getValue(), VdsProperties.DISK_STATS_FREE)));
        vds.setLocalDisksUsage(diskStats);
    }
}
#end_block

#method_before
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    List<VdsNetworkInterface> interfaces = new ArrayList<>();
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        Arrays.stream(ports).filter(port -> vdsInterfaces.containsKey(port.toString())).forEach(port -> interfaces.add(vdsInterfaces.get(port.toString())));
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        return Arrays.stream(ports).filter(port -> vdsInterfaces.containsKey(port.toString())).map(port -> vdsInterfaces.get(port.toString())).collect(Collectors.toList());
    }
    return new ArrayList<>();
}
#end_block

#method_before
private static SwitchType getSwitchType(Version clusterVersion, Map<String, Object> networkProperties) {
    Object switchType = networkProperties.get(VdsProperties.SWITCH_KEY);
    boolean switchTypeShouldBeReportedByOvs = FeatureSupported.ovsSupported(clusterVersion);
    if (switchTypeShouldBeReportedByOvs && switchType == null) {
        throw new IllegalStateException("Required SwitchType is not reported.");
    }
    return SwitchType.parse(switchType.toString());
}
#method_after
private static SwitchType getSwitchType(Version clusterVersion, Map<String, Object> networkProperties) {
    Object switchType = networkProperties.get(VdsProperties.SWITCH_KEY);
    boolean switchTypeShouldBeReportedByVdsm = FeatureSupported.ovsSupported(clusterVersion);
    if (switchTypeShouldBeReportedByVdsm && switchType == null) {
        throw new IllegalStateException("Required SwitchType is not reported.");
    }
    return SwitchType.parse(Objects.toString(switchType, null));
}
#end_block

#method_before
// we check for old bonding options,
// if we had value for the bonding options, i.e. the user set it by the UI
// and we have host that is not returning it's bonding options(host below 2.2.4) we override
private static void setBondingOptions(VDS vds, List<VdsNetworkInterface> oldInterfaces) {
    oldInterfaces.stream().filter(iface -> iface.getBondOptions() != null).forEach(iface -> vds.getInterfaces().stream().filter(newIface -> iface.getName().equals(newIface.getName()) && newIface.getBondOptions() == null).findFirst().ifPresent(newIface -> newIface.setBondOptions(iface.getBondOptions())));
}
#method_after
// we check for old bonding options,
// if we had value for the bonding options, i.e. the user set it by the UI
// and we have host that is not returning it's bonding options(host below 2.2.4) we override
private static void setBondingOptions(VDS vds, List<VdsNetworkInterface> oldInterfaces) {
    oldInterfaces.stream().filter(iface -> iface.getBondOptions() != null).forEach(iface -> vds.getInterfaces().stream().filter(newIface -> iface.getName().equals(newIface.getName())).filter(newIface -> newIface.getBondOptions() == null).findFirst().ifPresent(newIface -> newIface.setBondOptions(iface.getBondOptions())));
}
#end_block

#method_before
private static List<String> extracStringtList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return null;
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return null;
    }
    List<String> list = new ArrayList<>();
    Arrays.stream(items).forEach(item -> list.add((String) item));
    return list;
}
#method_after
private static List<String> extracStringtList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return null;
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return null;
    }
    return Arrays.stream(items).map(item -> (String) item).collect(Collectors.toList());
}
#end_block

#method_before
private static List<Integer> extractIntegerList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return Collections.emptyList();
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return Collections.emptyList();
    }
    List<Integer> list = new ArrayList<>();
    Arrays.stream(items).forEach(item -> list.add((Integer) item));
    return list;
}
#method_after
private static List<Integer> extractIntegerList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return Collections.emptyList();
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return Collections.emptyList();
    }
    return Arrays.stream(items).map(item -> (Integer) item).collect(Collectors.toList());
}
#end_block

#method_before
private static void updateV2VJobs(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.v2vJobs)) {
        return;
    }
    List<V2VJobInfo> v2vJobs = new ArrayList<>();
    ((Map<String, Object>) xmlRpcStruct.get(VdsProperties.v2vJobs)).entrySet().stream().forEach(job -> v2vJobs.add(buildV2VJobData(job.getKey(), (Map<String, Object>) job.getValue())));
    vds.getStatisticsData().setV2VJobs(v2vJobs);
}
#method_after
private static void updateV2VJobs(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.v2vJobs)) {
        return;
    }
    List<V2VJobInfo> v2vJobs = ((Map<String, Object>) xmlRpcStruct.get(VdsProperties.v2vJobs)).entrySet().stream().map(job -> buildV2VJobData(job.getKey(), (Map<String, Object>) job.getValue())).collect(Collectors.toList());
    vds.getStatisticsData().setV2VJobs(v2vJobs);
}
#end_block

#method_before
public static VM buildVmsDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(xmlRpcStruct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(xmlRpcStruct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(xmlRpcStruct));
    } catch (IllegalArgumentException ex) {
        log.error("Illegal architecture type: %s, replacing with x86_64", xmlRpcStruct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    } catch (NullPointerException ex) {
        log.error("null architecture type, replacing with x86_64, %s", vm);
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#method_after
public static VM buildVmsDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(xmlRpcStruct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(xmlRpcStruct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(xmlRpcStruct));
    } catch (IllegalArgumentException ex) {
        log.warn("Illegal architecture type: %s, replacing with x86_64", xmlRpcStruct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    } catch (NullPointerException ex) {
        log.warn("null architecture type, replacing with x86_64, %s", vm);
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#end_block

#method_before
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#method_after
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                Guid domainId = Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DomainId));
                List<Guid> domainIds = Collections.singletonList(domainId);
                image.setStorageIds(new ArrayList<>(domainIds));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setElapsedTime(assignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setElapsedTime(assignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
private static void updatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(assignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(assignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(assignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(getPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = assignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(getPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.glusterfsCliPackageName)) {
            Map<String, Object> glusterfsCli = (Map<String, Object>) packages.get(VdsProperties.glusterfsCliPackageName);
            vds.setGlusterfsCliVersion(getPackageRpmVersion(VdsProperties.glusterfsCliPackageName, glusterfsCli));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#method_after
private static void updatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(assignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(assignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(assignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        Map<String, Object> hostOsMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os);
        vds.setHostOs(getPackageVersionFormated(hostOsMap, true));
        if (hostOsMap.containsKey(VdsProperties.pretty_name)) {
            vds.setPrettyName(assignStringValue(hostOsMap, VdsProperties.pretty_name));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = assignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(getPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.glusterfsCliPackageName)) {
            Map<String, Object> glusterfsCli = (Map<String, Object>) packages.get(VdsProperties.glusterfsCliPackageName);
            vds.setGlusterfsCliVersion(getPackageRpmVersion(VdsProperties.glusterfsCliPackageName, glusterfsCli));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#end_block

#method_before
private static void extractInterfaceStatistics(Map<String, Object> dict, NetworkInterface<?> iface) {
    NetworkStatistics stats = iface.getStatistics();
    stats.setReceiveRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_rate));
    stats.setReceiveDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_dropped));
    stats.setReceivedBytes(assignLongValue(dict, VdsProperties.rx_total));
    stats.setTransmitRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_rate));
    stats.setTransmitDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_dropped));
    stats.setTransmittedBytes(assignLongValue(dict, VdsProperties.tx_total));
    stats.setSampleTime(assignDoubleValue(dict, VdsProperties.sample_time));
    iface.setSpeed(assignIntValue(dict, VdsProperties.INTERFACE_SPEED));
}
#method_after
private static void extractInterfaceStatistics(Map<String, Object> dict, NetworkInterface<?> iface) {
    NetworkStatistics stats = iface.getStatistics();
    stats.setReceiveDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.rx_dropped));
    stats.setReceivedBytes(assignLongValue(dict, VdsProperties.rx_total));
    stats.setTransmitDropRate(assignDoubleValueWithNullProtection(dict, VdsProperties.tx_dropped));
    stats.setTransmittedBytes(assignLongValue(dict, VdsProperties.tx_total));
    stats.setSampleTime(assignDoubleValue(dict, VdsProperties.sample_time));
    iface.setSpeed(assignIntValue(dict, VdsProperties.INTERFACE_SPEED));
}
#end_block

#method_before
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        vds.setLocalDisksUsage(diskStats);
        diskStatsStruct.entrySet().stream().forEach(entry -> diskStats.put(entry.getKey(), assignLongValue((Map<String, Object>) entry.getValue(), VdsProperties.DISK_STATS_FREE)));
    }
}
#method_after
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        // collect(Collectors.toMap(...)) will not work here as it uses merge() internally and
        // will fail on null values
        diskStatsStruct.entrySet().stream().forEach(e -> diskStats.put(e.getKey(), assignLongValue((Map<String, Object>) e.getValue(), VdsProperties.DISK_STATS_FREE)));
        vds.setLocalDisksUsage(diskStats);
    }
}
#end_block

#method_before
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    List<VdsNetworkInterface> interfaces = new ArrayList<>();
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        Arrays.stream(ports).filter(port -> vdsInterfaces.containsKey(port.toString())).forEach(port -> interfaces.add(vdsInterfaces.get(port.toString())));
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        return Arrays.stream(ports).filter(port -> vdsInterfaces.containsKey(port.toString())).map(port -> vdsInterfaces.get(port.toString())).collect(Collectors.toList());
    }
    return new ArrayList<>();
}
#end_block

#method_before
private static SwitchType getSwitchType(Version clusterVersion, Map<String, Object> networkProperties) {
    Object switchType = networkProperties.get(VdsProperties.SWITCH_KEY);
    boolean switchTypeShouldBeReportedByOvs = FeatureSupported.ovsSupported(clusterVersion);
    if (switchTypeShouldBeReportedByOvs && switchType == null) {
        throw new IllegalStateException("Required SwitchType is not reported.");
    }
    return SwitchType.parse(switchType.toString());
}
#method_after
private static SwitchType getSwitchType(Version clusterVersion, Map<String, Object> networkProperties) {
    Object switchType = networkProperties.get(VdsProperties.SWITCH_KEY);
    boolean switchTypeShouldBeReportedByVdsm = FeatureSupported.ovsSupported(clusterVersion);
    if (switchTypeShouldBeReportedByVdsm && switchType == null) {
        throw new IllegalStateException("Required SwitchType is not reported.");
    }
    return SwitchType.parse(Objects.toString(switchType, null));
}
#end_block

#method_before
// we check for old bonding options,
// if we had value for the bonding options, i.e. the user set it by the UI
// and we have host that is not returning it's bonding options(host below 2.2.4) we override
private static void setBondingOptions(VDS vds, List<VdsNetworkInterface> oldInterfaces) {
    oldInterfaces.stream().filter(iface -> iface.getBondOptions() != null).forEach(iface -> vds.getInterfaces().stream().filter(newIface -> iface.getName().equals(newIface.getName()) && newIface.getBondOptions() == null).findFirst().ifPresent(newIface -> newIface.setBondOptions(iface.getBondOptions())));
}
#method_after
// we check for old bonding options,
// if we had value for the bonding options, i.e. the user set it by the UI
// and we have host that is not returning it's bonding options(host below 2.2.4) we override
private static void setBondingOptions(VDS vds, List<VdsNetworkInterface> oldInterfaces) {
    oldInterfaces.stream().filter(iface -> iface.getBondOptions() != null).forEach(iface -> vds.getInterfaces().stream().filter(newIface -> iface.getName().equals(newIface.getName())).filter(newIface -> newIface.getBondOptions() == null).findFirst().ifPresent(newIface -> newIface.setBondOptions(iface.getBondOptions())));
}
#end_block

#method_before
private static <T> List<T> extractList(Map<String, Object> xmlRpcStruct, String propertyName, boolean returnNullOnEmpty) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return returnNullOnEmpty ? null : Collections.emptyList();
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return returnNullOnEmpty ? null : Collections.emptyList();
    }
    List<T> list = new ArrayList<>();
    Arrays.stream(items).forEach(item -> list.add((T) item));
    return list;
}
#method_after
private static <T> List<T> extractList(Map<String, Object> xmlRpcStruct, String propertyName, boolean returnNullOnEmpty) {
    if (xmlRpcStruct.containsKey(propertyName)) {
        Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
        if (items.length > 0) {
            return Arrays.stream(items).map(item -> (T) item).collect(Collectors.toList());
        }
    }
    return returnNullOnEmpty ? null : Collections.emptyList();
}
#end_block

#method_before
private static void updateV2VJobs(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.v2vJobs)) {
        return;
    }
    List<V2VJobInfo> v2vJobs = new ArrayList<>();
    ((Map<String, Object>) xmlRpcStruct.get(VdsProperties.v2vJobs)).entrySet().stream().forEach(job -> v2vJobs.add(buildV2VJobData(job.getKey(), (Map<String, Object>) job.getValue())));
    vds.getStatisticsData().setV2VJobs(v2vJobs);
}
#method_after
private static void updateV2VJobs(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.v2vJobs)) {
        return;
    }
    List<V2VJobInfo> v2vJobs = ((Map<String, Object>) xmlRpcStruct.get(VdsProperties.v2vJobs)).entrySet().stream().map(job -> buildV2VJobData(job.getKey(), (Map<String, Object>) job.getValue())).collect(Collectors.toList());
    vds.getStatisticsData().setV2VJobs(v2vJobs);
}
#end_block

#method_before
@Override
public VmPool update(VmPool incoming) {
    return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetVmPoolById, IdQueryParameters.class), VdcActionType.UpdateVmPoolWithVms, new UpdateParametersProvider());
}
#method_after
@Override
public VmPool update(VmPool incoming) {
    return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetVmPoolById, IdQueryParameters.class), VdcActionType.UpdateVmPool, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    Cluster cluster = getCluster(pool);
    pool.getCluster().setId(cluster.getId().toString());
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    org.ovirt.engine.core.common.businessentities.VmPool entity = map(pool);
    VM vm = mapToVM(pool, template, cluster);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    AddVmPoolWithVmsParameters params = new AddVmPoolWithVmsParameters(entity, vm, size);
    params.setConsoleEnabled(!getConsoleDevicesForEntity(template.getId()).isEmpty());
    params.setVirtioScsiEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, template.getId()).isEmpty());
    params.setSoundDeviceEnabled(pool.isSetSoundcardEnabled() ? pool.isSoundcardEnabled() : !VmHelper.getSoundDevicesForEntity(this, template.getId()).isEmpty());
    return performCreate(VdcActionType.AddVmPoolWithVms, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    Cluster cluster = getCluster(pool);
    pool.getCluster().setId(cluster.getId().toString());
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    org.ovirt.engine.core.common.businessentities.VmPool entity = map(pool);
    VM vm = mapToVM(pool, template, cluster);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    AddVmPoolWithVmsParameters params = new AddVmPoolWithVmsParameters(entity, vm, size);
    params.setConsoleEnabled(!getConsoleDevicesForEntity(template.getId()).isEmpty());
    params.setVirtioScsiEnabled(!VmHelper.getVirtioScsiControllersForEntity(this, template.getId()).isEmpty());
    params.setSoundDeviceEnabled(pool.isSetSoundcardEnabled() ? pool.isSoundcardEnabled() : !VmHelper.getSoundDevicesForEntity(this, template.getId()).isEmpty());
    return performCreate(VdcActionType.AddVmPool, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, IdQueryParameters.class));
}
#end_block

#method_before
private AddVmParameters buildAddVmParameters(String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    currVm.setStateless(!getVmPool().isStateful());
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmParameters parameters = new AddVmParameters(currVm);
    parameters.setPoolId(getVmPool().getVmPoolId());
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    // check if device is enabled or we need to override it to true
    parameters.setSoundDeviceEnabled(Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled()) || VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled()));
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#method_after
private AddVmParameters buildAddVmParameters(String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    currVm.setStateless(!getVmPool().isStateful());
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmParameters parameters = new AddVmParameters(currVm);
    parameters.setPoolId(getVmPool().getVmPoolId());
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    // check if device is enabled or we need to override it to true
    parameters.setSoundDeviceEnabled(Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled()) || vmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled()));
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    // A Pool cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    VmPool pool = getVmPoolDao().getByName(getParameters().getVmPool().getName());
    if (pool != null && (getActionType() == VdcActionType.AddVmPoolWithVms || !pool.getVmPoolId().equals(getParameters().getVmPoolId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    setStoragePoolId(getCluster().getStoragePoolId());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (!verifyAddVm()) {
        return false;
    }
    if (getVmTemplate().getDiskTemplateMap().values().size() != diskInfoDestinationMap.size()) {
        log.error("Can not found any default active domain for one of the disks of template with id '{}'", getVmTemplate().getId());
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        return false;
    }
    List<Guid> storageIds = new ArrayList<>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        Guid storageId = diskImage.getStorageIds().get(0);
        if (!storageIds.contains(storageId) && !areTemplateImagesInStorageReady(storageId)) {
            return false;
        }
        storageIds.add(storageId);
    }
    if (getActionType() == VdcActionType.AddVmPoolWithVms && getParameters().getVmsCount() < 1) {
        return failValidation(EngineMessage.VM_POOL_CANNOT_CREATE_WITH_NO_VMS);
    }
    if (getParameters().getVmPool().getPrestartedVms() > getParameters().getVmPool().getAssignedVmsCount() + getParameters().getVmsCount()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_PRESTARTED_VMS_CANNOT_EXCEED_VMS_COUNT);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return checkDestDomains();
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    // A Pool cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    VmPool pool = getVmPoolDao().getByName(getParameters().getVmPool().getName());
    if (pool != null && (getActionType() == VdcActionType.AddVmPool || !pool.getVmPoolId().equals(getParameters().getVmPoolId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    setStoragePoolId(getCluster().getStoragePoolId());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (!verifyAddVm()) {
        return false;
    }
    if (getVmTemplate().getDiskTemplateMap().values().size() != diskInfoDestinationMap.size()) {
        log.error("Can not found any default active domain for one of the disks of template with id '{}'", getVmTemplate().getId());
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        return false;
    }
    List<Guid> storageIds = new ArrayList<>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        Guid storageId = diskImage.getStorageIds().get(0);
        if (!storageIds.contains(storageId) && !areTemplateImagesInStorageReady(storageId)) {
            return false;
        }
        storageIds.add(storageId);
    }
    if (getActionType() == VdcActionType.AddVmPool && getParameters().getVmsCount() < 1) {
        return failValidation(EngineMessage.VM_POOL_CANNOT_CREATE_WITH_NO_VMS);
    }
    if (getParameters().getVmPool().getPrestartedVms() > getParameters().getVmPool().getAssignedVmsCount() + getParameters().getVmsCount()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_PRESTARTED_VMS_CANNOT_EXCEED_VMS_COUNT);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return checkDestDomains();
}
#end_block

#method_before
public void savePoolPostValidation() {
    final PoolModel model = (PoolModel) getWindow();
    VmPool pool = getCurrentPool();
    // Save changes.
    pool.setName(model.getName().getEntity());
    pool.setVmPoolDescription(model.getDescription().getEntity());
    pool.setClusterId(model.getSelectedCluster().getId());
    pool.setComment(model.getComment().getEntity());
    pool.setStateful(model.getPoolStateful().getEntity());
    pool.setPrestartedVms(model.getPrestartedVms().getEntity());
    pool.setMaxAssignedVmsPerUser(model.getMaxAssignedVmsPerUser().getEntity());
    EntityModel<VmPoolType> poolTypeSelectedItem = model.getPoolType().getSelectedItem();
    pool.setVmPoolType(poolTypeSelectedItem.getEntity());
    if (model.getSpiceProxyEnabled().getEntity()) {
        pool.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    VM vm = buildVmOnSave(model);
    vm.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    vm.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    vm.setStateless(false);
    vm.setInstanceTypeId(model.getInstanceTypes().getSelectedItem().getId());
    AddVmPoolWithVmsParameters param = new AddVmPoolWithVmsParameters(pool, vm, model.getNumOfDesktops().getEntity());
    param.setStorageDomainId(Guid.Empty);
    param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    BuilderExecutor.build(model, param, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getQuota().getSelectedItem() != null) {
        vm.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    model.startProgress();
    if (model.getIsNew()) {
        if (model.getIcon().getEntity().isCustom()) {
            param.setVmLargeIcon(model.getIcon().getEntity().getIcon());
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.AddVmPoolWithVms, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    } else {
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateVmPoolWithVms, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    }
}
#method_after
public void savePoolPostValidation() {
    final PoolModel model = (PoolModel) getWindow();
    VmPool pool = getCurrentPool();
    // Save changes.
    pool.setName(model.getName().getEntity());
    pool.setVmPoolDescription(model.getDescription().getEntity());
    pool.setClusterId(model.getSelectedCluster().getId());
    pool.setComment(model.getComment().getEntity());
    pool.setStateful(model.getPoolStateful().getEntity());
    pool.setPrestartedVms(model.getPrestartedVms().getEntity());
    pool.setMaxAssignedVmsPerUser(model.getMaxAssignedVmsPerUser().getEntity());
    EntityModel<VmPoolType> poolTypeSelectedItem = model.getPoolType().getSelectedItem();
    pool.setVmPoolType(poolTypeSelectedItem.getEntity());
    if (model.getSpiceProxyEnabled().getEntity()) {
        pool.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    VM vm = buildVmOnSave(model);
    vm.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    vm.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    vm.setStateless(false);
    vm.setInstanceTypeId(model.getInstanceTypes().getSelectedItem().getId());
    AddVmPoolWithVmsParameters param = new AddVmPoolWithVmsParameters(pool, vm, model.getNumOfDesktops().getEntity());
    param.setStorageDomainId(Guid.Empty);
    param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    BuilderExecutor.build(model, param, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getQuota().getSelectedItem() != null) {
        vm.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    model.startProgress();
    if (model.getIsNew()) {
        if (model.getIcon().getEntity().isCustom()) {
            param.setVmLargeIcon(model.getIcon().getEntity().getIcon());
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.AddVmPool, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    } else {
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateVmPool, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    }
}
#end_block

