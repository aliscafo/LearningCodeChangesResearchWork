795
#method_before
// ////////////////////////////////////
// Group Editing
// ////////////////////////////////////
protected void addBucketToGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED && nextObjective.type() != NextObjective.Type.BROADCAST) {
        log.warn("AddBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    // first check to see if bucket being added is not a duplicate of an
    // existing bucket. If it is for an existing outport, then its a duplicate.
    Set<TrafficTreatment> duplicateBuckets = Sets.newHashSet();
    List<Deque<GroupKey>> allActiveKeys = Ofdpa2Pipeline.appKryo.deserialize(next.data());
    Set<PortNumber> existingPorts = getExistingOutputPorts(allActiveKeys);
    Set<TrafficTreatment> nonDuplicateBuckets = Sets.newHashSet();
    NextObjective objectiveToAdd = null;
    nextObjective.next().forEach(trafficTreatment -> {
        PortNumber portNumber = readOutPortFromTreatment(trafficTreatment);
        if (portNumber == null) {
            return;
        }
        if (existingPorts.contains(portNumber)) {
            duplicateBuckets.add(trafficTreatment);
        } else {
            nonDuplicateBuckets.add(trafficTreatment);
        }
    });
    if (duplicateBuckets.isEmpty()) {
        // use the original objective
        objectiveToAdd = nextObjective;
    } else {
        // only use the non-duplicate buckets if there are any
        log.debug("Some buckets {} already exist in next id {}, duplicate " + "buckets will be ignored.", duplicateBuckets, nextObjective.id());
        if (!nonDuplicateBuckets.isEmpty()) {
            // new next objective with non duplicate treatments
            NextObjective.Builder builder = DefaultNextObjective.builder().withType(nextObjective.type()).withId(nextObjective.id()).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
            nonDuplicateBuckets.forEach(builder::addTreatment);
            ObjectiveContext context = nextObjective.context().orElse(null);
            objectiveToAdd = builder.addToExisting(context);
        }
    }
    if (objectiveToAdd == null) {
        return;
    }
    if (nextObjective.type() == NextObjective.Type.HASHED) {
        addBucketToHashGroup(objectiveToAdd, allActiveKeys);
    } else if (nextObjective.type() == NextObjective.Type.BROADCAST) {
        addBucketToBroadcastGroup(objectiveToAdd, allActiveKeys);
    }
}
#method_after
// ////////////////////////////////////
// Group Editing
// ////////////////////////////////////
protected void addBucketToGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED && nextObjective.type() != NextObjective.Type.BROADCAST) {
        log.warn("AddBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    // first check to see if bucket being added is not a duplicate of an
    // existing bucket. If it is for an existing outport, then its a duplicate.
    Set<TrafficTreatment> duplicateBuckets = Sets.newHashSet();
    List<Deque<GroupKey>> allActiveKeys = Ofdpa2Pipeline.appKryo.deserialize(next.data());
    Set<PortNumber> existingPorts = getExistingOutputPorts(allActiveKeys);
    Set<TrafficTreatment> nonDuplicateBuckets = Sets.newHashSet();
    NextObjective objectiveToAdd;
    nextObjective.next().forEach(trafficTreatment -> {
        PortNumber portNumber = readOutPortFromTreatment(trafficTreatment);
        if (portNumber == null) {
            return;
        }
        if (existingPorts.contains(portNumber)) {
            duplicateBuckets.add(trafficTreatment);
        } else {
            nonDuplicateBuckets.add(trafficTreatment);
        }
    });
    if (duplicateBuckets.isEmpty()) {
        // use the original objective
        objectiveToAdd = nextObjective;
    } else if (!nonDuplicateBuckets.isEmpty()) {
        // only use the non-duplicate buckets if there are any
        log.debug("Some buckets {} already exist in next id {}, duplicate " + "buckets will be ignored.", duplicateBuckets, nextObjective.id());
        // new next objective with non duplicate treatments
        NextObjective.Builder builder = DefaultNextObjective.builder().withType(nextObjective.type()).withId(nextObjective.id()).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        nonDuplicateBuckets.forEach(builder::addTreatment);
        ObjectiveContext context = nextObjective.context().orElse(null);
        objectiveToAdd = builder.addToExisting(context);
    } else {
        // buckets to add are already there - nothing to do
        return;
    }
    if (nextObjective.type() == NextObjective.Type.HASHED) {
        addBucketToHashGroup(objectiveToAdd, allActiveKeys);
    } else if (nextObjective.type() == NextObjective.Type.BROADCAST) {
        addBucketToBroadcastGroup(objectiveToAdd, allActiveKeys);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ofAgentStore = new DistributedOFAgentStore();
    TestUtils.setField(ofAgentStore, "coreService", createMock(CoreService.class));
    TestUtils.setField(ofAgentStore, "storageService", new TestStorageService());
    ofAgentStore.activate();
    expect(mockCoreService.registerApplication(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockCoreService);
    expect(mockLeadershipService.runForLeadership(anyObject())).andReturn(null).anyTimes();
    mockLeadershipService.addListener(anyObject());
    mockLeadershipService.removeListener(anyObject());
    mockLeadershipService.withdraw(anyObject());
    replay(mockLeadershipService);
    manager = new OFAgentManager();
    manager.coreService = mockCoreService;
    manager.leadershipService = mockLeadershipService;
    manager.virtualNetService = mockVirtualNetService;
    manager.clusterService = testClusterService;
    manager.ofAgentStore = ofAgentStore;
    manager.addListener(testListener);
    manager.activate();
}
#method_after
@Before
public void setUp() throws Exception {
    ofAgentStore = new DistributedOFAgentStore();
    TestUtils.setField(ofAgentStore, "coreService", createMock(CoreService.class));
    TestUtils.setField(ofAgentStore, "storageService", new TestStorageService());
    ofAgentStore.activate();
    expect(mockCoreService.registerApplication(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockCoreService);
    expect(mockClusterService.getLocalNode()).andReturn(LOCAL_NODE).anyTimes();
    replay(mockClusterService);
    expect(mockLeadershipService.runForLeadership(anyObject())).andReturn(null).anyTimes();
    mockLeadershipService.addListener(anyObject());
    mockLeadershipService.removeListener(anyObject());
    mockLeadershipService.withdraw(anyObject());
    replay(mockLeadershipService);
    target = new OFAgentManager();
    target.coreService = mockCoreService;
    target.leadershipService = mockLeadershipService;
    target.virtualNetService = mockVirtualNetService;
    target.clusterService = mockClusterService;
    target.ofAgentStore = ofAgentStore;
    target.addListener(testListener);
    target.activate();
}
#end_block

#method_before
@After
public void tearDown() {
    manager.removeListener(testListener);
    ofAgentStore.deactivate();
    manager.deactivate();
}
#method_after
@After
public void tearDown() {
    target.removeListener(testListener);
    ofAgentStore.deactivate();
    target.deactivate();
    ofAgentStore = null;
    target = null;
}
#end_block

#method_before
@Test
public void testCreateAndRemoveAgent() {
    manager.createAgent(OFAGENT_1);
    Set<OFAgent> agents = manager.agents();
    assertEquals("OFAgent set size did not match", 1, agents.size());
    manager.createAgent(OFAGENT_2);
    agents = manager.agents();
    assertEquals("OFAgent set size did not match", 2, agents.size());
    manager.removeAgent(NETWORK_1);
    agents = manager.agents();
    assertEquals("OFAgent set size did not match", 1, agents.size());
    manager.removeAgent(NETWORK_2);
    agents = manager.agents();
    assertEquals("OFAgent set size did not match", 0, agents.size());
    validateEvents(OFAGENT_CREATED, OFAGENT_CREATED, OFAGENT_REMOVED, OFAGENT_REMOVED);
}
#method_after
@Test
public void testCreateAndRemoveAgent() {
    target.createAgent(OFAGENT_1);
    Set<OFAgent> agents = target.agents();
    assertEquals("OFAgent set size did not match", 1, agents.size());
    target.createAgent(OFAGENT_2);
    agents = target.agents();
    assertEquals("OFAgent set size did not match", 2, agents.size());
    target.removeAgent(NETWORK_1);
    agents = target.agents();
    assertEquals("OFAgent set size did not match", 1, agents.size());
    target.removeAgent(NETWORK_2);
    agents = target.agents();
    assertEquals("OFAgent set size did not match", 0, agents.size());
    validateEvents(OFAGENT_CREATED, OFAGENT_CREATED, OFAGENT_REMOVED, OFAGENT_REMOVED);
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void testCreateNullAgent() {
    manager.createAgent(null);
}
#method_after
@Test(expected = NullPointerException.class)
public void testCreateNullAgent() {
    target.createAgent(null);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void testCreateDuplicateAgent() {
    manager.createAgent(OFAGENT_1);
    manager.createAgent(OFAGENT_1);
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void testCreateDuplicateAgent() {
    target.createAgent(OFAGENT_1);
    target.createAgent(OFAGENT_1);
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void testRemoveNullAgent() {
    manager.removeAgent(null);
}
#method_after
@Test(expected = NullPointerException.class)
public void testRemoveNullAgent() {
    target.removeAgent(null);
}
#end_block

#method_before
@Test(expected = IllegalStateException.class)
public void testRemoveNotFoundAgent() {
    manager.removeAgent(NETWORK_1);
}
#method_after
@Test(expected = IllegalStateException.class)
public void testRemoveNotFoundAgent() {
    target.removeAgent(NETWORK_1);
}
#end_block

#method_before
@Test(expected = IllegalStateException.class)
public void testRemoveStartedAgent() {
    manager.createAgent(OFAGENT_1);
    manager.startAgent(NETWORK_1);
    manager.removeAgent(NETWORK_1);
}
#method_after
@Test(expected = IllegalStateException.class)
public void testRemoveStartedAgent() {
    target.createAgent(OFAGENT_1);
    target.startAgent(NETWORK_1);
    target.removeAgent(NETWORK_1);
}
#end_block

#method_before
@Test
public void testStartAndStopAgent() {
    manager.createAgent(OFAGENT_1);
    manager.startAgent(NETWORK_1);
    OFAgent ofAgent = manager.agent(NETWORK_1);
    assertEquals("OFAgent state did not match", STARTED, ofAgent.state());
    manager.stopAgent(NETWORK_1);
    ofAgent = manager.agent(NETWORK_1);
    assertEquals("OFAgent state did not match", STOPPED, ofAgent.state());
    validateEvents(OFAGENT_CREATED, OFAGENT_STARTED, OFAGENT_STOPPED);
}
#method_after
@Test
public void testStartAndStopAgent() {
    target.createAgent(OFAGENT_1);
    target.startAgent(NETWORK_1);
    OFAgent ofAgent = target.agent(NETWORK_1);
    assertEquals("OFAgent state did not match", STARTED, ofAgent.state());
    target.stopAgent(NETWORK_1);
    ofAgent = target.agent(NETWORK_1);
    assertEquals("OFAgent state did not match", STOPPED, ofAgent.state());
    validateEvents(OFAGENT_CREATED, OFAGENT_STARTED, OFAGENT_STOPPED);
}
#end_block

#method_before
@Test
public void testAddController() {
    manager.createAgent(OFAGENT_1);
    manager.updateAgent(OFAGENT_1_CTRL_1);
    OFAgent ofAgent = manager.agent(NETWORK_1);
    assertEquals("OFAgent controller did not match", CONTROLLER_1, ofAgent.controllers());
    manager.updateAgent(OFAGENT_1_CTRL_2);
    ofAgent = manager.agent(NETWORK_1);
    assertEquals("OFAgent controller did not match", CONTROLLER_2, ofAgent.controllers());
    validateEvents(OFAGENT_CREATED, OFAGENT_CONTROLLER_ADDED, OFAGENT_CONTROLLER_ADDED);
}
#method_after
@Test
public void testAddController() {
    target.createAgent(OFAGENT_1);
    target.updateAgent(OFAGENT_1_CTRL_1);
    OFAgent ofAgent = target.agent(NETWORK_1);
    assertEquals("OFAgent controller did not match", CONTROLLER_1, ofAgent.controllers());
    target.updateAgent(OFAGENT_1_CTRL_2);
    ofAgent = target.agent(NETWORK_1);
    assertEquals("OFAgent controller did not match", CONTROLLER_2, ofAgent.controllers());
    validateEvents(OFAGENT_CREATED, OFAGENT_CONTROLLER_ADDED, OFAGENT_CONTROLLER_ADDED);
}
#end_block

#method_before
@Test
public void testRemoveController() {
    manager.createAgent(OFAGENT_1_CTRL_2);
    manager.updateAgent(OFAGENT_1_CTRL_1);
    OFAgent ofAgent = manager.agent(NETWORK_1);
    assertEquals("OFAgent controller did not match", CONTROLLER_1, ofAgent.controllers());
    manager.updateAgent(OFAGENT_1);
    ofAgent = manager.agent(NETWORK_1);
    assertTrue("OFAgent controller did not match", ofAgent.controllers().isEmpty());
    validateEvents(OFAGENT_CREATED, OFAGENT_CONTROLLER_REMOVED, OFAGENT_CONTROLLER_REMOVED);
}
#method_after
@Test
public void testRemoveController() {
    target.createAgent(OFAGENT_1_CTRL_2);
    target.updateAgent(OFAGENT_1_CTRL_1);
    OFAgent ofAgent = target.agent(NETWORK_1);
    assertEquals("OFAgent controller did not match", CONTROLLER_1, ofAgent.controllers());
    target.updateAgent(OFAGENT_1);
    ofAgent = target.agent(NETWORK_1);
    assertTrue("OFAgent controller did not match", ofAgent.controllers().isEmpty());
    validateEvents(OFAGENT_CREATED, OFAGENT_CONTROLLER_REMOVED, OFAGENT_CONTROLLER_REMOVED);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APPLICATION_NAME);
    localId = clusterService.getLocalNode().id();
    ofAgentService.addListener(ofAgentListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APPLICATION_NAME);
    localId = clusterService.getLocalNode().id();
    ioWorker = new NioEventLoopGroup();
    ofAgentService.addListener(ofAgentListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    ofAgentService.removeListener(ofAgentListener);
    ofAgentService.agents().forEach(this::processOFAgentStopped);
    ioWorker.shutdownGracefully();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    ofAgentService.removeListener(ofAgentListener);
    ofAgentService.agents().forEach(this::processOFAgentStopped);
    ioWorker.shutdownGracefully();
    eventExecutor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
private void sendRequest(IpAddress targetIp) {
    Interface intf = interfaceService.getMatchingInterface(targetIp);
    if (intf == null) {
        return;
    }
    if (!edgePortService.isEdgePoint(intf.connectPoint())) {
        log.warn("Aborting attempt to send probe out non-edge port: {}", intf);
        return;
    }
    for (InterfaceIpAddress ia : intf.ipAddressesList()) {
        if (ia.subnetAddress().contains(targetIp)) {
            sendProbe(intf.connectPoint(), targetIp, ia.ipAddress(), intf.mac(), intf.vlan());
            // account for use-cases where tagged-vlan config is used
            if (!intf.vlanTagged().isEmpty()) {
                intf.vlanTagged().forEach(tag -> {
                    log.info("Sending probe for target:{} out of intf:{} vlan:{}", targetIp, intf.connectPoint(), tag);
                    sendProbe(intf.connectPoint(), targetIp, ia.ipAddress(), intf.mac(), tag);
                });
            }
        }
    }
}
#method_after
private void sendRequest(IpAddress targetIp) {
    interfaceService.getMatchingInterfaces(targetIp).forEach(intf -> {
        if (!edgePortService.isEdgePoint(intf.connectPoint())) {
            log.warn("Aborting attempt to send probe out non-edge port: {}", intf);
            return;
        }
        intf.ipAddressesList().stream().filter(ia -> ia.subnetAddress().contains(targetIp)).forEach(ia -> {
            log.debug("Sending probe for target:{} out of intf:{} vlan:{}", targetIp, intf.connectPoint(), intf.vlan());
            sendProbe(intf.connectPoint(), targetIp, ia.ipAddress(), intf.mac(), intf.vlan());
            // account for use-cases where tagged-vlan config is used
            if (!intf.vlanTagged().isEmpty()) {
                intf.vlanTagged().forEach(tag -> {
                    log.debug("Sending probe for target:{} out of intf:{} vlan:{}", targetIp, intf.connectPoint(), tag);
                    sendProbe(intf.connectPoint(), targetIp, ia.ipAddress(), intf.mac(), tag);
                });
            }
        });
    });
}
#end_block

#method_before
@Override
public boolean editDeviceConfig(DeviceId deviceId, ResourceData resourceData, NetconfTranslator.OperationType operationType) throws IOException {
    NetconfSession session = getNetconfSession(deviceId);
    SchemaContext context = schemaContextProvider.getSchemaContext(ResourceId.builder().addBranchPointSchema("/", null).build());
    ResourceData modifiedPathResourceData = getResourceData(resourceData.resourceId(), resourceData.dataNodes(), new DefaultYangSerializerContext(context, null));
    DefaultCompositeData.Builder compositeDataBuilder = DefaultCompositeData.builder().resourceData(modifiedPathResourceData);
    for (DataNode node : resourceData.dataNodes()) {
        ResourceId resourceId = resourceData.resourceId();
        if (operationType != OperationType.DELETE) {
            resourceId = getAnnotatedNodeResourceId(resourceData.resourceId(), node);
        }
        if (resourceId != null) {
            DefaultAnnotatedNodeInfo.Builder annotatedNodeInfo = DefaultAnnotatedNodeInfo.builder();
            annotatedNodeInfo.resourceId(resourceId);
            annotatedNodeInfo.addAnnotation(new DefaultAnnotation(OP_SPECIFIER, operationType == OperationType.DELETE ? DELETE_OP_SPECIFIER : REPLACE_OP_SPECIFIER));
            compositeDataBuilder.addAnnotatedNodeInfo(annotatedNodeInfo.build());
        }
    }
    CompositeStream config = yangRuntimeService.encode(compositeDataBuilder.build(), new DefaultRuntimeContext.Builder().setDataFormat(XML_ENCODING_SPECIFIER).addAnnotation(new DefaultAnnotation(XMLNS_XC_SPECIFIER, NETCONF_1_0_BASE_NAMESPACE)).build());
    /* FIXME need to fix to string conversion. */
    if (session.editConfig("running", null, streamToString(config.resourceData()))) {
        /* NOTE: a failure to edit is reflected as a NetconfException.*/
        return true;
    }
    log.warn("Editing of the netconf device: {} failed.", deviceId);
    return false;
}
#method_after
@Override
public boolean editDeviceConfig(DeviceId deviceId, ResourceData resourceData, NetconfTranslator.OperationType operationType) throws IOException {
    NetconfSession session = getNetconfSession(deviceId);
    SchemaContext context = schemaContextProvider.getSchemaContext(ResourceId.builder().addBranchPointSchema("/", null).build());
    ResourceData modifiedPathResourceData = getResourceData(resourceData.resourceId(), resourceData.dataNodes(), new DefaultYangSerializerContext(context, null));
    DefaultCompositeData.Builder compositeDataBuilder = DefaultCompositeData.builder().resourceData(modifiedPathResourceData);
    for (DataNode node : resourceData.dataNodes()) {
        ResourceId resourceId = resourceData.resourceId();
        if (operationType != OperationType.DELETE) {
            resourceId = getAnnotatedNodeResourceId(resourceData.resourceId(), node);
        }
        if (resourceId != null) {
            DefaultAnnotatedNodeInfo.Builder annotatedNodeInfo = DefaultAnnotatedNodeInfo.builder();
            annotatedNodeInfo.resourceId(resourceId);
            annotatedNodeInfo.addAnnotation(new DefaultAnnotation(OP_SPECIFIER, operationType == OperationType.DELETE ? DELETE_OP_SPECIFIER : REPLACE_OP_SPECIFIER));
            compositeDataBuilder.addAnnotatedNodeInfo(annotatedNodeInfo.build());
        }
    }
    CompositeStream config = yangRuntimeService.encode(compositeDataBuilder.build(), new DefaultRuntimeContext.Builder().setDataFormat(XML_ENCODING_SPECIFIER).addAnnotation(new DefaultAnnotation(XMLNS_XC_SPECIFIER, NETCONF_1_0_BASE_NAMESPACE)).build());
    try {
        String reply = session.requestSync(Utils.editConfig(streamToString(config.resourceData())));
    } catch (NetconfException e) {
        log.error("failed to send a request sync", e);
        return false;
    }
    /* NOTE: a failure to edit is reflected as a NetconfException.*/
    return true;
}
#end_block

#method_before
@Override
public ResourceData getDeviceState(DeviceId deviceId) throws IOException {
    NetconfSession session = getNetconfSession(deviceId);
    /*TODO the first parameter will come into use if get is required to support filters.*/
    String reply = session.get(null, null);
    Matcher protocolStripper = GET_CORE_MESSAGE_PATTERN.matcher(reply);
    reply = protocolStripper.group(GET_CORE_MESSAGE_GROUP);
    return yangRuntimeService.decode(new DefaultCompositeStream(null, /*FIXME is UTF_8 the appropriate encoding? */
    new ByteArrayInputStream(reply.toString().getBytes(StandardCharsets.UTF_8))), new DefaultRuntimeContext.Builder().setDataFormat(XML_ENCODING_SPECIFIER).addAnnotation(new DefaultAnnotation(XMLNS_SPECIFIER, NETCONF_1_0_BASE_NAMESPACE)).build()).resourceData();
/* NOTE: a failure to get is reflected as a NetconfException.*/
}
#method_after
@Override
public ResourceData getDeviceState(DeviceId deviceId) throws IOException {
    NetconfSession session = getNetconfSession(deviceId);
    /*TODO the first parameter will come into use if get is required to support filters.*/
    String reply = session.get(null, null);
    Matcher protocolStripper = GET_CORE_MESSAGE_PATTERN.matcher(reply);
    reply = protocolStripper.group(GET_CORE_MESSAGE_GROUP);
    return yangRuntimeService.decode(new DefaultCompositeStream(null, /*FIXME is UTF_8 the appropriate encoding? */
    new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))), new DefaultRuntimeContext.Builder().setDataFormat(XML_ENCODING_SPECIFIER).addAnnotation(new DefaultAnnotation(XMLNS_SPECIFIER, NETCONF_1_0_BASE_NAMESPACE)).build()).resourceData();
/* NOTE: a failure to get is reflected as a NetconfException.*/
}
#end_block

#method_before
@Override
public boolean editDeviceConfig(DeviceId deviceId, ResourceData resourceData, NetconfTranslator.OperationType operationType) throws IOException {
    NetconfSession session = getNetconfSession(deviceId);
    ResourceData modifiedPathResourceData = getResourceData(resourceData.resourceId(), resourceData.dataNodes(), new DefaultYangSerializerContext(schemaContext, null));
    DefaultCompositeData.Builder compositeDataBuilder = DefaultCompositeData.builder().resourceData(modifiedPathResourceData);
    for (DataNode node : resourceData.dataNodes()) {
        ResourceId resourceId = resourceData.resourceId();
        if (operationType != OperationType.DELETE) {
            resourceId = getAnnotatedNodeResourceId(resourceData.resourceId(), node);
        }
        if (resourceId != null) {
            DefaultAnnotatedNodeInfo.Builder annotatedNodeInfo = DefaultAnnotatedNodeInfo.builder();
            annotatedNodeInfo.resourceId(resourceId);
            annotatedNodeInfo.addAnnotation(new DefaultAnnotation(OP_SPECIFIER, operationType == OperationType.DELETE ? DELETE_OP_SPECIFIER : REPLACE_OP_SPECIFIER));
            compositeDataBuilder.addAnnotatedNodeInfo(annotatedNodeInfo.build());
        }
    }
    CompositeStream config = yangRuntimeService.encode(compositeDataBuilder.build(), new DefaultRuntimeContext.Builder().setDataFormat(XML_ENCODING_SPECIFIER).addAnnotation(new DefaultAnnotation(XMLNS_XC_SPECIFIER, NETCONF_1_0_BASE_NAMESPACE)).build());
    /* FIXME need to fix to string conversion. */
    if (session.editConfig(streamToString(config.resourceData()))) {
        /* NOTE: a failure to edit is reflected as a NetconfException.*/
        return true;
    }
    log.warn("Editing of the netconf device: {} failed.", deviceId);
    return false;
}
#method_after
@Override
public boolean editDeviceConfig(DeviceId deviceId, ResourceData resourceData, NetconfTranslator.OperationType operationType) throws IOException {
    NetconfSession session = getNetconfSession(deviceId);
    SchemaContext context = schemaContextProvider.getSchemaContext(ResourceId.builder().addBranchPointSchema("/", null).build());
    ResourceData modifiedPathResourceData = getResourceData(resourceData.resourceId(), resourceData.dataNodes(), new DefaultYangSerializerContext(context, null));
    DefaultCompositeData.Builder compositeDataBuilder = DefaultCompositeData.builder().resourceData(modifiedPathResourceData);
    for (DataNode node : resourceData.dataNodes()) {
        ResourceId resourceId = resourceData.resourceId();
        if (operationType != OperationType.DELETE) {
            resourceId = getAnnotatedNodeResourceId(resourceData.resourceId(), node);
        }
        if (resourceId != null) {
            DefaultAnnotatedNodeInfo.Builder annotatedNodeInfo = DefaultAnnotatedNodeInfo.builder();
            annotatedNodeInfo.resourceId(resourceId);
            annotatedNodeInfo.addAnnotation(new DefaultAnnotation(OP_SPECIFIER, operationType == OperationType.DELETE ? DELETE_OP_SPECIFIER : REPLACE_OP_SPECIFIER));
            compositeDataBuilder.addAnnotatedNodeInfo(annotatedNodeInfo.build());
        }
    }
    CompositeStream config = yangRuntimeService.encode(compositeDataBuilder.build(), new DefaultRuntimeContext.Builder().setDataFormat(XML_ENCODING_SPECIFIER).addAnnotation(new DefaultAnnotation(XMLNS_XC_SPECIFIER, NETCONF_1_0_BASE_NAMESPACE)).build());
    /* FIXME need to fix to string conversion. */
    if (session.editConfig(streamToString(config.resourceData()))) {
        /* NOTE: a failure to edit is reflected as a NetconfException.*/
        return true;
    }
    log.warn("Editing of the netconf device: {} failed.", deviceId);
    return false;
}
#end_block

#method_before
public boolean ifAppInfoPresent() {
    return !appInfoMap.isEmpty();
}
#method_after
@Override
public boolean ifAppInfoPresent() {
    return !appInfoMap.isEmpty();
}
#end_block

#method_before
public void addProtocolInfo(RouteProtocol route, ProtocolInfo info) {
    if (protocolInfo == null) {
        protocolInfo = new HashMap<>();
    }
    protocolInfo.put(route, info);
}
#method_after
void addProtocolInfo(RouteProtocol route, ProtocolInfo info) {
    if (protocolInfo == null) {
        protocolInfo = new HashMap<>();
    }
    protocolInfo.put(route, info);
}
#end_block

#method_before
public void addIfName(String ifName) {
    if (ifNames == null) {
        ifNames = new LinkedList<>();
    }
    ifNames.add(ifName);
}
#method_after
void addIfName(String ifName) {
    if (ifNames == null) {
        ifNames = new LinkedList<>();
    }
    ifNames.add(ifName);
}
#end_block

#method_before
public void addAccessInfo(AccessInfo accessInfo) {
    if (accesses == null) {
        accesses = new LinkedList<>();
    }
    accesses.add(accessInfo);
}
#method_after
void addAccessInfo(AccessInfo accessInfo) {
    if (accesses == null) {
        accesses = new LinkedList<>();
    }
    accesses.add(accessInfo);
}
#end_block

#method_before
public ModelObjectData processCreateInstance(DriverService driverSvc, ModelObjectData modelData) {
    // TODO: Need to call the behaviour.
    return null;
}
#method_after
ModelObjectData processCreateInstance(DriverService driverSvc, ModelObjectData modelData) {
    // TODO: Need to call the behaviour.
    return null;
}
#end_block

#method_before
public ModelObjectData processCreateInterface(DriverService driverSvc, ModelObjectData modData) {
    // TODO: Need to call the behaviour.
    return null;
}
#method_after
ModelObjectData processCreateInterface(DriverService driverSvc, ModelObjectData modData) {
    // TODO: Need to call the behaviour.
    return null;
}
#end_block

#method_before
public ModelObjectData processCreateBgpInfo(DriverService driverSvc, BgpInfo bgpInfo, BgpDriverInfo driverInfo) {
    // TODO: Need to call the behaviour.
    return null;
}
#method_after
ModelObjectData processCreateBgpInfo(DriverService driverSvc, BgpInfo bgpInfo, BgpDriverInfo driverInfo) {
    // TODO: Need to call the behaviour.
    return null;
}
#end_block

#method_before
public ModelObjectData processDeleteInstance(DriverService driverSvc, ModelObjectData modData) {
    // TODO: Need to call the behaviour.
    return null;
}
#method_after
ModelObjectData processDeleteInstance(DriverService driverSvc, ModelObjectData modData) {
    // TODO: Need to call the behaviour.
    return null;
}
#end_block

#method_before
public ModelObjectData processDeleteInterface(DriverService driverSvc, ModelObjectData objectData) {
    // TODO: Need to call the behaviour.
    return null;
}
#method_after
ModelObjectData processDeleteInterface(DriverService driverSvc, ModelObjectData objectData) {
    // TODO: Need to call the behaviour.
    return null;
}
#end_block

#method_before
public ModelObjectData processDeleteBgpInfo(DriverService driverSvc, BgpInfo bgpInfo, BgpDriverInfo driverInfo) {
    // TODO: Need to call the behaviour.
    return null;
}
#method_after
ModelObjectData processDeleteBgpInfo(DriverService driverSvc, BgpInfo bgpInfo, BgpDriverInfo driverInfo) {
    // TODO: Need to call the behaviour.
    return null;
}
#end_block

#method_before
public boolean isIpv4Af() {
    return ipv4Af;
}
#method_after
boolean isIpv4Af() {
    return ipv4Af;
}
#end_block

#method_before
public boolean isIpv6Af() {
    return ipv6Af;
}
#method_after
boolean isIpv6Af() {
    return ipv6Af;
}
#end_block

#method_before
public void addV4Key(AccessInfo info) {
    if (v4Accesses == null) {
        v4Accesses = new LinkedList<>();
    }
    v4Accesses.add(info);
}
#method_after
void addV4Key(AccessInfo info) {
    if (v4Accesses == null) {
        v4Accesses = new LinkedList<>();
    }
    v4Accesses.add(info);
}
#end_block

#method_before
public void addV6Key(AccessInfo info) {
    if (v6Accesses == null) {
        v6Accesses = new LinkedList<>();
    }
    v6Accesses.add(info);
}
#method_after
void addV6Key(AccessInfo info) {
    if (v6Accesses == null) {
        v6Accesses = new LinkedList<>();
    }
    v6Accesses.add(info);
}
#end_block

#method_before
private void sendRequest(IpAddress targetIp) {
    interfaceService.getMatchingInterfaces(targetIp).stream().filter(matchIntf -> edgePortService.isEdgePoint(matchIntf.connectPoint())).forEach(intf -> {
        intf.ipAddressesList().stream().filter(ia -> ia.subnetAddress().contains(targetIp)).forEach(ia -> {
            log.info("Sending probe for target:{} out of intf:{} vlan:{}", targetIp, intf.connectPoint(), intf.vlan());
            sendProbe(intf.connectPoint(), targetIp, ia.ipAddress(), intf.mac(), intf.vlan());
            // account for use-cases where tagged-vlan config is used
            if (!intf.vlanTagged().isEmpty()) {
                intf.vlanTagged().forEach(tag -> {
                    log.info("Sending probe for target:{} out of intf:{} vlan:{}", targetIp, intf.connectPoint(), tag);
                    sendProbe(intf.connectPoint(), targetIp, ia.ipAddress(), intf.mac(), tag);
                });
            }
        });
    });
}
#method_after
private void sendRequest(IpAddress targetIp) {
    interfaceService.getMatchingInterfaces(targetIp).forEach(intf -> {
        if (!edgePortService.isEdgePoint(intf.connectPoint())) {
            log.warn("Aborting attempt to send probe out non-edge port: {}", intf);
            return;
        }
        intf.ipAddressesList().stream().filter(ia -> ia.subnetAddress().contains(targetIp)).forEach(ia -> {
            log.info("Sending probe for target:{} out of intf:{} vlan:{}", targetIp, intf.connectPoint(), intf.vlan());
            sendProbe(intf.connectPoint(), targetIp, ia.ipAddress(), intf.mac(), intf.vlan());
            // account for use-cases where tagged-vlan config is used
            if (!intf.vlanTagged().isEmpty()) {
                intf.vlanTagged().forEach(tag -> {
                    log.info("Sending probe for target:{} out of intf:{} vlan:{}", targetIp, intf.connectPoint(), tag);
                    sendProbe(intf.connectPoint(), targetIp, ia.ipAddress(), intf.mac(), tag);
                });
            }
        });
    });
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    configRegistry.removeListener(configListener);
    deviceService.removeListener(deviceListener);
    nodeStore.removeListener(nodeStoreListener);
    componentConfigService.unregisterProperties(getClass(), false);
    configRegistry.unregisterConfigFactory(configFactory);
    leadershipService.withdraw(appId.name());
    eventExecutor.shutdown();
    nodeStore.clear();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    configRegistry.removeListener(configListener);
    deviceService.removeListener(deviceListener);
    nodeStore.removeListener(nodeStoreListener);
    componentConfigService.unregisterProperties(getClass(), false);
    configRegistry.unregisterConfigFactory(configFactory);
    leadershipService.withdraw(appId.name());
    eventExecutor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void processDeviceCreatedState(OpenstackNode node) {
    // make sure there is OVSDB connection
    if (!isOvsdbConnected(node)) {
        connectOvsdb(node);
        return;
    } else if (!node.dataIp().isPresent() && !node.vlanPort().isPresent()) {
        log.error("There is neither tunnel interface nor vlan port");
        return;
    }
    process(new OpenstackNodeEvent(DEVICE_CREATED, node));
    if (node.dataIp().isPresent()) {
        createTunnelInterface(node);
    }
    if (node.vlanPort().isPresent()) {
        addVlanPort(node);
    }
    if (node.type().equals(NodeType.GATEWAY)) {
        createPatchInterface(node);
        addUplink(node);
        // TODO remove this when OVSDB provides port event
        setNodeState(node, nodeState(node));
    }
}
#method_after
@Override
public void processDeviceCreatedState(OpenstackNode node) {
    // make sure there is OVSDB connection
    if (!isOvsdbConnected(node)) {
        connectOvsdb(node);
        return;
    }
    process(new OpenstackNodeEvent(DEVICE_CREATED, node));
    if (node.dataIp().isPresent()) {
        createTunnelInterface(node);
    }
    if (node.vlanPort().isPresent()) {
        addVlanPort(node);
    }
    if (node.type().equals(NodeType.GATEWAY)) {
        createPatchInterface(node);
        addUplink(node);
        // TODO remove this when OVSDB provides port event
        setNodeState(node, nodeState(node));
    }
}
#end_block

#method_before
private NodeState nodeState(OpenstackNode node) {
    if (!isOvsdbConnected(node) || !deviceService.isAvailable(node.intBridge()) || !isBridgeCreated(node.ovsdbId(), INTEGRATION_BRIDGE)) {
        return INIT;
    }
    // TODO use device service when we use single ONOS cluster for both openstackNode and vRouter
    if (node.type().equals(NodeType.GATEWAY) && !isBridgeCreated(node.ovsdbId(), ROUTER_BRIDGE)) {
        return INIT;
    }
    if (!isIfaceCreated(node.ovsdbId(), DEFAULT_TUNNEL)) {
        return DEVICE_CREATED;
    }
    if (node.type().equals(NodeType.GATEWAY) && (!isIfaceCreated(node.ovsdbId(), PATCH_ROUT_BRIDGE) || !isIfaceCreated(node.ovsdbId(), PATCH_INTG_BRIDGE) || !isIfaceCreated(node.ovsdbId(), node.uplink().get()))) {
        return DEVICE_CREATED;
    }
    return COMPLETE;
}
#method_after
private NodeState nodeState(OpenstackNode node) {
    if (!isOvsdbConnected(node) || !deviceService.isAvailable(node.intBridge()) || !isBridgeCreated(node.ovsdbId(), INTEGRATION_BRIDGE)) {
        return INIT;
    }
    // TODO use device service when we use single ONOS cluster for both openstackNode and vRouter
    if (node.type().equals(NodeType.GATEWAY) && !isBridgeCreated(node.ovsdbId(), ROUTER_BRIDGE)) {
        return INIT;
    }
    if (node.dataIp().isPresent() && !isIfaceCreated(node.ovsdbId(), DEFAULT_TUNNEL)) {
        return DEVICE_CREATED;
    }
    if (node.vlanPort().isPresent() && !isIfaceCreated(node.ovsdbId(), node.vlanPort().get())) {
        return DEVICE_CREATED;
    }
    if (node.type().equals(NodeType.GATEWAY) && (!isIfaceCreated(node.ovsdbId(), PATCH_ROUT_BRIDGE) || !isIfaceCreated(node.ovsdbId(), PATCH_INTG_BRIDGE) || !isIfaceCreated(node.ovsdbId(), node.uplink().get()))) {
        return DEVICE_CREATED;
    }
    return COMPLETE;
}
#end_block

#method_before
private void addVlanPort(OpenstackNode node) {
    if (isIfaceCreated(node.ovsdbId(), node.vlanPort().get())) {
        return;
    }
    Device device = deviceService.getDevice(node.ovsdbId());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.error("Failed to add port {} on {}", node.uplink().get(), node.ovsdbId());
        return;
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    bridgeConfig.addPort(BridgeName.bridgeName(INTEGRATION_BRIDGE), node.vlanPort().get());
}
#method_after
private void addVlanPort(OpenstackNode node) {
    if (isIfaceCreated(node.ovsdbId(), node.vlanPort().get())) {
        return;
    }
    Device device = deviceService.getDevice(node.ovsdbId());
    if (device == null || !device.is(BridgeConfig.class)) {
        log.error("Failed to add port {} on {}", node.vlanPort().get(), node.ovsdbId());
        return;
    }
    BridgeConfig bridgeConfig = device.as(BridgeConfig.class);
    bridgeConfig.addPort(BridgeName.bridgeName(INTEGRATION_BRIDGE), node.vlanPort().get());
}
#end_block

#method_before
private Set<String> systemIfaces(OpenstackNode node) {
    Set<String> ifaces = Sets.newHashSet(DEFAULT_TUNNEL);
    if (node.type().equals(NodeType.GATEWAY)) {
        ifaces.add(PATCH_INTG_BRIDGE);
        ifaces.add(PATCH_ROUT_BRIDGE);
        ifaces.add(node.uplink().get());
    }
    return ifaces;
}
#method_after
private Set<String> systemIfaces(OpenstackNode node) {
    Set<String> ifaces = Sets.newHashSet();
    node.dataIp().ifPresent(ip -> ifaces.add(DEFAULT_TUNNEL));
    node.vlanPort().ifPresent(p -> ifaces.add(p));
    if (node.type().equals(NodeType.GATEWAY)) {
        ifaces.add(PATCH_INTG_BRIDGE);
        ifaces.add(PATCH_ROUT_BRIDGE);
        ifaces.add(node.uplink().get());
    }
    return ifaces;
}
#end_block

#method_before
@Override
public boolean isValid() {
    boolean result = hasOnlyFields(NODES);
    if (object.get(NODES) == null || object.get(NODES).size() < 1) {
        final String msg = "No node is present";
        throw new IllegalArgumentException(msg);
    }
    for (JsonNode node : object.get(NODES)) {
        ObjectNode osNode = (ObjectNode) node;
        result &= hasOnlyFields(osNode, HOST_NAME, TYPE, MANAGEMENT_IP, DATA_IP, INTEGRATION_BRIDGE, ROUTER_BRIDGE, UPLINK_PORT_NAME, ROUTER_CONTROLLER, VLAN_PORT_NAME);
        result &= isString(osNode, HOST_NAME, MANDATORY);
        result &= isString(osNode, TYPE, MANDATORY);
        result &= isIpAddress(osNode, MANAGEMENT_IP, MANDATORY);
        result &= isString(osNode, INTEGRATION_BRIDGE, MANDATORY);
        result &= isString(osNode, VLAN_PORT_NAME, OPTIONAL);
        result &= isIpAddress(osNode, DATA_IP, OPTIONAL);
        DeviceId.deviceId(osNode.get(INTEGRATION_BRIDGE).asText());
        NodeType.valueOf(osNode.get(TYPE).asText());
        if (osNode.get(TYPE).asText().equals(GATEWAY.name())) {
            result &= isString(osNode, ROUTER_BRIDGE, MANDATORY);
            DeviceId.deviceId(osNode.get(ROUTER_BRIDGE).asText());
            result &= isString(osNode, UPLINK_PORT_NAME, MANDATORY);
            result &= isIpAddress(osNode, ROUTER_CONTROLLER, MANDATORY);
        }
    }
    return result;
}
#method_after
@Override
public boolean isValid() {
    boolean result = hasOnlyFields(NODES);
    if (object.get(NODES) == null || object.get(NODES).size() < 1) {
        final String msg = "No node is present";
        throw new IllegalArgumentException(msg);
    }
    for (JsonNode node : object.get(NODES)) {
        if (get(node, DATA_IP) == null && get(node, VLAN_PORT_NAME) == null) {
            final String msg = "There is neither tunnel interface nor vlan port";
            throw new IllegalArgumentException(msg);
        }
        ObjectNode osNode = (ObjectNode) node;
        result &= hasOnlyFields(osNode, HOST_NAME, TYPE, MANAGEMENT_IP, DATA_IP, INTEGRATION_BRIDGE, ROUTER_BRIDGE, UPLINK_PORT_NAME, ROUTER_CONTROLLER, VLAN_PORT_NAME);
        result &= isString(osNode, HOST_NAME, MANDATORY);
        result &= isString(osNode, TYPE, MANDATORY);
        result &= isIpAddress(osNode, MANAGEMENT_IP, MANDATORY);
        result &= isString(osNode, INTEGRATION_BRIDGE, MANDATORY);
        result &= isString(osNode, VLAN_PORT_NAME, OPTIONAL);
        result &= isIpAddress(osNode, DATA_IP, OPTIONAL);
        DeviceId.deviceId(osNode.get(INTEGRATION_BRIDGE).asText());
        NodeType.valueOf(osNode.get(TYPE).asText());
        if (osNode.get(TYPE).asText().equals(GATEWAY.name())) {
            result &= isString(osNode, ROUTER_BRIDGE, MANDATORY);
            DeviceId.deviceId(osNode.get(ROUTER_BRIDGE).asText());
            result &= isString(osNode, UPLINK_PORT_NAME, MANDATORY);
            result &= isIpAddress(osNode, ROUTER_CONTROLLER, MANDATORY);
        }
    }
    return result;
}
#end_block

#method_before
@Override
@Deprecated
public Interface getMatchingInterface(IpAddress ip) {
    return null;
}
#method_after
@Override
public Interface getMatchingInterface(IpAddress ip) {
    return null;
}
#end_block

#method_before
@Override
@Deprecated
public Interface getMatchingInterface(IpAddress ip) {
    return getFirstMatchingInterface(ip);
}
#method_after
@Override
public Interface getMatchingInterface(IpAddress ip) {
    return getMatchingInterfacesStream(ip).findFirst().orElse(null);
}
#end_block

#method_before
@Override
public Set<Interface> getMatchingInterfaces(IpAddress ip) {
    return interfaces.values().stream().flatMap(Collection::stream).filter(intf -> intf.ipAddressesList().stream().anyMatch(intfIp -> intfIp.subnetAddress().contains(ip))).collect(toSet());
}
#method_after
@Override
public Set<Interface> getMatchingInterfaces(IpAddress ip) {
    return getMatchingInterfacesStream(ip).collect(toSet());
}
#end_block

#method_before
public static Tunnel te2YangTunnelConverter(TeTunnel tunnel, boolean isConfig) {
    List<PrimaryPaths> pathsList = new ArrayList<>();
    if (tunnel.primaryPaths() != null) {
        tunnel.primaryPaths().forEach(tePath -> pathsList.add(te2YangPrimaryPath(tePath)));
    }
    tunnel.primaryPaths().forEach(tePath -> pathsList.add(te2YangPrimaryPath(tePath)));
    Tunnel.TunnelBuilder builder = new DefaultTunnel.TunnelBuilder().type(te2YangTunnelType(tunnel.type())).name(name(tunnel.name())).identifier(tunnel.teTunnelKey().teTunnelId()).state(te2YangTunnelState(tunnel)).primaryPaths(pathsList);
    Tunnel.TunnelBuilder tunnelBuilder = isConfig ? builder.config(te2YangTunnelConfig(tunnel)) : builder.state(te2YangTunnelState(tunnel));
    return tunnelBuilder.build();
}
#method_after
public static Tunnel te2YangTunnelConverter(TeTunnel tunnel, boolean isConfig) {
    List<PrimaryPaths> pathsList = new ArrayList<>();
    if (tunnel.primaryPaths() != null) {
        tunnel.primaryPaths().forEach(tePath -> pathsList.add(te2YangPrimaryPath(tePath)));
    }
    tunnel.primaryPaths().forEach(tePath -> pathsList.add(te2YangPrimaryPath(tePath)));
    Tunnel.TunnelBuilder builder = new DefaultTunnel.TunnelBuilder().type(te2YangTunnelType(tunnel.type())).name(validName(tunnel.name())).identifier(tunnel.teTunnelKey().teTunnelId()).state(te2YangTunnelState(tunnel)).primaryPaths(pathsList);
    Tunnel.TunnelBuilder tunnelBuilder = isConfig ? builder.config(te2YangTunnelConfig(tunnel)) : builder.state(te2YangTunnelState(tunnel));
    return tunnelBuilder.build();
}
#end_block

#method_before
private static State te2YangTunnelState(TeTunnel tunnel) {
    State.StateBuilder stateBuilder = new DefaultState.StateBuilder();
    stateBuilder.name(name(tunnel.name())).identifier((int) tunnel.teTunnelKey().teTunnelId()).source((longToIp(tunnel.srcNode().teNodeId()))).destination((longToIp(tunnel.dstNode().teNodeId()))).srcTpId(longToByte(tunnel.srcTp().ttpId())).dstTpId(longToByte(tunnel.dstTp().ttpId())).adminStatus(te2YangStateType(tunnel.adminStatus())).lspProtectionType(te2YangProtectionType(tunnel.lspProtectionType())).type(te2YangTunnelType(tunnel.type())).build();
    return stateBuilder.build();
}
#method_after
private static State te2YangTunnelState(TeTunnel tunnel) {
    State.StateBuilder stateBuilder = new DefaultState.StateBuilder();
    stateBuilder.name(validName(tunnel.name())).identifier((int) tunnel.teTunnelKey().teTunnelId()).source((longToIp(tunnel.srcNode().teNodeId()))).destination((longToIp(tunnel.dstNode().teNodeId()))).srcTpId(longToByte(tunnel.srcTp().ttpId())).dstTpId(longToByte(tunnel.dstTp().ttpId())).adminStatus(te2YangStateType(tunnel.adminStatus())).lspProtectionType(te2YangProtectionType(tunnel.lspProtectionType())).type(te2YangTunnelType(tunnel.type())).build();
    return stateBuilder.build();
}
#end_block

#method_before
private static Config te2YangTunnelConfig(TeTunnel tunnel) {
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.rev20160705.ietfte.tunnelproperties.DefaultConfig.ConfigBuilder configBuilder = new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.rev20160705.ietfte.tunnelproperties.DefaultConfig.ConfigBuilder();
    configBuilder.name(name(tunnel.name())).identifier((int) tunnel.teTunnelKey().teTunnelId()).source((longToIp(tunnel.srcNode().teNodeId()))).destination((longToIp(tunnel.dstNode().teNodeId()))).srcTpId(longToByte(tunnel.srcTp().ttpId())).dstTpId(longToByte(tunnel.dstTp().ttpId())).adminStatus(te2YangStateType(tunnel.adminStatus())).lspProtectionType(te2YangProtectionType(tunnel.lspProtectionType())).type(te2YangTunnelType(tunnel.type())).build();
    return configBuilder.build();
}
#method_after
private static Config te2YangTunnelConfig(TeTunnel tunnel) {
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.rev20160705.ietfte.tunnelproperties.DefaultConfig.ConfigBuilder configBuilder = new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.rev20160705.ietfte.tunnelproperties.DefaultConfig.ConfigBuilder();
    configBuilder.name(validName(tunnel.name())).identifier((int) tunnel.teTunnelKey().teTunnelId()).source((longToIp(tunnel.srcNode().teNodeId()))).destination((longToIp(tunnel.dstNode().teNodeId()))).srcTpId(longToByte(tunnel.srcTp().ttpId())).dstTpId(longToByte(tunnel.dstTp().ttpId())).adminStatus(te2YangStateType(tunnel.adminStatus())).lspProtectionType(te2YangProtectionType(tunnel.lspProtectionType())).type(te2YangTunnelType(tunnel.type())).build();
    return configBuilder.build();
}
#end_block

#method_before
@Activate
public void activateStore() {
    KryoNamespace.Builder kryoBuilder = new KryoNamespace.Builder().register(KryoNamespaces.BASIC).register(java.lang.Class.class).register(DataNode.Type.class).register(LeafNode.class).register(InnerNode.class).register(ResourceId.class).register(NodeKey.class).register(SchemaId.class).register(java.util.LinkedHashMap.class);
    keystore = storageService.<DataNode.Type>documentTreeBuilder().withSerializer(Serializer.using(kryoBuilder.build())).withName("config-key-store").withRelaxedReadConsistency().buildDocumentTree();
    objectStore = storageService.<String, LeafNode>consistentMapBuilder().withSerializer(Serializer.using(kryoBuilder.build())).withName("config-object-store").withRelaxedReadConsistency().build();
    keystore.addListener(klistener);
    objectStore.addListener(olistener);
    log.info("DyanmicConfig Store Active");
}
#method_after
@Activate
public void activateStore() {
    KryoNamespace.Builder kryoBuilder = new KryoNamespace.Builder().register(KryoNamespaces.BASIC).register(java.lang.Class.class).register(DataNode.Type.class).register(LeafNode.class).register(InnerNode.class).register(ResourceId.class).register(NodeKey.class).register(SchemaId.class).register(LeafListKey.class).register(ListKey.class).register(KeyLeaf.class).register(java.util.LinkedHashMap.class);
    keystore = storageService.<DataNode.Type>documentTreeBuilder().withSerializer(Serializer.using(kryoBuilder.build())).withName("config-key-store").withRelaxedReadConsistency().buildDocumentTree();
    objectStore = storageService.<String, LeafNode>consistentMapBuilder().withSerializer(Serializer.using(kryoBuilder.build())).withName("config-object-store").withRelaxedReadConsistency().build();
    keystore.addListener(klistener);
    objectStore.addListener(olistener);
    log.info("DyanmicConfig Store Active");
}
#end_block

#method_before
@Activate
public void activate() {
    store.setDelegate(storeDelegate);
    log.info("DynamicConfigService Started");
}
#method_after
@Activate
public void activate() {
    store.setDelegate(storeDelegate);
    eventDispatcher.addSink(DynamicConfigEvent.class, listenerRegistry);
    log.info("DynamicConfigService Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    store.unsetDelegate(storeDelegate);
    log.info("DynamicConfigService Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    store.unsetDelegate(storeDelegate);
    eventDispatcher.removeSink(DynamicConfigEvent.class);
    log.info("DynamicConfigService Stopped");
}
#end_block

#method_before
@Activate
protected void activate() {
    cfgServcie.addConfigListener(resId, this);
    log.info("NetConfListener Started");
}
#method_after
@Activate
protected void activate() {
    cfgServcie.addListener(this);
    log.info("NetConfListener Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgServcie.removeConfigListener(resId, this);
    log.info("NetConfListener Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgServcie.removeListener(this);
    log.info("NetConfListener Stopped");
}
#end_block

#method_before
public boolean isRelevant(DynamicConfigEvent event) {
    if (event.subject().equals(resId)) {
        log.info("isRelevant {} = {}", resId, event.subject());
        // can i know the specific device here and filter accordingly?
        return true;
    } else {
        log.info("isRelevant {} != {}", resId, event.subject());
        return false;
    }
}
#method_after
public boolean isRelevant(DynamicConfigEvent event) {
    if (event.subject().equals(resId)) {
        log.info("isRelevant {} = {}", resId, event.subject());
        return true;
    } else {
        log.info("isRelevant {} != {}", resId, event.subject());
        return false;
    }
}
#end_block

#method_before
public void event(DynamicConfigEvent event) {
    if (!isRelevant(event)) {
        log.info("event is not relevanyt!!!! {} != {}", resId, event.subject());
        return;
    }
    switch(event.type()) {
        case NODE_ADDED:
            log.info("NetConfListener: RXD NODE_ADDED event");
            Filter filt = new Filter();
            // can i know the specific device here?
            DataNode node = cfgServcie.readNode(event.subject(), filt);
            // netconf passive call here
            break;
        case NODE_UPDATED:
            log.info("NetConfListener: RXD NODE_UPDATED event");
            break;
        case NODE_REPLACED:
            log.info("NetConfListener: RXD NODE_REPLACED event");
            break;
        case NODE_DELETED:
            log.info("NetConfListener: RXD NODE_DELETED event");
            break;
        case UNKNOWN_OPRN:
        default:
            log.warn("NetConfListener: unknown event: {}", event.type());
            break;
    }
}
#method_after
public void event(DynamicConfigEvent event) {
    if (!isRelevant(event)) {
        log.info("event is not relevanyt!!!! {} != {}", resId, event.subject());
        return;
    }
    switch(event.type()) {
        case NODE_ADDED:
            log.info("NetConfListener: RXD NODE_ADDED event");
            Filter filt = new Filter();
            DataNode node = cfgServcie.readNode(event.subject(), filt);
            // call netconf passive
            break;
        case NODE_UPDATED:
            log.info("NetConfListener: RXD NODE_UPDATED event");
            break;
        case NODE_REPLACED:
            log.info("NetConfListener: RXD NODE_REPLACED event");
            break;
        case NODE_DELETED:
            log.info("NetConfListener: RXD NODE_DELETED event");
            break;
        case UNKNOWN_OPRN:
        default:
            log.warn("NetConfListener: unknown event: {}", event.type());
            break;
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NETWORKING_APP_ID);
    allocatedPortNumMap = storageService.<Integer, Long>consistentMapBuilder().withSerializer(Serializer.using(NUMBER_SERIALIZER.build())).withName("openstackrouting-allocatedportnummap").withApplicationId(appId).build();
    unUsedPortNumSet = storageService.<Integer>setBuilder().withName("openstackrouting-unusedportnumset").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    for (int i = TP_PORT_MINIMUM_NUM; i < TP_PORT_MAXIMUM_NUM; i++) {
        unUsedPortNumSet.add(Integer.valueOf(i));
    }
    packetService.addProcessor(packetProcessor, PacketProcessor.director(1));
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NETWORKING_APP_ID);
    allocatedPortNumMap = storageService.<Integer, Long>consistentMapBuilder().withSerializer(Serializer.using(NUMBER_SERIALIZER.build())).withName("openstackrouting-allocatedportnummap").withApplicationId(appId).build();
    unUsedPortNumSet = storageService.<Integer>setBuilder().withName("openstackrouting-unusedportnumset").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    initializeUnusedPortNumSet();
    packetService.addProcessor(packetProcessor, PacketProcessor.director(1));
    log.info("Started");
}
#end_block

#method_before
@Override
public void init(UiConnection connection, ServiceDirectory directory) {
    super.init(connection, directory);
    roadmService = get(RoadmService.class);
    deviceService = roadmService.getDeviceService();
    flowRuleService = roadmService.getFlowRuleService();
}
#method_after
@Override
public void init(UiConnection connection, ServiceDirectory directory) {
    super.init(connection, directory);
    roadmService = get(RoadmService.class);
    deviceService = get(DeviceService.class);
    flowRuleService = get(FlowRuleService.class);
}
#end_block

#method_before
@Override
protected void populateTable(TableModel tm, ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    // Update flows
    Iterable<FlowEntry> flowEntries = flowRuleService.getFlowEntries(deviceId);
    for (FlowEntry flowEntry : flowEntries) {
        populateRow(tm.addRow(), flowEntry, deviceId);
    }
}
#method_after
@Override
protected void populateTable(TableModel tm, ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    // Update flows
    Iterable<FlowEntry> flowEntries = flowRuleService.getFlowEntries(deviceId);
    for (FlowEntry flowEntry : flowEntries) {
        populateRow(tm.addRow(), flowEntry, deviceId);
    }
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    FlowId flowId = FlowId.valueOf(number(payload, FLOW_ID));
    // Get connection information from the flow
    FlowEntry entry = findFlow(deviceId, flowId);
    if (entry == null) {
        log.error("Unable to find flow rule to set attenuation for device {}", deviceId);
        return;
    }
    ChannelData channelData = ChannelData.fromFlow(entry);
    PortNumber port = channelData.outPort();
    OchSignal signal = channelData.ochSignal();
    Range<Long> range = roadmService.attenuationRange(deviceId, port, signal);
    Long attenuation = payload.get(ATTENUATION).asLong();
    boolean validAttenuation = range != null && range.contains(attenuation);
    if (validAttenuation) {
        roadmService.setAttenuation(deviceId, port, signal, attenuation);
    }
    ObjectNode rootNode = objectNode();
    // Send back flowId so view can identify which callback function to use
    rootNode.put(FLOW_ID, payload.get(FLOW_ID).asText());
    rootNode.put(RoadmUtil.VALID, validAttenuation);
    if (range == null) {
        rootNode.put(RoadmUtil.MESSAGE, NO_ATTENUATION_MSG);
    } else {
        rootNode.put(RoadmUtil.MESSAGE, String.format(ATTENUATION_RANGE_MSG, range.toString()));
    }
    sendMessage(ROADM_SET_ATTENUATION_RESP, rootNode);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    FlowId flowId = FlowId.valueOf(number(payload, FLOW_ID));
    // Get connection information from the flow
    FlowEntry entry = findFlow(deviceId, flowId);
    if (entry == null) {
        log.error("Unable to find flow rule to set attenuation for device {}", deviceId);
        return;
    }
    ChannelData channelData = ChannelData.fromFlow(entry);
    PortNumber port = channelData.outPort();
    OchSignal signal = channelData.ochSignal();
    Range<Long> range = roadmService.attenuationRange(deviceId, port, signal);
    Long attenuation = payload.get(ATTENUATION).asLong();
    boolean validAttenuation = range != null && range.contains(attenuation);
    if (validAttenuation) {
        roadmService.setAttenuation(deviceId, port, signal, attenuation);
    }
    ObjectNode rootNode = objectNode();
    // Send back flowId so view can identify which callback function to use
    rootNode.put(FLOW_ID, payload.get(FLOW_ID).asText());
    rootNode.put(RoadmUtil.VALID, validAttenuation);
    if (range == null) {
        rootNode.put(RoadmUtil.MESSAGE, NO_ATTENUATION_MSG);
    } else {
        rootNode.put(RoadmUtil.MESSAGE, String.format(ATTENUATION_RANGE_MSG, range.toString()));
    }
    sendMessage(ROADM_SET_ATTENUATION_RESP, rootNode);
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    FlowId flowId = FlowId.valueOf(payload.get(ID).asLong());
    roadmService.removeConnection(deviceId, flowId);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    FlowId flowId = FlowId.valueOf(payload.get(ID).asLong());
    roadmService.removeConnection(deviceId, flowId);
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    ObjectNode flowNode = node(payload, FORM_DATA);
    int priority = (int) number(flowNode, PRIORITY);
    boolean permanent = bool(flowNode, PERMANENT);
    int timeout = (int) number(flowNode, TIMEOUT);
    PortNumber inPort = PortNumber.portNumber(number(flowNode, IN_PORT));
    PortNumber outPort = PortNumber.portNumber(number(flowNode, OUT_PORT));
    ObjectNode chNode = node(flowNode, CHANNEL_SPACING);
    ChannelSpacing spacing = channelSpacing((int) number(chNode, CHANNEL_SPACING_INDEX));
    int multiplier = (int) number(flowNode, CHANNEL_MULTIPLIER);
    OchSignal och = OchSignal.newDwdmSlot(spacing, multiplier);
    long att = number(flowNode, ATTENUATION);
    boolean showItems = deviceService.getDevice(did).type() != Type.FIBER_SWITCH;
    boolean validInPort = roadmService.validInputPort(did, inPort);
    boolean validOutPort = roadmService.validOutputPort(did, outPort);
    boolean validConnect = roadmService.validConnection(did, inPort, outPort);
    boolean validSpacing = true;
    boolean validChannel = roadmService.validChannel(did, inPort, och);
    boolean channelAvailable = roadmService.channelAvailable(did, och);
    boolean validAttenuation = roadmService.attenuationInRange(did, outPort, att);
    if (validConnect) {
        if (validChannel && channelAvailable) {
            if (validAttenuation) {
                roadmService.createConnection(did, priority, permanent, timeout, inPort, outPort, och, att);
            } else {
                roadmService.createConnection(did, priority, permanent, timeout, inPort, outPort, och);
            }
        } else {
            roadmService.createConnection(did, priority, permanent, timeout, inPort, outPort);
        }
    }
    String channelMessage = "Invalid channel";
    String attenuationMessage = "Invalid attenuation";
    if (showItems) {
        // Construct error for channel
        if (!validChannel) {
            Set<OchSignal> lambdas = roadmService.queryLambdas(did, outPort);
            if (lambdas != null) {
                Range<Integer> range = channelRange(lambdas);
                if (range.contains(och.spacingMultiplier())) {
                    // Channel spacing error
                    validSpacing = false;
                } else {
                    channelMessage = String.format(CHANNEL_ERR_MSG, range.toString());
                }
            }
        }
        // Construct error for attenuation
        if (!validAttenuation) {
            Range<Long> range = roadmService.attenuationRange(did, outPort, och);
            if (range != null) {
                attenuationMessage = String.format(ATTENUATION_ERR_MSG, range.toString());
            }
        }
    }
    // Build response
    ObjectNode node = objectNode();
    node.set(IN_PORT, validationObject(validInPort, IN_PORT_ERR_MSG));
    node.set(OUT_PORT, validationObject(validOutPort, OUT_PORT_ERR_MSG));
    node.set(CONNECTION, validationObject(validConnect, CONNECTION_ERR_MSG));
    node.set(CHANNEL_SPACING, validationObject(validChannel || validSpacing, CHANNEL_SPACING_ERR_MSG));
    node.set(CHANNEL_MULTIPLIER, validationObject(validChannel || !validSpacing, channelMessage));
    node.set(CHANNEL_AVAILABLE, validationObject(!validChannel || channelAvailable, CHANNEL_AVAILABLE_ERR_MSG));
    node.set(ATTENUATION, validationObject(validAttenuation, attenuationMessage));
    sendMessage(ROADM_CREATE_FLOW_RESP, node);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    ObjectNode flowNode = node(payload, FORM_DATA);
    int priority = (int) number(flowNode, PRIORITY);
    boolean permanent = bool(flowNode, PERMANENT);
    int timeout = (int) number(flowNode, TIMEOUT);
    PortNumber inPort = PortNumber.portNumber(number(flowNode, IN_PORT));
    PortNumber outPort = PortNumber.portNumber(number(flowNode, OUT_PORT));
    ObjectNode chNode = node(flowNode, CHANNEL_SPACING);
    ChannelSpacing spacing = channelSpacing((int) number(chNode, CHANNEL_SPACING_INDEX));
    int multiplier = (int) number(flowNode, CHANNEL_MULTIPLIER);
    OchSignal och = OchSignal.newDwdmSlot(spacing, multiplier);
    long att = number(flowNode, ATTENUATION);
    boolean showItems = deviceService.getDevice(did).type() != Type.FIBER_SWITCH;
    boolean validInPort = roadmService.validInputPort(did, inPort);
    boolean validOutPort = roadmService.validOutputPort(did, outPort);
    boolean validConnect = roadmService.validConnection(did, inPort, outPort);
    boolean validSpacing = true;
    boolean validChannel = roadmService.validChannel(did, inPort, och);
    boolean channelAvailable = roadmService.channelAvailable(did, och);
    boolean validAttenuation = roadmService.attenuationInRange(did, outPort, att);
    if (validConnect) {
        if (validChannel && channelAvailable) {
            if (validAttenuation) {
                roadmService.createConnection(did, priority, permanent, timeout, inPort, outPort, och, att);
            } else {
                roadmService.createConnection(did, priority, permanent, timeout, inPort, outPort, och);
            }
        }
    }
    String channelMessage = "Invalid channel";
    String attenuationMessage = "Invalid attenuation";
    if (showItems) {
        // Construct error for channel
        if (!validChannel) {
            Set<OchSignal> lambdas = roadmService.queryLambdas(did, outPort);
            if (lambdas != null) {
                Range<Integer> range = channelRange(lambdas);
                if (range.contains(och.spacingMultiplier())) {
                    // Channel spacing error
                    validSpacing = false;
                } else {
                    channelMessage = String.format(CHANNEL_ERR_MSG, range.toString());
                }
            }
        }
        // Construct error for attenuation
        if (!validAttenuation) {
            Range<Long> range = roadmService.attenuationRange(did, outPort, och);
            if (range != null) {
                attenuationMessage = String.format(ATTENUATION_ERR_MSG, range.toString());
            }
        }
    }
    // Build response
    ObjectNode node = objectNode();
    node.set(IN_PORT, validationObject(validInPort, IN_PORT_ERR_MSG));
    node.set(OUT_PORT, validationObject(validOutPort, OUT_PORT_ERR_MSG));
    node.set(CONNECTION, validationObject(validConnect, CONNECTION_ERR_MSG));
    node.set(CHANNEL_SPACING, validationObject(validChannel || validSpacing, CHANNEL_SPACING_ERR_MSG));
    node.set(CHANNEL_MULTIPLIER, validationObject(validChannel || !validSpacing, channelMessage));
    node.set(CHANNEL_AVAILABLE, validationObject(!validChannel || channelAvailable, CHANNEL_AVAILABLE_ERR_MSG));
    node.set(ATTENUATION, validationObject(validAttenuation, attenuationMessage));
    sendMessage(ROADM_CREATE_FLOW_RESP, node);
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    Type devType = deviceService.getDevice(did).type();
    // Build response
    ObjectNode node = objectNode();
    node.put(SHOW_CHANNEL, devType != Type.FIBER_SWITCH);
    node.put(SHOW_ATTENUATION, devType == Type.ROADM);
    sendMessage(ROADM_SHOW_ITEMS_RESP, node);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    Type devType = deviceService.getDevice(did).type();
    // Build response
    ObjectNode node = objectNode();
    node.put(SHOW_CHANNEL, devType != Type.FIBER_SWITCH);
    node.put(SHOW_ATTENUATION, devType == Type.ROADM);
    sendMessage(ROADM_SHOW_ITEMS_RESP, node);
}
#end_block

#method_before
@Override
public void init(UiConnection connection, ServiceDirectory directory) {
    super.init(connection, directory);
    roadmService = get(RoadmService.class);
    deviceService = roadmService.getDeviceService();
}
#method_after
@Override
public void init(UiConnection connection, ServiceDirectory directory) {
    super.init(connection, directory);
    roadmService = get(RoadmService.class);
    deviceService = get(DeviceService.class);
}
#end_block

#method_before
@Override
protected void populateTable(TableModel tm, ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    if (deviceService.isAvailable(deviceId)) {
        List<Port> ports = deviceService.getPorts(deviceId);
        for (Port port : ports) {
            populateRow(tm.addRow(), port, deviceId);
        }
    }
}
#method_after
@Override
protected void populateTable(TableModel tm, ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    if (deviceService.isAvailable(deviceId)) {
        List<Port> ports = deviceService.getPorts(deviceId);
        for (Port port : ports) {
            populateRow(tm.addRow(), port, deviceId);
        }
    }
}
#end_block

#method_before
private String getPortServiceState(DeviceId deviceId, PortNumber portNumber) {
    Port port = deviceService.getPort(deviceId, portNumber);
    return RoadmUtil.defaultString(port.annotations().value(INPUT_PORT_STATUS), RoadmUtil.UNKNOWN);
}
#method_after
private String getPortServiceState(DeviceId deviceId, PortNumber portNumber) {
    return RoadmUtil.defaultString(roadmService.getProtectionSwitchPortState(deviceId, portNumber), RoadmUtil.UNKNOWN);
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    PortNumber portNumber = PortNumber.portNumber(payload.get(ID).asLong());
    Range<Long> range = roadmService.targetPortPowerRange(deviceId, portNumber);
    if (range == null) {
        log.warn("Unable to determine target power range for device {}", deviceId);
        return;
    }
    Long targetPower = payload.get(TARGET_POWER).asLong();
    boolean validTargetPower = range.contains(targetPower);
    if (validTargetPower) {
        roadmService.setTargetPortPower(deviceId, portNumber, targetPower);
    }
    ObjectNode rootNode = objectNode();
    rootNode.put(ID, payload.get(ID).asText());
    rootNode.put(RoadmUtil.VALID, validTargetPower);
    rootNode.put(RoadmUtil.MESSAGE, String.format(TARGET_POWER_ERR_MSG, range.toString()));
    sendMessage(ROADM_SET_TARGET_POWER_RESP, rootNode);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    PortNumber portNumber = PortNumber.portNumber(payload.get(ID).asLong());
    Range<Long> range = roadmService.targetPortPowerRange(deviceId, portNumber);
    if (range == null) {
        log.warn("Unable to determine target power range for device {}", deviceId);
        return;
    }
    Long targetPower = payload.get(TARGET_POWER).asLong();
    boolean validTargetPower = range.contains(targetPower);
    if (validTargetPower) {
        roadmService.setTargetPortPower(deviceId, portNumber, targetPower);
    }
    ObjectNode rootNode = objectNode();
    rootNode.put(ID, payload.get(ID).asText());
    rootNode.put(RoadmUtil.VALID, validTargetPower);
    rootNode.put(RoadmUtil.MESSAGE, String.format(TARGET_POWER_ERR_MSG, range.toString()));
    sendMessage(ROADM_SET_TARGET_POWER_RESP, rootNode);
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    Type devType = deviceService.getDevice(did).type();
    // Build response
    ObjectNode node = objectNode();
    node.put(SHOW_TARGET_POWER, devType != Type.FIBER_SWITCH);
    node.put(SHOW_SERVICE_STATE, devType == Type.FIBER_SWITCH);
    node.put(SHOW_FLOW_ICON, devType == Type.ROADM);
    sendMessage(ROADM_SHOW_ITEMS_RESP, node);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    Type devType = deviceService.getDevice(did).type();
    // Build response
    ObjectNode node = objectNode();
    node.put(SHOW_TARGET_POWER, devType != Type.FIBER_SWITCH);
    node.put(SHOW_SERVICE_STATE, devType == Type.FIBER_SWITCH);
    node.put(SHOW_FLOW_ICON, devType == Type.ROADM);
    sendMessage(ROADM_SHOW_ITEMS_RESP, node);
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID, RoadmUtil.NONE));
    ObjectNode node = objectNode();
    if (!deviceService.isAvailable(did)) {
        node.put(RoadmUtil.VALID, false);
        node.put(RoadmUtil.MESSAGE, DEVICE_INVALID_ERR_MSG);
        sendMessage(ROADM_SET_OPS_MODE_RESP, node);
        return;
    }
    Type devType = deviceService.getDevice(did).type();
    if (devType != Type.FIBER_SWITCH) {
        node.put(RoadmUtil.VALID, false);
        node.put(RoadmUtil.MESSAGE, TYPE_INVALID_ERR_MSG);
        sendMessage(ROADM_SET_OPS_MODE_RESP, node);
        return;
    }
    String mode = string(payload, OPS_MODE_TITLE, RoadmUtil.NONE);
    OpsPortType type = OpsPortType.valueOf(mode.toUpperCase());
    PortNumber inPort = PortNumber.portNumber(type.ordinal());
    PortNumber outPort = PortNumber.portNumber(OpsPortType.CLIENT.ordinal());
    roadmService.getFlowRuleService().purgeFlowRules(did);
    roadmService.createConnection(did, 0, true, 0, inPort, outPort);
    node.put(RoadmUtil.VALID, true);
    sendMessage(ROADM_SET_OPS_MODE_RESP, node);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, RoadmUtil.DEV_ID));
    ObjectNode node = objectNode();
    if (!deviceService.isAvailable(did)) {
        node.put(RoadmUtil.VALID, false);
        node.put(RoadmUtil.MESSAGE, DEVICE_INVALID_ERR_MSG);
        sendMessage(ROADM_SET_OPS_MODE_RESP, node);
        return;
    }
    Type devType = deviceService.getDevice(did).type();
    if (devType != Type.FIBER_SWITCH) {
        node.put(RoadmUtil.VALID, false);
        node.put(RoadmUtil.MESSAGE, TYPE_INVALID_ERR_MSG);
        sendMessage(ROADM_SET_OPS_MODE_RESP, node);
        return;
    }
    // get virtual port and switch port from payload
    roadmService.setProtectionSwitchWorkingPath(did, (int) number(payload, OPS_SWITCH_INDEX));
    node.put(RoadmUtil.VALID, true);
    sendMessage(ROADM_SET_OPS_MODE_RESP, node);
}
#end_block

#method_before
@Override
public FlowId createConnection(DeviceId deviceId, int priority, boolean isPermanent, int timeout, PortNumber inPort, PortNumber outPort, OchSignal ochSignal) {
    checkNotNull(deviceId);
    checkNotNull(inPort);
    checkNotNull(outPort);
    FlowRule.Builder flowBuilder = new DefaultFlowRule.Builder();
    flowBuilder.fromApp(appId);
    flowBuilder.withPriority(priority);
    if (isPermanent) {
        flowBuilder.makePermanent();
    } else {
        flowBuilder.makeTemporary(timeout);
    }
    flowBuilder.forDevice(deviceId);
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.add(Criteria.matchInPort(inPort));
    selectorBuilder.add(Criteria.matchOchSignalType(OchSignalType.FIXED_GRID));
    selectorBuilder.add(Criteria.matchLambda(ochSignal));
    flowBuilder.withSelector(selectorBuilder.build());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.add(Instructions.createOutput(outPort));
    flowBuilder.withTreatment(treatmentBuilder.build());
    FlowRule flowRule = flowBuilder.build();
    flowRuleService.applyFlowRules(flowRule);
    log.info("Created connection from input port {} to output port {}", inPort.toLong(), outPort.toLong());
    return flowRule.id();
}
#method_after
@Override
public FlowId createConnection(DeviceId deviceId, int priority, boolean isPermanent, int timeout, PortNumber inPort, PortNumber outPort, OchSignal ochSignal) {
    checkNotNull(deviceId);
    checkNotNull(inPort);
    checkNotNull(outPort);
    TrafficSelector selector = DefaultTrafficSelector.builder().add(Criteria.matchInPort(inPort)).add(Criteria.matchOchSignalType(OchSignalType.FIXED_GRID)).add(Criteria.matchLambda(ochSignal)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().add(Instructions.createOutput(outPort)).build();
    FlowRule.Builder flowBuilder = DefaultFlowRule.builder().forDevice(deviceId).fromApp(appId).withPriority(priority).withSelector(selector).withTreatment(treatment);
    if (isPermanent) {
        flowBuilder.makePermanent();
    } else {
        flowBuilder.makeTemporary(timeout);
    }
    FlowRule flowRule = flowBuilder.build();
    flowRuleService.applyFlowRules(flowRule);
    log.info("Created connection from input port {} to output port {}", inPort.toLong(), outPort.toLong());
    return flowRule.id();
}
#end_block

#method_before
private LambdaQuery getLambdaQuery(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null && device.is(LambdaQuery.class)) {
        return device.as(LambdaQuery.class);
    }
    return null;
}
#method_after
private LambdaQuery getLambdaQuery(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null && device.is(LambdaQuery.class)) {
        return device.as(LambdaQuery.class);
    }
    log.warn("Unable to load LambdaQuery for {}", deviceId);
    return null;
}
#end_block

#method_before
private void initDevices() {
    for (Device device : deviceService.getDevices(Device.Type.ROADM)) {
        initDevice(device.id());
    // setAllInitialTargetPortPowers(device.id());
    }
}
#method_after
private void initDevices() {
    for (Device device : deviceService.getDevices(Device.Type.ROADM)) {
        initDevice(device.id());
    // FIXME
    // As roadm application is a optional tool for now.
    // The target power initialization will be enhanced later,
    // hopefully using an formal optical subsystem.
    // setAllInitialTargetPortPowers(device.id());
    }
}
#end_block

#method_before
@Override
public CompletableFuture<ConnectPoint> createProtectionEndpoint(ProtectedTransportEndpointDescription configuration) {
    // This OPS device only support one protection group of port 2 and port 3
    CompletableFuture result = new CompletableFuture<ConnectPoint>();
    // add flow form client port to virtual port. This set device in auto switch mode
    addFlow(PortNumber.portNumber(VIRTUAL_PORT));
    // TODO: how to update the port description (add fingerprint) of the virtual port?
    // TODO: how to save the peer device ID?
    result.complete(new ConnectPoint(this.data().deviceId(), PortNumber.portNumber(VIRTUAL_PORT)));
    return result;
}
#method_after
@Override
public CompletableFuture<ConnectPoint> createProtectionEndpoint(ProtectedTransportEndpointDescription configuration) {
    // This OPS device only support one protection group of port 2 and port 3
    CompletableFuture result = new CompletableFuture<ConnectPoint>();
    // add flow from client port to virtual port. This set device in auto switch mode
    addFlow(PortNumber.portNumber(VIRTUAL_PORT));
    // add a virtual link bewteen two virtual ports of this device and peer
    addLinkToPeer(configuration.peer());
    result.complete(new ConnectPoint(this.data().deviceId(), PortNumber.portNumber(VIRTUAL_PORT)));
    return result;
}
#end_block

#method_before
@Override
public CompletableFuture<ConnectPoint> updateProtectionEndpoint(ConnectPoint identifier, ProtectedTransportEndpointDescription configuration) {
    return null;
}
#method_after
@Override
public CompletableFuture<ConnectPoint> updateProtectionEndpoint(ConnectPoint identifier, ProtectedTransportEndpointDescription configuration) {
    log.warn("Update protection configuration is not supported by this device");
    CompletableFuture result = new CompletableFuture<ConnectPoint>();
    result.complete(new ConnectPoint(this.data().deviceId(), PortNumber.portNumber(VIRTUAL_PORT)));
    return result;
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> deleteProtectionEndpoint(ConnectPoint identifier) {
    // OPS has only one protection group
    CompletableFuture result = new CompletableFuture<Boolean>();
    if (identifier.port().toLong() == VIRTUAL_PORT) {
        deleteFlow();
        result.complete(true);
    } else {
        result.complete(false);
    }
    return result;
}
#method_after
@Override
public CompletableFuture<Boolean> deleteProtectionEndpoint(ConnectPoint identifier) {
    // OPS has only one protection group
    CompletableFuture result = new CompletableFuture<Boolean>();
    if (identifier.port().toLong() == VIRTUAL_PORT) {
        // add a link bewteen two virtual ports of this device and peer
        removeLinkToPeer(getPeerId());
        deleteFlow();
        result.complete(true);
    } else {
        result.complete(false);
    }
    return result;
}
#end_block

#method_before
@Override
public CompletableFuture<Void> switchWorkingPath(ConnectPoint identifier, int index) {
    // send switch command to switch to device by sending a flow-mod message.
    deleteFlow();
    addFlow(PortNumber.portNumber(index));
    return null;
}
#method_after
@Override
public CompletableFuture<Void> switchWorkingPath(ConnectPoint identifier, int index) {
    CompletableFuture result = new CompletableFuture<Boolean>();
    // send switch command to switch to device by sending a flow-mod message.
    if (identifier.port().toLong() == VIRTUAL_PORT) {
        deleteFlow();
        addFlow(PortNumber.portNumber(index));
        result.complete(true);
    } else {
        result.complete(false);
    }
    return result;
}
#end_block

#method_before
private ProtectedTransportEndpointDescription getProtectedTransportEndpointDescription() {
    List<TransportEndpointDescription> teds = new ArrayList<>();
    FilteredConnectPoint fcpPrimary = new FilteredConnectPoint(new ConnectPoint(this.data().deviceId(), PortNumber.portNumber(PRIMARY_PORT)));
    FilteredConnectPoint fcpSecondary = new FilteredConnectPoint(new ConnectPoint(this.data().deviceId(), PortNumber.portNumber(SECONDARY_PORT)));
    TransportEndpointDescription tedPrimary = TransportEndpointDescription.builder().withOutput(fcpPrimary).build();
    TransportEndpointDescription tedSecondary = TransportEndpointDescription.builder().withOutput(fcpSecondary).build();
    teds.add(PRIMARY_PORT, tedPrimary);
    teds.add(SECONDARY_PORT, tedSecondary);
    return ProtectedTransportEndpointDescription.of(teds, // TODO: how can we get the peerID?
    this.data().deviceId(), ProtectionConfigBehaviour.FINGERPRINT);
}
#method_after
private ProtectedTransportEndpointDescription getProtectedTransportEndpointDescription() {
    List<TransportEndpointDescription> teds = new ArrayList<>();
    FilteredConnectPoint fcpPrimary = new FilteredConnectPoint(new ConnectPoint(data().deviceId(), PortNumber.portNumber(PRIMARY_PORT)));
    FilteredConnectPoint fcpSecondary = new FilteredConnectPoint(new ConnectPoint(data().deviceId(), PortNumber.portNumber(SECONDARY_PORT)));
    TransportEndpointDescription tedPrimary = TransportEndpointDescription.builder().withOutput(fcpPrimary).build();
    TransportEndpointDescription tedSecondary = TransportEndpointDescription.builder().withOutput(fcpSecondary).build();
    teds.add(tedPrimary);
    teds.add(tedSecondary);
    return ProtectedTransportEndpointDescription.of(teds, getPeerId(), OPLINK_FINGERPRINT);
}
#end_block

#method_before
private Map<String, String> getProtectionStateAttributes(PortNumber portNumber) {
    Map<String, String> attributes = new HashMap<>();
    // get status form port annotations, the status is update by hand shaker driver periodically
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Port port = deviceService.getPort(this.data().deviceId(), portNumber);
    if (port != null) {
        String portStatus = port.annotations().value(INPUT_STATUS);
        attributes.put(INPUT_STATUS, portStatus);
    }
    return attributes;
}
#method_after
private Map<String, String> getProtectionStateAttributes(PortNumber portNumber) {
    Map<String, String> attributes = new HashMap<>();
    // get status form port annotations, the status is update by hand shaker driver periodically
    Port port = deviceService.getPort(this.data().deviceId(), portNumber);
    if (port != null) {
        String portStatus = port.annotations().value(OpticalAnnotations.INPUT_PORT_STATUS);
        attributes.put(OpticalAnnotations.INPUT_PORT_STATUS, portStatus);
    }
    return attributes;
}
#end_block

#method_before
private int getActiveIndex() {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Port port = deviceService.getPort(this.data().deviceId(), PortNumber.portNumber(PRIMARY_PORT));
    if (port != null) {
        if (port.annotations().value(INPUT_STATUS).equals(IN_SERVICE_STATUS)) {
            return PRIMARY_PORT;
        }
    }
    return SECONDARY_PORT;
}
#method_after
private int getActiveIndex() {
    Port port = deviceService.getPort(this.data().deviceId(), PortNumber.portNumber(PRIMARY_PORT));
    if (port != null) {
        if (port.annotations().value(OpticalAnnotations.INPUT_PORT_STATUS).equals(OpticalAnnotations.STATUS_IN_SERVICE)) {
            return PRIMARY_PORT;
        }
    }
    return SECONDARY_PORT;
}
#end_block

#method_before
private ProtectedTransportEndpointState getProtectedTransportEndpointState() {
    List<TransportEndpointState> tess = new ArrayList<>();
    FilteredConnectPoint fcpPrimary = new FilteredConnectPoint(new ConnectPoint(this.data().deviceId(), PortNumber.portNumber(PRIMARY_PORT)));
    FilteredConnectPoint fcpSecondary = new FilteredConnectPoint(new ConnectPoint(this.data().deviceId(), PortNumber.portNumber(SECONDARY_PORT)));
    TransportEndpointDescription tedPrimary = TransportEndpointDescription.builder().withOutput(fcpPrimary).build();
    TransportEndpointDescription tedSecondary = TransportEndpointDescription.builder().withOutput(fcpSecondary).build();
    TransportEndpointState tesPrimary = TransportEndpointState.builder().withDescription(tedPrimary).withId(TransportEndpointId.of(PRIMARY_ID)).addAttributes(getProtectionStateAttributes(PortNumber.portNumber(PRIMARY_PORT))).build();
    TransportEndpointState tesSecondary = TransportEndpointState.builder().withDescription(tedSecondary).withId(TransportEndpointId.of(SECONDARY_ID)).addAttributes(getProtectionStateAttributes((PortNumber.portNumber(SECONDARY_PORT)))).build();
    tess.add(PRIMARY_PORT, tesPrimary);
    tess.add(SECONDARY_PORT, tesSecondary);
    return ProtectedTransportEndpointState.builder().withDescription(getProtectedTransportEndpointDescription()).withPathStates(tess).withActivePathIndex(getActiveIndex()).build();
}
#method_after
private ProtectedTransportEndpointState getProtectedTransportEndpointState() {
    List<TransportEndpointState> tess = new ArrayList<>();
    FilteredConnectPoint fcpPrimary = new FilteredConnectPoint(new ConnectPoint(data().deviceId(), PortNumber.portNumber(PRIMARY_PORT)));
    FilteredConnectPoint fcpSecondary = new FilteredConnectPoint(new ConnectPoint(data().deviceId(), PortNumber.portNumber(SECONDARY_PORT)));
    TransportEndpointDescription tedPrimary = TransportEndpointDescription.builder().withOutput(fcpPrimary).build();
    TransportEndpointDescription tedSecondary = TransportEndpointDescription.builder().withOutput(fcpSecondary).build();
    TransportEndpointState tesPrimary = TransportEndpointState.builder().withDescription(tedPrimary).withId(TransportEndpointId.of(PRIMARY_ID)).addAttributes(getProtectionStateAttributes(PortNumber.portNumber(PRIMARY_PORT))).build();
    TransportEndpointState tesSecondary = TransportEndpointState.builder().withDescription(tedSecondary).withId(TransportEndpointId.of(SECONDARY_ID)).addAttributes(getProtectionStateAttributes((PortNumber.portNumber(SECONDARY_PORT)))).build();
    tess.add(tesPrimary);
    tess.add(tesSecondary);
    return ProtectedTransportEndpointState.builder().withDescription(getProtectedTransportEndpointDescription()).withPathStates(tess).withActivePathIndex(getActiveIndex()).build();
}
#end_block

#method_before
private void addFlow(PortNumber workingPort) {
    FlowRuleService flowRuleService = this.handler().get(FlowRuleService.class);
    // add default flow to put device in auto mode.
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    FlowEntry.Builder flowEntry = DefaultFlowEntry.builder();
    // set working port as flow's input port
    selectorBuilder.matchInPort(workingPort);
    // the flow's  output port is always the clinet port
    treatment.setOutput(PortNumber.portNumber(CLIENT_PORT));
    flowEntry.forDevice(this.data().deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatment.build()).makePermanent();
    // install flow rule
    flowRuleService.applyFlowRules(flowEntry.build());
}
#method_after
private void addFlow(PortNumber workingPort) {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    FlowRule.Builder flowRule = DefaultFlowRule.builder();
    // set working port as flow's input port
    selectorBuilder.matchInPort(workingPort);
    // the flow's  output port is always the clinet port
    treatment.setOutput(PortNumber.portNumber(CLIENT_PORT));
    flowRule.forDevice(this.data().deviceId()).withSelector(selectorBuilder.build()).withTreatment(treatment.build()).makePermanent();
    // install flow rule
    flowRuleService.applyFlowRules(flowRule.build());
}
#end_block

#method_before
private void deleteFlow() {
    // remove all the flows.
    FlowRuleService flowRuleService = this.handler().get(FlowRuleService.class);
    flowRuleService.purgeFlowRules(this.data().deviceId());
}
#method_after
private void deleteFlow() {
    // remove all the flows.
    flowRuleService.purgeFlowRules(this.data().deviceId());
}
#end_block

#method_before
@Override
public YobWorkBench createObject(DataNode curNode, YangSchemaNode context, DefaultYangModelRegistry registry) {
    // For single instance leaf no need to create an object.
    return null;
}
#method_after
@Override
YobWorkBench createObject(YangSchemaNode schemaNode, DefaultYangModelRegistry registry) {
    // For single instance leaf no need to create an object.
    return null;
}
#end_block

#method_before
public void buildObject(YobWorkBench curWorkbench, YangModelRegistry registry) {
// For single instance leaf no need to build an object.
}
#method_after
void buildObject(YobWorkBench curWorkbench, YangModelRegistry registry) {
// For single instance leaf no need to build an object.
}
#end_block

#method_before
@Override
public void setInParent(DataNode leafNode, YobWorkBench curWb, YobWorkBench parentWb, DefaultYangModelRegistry registry) {
    Class<?> parentClass = null;
    try {
        YangSchemaNode schemaNode = getChildSchemaNode(leafNode, curWb.schemaNode());
        YangSchemaNode referredSchema = schemaNode;
        while (referredSchema.getReferredSchema() != null) {
            referredSchema = referredSchema.getReferredSchema();
        }
        String setterInParent = referredSchema.getJavaAttributeName();
        Object parentObj = curWb.getParentObject(registry, schemaNode);
        parentClass = parentObj.getClass();
        YangDataTypes dataType = ((YangLeaf) referredSchema).getDataType().getDataType();
        if (((LeafNode) leafNode).value() != null || dataType == YangDataTypes.EMPTY) {
            Field leafName = parentClass.getDeclaredField(setterInParent);
            Method setterMethod = parentClass.getDeclaredMethod(setterInParent, leafName.getType());
            setDataFromStringValue(dataType, ((LeafNode) leafNode).value(), setterMethod, parentObj, referredSchema, curWb.schemaNode());
        }
    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, parentClass.getName());
        throw new ModelConvertorException(E_FAIL_TO_INVOKE_METHOD + parentClass.getName());
    }
}
#method_after
@Override
void setInParent(DataNode leafNode, YobWorkBench curWb, YobWorkBench parentWb, DefaultYangModelRegistry registry) {
    Class<?> parentClass = null;
    try {
        YangSchemaNode schemaNode = getChildSchemaNode(leafNode, curWb.schemaNode());
        YangSchemaNode referredSchema = schemaNode;
        while (referredSchema.getReferredSchema() != null) {
            referredSchema = referredSchema.getReferredSchema();
        }
        String setterInParent = referredSchema.getJavaAttributeName();
        Object parentObj = curWb.getParentObject(registry, schemaNode);
        parentClass = parentObj.getClass();
        YangDataTypes dataType = ((YangLeaf) referredSchema).getDataType().getDataType();
        if (((LeafNode) leafNode).value() != null || dataType == YangDataTypes.EMPTY) {
            Field leafName = parentClass.getDeclaredField(setterInParent);
            Method setterMethod = parentClass.getDeclaredMethod(setterInParent, leafName.getType());
            setDataFromStringValue(dataType, ((LeafNode) leafNode).value(), setterMethod, parentObj, referredSchema, curWb.schemaNode());
        }
    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, parentClass.getName());
        throw new ModelConvertorException(E_FAIL_TO_INVOKE_METHOD + parentClass.getName());
    }
}
#end_block

#method_before
@Override
public ModelObjectData getYangObject(ResourceData data) {
    DefaultModelObjectData.Builder builder = DefaultModelObjectData.builder();
    ModelObjectId id = null;
    if (data.resourceId() != null) {
        id = getModelObjectId(data.resourceId());
    }
    List<DataNode> dataNodes = data.dataNodes();
    if (nonEmpty(dataNodes)) {
        for (DataNode dataNode : dataNodes) {
            YobListener listener = new YobListener(lastIndexNode, registry);
            walk(listener, dataNode);
            List<ModelObject> objList = listener.modelObjectList();
            if (objList != null) {
                for (ModelObject obj : objList) {
                    builder.addModelObject(obj);
                }
            }
        }
    }
    return builder.identifer(id).build();
}
#method_after
public ModelObjectData getYangObject(ResourceData data) {
    DefaultModelObjectData.Builder builder = DefaultModelObjectData.builder();
    ModelObjectId id = null;
    if (data.resourceId() != null) {
        id = convertRscIdToMoId(data.resourceId());
    }
    List<DataNode> dataNodes = data.dataNodes();
    if (nonEmpty(dataNodes)) {
        for (DataNode dataNode : dataNodes) {
            YobListener listener = new YobListener(lastIndexNode, registry);
            walk(listener, dataNode);
            List<ModelObject> objList = listener.modelObjectList();
            if (objList != null) {
                for (ModelObject obj : objList) {
                    builder.addModelObject(obj);
                }
            }
        }
    }
    return builder.identifer(id).build();
}
#end_block

#method_before
public ModelObjectId convertRscIdToMoId(ResourceId id) {
    ModelObjectId.Builder midb = ModelObjectId.builder();
    if (id != null) {
        List<NodeKey> nodeKeys = id.nodeKeys();
        NodeKey key;
        SchemaId sId;
        if (nonEmpty(nodeKeys)) {
            Iterator<NodeKey> it = nodeKeys.iterator();
            while (it.hasNext()) {
                key = it.next();
                sId = key.schemaId();
                if (sId.name().equals(FORWARD_SLASH)) {
                    continue;
                }
                YangSchemaNode schemaNode = ((YangSchemaNode) getChildSchemaContext(lastIndexNode, sId.name(), sId.namespace()));
                if (key instanceof ListKey) {
                    midb = handleListKey(midb, registry, schemaNode, key);
                } else if (key instanceof LeafListKey) {
                    LeafListKey llKey = (LeafListKey) key;
                    midb = handleLeafListKey(midb, registry, lastIndexNode, llKey);
                } else {
                    midb = handleNodeKey(midb, registry, schemaNode, key, lastIndexNode);
                }
                lastIndexNode = schemaNode;
            }
        }
    }
    return midb.build();
}
#method_after
private ModelObjectId convertRscIdToMoId(ResourceId id) {
    ModelObjectId.Builder midb = ModelObjectId.builder();
    if (id != null) {
        List<NodeKey> nodeKeys = id.nodeKeys();
        NodeKey key;
        SchemaId sId;
        if (nonEmpty(nodeKeys)) {
            Iterator<NodeKey> it = nodeKeys.iterator();
            while (it.hasNext()) {
                key = it.next();
                sId = key.schemaId();
                if (sId.name().equals(FORWARD_SLASH)) {
                    continue;
                }
                YangSchemaNode schemaNode;
                if (lastIndexNode == null) {
                    schemaNode = ((YangSchemaNode) registry.getChildContext(sId));
                } else {
                    schemaNode = ((YangSchemaNode) getChildSchemaContext(lastIndexNode, sId.name(), sId.namespace()));
                }
                if (key instanceof ListKey) {
                    midb = handleListKey(midb, registry, schemaNode, key);
                } else if (key instanceof LeafListKey) {
                    LeafListKey llKey = (LeafListKey) key;
                    midb = handleLeafListKey(midb, registry, schemaNode, llKey);
                } else {
                    midb = handleNodeKey(midb, registry, schemaNode, key);
                }
                if (!(schemaNode instanceof YangLeaf) || !(schemaNode instanceof YangLeafList)) {
                    lastIndexNode = schemaNode;
                }
            }
        }
    }
    return midb.build();
}
#end_block

#method_before
public static void setDataFromStringValue(YangDataTypes type, Object value, Method parentSetter, Object parentObj, YangSchemaNode schemaNode, YangSchemaNode parentSchema) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    switch(type) {
        case INT8:
        case UINT8:
        case INT16:
        case UINT16:
        case INT32:
        case UINT32:
        case INT64:
        case UINT64:
        case BOOLEAN:
        case EMPTY:
        case STRING:
            parentSetter.invoke(parentObj, value);
            break;
        case BINARY:
            parentSetter.invoke(parentObj, ((String) value).getBytes());
            break;
        case BITS:
            parseBitSetTypeInfo(parentSetter, parentObj, value, schemaNode, parentSchema);
            break;
        case DECIMAL64:
            parentSetter.invoke(parentObj, new BigDecimal(value.toString()));
            break;
        case DERIVED:
            parseDerivedTypeInfo(parentSetter, parentObj, value.toString(), false, schemaNode);
            break;
        case IDENTITYREF:
            parseIdentityRefInfo(parentSetter, parentObj, value, schemaNode);
            break;
        case UNION:
            parseDerivedTypeInfo(parentSetter, parentObj, value.toString(), false, schemaNode);
            break;
        case LEAFREF:
            parseLeafRefTypeInfo(parentSetter, parentObj, value, schemaNode, parentSchema);
            break;
        case ENUMERATION:
            parseDerivedTypeInfo(parentSetter, parentObj, value.toString(), true, schemaNode);
            break;
        default:
            log.error(E_DATA_TYPE_NOT_SUPPORT);
    }
}
#method_after
static void setDataFromStringValue(YangDataTypes type, Object value, Method parentSetter, Object parentObj, YangSchemaNode schemaNode, YangSchemaNode parentSchema) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    switch(type) {
        case INT8:
        case UINT8:
        case INT16:
        case UINT16:
        case INT32:
        case UINT32:
        case INT64:
        case UINT64:
        case BOOLEAN:
        case EMPTY:
        case STRING:
            parentSetter.invoke(parentObj, value);
            break;
        case BINARY:
            parentSetter.invoke(parentObj, ((String) value).getBytes());
            break;
        case BITS:
            parseBitSetTypeInfo(parentSetter, parentObj, value, schemaNode, parentSchema);
            break;
        case DECIMAL64:
            parentSetter.invoke(parentObj, new BigDecimal(value.toString()));
            break;
        case DERIVED:
            parseDerivedTypeInfo(parentSetter, parentObj, value.toString(), false, schemaNode);
            break;
        case IDENTITYREF:
            parseIdentityRefInfo(parentSetter, parentObj, value, schemaNode);
            break;
        case UNION:
            parseDerivedTypeInfo(parentSetter, parentObj, value.toString(), false, schemaNode);
            break;
        case LEAFREF:
            parseLeafRefTypeInfo(parentSetter, parentObj, value, schemaNode, parentSchema);
            break;
        case ENUMERATION:
            parseDerivedTypeInfo(parentSetter, parentObj, value.toString(), true, schemaNode);
            break;
        default:
            log.error(E_DATA_TYPE_NOT_SUPPORT);
    }
}
#end_block

#method_before
private static void parseDerivedTypeInfo(Method parentSetter, Object parentObj, String value, boolean isEnum, YangSchemaNode leaf) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    Class<?> childSetClass = null;
    Constructor<?> childConstructor = null;
    Object childValue = null;
    Object childObject = null;
    Method childMethod = null;
    while (leaf.getReferredSchema() != null) {
        leaf = leaf.getReferredSchema();
    }
    String qualifiedClassName = leaf.getJavaPackage() + PERIOD + getCapitalCase(leaf.getJavaClassNameOrBuiltInType());
    ClassLoader classLoader = parentObj.getClass().getClassLoader();
    try {
        childSetClass = classLoader.loadClass(qualifiedClassName);
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, qualifiedClassName);
    }
    if (!isEnum) {
        if (childSetClass != null) {
            childConstructor = childSetClass.getDeclaredConstructor();
        }
        if (childConstructor != null) {
            childConstructor.setAccessible(true);
        }
        try {
            if (childConstructor != null) {
                childObject = childConstructor.newInstance();
            }
        } catch (InstantiationException e) {
            log.error(E_FAIL_TO_LOAD_CONSTRUCTOR, qualifiedClassName);
        }
        if (childSetClass != null) {
            childMethod = childSetClass.getDeclaredMethod(FROM_STRING, String.class);
        }
    } else {
        if (childSetClass != null) {
            childMethod = childSetClass.getDeclaredMethod(OF, String.class);
        }
    }
    if (childMethod != null) {
        childValue = childMethod.invoke(childObject, value);
    }
    parentSetter.invoke(parentObj, childValue);
}
#method_after
static void parseDerivedTypeInfo(Method parentSetter, Object parentObj, String value, boolean isEnum, YangSchemaNode leaf) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    Class<?> childSetClass = null;
    Constructor<?> childConstructor = null;
    Object childValue = null;
    Object childObject = null;
    Method childMethod = null;
    while (leaf.getReferredSchema() != null) {
        leaf = leaf.getReferredSchema();
    }
    String qualifiedClassName = leaf.getJavaPackage() + PERIOD + getCapitalCase(leaf.getJavaClassNameOrBuiltInType());
    ClassLoader classLoader = parentObj.getClass().getClassLoader();
    try {
        childSetClass = classLoader.loadClass(qualifiedClassName);
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, qualifiedClassName);
    }
    if (!isEnum) {
        if (childSetClass != null) {
            childConstructor = childSetClass.getDeclaredConstructor();
        }
        if (childConstructor != null) {
            childConstructor.setAccessible(true);
        }
        try {
            if (childConstructor != null) {
                childObject = childConstructor.newInstance();
            }
        } catch (InstantiationException e) {
            log.error(E_FAIL_TO_LOAD_CONSTRUCTOR, qualifiedClassName);
        }
        if (childSetClass != null) {
            childMethod = childSetClass.getDeclaredMethod(FROM_STRING, String.class);
        }
    } else {
        if (childSetClass != null) {
            childMethod = childSetClass.getDeclaredMethod(OF, String.class);
        }
    }
    if (childMethod != null) {
        childValue = childMethod.invoke(childObject, value);
    }
    parentSetter.invoke(parentObj, childValue);
}
#end_block

#method_before
private static void parseBitSetTypeInfo(Method parentSetterMethod, Object parentObject, Object leafValue, YangSchemaNode leaf, YangSchemaNode parentSchema) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    Class<?> childSetClass = null;
    Object childValue = null;
    Object childObject = null;
    Method childMethod = null;
    while (leaf.getReferredSchema() != null) {
        leaf = leaf.getReferredSchema();
    }
    String qualifiedClassName = parentSchema.getJavaPackage() + PERIOD + parentSchema.getJavaAttributeName().toLowerCase() + PERIOD + getCapitalCase(leaf.getJavaAttributeName());
    ClassLoader classLoader = parentObject.getClass().getClassLoader();
    try {
        childSetClass = classLoader.loadClass(qualifiedClassName);
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, qualifiedClassName);
    }
    if (childSetClass != null) {
        childMethod = childSetClass.getDeclaredMethod(FROM_STRING, String.class);
    }
    if (childMethod != null) {
        childValue = childMethod.invoke(childObject, leafValue);
    }
    parentSetterMethod.invoke(parentObject, childValue);
}
#method_after
static void parseBitSetTypeInfo(Method parentSetterMethod, Object parentObject, Object leafValue, YangSchemaNode leaf, YangSchemaNode parentSchema) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    Class<?> childSetClass = null;
    Object childValue = null;
    Object childObject = null;
    Method childMethod = null;
    while (leaf.getReferredSchema() != null) {
        leaf = leaf.getReferredSchema();
    }
    String qualifiedClassName = parentSchema.getJavaPackage() + PERIOD + parentSchema.getJavaAttributeName().toLowerCase() + PERIOD + getCapitalCase(leaf.getJavaAttributeName());
    ClassLoader classLoader = parentObject.getClass().getClassLoader();
    try {
        childSetClass = classLoader.loadClass(qualifiedClassName);
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, qualifiedClassName);
    }
    if (childSetClass != null) {
        childMethod = childSetClass.getDeclaredMethod(FROM_STRING, String.class);
    }
    if (childMethod != null) {
        childValue = childMethod.invoke(childObject, leafValue);
    }
    parentSetterMethod.invoke(parentObject, childValue);
}
#end_block

#method_before
private static void parseLeafRefTypeInfo(Method parentSetterMethod, Object parentObject, Object leafValue, YangSchemaNode schemaNode, YangSchemaNode parentSchema) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    while (schemaNode.getReferredSchema() != null) {
        schemaNode = schemaNode.getReferredSchema();
    }
    YangLeafRef leafRef;
    if (schemaNode instanceof YangLeaf) {
        leafRef = (YangLeafRef) ((YangLeaf) schemaNode).getDataType().getDataTypeExtendedInfo();
    } else {
        leafRef = (YangLeafRef) ((YangLeafList) schemaNode).getDataType().getDataTypeExtendedInfo();
    }
    YangType type = leafRef.getEffectiveDataType();
    if (type.getDataType() == YangDataTypes.DERIVED && schemaNode.getJavaPackage().equals(YobConstants.JAVA_LANG)) {
        /*
             * If leaf is inside grouping, then its return type will be of type
             * Object and if its actual type is derived type then get the
             * effective built-in type and set the value.
             */
        YangDerivedInfo derivedInfo = (YangDerivedInfo) leafRef.getEffectiveDataType().getDataTypeExtendedInfo();
        YobUtils.setDataFromStringValue(derivedInfo.getEffectiveBuiltInType(), leafValue, parentSetterMethod, parentObject, schemaNode, parentSchema);
    } else {
        YobUtils.setDataFromStringValue(type.getDataType(), leafValue, parentSetterMethod, parentObject, schemaNode, parentSchema);
    }
}
#method_after
static void parseLeafRefTypeInfo(Method parentSetterMethod, Object parentObject, Object leafValue, YangSchemaNode schemaNode, YangSchemaNode parentSchema) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    while (schemaNode.getReferredSchema() != null) {
        schemaNode = schemaNode.getReferredSchema();
    }
    YangLeafRef leafRef;
    if (schemaNode instanceof YangLeaf) {
        leafRef = (YangLeafRef) ((YangLeaf) schemaNode).getDataType().getDataTypeExtendedInfo();
    } else {
        leafRef = (YangLeafRef) ((YangLeafList) schemaNode).getDataType().getDataTypeExtendedInfo();
    }
    YangType type = leafRef.getEffectiveDataType();
    if (type.getDataType() == YangDataTypes.DERIVED && schemaNode.getJavaPackage().equals(YobConstants.JAVA_LANG)) {
        /*
             * If leaf is inside grouping, then its return type will be of type
             * Object and if its actual type is derived type then get the
             * effective built-in type and set the value.
             */
        YangDerivedInfo derivedInfo = (YangDerivedInfo) leafRef.getEffectiveDataType().getDataTypeExtendedInfo();
        YobUtils.setDataFromStringValue(derivedInfo.getEffectiveBuiltInType(), leafValue, parentSetterMethod, parentObject, schemaNode, parentSchema);
    } else {
        YobUtils.setDataFromStringValue(type.getDataType(), leafValue, parentSetterMethod, parentObject, schemaNode, parentSchema);
    }
}
#end_block

#method_before
public static ClassLoader getClassLoader(YangSchemaNode schemaNode, DefaultYangModelRegistry reg) {
    YangSchemaNode curNode = schemaNode;
    while (!(curNode instanceof RpcNotificationContainer)) {
        curNode = ((YangNode) curNode).getParent();
    }
    Class<?> regClass = reg.getRegisteredClass(curNode);
    return regClass.getClassLoader();
}
#method_after
static ClassLoader getClassLoader(YangSchemaNode schemaNode, DefaultYangModelRegistry reg) {
    YangSchemaNode curNode = schemaNode;
    while (!(curNode instanceof RpcNotificationContainer)) {
        curNode = ((YangNode) curNode).getParent();
    }
    Class<?> regClass = reg.getRegisteredClass(curNode);
    return regClass.getClassLoader();
}
#end_block

#method_before
public static ClassLoader getTargetClassLoader(ClassLoader curLoader, YangSchemaNodeContextInfo context, DefaultYangModelRegistry reg) {
    YangSchemaNode augmentSchemaNode = context.getContextSwitchedNode();
    if (augmentSchemaNode.getYangSchemaNodeType() == YANG_AUGMENT_NODE) {
        YangSchemaNode moduleNode = ((YangNode) augmentSchemaNode).getParent();
        Class<?> moduleClass = reg.getRegisteredClass(moduleNode);
        if (moduleClass == null) {
            throw new ModelConvertorException(E_FAIL_TO_LOAD_CLASS + moduleNode.getJavaClassNameOrBuiltInType());
        }
        return moduleClass.getClassLoader();
    }
    return curLoader;
}
#method_after
static ClassLoader getTargetClassLoader(ClassLoader curLoader, YangSchemaNodeContextInfo context, DefaultYangModelRegistry reg) {
    YangSchemaNode augmentSchemaNode = context.getContextSwitchedNode();
    if (augmentSchemaNode.getYangSchemaNodeType() == YANG_AUGMENT_NODE) {
        YangSchemaNode moduleNode = ((YangNode) augmentSchemaNode).getParent();
        Class<?> moduleClass = reg.getRegisteredClass(moduleNode);
        if (moduleClass == null) {
            throw new ModelConvertorException(E_FAIL_TO_LOAD_CLASS + moduleNode.getJavaClassNameOrBuiltInType());
        }
        return moduleClass.getClassLoader();
    }
    return curLoader;
}
#end_block

#method_before
public static String getQualifiedDefaultClass(YangSchemaNode schemaNode) {
    String packageName = schemaNode.getJavaPackage();
    String className = getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());
    if (schemaNode instanceof RpcNotificationContainer) {
        return packageName + PERIOD + className + OP_PARAM;
    }
    return packageName + PERIOD + DEFAULT + className;
}
#method_after
static String getQualifiedDefaultClass(YangSchemaNode schemaNode) {
    String packageName = schemaNode.getJavaPackage();
    String className = getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());
    if (schemaNode instanceof RpcNotificationContainer) {
        return packageName + PERIOD + className + OP_PARAM;
    }
    return packageName + PERIOD + DEFAULT + className;
}
#end_block

#method_before
public static String getQualifiedinterface(YangSchemaNode schemaNode) {
    String packageName = schemaNode.getJavaPackage();
    String className = getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());
    return packageName + PERIOD + className;
}
#method_after
static String getQualifiedinterface(YangSchemaNode schemaNode) {
    String packageName = schemaNode.getJavaPackage();
    String className = getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());
    return packageName + PERIOD + className;
}
#end_block

#method_before
public static String getCapitalCase(String name) {
    return name.substring(0, 1).toUpperCase() + name.substring(1);
}
#method_after
static String getCapitalCase(String name) {
    return name.substring(0, 1).toUpperCase() + name.substring(1);
}
#end_block

#method_before
private static void parseIdentityRefInfo(Method parentSetterMethod, Object parentObject, Object leafValue, YangSchemaNode schemaNode) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    Class<?> childSetClass = null;
    Object childValue = null;
    Method childMethod = null;
    while (schemaNode.getReferredSchema() != null) {
        schemaNode = schemaNode.getReferredSchema();
    }
    String qualifiedClassName = null;
    YangType type;
    if (schemaNode instanceof YangLeaf) {
        type = ((YangLeaf) schemaNode).getDataType();
    } else {
        type = ((YangLeafList) schemaNode).getDataType();
    }
    if (type.getDataType() == YangDataTypes.LEAFREF && schemaNode.getJavaPackage().equals(YobConstants.JAVA_LANG)) {
        YangLeafRef leafref = ((YangLeafRef) type.getDataTypeExtendedInfo());
        YangType effectiveType = leafref.getEffectiveDataType();
        if (effectiveType.getDataType() == YangDataTypes.IDENTITYREF) {
            YangIdentityRef identityref = ((YangIdentityRef) effectiveType.getDataTypeExtendedInfo());
            YangIdentity identity = identityref.getReferredIdentity();
            qualifiedClassName = identity.getJavaPackage() + PERIOD + getCapitalCase(identity.getJavaClassNameOrBuiltInType());
        }
    } else {
        qualifiedClassName = schemaNode.getJavaPackage() + PERIOD + getCapitalCase(schemaNode.getJavaClassNameOrBuiltInType());
    }
    ClassLoader classLoader = parentObject.getClass().getClassLoader();
    try {
        childSetClass = classLoader.loadClass(qualifiedClassName);
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, qualifiedClassName);
    }
    if (childSetClass != null) {
        childMethod = childSetClass.getDeclaredMethod(FROM_STRING, String.class);
    }
    if (childMethod != null) {
        childValue = childMethod.invoke(null, leafValue);
    }
    parentSetterMethod.invoke(parentObject, childValue);
}
#method_after
static void parseIdentityRefInfo(Method parentSetterMethod, Object parentObject, Object leafValue, YangSchemaNode schemaNode) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    Class<?> childSetClass = null;
    Object childValue = null;
    Method childMethod = null;
    while (schemaNode.getReferredSchema() != null) {
        schemaNode = schemaNode.getReferredSchema();
    }
    String qualifiedClassName;
    YangType type;
    if (schemaNode instanceof YangLeaf) {
        type = ((YangLeaf) schemaNode).getDataType();
    } else {
        type = ((YangLeafList) schemaNode).getDataType();
    }
    YangIdentityRef identityRef = null;
    YangIdentity derivedId;
    if (type.getDataType() == YangDataTypes.LEAFREF && schemaNode.getJavaPackage().equals(YobConstants.JAVA_LANG)) {
        YangLeafRef leafref = ((YangLeafRef) type.getDataTypeExtendedInfo());
        YangType effectiveType = leafref.getEffectiveDataType();
        if (effectiveType.getDataType() == YangDataTypes.IDENTITYREF) {
            identityRef = ((YangIdentityRef) effectiveType.getDataTypeExtendedInfo());
        }
    } else {
        identityRef = ((YangIdentityRef) type.getDataTypeExtendedInfo());
    }
    derivedId = getDerivedIdentity(leafValue.toString(), identityRef.getReferredIdentity());
    if (derivedId == null) {
        throw new ModelConvertorException(E_INVALID_IDENTITY_DATA);
    }
    qualifiedClassName = derivedId.getJavaPackage() + PERIOD + getCapitalCase(derivedId.getJavaClassNameOrBuiltInType());
    ClassLoader classLoader = parentObject.getClass().getClassLoader();
    try {
        childSetClass = classLoader.loadClass(qualifiedClassName);
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, qualifiedClassName);
    }
    if (childSetClass != null) {
        childMethod = childSetClass.getDeclaredMethod(FROM_STRING, String.class);
    }
    if (childMethod != null) {
        childValue = childMethod.invoke(null, leafValue);
    }
    parentSetterMethod.invoke(parentObject, childValue);
}
#end_block

#method_before
public static YangSchemaNode getChildSchemaNode(DataNode dataNode, SchemaContext context) {
    SchemaId schemaId = dataNode.key().schemaId();
    SchemaContext schemaContext = getChildSchemaContext(context, schemaId.name(), schemaId.namespace());
    return ((YangSchemaNode) schemaContext);
}
#method_after
static YangSchemaNode getChildSchemaNode(DataNode dataNode, SchemaContext context) {
    SchemaId schemaId = dataNode.key().schemaId();
    SchemaContext schemaContext = getChildSchemaContext(context, schemaId.name(), schemaId.namespace());
    return ((YangSchemaNode) schemaContext);
}
#end_block

#method_before
public static ModelObject buildLeafModelObject(DataNode dataNode, YangSchemaNode leafHolder, DefaultYangModelRegistry reg) {
    LeafModelObject leafObj = new LeafModelObject();
    leafObj.addValue(((LeafNode) dataNode).value());
    LeafIdentifier leafId = getLeafIdentifier(dataNode.key().schemaId(), leafHolder, reg);
    leafObj.leafIdentifier(leafId);
    return leafObj;
}
#method_after
static ModelObject buildLeafModelObject(DataNode dataNode, YangSchemaNode leafHolder, DefaultYangModelRegistry reg) {
    if (leafHolder == null) {
        YangSchemaNode schemaNode = ((YangSchemaNode) reg.getChildContext(dataNode.key().schemaId()));
        if (schemaNode instanceof YangLeaf) {
            leafHolder = ((YangSchemaNode) ((YangLeaf) schemaNode).getContainedIn());
        } else {
            leafHolder = ((YangSchemaNode) ((YangLeafList) schemaNode).getContainedIn());
        }
    }
    LeafModelObject leafObj = new LeafModelObject();
    leafObj.addValue(((LeafNode) dataNode).value());
    LeafIdentifier leafId = getLeafIdentifier(dataNode.key().schemaId(), leafHolder, reg);
    leafObj.leafIdentifier(leafId);
    return leafObj;
}
#end_block

#method_before
public static LeafIdentifier getLeafIdentifier(SchemaId id, YangSchemaNode leafHolder, DefaultYangModelRegistry reg) {
    String qualName = getQualifiedDefaultClass(leafHolder);
    ClassLoader classLoader = getClassLoader(leafHolder, reg);
    try {
        Class<InnerModelObject> cls = (Class<InnerModelObject>) classLoader.loadClass(qualName);
        Class<?>[] intfs = cls.getInterfaces();
        Class<?> intf = null;
        for (Class<?> in : intfs) {
            if (in.getName().equals(getJavaQualifiedInterFaceName(leafHolder))) {
                intf = in;
                break;
            }
        }
        String leafId;
        if (intf != null) {
            leafId = intf.getName() + ENUM_LEAF_IDENTIFIER;
        } else {
            throw new ModelConvertorException(E_FAIL_TO_LOAD_LEAF_IDENTIFIER_CLASS);
        }
        Class<Enum> leafIdentifier = (Class<Enum>) cls.getClassLoader().loadClass(leafId);
        Enum[] enumConst = leafIdentifier.getEnumConstants();
        for (Enum e : enumConst) {
            if (e.name().equalsIgnoreCase(id.name())) {
                return ((LeafIdentifier) e);
            }
        }
    } catch (ClassNotFoundException e) {
        throw new ModelConvertorException(E_FAIL_TO_LOAD_CLASS);
    }
    return null;
}
#method_after
static LeafIdentifier getLeafIdentifier(SchemaId id, YangSchemaNode leafHolder, DefaultYangModelRegistry reg) {
    String qualName = getQualifiedDefaultClass(leafHolder);
    ClassLoader classLoader = getClassLoader(leafHolder, reg);
    try {
        Class<InnerModelObject> cls = (Class<InnerModelObject>) classLoader.loadClass(qualName);
        Class<?>[] intfs = cls.getInterfaces();
        Class<?> intf = null;
        for (Class<?> in : intfs) {
            if (in.getName().equals(getJavaQualifiedInterFaceName(leafHolder))) {
                intf = in;
                break;
            }
        }
        String leafId;
        if (intf != null) {
            leafId = intf.getName() + ENUM_LEAF_IDENTIFIER;
        } else {
            throw new ModelConvertorException(E_FAIL_TO_LOAD_LEAF_IDENTIFIER_CLASS);
        }
        Class<Enum> leafIdentifier = (Class<Enum>) cls.getClassLoader().loadClass(leafId);
        Enum[] enumConst = leafIdentifier.getEnumConstants();
        for (Enum e : enumConst) {
            if (e.name().equalsIgnoreCase(id.name())) {
                return ((LeafIdentifier) e);
            }
        }
    } catch (ClassNotFoundException e) {
        throw new ModelConvertorException(E_FAIL_TO_LOAD_CLASS);
    }
    return null;
}
#end_block

#method_before
public static Class<?> fetchClassForNode(ClassLoader loader, String name) {
    try {
        return loader.loadClass(name);
    } catch (ClassNotFoundException e) {
        throw new ModelConvertorException(E_FAIL_TO_LOAD_CLASS + name);
    }
}
#method_after
static Class<?> fetchClassForNode(ClassLoader loader, String name) {
    try {
        return loader.loadClass(name);
    } catch (ClassNotFoundException e) {
        throw new ModelConvertorException(E_FAIL_TO_LOAD_CLASS + name);
    }
}
#end_block

#method_before
public static Object getInstanceOfClass(ClassLoader loader, String name) {
    try {
        Class<?> defaultClass = loader.loadClass(name);
        return defaultClass.newInstance();
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, name);
        throw new ModelConvertorException(E_FAIL_TO_LOAD_CLASS + name);
    } catch (NullPointerException e) {
        log.error(L_REFLECTION_FAIL_TO_CREATE_OBJ, name);
        throw new ModelConvertorException(E_REFLECTION_FAIL_TO_CREATE_OBJ + name);
    } catch (InstantiationException | IllegalAccessException e) {
        log.error(L_FAIL_TO_CREATE_OBJ, name);
        throw new ModelConvertorException(E_FAIL_TO_CREATE_OBJ + name);
    }
}
#method_after
static Object getInstanceOfClass(ClassLoader loader, String name) {
    try {
        Class<?> defaultClass = loader.loadClass(name);
        return defaultClass.newInstance();
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, name);
        throw new ModelConvertorException(E_FAIL_TO_LOAD_CLASS + name);
    } catch (NullPointerException e) {
        log.error(L_REFLECTION_FAIL_TO_CREATE_OBJ, name);
        throw new ModelConvertorException(E_REFLECTION_FAIL_TO_CREATE_OBJ + name);
    } catch (InstantiationException | IllegalAccessException e) {
        log.error(L_FAIL_TO_CREATE_OBJ, name);
        throw new ModelConvertorException(E_FAIL_TO_CREATE_OBJ + name);
    }
}
#end_block

#method_before
public static String getJavaQualifiedInterFaceName(YangSchemaNode node) {
    if (node != null) {
        return node.getJavaPackage() + PERIOD + getCapitalCase(node.getJavaClassNameOrBuiltInType());
    }
    return null;
}
#method_after
static String getJavaQualifiedInterFaceName(YangSchemaNode node) {
    if (node != null) {
        return node.getJavaPackage() + PERIOD + getCapitalCase(node.getJavaClassNameOrBuiltInType());
    }
    return null;
}
#end_block

#method_before
public static String getKeyClassName(YangSchemaNode node) {
    if (node != null) {
        return getJavaQualifiedInterFaceName(node) + "Keys";
    }
    return null;
}
#method_after
static String getKeyClassName(YangSchemaNode node) {
    if (node != null) {
        return getJavaQualifiedInterFaceName(node) + "Keys";
    }
    return null;
}
#end_block

#method_before
public static YangLeaf getKeyLeafSchema(KeyLeaf keyleaf, YangSchemaNode node) {
    YangList list = ((YangList) node);
    List<YangLeaf> keyLeaves = list.getListOfLeaf();
    Iterator<YangLeaf> it = keyLeaves.iterator();
    while (it.hasNext()) {
        YangLeaf leaf = it.next();
        if (leaf.getName().equals(keyleaf.leafSchema().name())) {
            return leaf;
        }
    }
    return null;
}
#method_after
static YangLeaf getKeyLeafSchema(KeyLeaf keyleaf, YangSchemaNode node) {
    YangList list = ((YangList) node);
    List<YangLeaf> keyLeaves = list.getListOfLeaf();
    Iterator<YangLeaf> it = keyLeaves.iterator();
    while (it.hasNext()) {
        YangLeaf leaf = it.next();
        if (leaf.getName().equals(keyleaf.leafSchema().name())) {
            return leaf;
        }
    }
    return null;
}
#end_block

#method_before
public static <T extends InnerModelObject & MultiInstanceObject<K>, K extends KeyInfo<T>> ModelObjectId.Builder handleListKey(ModelObjectId.Builder midb, DefaultYangModelRegistry reg, YangSchemaNode node, NodeKey key) {
    ListKey listKey = (ListKey) key;
    List<KeyLeaf> keyLeaves = listKey.keyLeafs();
    String keyClassName;
    Class<KeyInfo> keyClass;
    Object value;
    String javaName = null;
    Method setter;
    if (nonEmpty(keyLeaves)) {
        String qualName = getQualifiedDefaultClass(node);
        ClassLoader classLoader = getClassLoader(node, reg);
        Class<T> listClass = ((Class<T>) fetchClassForNode(classLoader, qualName));
        K keyObj;
        if (listClass != null) {
            keyClassName = getKeyClassName(node);
            try {
                keyClass = (Class<KeyInfo>) listClass.getClassLoader().loadClass(keyClassName);
                keyObj = (K) keyClass.newInstance();
                for (KeyLeaf leaf : keyLeaves) {
                    YangLeaf leafSchema = getKeyLeafSchema(leaf, node);
                    YangDataTypes datatype = leafSchema.getDataType().getDataType();
                    javaName = getCamelCase(leaf.leafSchema().name(), null);
                    Field leafName = keyClass.getDeclaredField(javaName);
                    setter = keyClass.getDeclaredMethod(javaName, leafName.getType());
                    value = leaf.leafValue();
                    setDataFromStringValue(datatype, value, setter, keyObj, leafSchema, node);
                    midb = midb.addChild(listClass, keyObj);
                }
            } catch (NoSuchMethodException e) {
                throw new ModelConvertorException("Failed to load setter method for " + javaName + " in key class" + keyClassName);
            } catch (InvocationTargetException e) {
                throw new ModelConvertorException("Failed to invoke setter method for " + javaName + " in key class" + keyClassName);
            } catch (ClassNotFoundException e) {
                throw new ModelConvertorException("Failed to load key class" + keyClassName);
            } catch (IllegalAccessException | InstantiationException e) {
                throw new ModelConvertorException("Failed Instantiation of key class" + keyClassName);
            } catch (NoSuchFieldException e) {
                e.printStackTrace();
            }
        }
    }
    return midb;
}
#method_after
static <T extends InnerModelObject & MultiInstanceObject<K>, K extends KeyInfo<T>> ModelObjectId.Builder handleListKey(ModelObjectId.Builder midb, DefaultYangModelRegistry reg, YangSchemaNode node, NodeKey key) {
    ListKey listKey = (ListKey) key;
    List<KeyLeaf> keyLeaves = listKey.keyLeafs();
    String keyClassName;
    Class<KeyInfo> keyClass;
    Object value;
    String javaName = null;
    Method setter;
    if (nonEmpty(keyLeaves)) {
        String qualName = getQualifiedDefaultClass(node);
        ClassLoader classLoader = getClassLoader(node, reg);
        Class<T> listClass = ((Class<T>) fetchClassForNode(classLoader, qualName));
        K keyObj;
        if (listClass != null) {
            keyClassName = getKeyClassName(node);
            try {
                keyClass = (Class<KeyInfo>) listClass.getClassLoader().loadClass(keyClassName);
                keyObj = (K) keyClass.newInstance();
                for (KeyLeaf leaf : keyLeaves) {
                    YangLeaf leafSchema = getKeyLeafSchema(leaf, node);
                    YangDataTypes datatype = leafSchema.getDataType().getDataType();
                    javaName = getCamelCase(leaf.leafSchema().name(), null);
                    Field leafName = keyClass.getDeclaredField(javaName);
                    setter = keyClass.getDeclaredMethod(javaName, leafName.getType());
                    value = leaf.leafValue();
                    setDataFromStringValue(datatype, value, setter, keyObj, leafSchema, node);
                    midb = midb.addChild(listClass, keyObj);
                }
            } catch (NoSuchMethodException e) {
                throw new ModelConvertorException("Failed to load setter method for " + javaName + " in key class" + keyClassName);
            } catch (InvocationTargetException e) {
                throw new ModelConvertorException("Failed to invoke setter method for " + javaName + " in key class" + keyClassName);
            } catch (ClassNotFoundException e) {
                throw new ModelConvertorException("Failed to load key class" + keyClassName);
            } catch (IllegalAccessException | InstantiationException e) {
                throw new ModelConvertorException("Failed Instantiation of key class" + keyClassName);
            } catch (NoSuchFieldException e) {
                e.printStackTrace();
            }
        }
    }
    return midb;
}
#end_block

#method_before
public static ModelObjectId.Builder handleLeafListKey(ModelObjectId.Builder midb, DefaultYangModelRegistry reg, YangSchemaNode parentSchema, LeafListKey key) {
    Class<?> intf = null;
    String qualName = getQualifiedDefaultClass(parentSchema);
    ClassLoader classLoader = getClassLoader(parentSchema, reg);
    Class<?> parentClass = fetchClassForNode(classLoader, qualName);
    Class<?>[] interfaces = parentClass.getInterfaces();
    for (Class<?> in : interfaces) {
        if (in.getName().equals(getJavaQualifiedInterFaceName(parentSchema))) {
            intf = in;
            break;
        }
    }
    String leafName;
    if (intf != null) {
        leafName = intf.getName() + ENUM_LEAF_IDENTIFIER;
        try {
            Class<Enum> leafId = (Class<Enum>) parentClass.getClassLoader().loadClass(leafName);
            Enum[] enumConst = leafId.getEnumConstants();
            for (Enum e : enumConst) {
                if (e.name().equalsIgnoreCase(key.schemaId().name())) {
                    midb = midb.addChild(((LeafIdentifier) e), key.value());
                    return midb;
                }
            }
        } catch (ClassNotFoundException e) {
            throw new ModelConvertorException("Failed to load leaf identifier class." + leafName);
        }
    }
    return midb;
}
#method_after
static ModelObjectId.Builder handleLeafListKey(ModelObjectId.Builder midb, DefaultYangModelRegistry reg, YangSchemaNode schemaNode, LeafListKey key) {
    Class<?> intf = null;
    YangSchemaNode parentSchema = ((YangSchemaNode) ((YangLeafList) schemaNode).getContainedIn());
    String qualName = getQualifiedDefaultClass(parentSchema);
    ClassLoader classLoader = getClassLoader(parentSchema, reg);
    Class<?> parentClass = fetchClassForNode(classLoader, qualName);
    Class<?>[] interfaces = parentClass.getInterfaces();
    for (Class<?> in : interfaces) {
        if (in.getName().equals(getJavaQualifiedInterFaceName(parentSchema))) {
            intf = in;
            break;
        }
    }
    String leafName;
    if (intf != null) {
        leafName = intf.getName() + ENUM_LEAF_IDENTIFIER;
        try {
            Class<Enum> leafId = (Class<Enum>) parentClass.getClassLoader().loadClass(leafName);
            Enum[] enumConst = leafId.getEnumConstants();
            for (Enum e : enumConst) {
                if (e.name().equalsIgnoreCase(key.schemaId().name())) {
                    midb = midb.addChild(((LeafIdentifier) e), key.value());
                    return midb;
                }
            }
        } catch (ClassNotFoundException e) {
            throw new ModelConvertorException("Failed to load leaf identifier class." + leafName);
        }
    }
    return midb;
}
#end_block

#method_before
public static ModelObjectId.Builder handleNodeKey(ModelObjectId.Builder midb, DefaultYangModelRegistry reg, YangSchemaNode node, NodeKey key, YangSchemaNode parentSchema) {
    if (node != null) {
        if (!(node instanceof YangLeaf)) {
            String qualName = getQualifiedDefaultClass(node);
            ClassLoader classLoader = getClassLoader(node, reg);
            Class<InnerModelObject> nodeClass = (Class<InnerModelObject>) fetchClassForNode(classLoader, qualName);
            if (nodeClass != null) {
                midb = midb.addChild(nodeClass);
            }
        } else {
            midb = handleLeafInfo(midb, reg, key, parentSchema);
        }
    }
    return midb;
}
#method_after
static ModelObjectId.Builder handleNodeKey(ModelObjectId.Builder midb, DefaultYangModelRegistry reg, YangSchemaNode node, NodeKey key) {
    if (node != null) {
        if (!(node instanceof YangLeaf)) {
            String qualName = getQualifiedDefaultClass(node);
            ClassLoader classLoader = getClassLoader(node, reg);
            Class<InnerModelObject> nodeClass = (Class<InnerModelObject>) fetchClassForNode(classLoader, qualName);
            if (nodeClass != null) {
                midb = midb.addChild(nodeClass);
            }
        } else {
            midb = handleLeafInfo(midb, reg, key, node);
        }
    }
    return midb;
}
#end_block

#method_before
public static ModelObjectId.Builder handleLeafInfo(ModelObjectId.Builder midb, DefaultYangModelRegistry reg, NodeKey key, YangSchemaNode parentSchema) {
    String qualName = getQualifiedDefaultClass(parentSchema);
    ClassLoader classLoader = getClassLoader(parentSchema, reg);
    Class<InnerModelObject> nodeClass = (Class<InnerModelObject>) fetchClassForNode(classLoader, qualName);
    Class<?>[] interfaces = nodeClass.getInterfaces();
    for (Class<?> intf : interfaces) {
        String leafId = intf.getName() + ENUM_LEAF_IDENTIFIER;
        try {
            Class<Enum> leafIdentifier = (Class<Enum>) nodeClass.getClassLoader().loadClass(leafId);
            Enum[] enumConst = leafIdentifier.getEnumConstants();
            for (Enum e : enumConst) {
                if (e.name().equalsIgnoreCase(key.schemaId().name())) {
                    midb = midb.addChild(((LeafIdentifier) e));
                    return midb;
                }
            }
        } catch (ClassNotFoundException e) {
            throw new ModelConvertorException(E_FAIL_TO_LOAD_LEAF_IDENTIFIER_CLASS);
        }
    }
    return midb;
}
#method_after
static ModelObjectId.Builder handleLeafInfo(ModelObjectId.Builder midb, DefaultYangModelRegistry reg, NodeKey key, YangSchemaNode schemaNode) {
    YangSchemaNode parentSchema = ((YangSchemaNode) ((YangLeaf) schemaNode).getContainedIn());
    String qualName = getQualifiedDefaultClass(parentSchema);
    ClassLoader classLoader = getClassLoader(parentSchema, reg);
    Class<InnerModelObject> nodeClass = (Class<InnerModelObject>) fetchClassForNode(classLoader, qualName);
    Class<?>[] interfaces = nodeClass.getInterfaces();
    for (Class<?> intf : interfaces) {
        String leafId = intf.getName() + ENUM_LEAF_IDENTIFIER;
        try {
            Class<Enum> leafIdentifier = (Class<Enum>) nodeClass.getClassLoader().loadClass(leafId);
            Enum[] enumConst = leafIdentifier.getEnumConstants();
            for (Enum e : enumConst) {
                if (e.name().equalsIgnoreCase(key.schemaId().name())) {
                    midb = midb.addChild(((LeafIdentifier) e));
                    return midb;
                }
            }
        } catch (ClassNotFoundException e) {
            throw new ModelConvertorException(E_FAIL_TO_LOAD_LEAF_IDENTIFIER_CLASS);
        }
    }
    return midb;
}
#end_block

#method_before
@Override
public YobWorkBench createObject(DataNode curNode, YangSchemaNode context, DefaultYangModelRegistry registry) {
    // For multi instance leaf no need to create an object.
    return null;
}
#method_after
@Override
YobWorkBench createObject(YangSchemaNode schemaNode, DefaultYangModelRegistry registry) {
    // For multi instance leaf no need to create an object.
    return null;
}
#end_block

#method_before
public void buildObject(YobWorkBench curWorkbench, YangModelRegistry registry) {
// For multi instance leaf no need to build an object.
}
#method_after
void buildObject(YobWorkBench curWorkbench, YangModelRegistry registry) {
// For multi instance leaf no need to build an object.
}
#end_block

#method_before
@Override
public void setInParent(DataNode leafNode, YobWorkBench curWb, YobWorkBench parentWb, DefaultYangModelRegistry reg) {
    Class<?> parentClass = null;
    try {
        YangSchemaNode schemaNode = getChildSchemaNode(leafNode, curWb.schemaNode());
        YangSchemaNode referredSchema = schemaNode;
        while (referredSchema.getReferredSchema() != null) {
            referredSchema = referredSchema.getReferredSchema();
        }
        String setterInParent = referredSchema.getJavaAttributeName();
        Object parentObj = curWb.getParentObject(reg, schemaNode);
        parentClass = parentObj.getClass();
        Field leafName = parentClass.getDeclaredField(setterInParent);
        ParameterizedType genericListType = (ParameterizedType) leafName.getGenericType();
        Class<?> genericListClass;
        if (((YangLeafList) referredSchema).getDataType().getDataType() == IDENTITYREF) {
            ParameterizedType type = (ParameterizedType) genericListType.getActualTypeArguments()[0];
            genericListClass = type.getClass().getClass();
        } else {
            genericListClass = (Class<?>) genericListType.getActualTypeArguments()[0];
        }
        Method setterMethod = parentClass.getDeclaredMethod(ADD_TO + getCapitalCase(setterInParent), genericListClass);
        JavaQualifiedTypeInfoContainer javaQualifiedType = (JavaQualifiedTypeInfoContainer) referredSchema;
        YangType<?> yangType = ((YangLeafList) javaQualifiedType).getDataType();
        setDataFromStringValue(yangType.getDataType(), ((LeafNode) leafNode).value(), setterMethod, parentObj, referredSchema, curWb.schemaNode());
    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, parentClass.getName());
        throw new ModelConvertorException(E_FAIL_TO_INVOKE_METHOD + parentClass.getName());
    }
}
#method_after
@Override
void setInParent(DataNode leafNode, YobWorkBench curWb, YobWorkBench parentWb, DefaultYangModelRegistry reg) {
    Class<?> parentClass = null;
    try {
        YangSchemaNode schemaNode = getChildSchemaNode(leafNode, curWb.schemaNode());
        YangSchemaNode referredSchema = schemaNode;
        while (referredSchema.getReferredSchema() != null) {
            referredSchema = referredSchema.getReferredSchema();
        }
        String setterInParent = referredSchema.getJavaAttributeName();
        Object parentObj = curWb.getParentObject(reg, schemaNode);
        parentClass = parentObj.getClass();
        Field leafName = parentClass.getDeclaredField(setterInParent);
        ParameterizedType genericListType = (ParameterizedType) leafName.getGenericType();
        Class<?> genericListClass;
        if (((YangLeafList) referredSchema).getDataType().getDataType() == IDENTITYREF) {
            ParameterizedType type = (ParameterizedType) genericListType.getActualTypeArguments()[0];
            genericListClass = type.getClass().getClass();
        } else {
            genericListClass = (Class<?>) genericListType.getActualTypeArguments()[0];
        }
        Method setterMethod = parentClass.getDeclaredMethod(ADD_TO + getCapitalCase(setterInParent), genericListClass);
        JavaQualifiedTypeInfoContainer javaQualifiedType = (JavaQualifiedTypeInfoContainer) referredSchema;
        YangType<?> yangType = ((YangLeafList) javaQualifiedType).getDataType();
        setDataFromStringValue(yangType.getDataType(), ((LeafNode) leafNode).value(), setterMethod, parentObj, referredSchema, curWb.schemaNode());
    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, parentClass.getName());
        throw new ModelConvertorException(E_FAIL_TO_INVOKE_METHOD + parentClass.getName());
    }
}
#end_block

#method_before
public ClassLoader classLoader() {
    return classLoader;
}
#method_after
ClassLoader classLoader() {
    return classLoader;
}
#end_block

#method_before
public void classLoader(ClassLoader loader) {
    classLoader = loader;
}
#method_after
void classLoader(ClassLoader loader) {
    classLoader = loader;
}
#end_block

#method_before
public String setterInParent() {
    return setterInParent;
}
#method_after
String setterInParent() {
    return setterInParent;
}
#end_block

#method_before
public void setterInParent(String name) {
    setterInParent = name;
}
#method_after
void setterInParent(String name) {
    setterInParent = name;
}
#end_block

#method_before
public YangSchemaNode schemaNode() {
    return schemaNode;
}
#method_after
YangSchemaNode schemaNode() {
    return schemaNode;
}
#end_block

#method_before
public void schemaNode(YangSchemaNode node) {
    schemaNode = node;
}
#method_after
void schemaNode(YangSchemaNode node) {
    schemaNode = node;
}
#end_block

#method_before
public Map<YangSchemaNodeIdentifier, YobWorkBench> attributeMap() {
    return attributeMap;
}
#method_after
Map<YangSchemaNodeIdentifier, YobWorkBench> attributeMap() {
    return attributeMap;
}
#end_block

#method_before
public void attributeMap(Map<YangSchemaNodeIdentifier, YobWorkBench> attributeMap) {
    this.attributeMap = attributeMap;
}
#method_after
void attributeMap(Map<YangSchemaNodeIdentifier, YobWorkBench> attributeMap) {
    this.attributeMap = attributeMap;
}
#end_block

#method_before
public Object getBuiltObject() {
    return builtObject;
}
#method_after
Object getBuiltObject() {
    return builtObject;
}
#end_block

#method_before
public void setBuiltObject(Object obj) {
    builtObject = obj;
}
#method_after
void setBuiltObject(Object obj) {
    builtObject = obj;
}
#end_block

#method_before
public void setObject(YobWorkBench curWb, DataNode dataNode, DefaultYangModelRegistry reg) {
    Object parentObj = getParentObject(reg, curWb.schemaNode());
    setObjectInParent(parentObj, curWb.setterInParent(), curWb.getBuiltObject(), dataNode.type());
}
#method_after
void setObject(YobWorkBench curWb, DataNode dataNode, DefaultYangModelRegistry reg) {
    Object parentObj = getParentObject(reg, curWb.schemaNode());
    setObjectInParent(parentObj, curWb.setterInParent(), curWb.getBuiltObject(), dataNode.type());
}
#end_block

#method_before
public Object getParentObject(DefaultYangModelRegistry reg, YangSchemaNode schemaNode) {
    YangSchemaNodeIdentifier targetNode = schemaNode.getYangSchemaNodeIdentifier();
    YobWorkBench curWorkBench = this;
    YangSchemaNode nonSchemaHolder;
    do {
        // Current Schema node context
        YangSchemaNodeContextInfo schemaContext;
        YangSchemaNode parentSchema = null;
        try {
            // Find the new schema context node.
            parentSchema = curWorkBench.schemaNode();
            schemaContext = parentSchema.getChildSchema(targetNode);
        } catch (DataModelException e) {
            throw new ModelConvertorException(parentSchema.getName() + E_HAS_NO_CHILD + targetNode.getName());
        }
        nonSchemaHolder = schemaContext.getContextSwitchedNode();
        // If the descendant schema node is in switched context
        if (nonSchemaHolder != null) {
            YangSchemaNodeIdentifier nonSchemaIdentifier = nonSchemaHolder.getYangSchemaNodeIdentifier();
            // check if the descendant builder container is already available
            YobWorkBench childWorkBench = curWorkBench.attributeMap.get(nonSchemaIdentifier);
            if (childWorkBench == null) {
                YobWorkBench newWorkBench = getNewChildWorkBench(schemaContext, targetNode, curWorkBench, reg);
                curWorkBench.attributeMap.put(nonSchemaIdentifier, newWorkBench);
                curWorkBench = newWorkBench;
            } else {
                curWorkBench = childWorkBench;
            }
        }
    } while (nonSchemaHolder != null);
    return curWorkBench.getBuiltObject();
}
#method_after
Object getParentObject(DefaultYangModelRegistry reg, YangSchemaNode schemaNode) {
    YangSchemaNodeIdentifier targetNode = schemaNode.getYangSchemaNodeIdentifier();
    YobWorkBench curWorkBench = this;
    YangSchemaNode nonSchemaHolder;
    do {
        // Current Schema node context
        YangSchemaNodeContextInfo schemaContext;
        YangSchemaNode parentSchema = null;
        try {
            // Find the new schema context node.
            parentSchema = curWorkBench.schemaNode();
            schemaContext = parentSchema.getChildSchema(targetNode);
        } catch (DataModelException e) {
            throw new ModelConvertorException(parentSchema.getName() + E_HAS_NO_CHILD + targetNode.getName());
        }
        nonSchemaHolder = schemaContext.getContextSwitchedNode();
        // If the descendant schema node is in switched context
        if (nonSchemaHolder != null) {
            YangSchemaNodeIdentifier nonSchemaIdentifier = nonSchemaHolder.getYangSchemaNodeIdentifier();
            // check if the descendant builder container is already available
            YobWorkBench childWorkBench = curWorkBench.attributeMap.get(nonSchemaIdentifier);
            if (childWorkBench == null) {
                YobWorkBench newWorkBench = getNewChildWorkBench(schemaContext, targetNode, curWorkBench, reg);
                curWorkBench.attributeMap.put(nonSchemaIdentifier, newWorkBench);
                curWorkBench = newWorkBench;
            } else {
                curWorkBench = childWorkBench;
            }
        }
    } while (nonSchemaHolder != null);
    return curWorkBench.getBuiltObject();
}
#end_block

#method_before
private static YobWorkBench getNewChildWorkBench(YangSchemaNodeContextInfo childContext, YangSchemaNodeIdentifier targetNode, YobWorkBench curWorkBench, DefaultYangModelRegistry registry) {
    YangSchemaNode ctxSwitchedNode = childContext.getContextSwitchedNode();
    String name;
    /* This is the first child trying to set its object in the
         current context. */
    String setterInParent = ctxSwitchedNode.getJavaAttributeName();
    /* If current switched context is choice, then case class needs to be
         used. */
    if (ctxSwitchedNode.getYangSchemaNodeType() == YANG_CHOICE_NODE) {
        try {
            childContext = ctxSwitchedNode.getChildSchema(targetNode);
            ctxSwitchedNode = childContext.getContextSwitchedNode();
            name = getQualifiedDefaultClass(childContext.getContextSwitchedNode());
        } catch (DataModelException e) {
            throw new ModelConvertorException(ctxSwitchedNode.getName() + E_HAS_NO_CHILD + targetNode.getName());
        }
    } else if (ctxSwitchedNode.getYangSchemaNodeType() == YANG_AUGMENT_NODE) {
        name = getQualifiedDefaultClass(ctxSwitchedNode);
        setterInParent = YobUtils.getQualifiedinterface(ctxSwitchedNode);
    } else {
        name = getQualifiedDefaultClass(childContext.getSchemaNode());
    }
    ClassLoader newClassesLoader = YobUtils.getTargetClassLoader(curWorkBench.classLoader, childContext, registry);
    Object obj = getInstanceOfClass(newClassesLoader, name);
    return new YobWorkBench(newClassesLoader, obj, setterInParent, ctxSwitchedNode);
}
#method_after
static YobWorkBench getNewChildWorkBench(YangSchemaNodeContextInfo childContext, YangSchemaNodeIdentifier targetNode, YobWorkBench curWorkBench, DefaultYangModelRegistry registry) {
    YangSchemaNode ctxSwitchedNode = childContext.getContextSwitchedNode();
    String name;
    /* This is the first child trying to set its object in the
         current context. */
    String setterInParent = ctxSwitchedNode.getJavaAttributeName();
    /* If current switched context is choice, then case class needs to be
         used. */
    if (ctxSwitchedNode.getYangSchemaNodeType() == YANG_CHOICE_NODE) {
        try {
            childContext = ctxSwitchedNode.getChildSchema(targetNode);
            ctxSwitchedNode = childContext.getContextSwitchedNode();
            name = getQualifiedDefaultClass(childContext.getContextSwitchedNode());
        } catch (DataModelException e) {
            throw new ModelConvertorException(ctxSwitchedNode.getName() + E_HAS_NO_CHILD + targetNode.getName());
        }
    } else if (ctxSwitchedNode.getYangSchemaNodeType() == YANG_AUGMENT_NODE) {
        name = getQualifiedDefaultClass(ctxSwitchedNode);
        setterInParent = YobUtils.getQualifiedinterface(ctxSwitchedNode);
    } else {
        name = getQualifiedDefaultClass(childContext.getSchemaNode());
    }
    ClassLoader newClassesLoader = YobUtils.getTargetClassLoader(curWorkBench.classLoader, childContext, registry);
    Object obj = getInstanceOfClass(newClassesLoader, name);
    return new YobWorkBench(newClassesLoader, obj, setterInParent, ctxSwitchedNode);
}
#end_block

#method_before
private static void addInAugmentation(Object builder, Object instance) {
    Class<?> builderClass = builder.getClass();
    Class<?> baseClass = builderClass.getSuperclass();
    try {
        Method method = baseClass.getDeclaredMethod(ADD_AUGMENT_METHOD, InnerModelObject.class);
        method.invoke(builder, instance);
    } catch (NoSuchMethodException e) {
        log.error(L_FAIL_TO_GET_METHOD, ADD_AUGMENT_METHOD);
        throw new ModelConvertorException(E_FAIL_TO_GET_METHOD + ADD_AUGMENT_METHOD);
    } catch (InvocationTargetException | IllegalAccessException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, ADD_AUGMENT_METHOD);
        throw new ModelConvertorException(E_FAIL_TO_INVOKE_METHOD + ADD_AUGMENT_METHOD);
    }
}
#method_after
static void addInAugmentation(Object builder, Object instance) {
    Class<?> builderClass = builder.getClass();
    Class<?> baseClass = builderClass.getSuperclass();
    try {
        Method method = baseClass.getDeclaredMethod(ADD_AUGMENT_METHOD, InnerModelObject.class);
        method.invoke(builder, instance);
    } catch (NoSuchMethodException e) {
        log.error(L_FAIL_TO_GET_METHOD, ADD_AUGMENT_METHOD);
        throw new ModelConvertorException(E_FAIL_TO_GET_METHOD + ADD_AUGMENT_METHOD);
    } catch (InvocationTargetException | IllegalAccessException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, ADD_AUGMENT_METHOD);
        throw new ModelConvertorException(E_FAIL_TO_INVOKE_METHOD + ADD_AUGMENT_METHOD);
    }
}
#end_block

#method_before
private void buildNonSchemaAttributes(YangModelRegistry reg) {
    for (Map.Entry<YangSchemaNodeIdentifier, YobWorkBench> entry : attributeMap.entrySet()) {
        YobWorkBench childWorkBench = entry.getValue();
        YangSchemaNode childSchema = childWorkBench.schemaNode();
        childWorkBench.buildObject(reg);
        if (childSchema.getYangSchemaNodeType() == YANG_AUGMENT_NODE) {
            addInAugmentation(builtObject, childWorkBench.getBuiltObject());
            continue;
        }
        setObjectInParent(builtObject, childWorkBench.setterInParent, childWorkBench.getBuiltObject(), SINGLE_INSTANCE_NODE);
    }
}
#method_after
void buildNonSchemaAttributes(YangModelRegistry reg) {
    for (Map.Entry<YangSchemaNodeIdentifier, YobWorkBench> entry : attributeMap.entrySet()) {
        YobWorkBench childWorkBench = entry.getValue();
        YangSchemaNode childSchema = childWorkBench.schemaNode();
        childWorkBench.buildObject(reg);
        if (childSchema.getYangSchemaNodeType() == YANG_AUGMENT_NODE) {
            addInAugmentation(builtObject, childWorkBench.getBuiltObject());
            continue;
        }
        setObjectInParent(builtObject, childWorkBench.setterInParent, childWorkBench.getBuiltObject(), SINGLE_INSTANCE_NODE);
    }
}
#end_block

#method_before
public void buildObject(YangModelRegistry reg) {
    buildNonSchemaAttributes(reg);
}
#method_after
void buildObject(YangModelRegistry reg) {
    buildNonSchemaAttributes(reg);
}
#end_block

#method_before
public YobHandler getYobHandlerForContext(DataNode.Type type) {
    YobHandler yobHandler = HANDLER_MAP.get(type);
    if (yobHandler == null) {
        log.error(E_DATA_NODE_TYPE_IS_NOT_SUPPORT);
        throw new ModelConvertorException(E_DATA_NODE_TYPE_IS_NOT_SUPPORT);
    }
    return yobHandler;
}
#method_after
YobHandler getYobHandlerForContext(DataNode.Type type) {
    YobHandler yobHandler = HANDLER_MAP.get(type);
    if (yobHandler == null) {
        log.error(E_DATA_NODE_TYPE_IS_NOT_SUPPORT);
        throw new ModelConvertorException(E_DATA_NODE_TYPE_IS_NOT_SUPPORT);
    }
    return yobHandler;
}
#end_block

#method_before
public static YobHandlerFactory instance() {
    return LazyHolder.INSTANCE;
}
#method_after
static YobHandlerFactory instance() {
    return LazyHolder.INSTANCE;
}
#end_block

#method_before
public void setParentContext() {
    if (this instanceof SchemaDataNode) {
        parentContext = getParentSchemaContext(this.getParent());
        // As rpc node is not leaf holder
        if (this.nodeType != RPC_NODE) {
            ((YangLeavesHolder) this).setLeafParentContext();
        }
    } else if (this instanceof YangCase || this instanceof YangAugment) {
        ((YangLeavesHolder) this).setLeafParentContext();
    }
}
#method_after
public void setParentContext() {
    if (this instanceof SchemaDataNode) {
        parentContext = getParentSchemaContext(this.getParent());
        // As rpc node is not leaf holder
        if (this.nodeType != RPC_NODE) {
            ((YangLeavesHolder) this).setLeafParentContext();
        }
        // setting the schema Id
        schemaId = new SchemaId(getName(), getNameSpace().getModuleNamespace());
    } else if (this instanceof YangCase || this instanceof YangAugment) {
        ((YangLeavesHolder) this).setLeafParentContext();
    }
}
#end_block

#method_before
public void modelObjectList(List<ModelObject> modelObjectList) {
    this.modelObjectList = modelObjectList;
}
#method_after
public void modelObjectList(List<ModelObject> moList) {
    modelObjectList = moList;
}
#end_block

#method_before
@Override
public void enterDataNode(DataNode node) {
    SchemaId schemaId = node.key().schemaId();
    if (schemaId.name().equals(FORWARD_SLASH)) {
        return;
    }
    if (parentSchema == null) {
        parentSchema = getModuleFromNamespace(schemaId.namespace(), registry);
        if (parentSchema == null) {
            throw new ModelConvertorException("Failed to find schema node");
        }
    }
    YangSchemaNode schemaNode;
    if (wbStack.isEmpty()) {
        // It is first level child of root node.
        schemaNode = ((YangSchemaNode) getChildSchemaContext(parentSchema, schemaId.name(), schemaId.namespace()));
    } else {
        /*
             * get schema context for the node from parent data node's schema
             * context.
             */
        SchemaContext parentContext = wbStack.peek().schemaNode();
        schemaNode = ((YangSchemaNode) getChildSchemaContext(parentContext, schemaId.name(), schemaId.namespace()));
    }
    // get YOB handler based on node type
    YobHandler nodeHandler = handlerFactory.getYobHandlerForContext(node.type());
    // Create object for the data node
    YobWorkBench workBench = nodeHandler.createObject(node, schemaNode, registry);
    if (workBench != null) {
        wbStack.push(workBench);
    }
}
#method_after
@Override
public void enterDataNode(DataNode node) {
    SchemaId schemaId = node.key().schemaId();
    if (schemaId.name().equals(FORWARD_SLASH)) {
        return;
    }
    YangSchemaNode schemaNode;
    if (wbStack.isEmpty() && lastIndexSchema == null) {
        /*
             * It is first level child and resource id is null. So get the
             * schema information from registry.
             */
        schemaNode = ((YangSchemaNode) registry.getChildContext(schemaId));
    } else if (wbStack.isEmpty() && lastIndexSchema != null) {
        /*
             * Resource id is not null, lastIndexSchema will have schema node
             * of last node key in resource id.
             */
        schemaNode = ((YangSchemaNode) getChildSchemaContext(lastIndexSchema, schemaId.name(), schemaId.namespace()));
    } else {
        /*
             * get schema context for the node from parent data node's schema
             * context.
             */
        SchemaContext parentContext = wbStack.peek().schemaNode();
        schemaNode = ((YangSchemaNode) getChildSchemaContext(parentContext, schemaId.name(), schemaId.namespace()));
    }
    // get YOB handler based on node type
    YobHandler nodeHandler = handlerFactory.getYobHandlerForContext(node.type());
    // Create object for the data node
    YobWorkBench workBench = nodeHandler.createObject(schemaNode, registry);
    if (workBench != null) {
        wbStack.push(workBench);
    }
}
#end_block

#method_before
@Override
public void exitDataNode(DataNode node) {
    SchemaId schemaId = node.key().schemaId();
    if (schemaId.name().equals(FORWARD_SLASH)) {
        return;
    }
    YobWorkBench curWb;
    YobWorkBench parentWb = null;
    if (node instanceof InnerNode) {
        if (wbStack.size() == 1) {
            curWb = wbStack.pop();
            YobHandler nodeHandler = handlerFactory.getYobHandlerForContext(node.type());
            nodeHandler.buildObject(curWb, registry);
            modelObjectList.add(((ModelObject) curWb.getBuiltObject()));
            return;
        } else {
            curWb = wbStack.pop();
            parentWb = wbStack.peek();
        }
    } else {
        if (wbStack.isEmpty()) {
            ModelObject obj = buildLeafModelObject(node, parentSchema, registry);
            modelObjectList.add(obj);
            return;
        }
        curWb = wbStack.peek();
    }
    YobHandler nodeHandler = handlerFactory.getYobHandlerForContext(node.type());
    nodeHandler.buildObject(curWb, registry);
    nodeHandler.setInParent(node, curWb, parentWb, registry);
}
#method_after
@Override
public void exitDataNode(DataNode node) {
    SchemaId schemaId = node.key().schemaId();
    if (schemaId.name().equals(FORWARD_SLASH)) {
        return;
    }
    YobWorkBench curWb;
    YobWorkBench parentWb = null;
    if (node instanceof InnerNode) {
        if (wbStack.size() == 1) {
            curWb = wbStack.pop();
            YobHandler nodeHandler = handlerFactory.getYobHandlerForContext(node.type());
            nodeHandler.buildObject(curWb, registry);
            modelObjectList.add(((ModelObject) curWb.getBuiltObject()));
            return;
        } else {
            curWb = wbStack.pop();
            parentWb = wbStack.peek();
        }
    } else {
        if (wbStack.isEmpty()) {
            ModelObject obj = buildLeafModelObject(node, lastIndexSchema, registry);
            modelObjectList.add(obj);
            return;
        }
        curWb = wbStack.peek();
    }
    YobHandler nodeHandler = handlerFactory.getYobHandlerForContext(node.type());
    nodeHandler.buildObject(curWb, registry);
    nodeHandler.setInParent(node, curWb, parentWb, registry);
}
#end_block

#method_before
public static Object getObject(YangType typeInfo, String leafValue, YangDataTypes dataType) throws IllegalArgumentException {
    YangDataTypes type;
    if (dataType != null) {
        type = dataType;
    } else {
        type = typeInfo.getDataType();
    }
    switch(type) {
        case INT8:
            return Byte.parseByte(leafValue);
        case UINT8:
        case INT16:
            return Short.parseShort(leafValue);
        case UINT16:
        case INT32:
            return Integer.parseInt(leafValue);
        case UINT32:
        case INT64:
            return Long.parseLong(leafValue);
        case UINT64:
            return new BigInteger(leafValue);
        case EMPTY:
            if (leafValue == null || leafValue.equals("")) {
                return true;
            } else {
                throw new IllegalArgumentException(E_NONEMPTY);
            }
        case BOOLEAN:
            return Boolean.parseBoolean(leafValue);
        case BINARY:
            byte[] data = Base64.getDecoder().decode(leafValue);
            String str = new String(data);
            return str;
        case BITS:
        case IDENTITYREF:
        case ENUMERATION:
        case STRING:
            return leafValue;
        case DECIMAL64:
            return new BigDecimal(leafValue);
        case LEAFREF:
            YangType refType = ((YangLeafRef) typeInfo.getDataTypeExtendedInfo()).getEffectiveDataType();
            return getObject(refType, leafValue, refType.getDataType());
        case DERIVED:
            // referred typedef's list of type will always has only one type
            YangType referredType = ((YangDerivedInfo) typeInfo.getDataTypeExtendedInfo()).getReferredTypeDef().getTypeList().get(0);
            return getObject(referredType, leafValue, ((YangDerivedInfo) typeInfo.getDataTypeExtendedInfo()).getEffectiveBuiltInType());
        case UNION:
            return parseUnionTypeInfo(typeInfo, leafValue);
        default:
            throw new IllegalArgumentException(E_DATATYPE);
    }
}
#method_after
public static Object getObject(YangType typeInfo, String leafValue, YangDataTypes dataType) throws IllegalArgumentException {
    YangDataTypes type;
    if (dataType != null) {
        type = dataType;
    } else {
        type = typeInfo.getDataType();
    }
    switch(type) {
        case INT8:
            return Byte.parseByte(leafValue);
        case UINT8:
        case INT16:
            return Short.parseShort(leafValue);
        case UINT16:
        case INT32:
            return Integer.parseInt(leafValue);
        case UINT32:
        case INT64:
            return Long.parseLong(leafValue);
        case UINT64:
            return new BigInteger(leafValue);
        case EMPTY:
            if (leafValue == null || leafValue.equals("")) {
                return true;
            } else {
                throw new IllegalArgumentException(E_NONEMPTY);
            }
        case BOOLEAN:
            return Boolean.parseBoolean(leafValue);
        case BINARY:
            byte[] data = Base64.getDecoder().decode(leafValue);
            String str = new String(data);
            return str;
        case BITS:
        case IDENTITYREF:
        case ENUMERATION:
        case STRING:
            return leafValue;
        case DECIMAL64:
            return new BigDecimal(leafValue);
        case LEAFREF:
            YangType refType = ((YangLeafRef) typeInfo.getDataTypeExtendedInfo()).getEffectiveDataType();
            return getObject(refType, leafValue, refType.getDataType());
        case DERIVED:
            // referred typedef's list of type will always has only one type
            YangType rt = ((YangDerivedInfo) typeInfo.getDataTypeExtendedInfo()).getReferredTypeDef().getTypeList().get(0);
            return getObject(rt, leafValue, ((YangDerivedInfo) typeInfo.getDataTypeExtendedInfo()).getEffectiveBuiltInType());
        case UNION:
            return parseUnionTypeInfo(typeInfo, leafValue);
        default:
            throw new IllegalArgumentException(E_DATATYPE);
    }
}
#end_block

#method_before
public YobWorkBench createObject(DataNode dataNode, YangSchemaNode schemaNode, DefaultYangModelRegistry reg) {
    YangSchemaNode node = schemaNode;
    while (node.getReferredSchema() != null) {
        node = node.getReferredSchema();
    }
    String qualName = getQualifiedDefaultClass(node);
    ClassLoader classLoader = getClassLoader(node, reg);
    String setterName = schemaNode.getJavaAttributeName();
    Object builtObject = getInstanceOfClass(classLoader, qualName);
    return new YobWorkBench(classLoader, builtObject, setterName, schemaNode);
}
#method_after
YobWorkBench createObject(YangSchemaNode schemaNode, DefaultYangModelRegistry reg) {
    YangSchemaNode node = schemaNode;
    while (node.getReferredSchema() != null) {
        node = node.getReferredSchema();
    }
    String qualName = getQualifiedDefaultClass(node);
    ClassLoader classLoader = getClassLoader(node, reg);
    String setterName = schemaNode.getJavaAttributeName();
    Object builtObject = getInstanceOfClass(classLoader, qualName);
    return new YobWorkBench(classLoader, builtObject, setterName, schemaNode);
}
#end_block

#method_before
public void setInParent(DataNode dataNode, YobWorkBench childWb, YobWorkBench parentWb, DefaultYangModelRegistry reg) {
    parentWb.setObject(childWb, dataNode, reg);
}
#method_after
void setInParent(DataNode dataNode, YobWorkBench childWb, YobWorkBench parentWb, DefaultYangModelRegistry reg) {
    parentWb.setObject(childWb, dataNode, reg);
}
#end_block

#method_before
public void buildObject(YobWorkBench curWorkbench, YangModelRegistry reg) {
    curWorkbench.buildObject(reg);
}
#method_after
void buildObject(YobWorkBench curWorkbench, YangModelRegistry reg) {
    curWorkbench.buildObject(reg);
}
#end_block

#method_before
private void addZoomPan(ObjectNode result, UiTopoLayoutId layoutId) {
    // need to look up topo_zoom settings from preferences service.
    // NOTE:
    // UiPreferencesService API only allows us to retrieve ALL prefs for
    // the given user. It would be better if we could call something like:
    // 
    // ObjectNode value = prefService.getPreference(userName, prefKey);
    // 
    // to get back a single value.
    Map<String, ObjectNode> userPrefs = prefService.getPreferences(userName);
    ObjectNode zoomPrefs = userPrefs.get(PKEY_TOPO_ZOOM);
    if (zoomPrefs == null) {
        // no zoom prefs structure yet.. so initialize..
        ObjectNode zoomForLayout = objectNode().put(ZOOM_SCALE, DEFAULT_SCALE).put(ZOOM_PAN_X, DEFAULT_PAN).put(ZOOM_PAN_Y, DEFAULT_PAN);
        zoomPrefs = objectNode();
        zoomPrefs.set(layoutId.id(), zoomForLayout);
        prefService.setPreference(userName, PKEY_TOPO_ZOOM, zoomPrefs);
    }
    ObjectNode zoomData = (ObjectNode) zoomPrefs.get(layoutId.id());
    if (zoomData == null) {
        zoomData = (ObjectNode) zoomPrefs.get("_default_");
    }
    result.put("bgZoomScale", zoomData.get(ZOOM_SCALE).asText());
    result.put("bgZoomPanX", zoomData.get(ZOOM_PAN_X).asText());
    result.put("bgZoomPanY", zoomData.get(ZOOM_PAN_Y).asText());
}
#method_after
private void addZoomPan(ObjectNode result, UiTopoLayoutId layoutId) {
    // need to look up topo_zoom settings from preferences service.
    // NOTE:
    // UiPreferencesService API only allows us to retrieve ALL prefs for
    // the given user. It would be better if we could call something like:
    // 
    // ObjectNode value = prefService.getPreference(userName, prefKey);
    // 
    // to get back a single value.
    Map<String, ObjectNode> userPrefs = prefService.getPreferences(userName);
    ObjectNode zoomPrefs = userPrefs.get(PKEY_TOPO_ZOOM);
    if (zoomPrefs == null) {
        zoomPrefs = initialZoomForLayout(objectNode(), layoutId.id());
    }
    ObjectNode zoomData = (ObjectNode) zoomPrefs.get(layoutId.id());
    if (zoomData == null) {
        zoomPrefs = initialZoomForLayout(zoomPrefs, layoutId.id());
        zoomData = (ObjectNode) zoomPrefs.get(layoutId.id());
    }
    result.put("bgZoomScale", zoomData.get(ZOOM_SCALE).asText());
    result.put("bgZoomPanX", zoomData.get(ZOOM_PAN_X).asText());
    result.put("bgZoomPanY", zoomData.get(ZOOM_PAN_Y).asText());
}
#end_block

#method_before
public static DefaultOFSwitchCapabilities.Builder builder() {
    return new Builder();
}
#method_after
public static Builder builder() {
    return new Builder();
}
#end_block

#method_before
public Builder flowStats() {
    ofCapabilities.add(OFCapabilities.FLOW_STATS);
    return this;
}
#method_after
@Override
public Builder flowStats() {
    ofCapabilities.add(OFCapabilities.FLOW_STATS);
    return this;
}
#end_block

#method_before
public Builder tableStats() {
    ofCapabilities.add(OFCapabilities.TABLE_STATS);
    return this;
}
#method_after
@Override
public Builder tableStats() {
    ofCapabilities.add(OFCapabilities.TABLE_STATS);
    return this;
}
#end_block

#method_before
public Builder portStats() {
    ofCapabilities.add(OFCapabilities.PORT_STATS);
    return this;
}
#method_after
@Override
public Builder portStats() {
    ofCapabilities.add(OFCapabilities.PORT_STATS);
    return this;
}
#end_block

#method_before
public Builder groupStats() {
    ofCapabilities.add(OFCapabilities.GROUP_STATS);
    return this;
}
#method_after
@Override
public Builder groupStats() {
    ofCapabilities.add(OFCapabilities.GROUP_STATS);
    return this;
}
#end_block

#method_before
public Builder ipReasm() {
    ofCapabilities.add(OFCapabilities.IP_REASM);
    return this;
}
#method_after
@Override
public Builder ipReasm() {
    ofCapabilities.add(OFCapabilities.IP_REASM);
    return this;
}
#end_block

#method_before
public Builder queueStats() {
    ofCapabilities.add(OFCapabilities.QUEUE_STATS);
    return this;
}
#method_after
@Override
public Builder queueStats() {
    ofCapabilities.add(OFCapabilities.QUEUE_STATS);
    return this;
}
#end_block

#method_before
public Builder portBlocked() {
    ofCapabilities.add(OFCapabilities.PORT_STATS);
    return this;
}
#method_after
@Override
public Builder portBlocked() {
    ofCapabilities.add(OFCapabilities.PORT_BLOCKED);
    return this;
}
#end_block

#method_before
public DefaultOFSwitchCapabilities build() {
    return new DefaultOFSwitchCapabilities(ofCapabilities);
}
#method_after
@Override
public OFSwitchCapabilities build() {
    return new DefaultOFSwitchCapabilities(ofCapabilities);
}
#end_block

#method_before
@Activate
protected void activate() {
    // TODO listen to the virtual network event
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    // TODO listen to the virtual network event
    ioWorker = new NioEventLoopGroup();
    log.info("Started");
}
#end_block

#method_before
public void connect() {
    SocketAddress remoteAddr = new InetSocketAddress(controller.ip().toInetAddress(), controller.port().toInt());
    log.debug("Controller IP Address: {}, Port: {}", controller.ip().toString(), controller.port().toString());
    Bootstrap bootstrap = new Bootstrap();
    bootstrap.group(workGroup).channel(NioSocketChannel.class).option(ChannelOption.SO_KEEPALIVE, true).handler(new OFChannelInitializer(ofSwitch));
    bootstrap.connect(remoteAddr).addListener(this);
}
#method_after
public void connect() {
    SocketAddress remoteAddr = new InetSocketAddress(controller.ip().toInetAddress(), controller.port().toInt());
    log.debug("Connecting to controller {}:{}", controller.ip(), controller.port());
    Bootstrap bootstrap = new Bootstrap();
    bootstrap.group(workGroup).channel(NioSocketChannel.class).option(ChannelOption.SO_KEEPALIVE, true).handler(new OFChannelInitializer(ofSwitch));
    bootstrap.connect(remoteAddr).addListener(this);
}
#end_block

#method_before
@Override
public void operationComplete(ChannelFuture future) throws Exception {
    if (future.isSuccess()) {
        log.info("Connected to controller {} with port {}", controller.ip().toString(), controller.port().toString());
    } else {
        log.info("Failed to connect. Retry...");
        if (retryCount.getAndIncrement() < Constants.MAX_RETRY) {
            this.connect();
        }
    }
}
#method_after
@Override
public void operationComplete(ChannelFuture future) throws Exception {
    if (future.isSuccess()) {
        log.debug("Connected to controller {}:{}", controller.ip(), controller.port());
    } else {
        log.info("Failed to connect controller {}:{}. Retry...", controller.ip(), controller.port());
        if (retryCount.getAndIncrement() < MAX_RETRY) {
            this.connect();
        }
    }
}
#end_block

#method_before
@Override
protected void encode(ChannelHandlerContext ctx, OFMessage msg, ByteBuf out) throws Exception {
    log.info("encode called");
    if (!ctx.channel().isActive()) {
        return;
    }
    try {
        ByteBuf byteBuf = PooledByteBufAllocator.DEFAULT.directBuffer();
        msg.writeTo(byteBuf);
        ctx.writeAndFlush(byteBuf);
    } catch (Exception e) {
        log.error("error occured because of {}", e.getMessage());
    }
}
#method_after
@Override
protected void encode(ChannelHandlerContext ctx, Iterable<OFMessage> msgList, ByteBuf out) throws Exception {
    if (!ctx.channel().isActive()) {
        return;
    }
    if (msgList instanceof Iterable) {
        msgList.forEach(msg -> {
            try {
                ByteBuf byteBuf = PooledByteBufAllocator.DEFAULT.directBuffer();
                msg.writeTo(byteBuf);
                ctx.writeAndFlush(byteBuf);
            } catch (Exception e) {
                log.error("error occured because of {}", e.getMessage());
            }
        });
    }
}
#end_block

#method_before
@Override
protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
    log.debug("decode called. Received message from {}: {}", ctx.channel().remoteAddress(), in.readableBytes());
    if (!ctx.channel().isActive()) {
        return;
    }
    try {
        OFMessageReader<OFMessage> reader = OFFactories.getGenericReader();
        OFMessage message = reader.readFrom(in);
        out.add(message);
        log.debug("OpenFlow message {} added", message.toString());
    } catch (Throwable cause) {
        log.error("Exception occured while processing decoding because of {}", cause.getMessage());
    }
}
#method_after
@Override
protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
    if (!ctx.channel().isActive()) {
        return;
    }
    try {
        OFMessageReader<OFMessage> reader = OFFactories.getGenericReader();
        OFMessage message = reader.readFrom(in);
        out.add(message);
    } catch (Throwable cause) {
        log.error("Exception occured while processing decoding because of {}", cause.getMessage());
    }
}
#end_block

#method_before
// TODO add builder
@Override
public VirtualDevice device() {
    return device();
}
#method_after
// TODO add builder
@Override
public Device device() {
    return device;
}
#end_block

#method_before
@Override
public void processControllerCommand(ChannelHandlerContext ctx, OFMessage msg) {
// TODO process controller command
}
#method_after
@Override
public void processControllerCommand(Channel channel, OFMessage msg) {
// TODO process controller command
}
#end_block

#method_before
@Override
public void processStatsRequest(ChannelHandlerContext ctx, OFMessage msg) {
// TODO process request and send reply
}
#method_after
@Override
public void processStatsRequest(Channel channel, OFMessage msg) {
// TODO process request and send reply
}
#end_block

#method_before
@Override
public void processRoleRequest(ChannelHandlerContext ctx, OFMessage msg) {
// TODO process role request and send reply
}
#method_after
@Override
public void processRoleRequest(Channel channel, OFMessage msg) {
// TODO process role request and send reply
}
#end_block

#method_before
@Override
public void processFeaturesRequest(ChannelHandlerContext ctx, OFMessage msg) {
    // TODO process features request and send reply
    OFFeaturesReply.Builder frBuilder = FACTORY.buildFeaturesReply().setDatapathId(datapathId).setNBuffers(Constants.N_BUFFERS).setNTables(Constants.N_TABLES).setCapabilities(capabilities.ofSwitchcapabilities()).setXid(msg.getXid());
    ctx.write(frBuilder.build());
}
#method_after
@Override
public void processFeaturesRequest(Channel channel, OFMessage msg) {
    // TODO process features request and send reply
    List<OFMessage> ofMessageList = Lists.newArrayList();
    OFFeaturesReply.Builder frBuilder = FACTORY.buildFeaturesReply().setDatapathId(datapathId).setNBuffers(N_BUFFERS).setNTables(N_TABLES).setCapabilities(capabilities.ofSwitchCapabilities()).setXid(msg.getXid());
    ofMessageList.add(frBuilder.build());
    channel.write(ofMessageList);
}
#end_block

#method_before
@Override
public void processLldp(ChannelHandlerContext ctx, OFMessage msg) {
// TODO process lldp
}
#method_after
@Override
public void processLldp(Channel channel, OFMessage msg) {
// TODO process lldp
}
#end_block

#method_before
@Override
public void sendOfHello(ChannelHandlerContext ctx) {
    OFHello.Builder ofHello = FACTORY.buildHello().setXid(this.handshakeTransactionIds--);
    ctx.write(ofHello.build());
}
#method_after
@Override
public void sendOfHello(Channel channel) {
    List<OFMessage> ofMessageList = Lists.newArrayList();
    OFHello.Builder ofHello = FACTORY.buildHello().setXid(this.handshakeTransactionIds--);
    ofMessageList.add(ofHello.build());
    channel.write(ofMessageList);
}
#end_block

#method_before
@Override
public void processEchoRequest(ChannelHandlerContext ctx, OFMessage msg) {
    OFEchoReply.Builder echoBuilder = FACTORY.buildEchoReply().setXid(msg.getXid()).setData(((OFEchoRequest) msg).getData());
    ctx.write(echoBuilder.build());
}
#method_after
@Override
public void processEchoRequest(Channel channel, OFMessage msg) {
    List<OFMessage> ofMessageList = Lists.newArrayList();
    OFEchoReply.Builder echoBuilder = FACTORY.buildEchoReply().setXid(msg.getXid()).setData(((OFEchoRequest) msg).getData());
    ofMessageList.add(echoBuilder.build());
    channel.write(ofMessageList);
}
#end_block

#method_before
@Override
public void channelActive(ChannelHandlerContext ctx) throws Exception {
    this.ctx = ctx;
    log.debug("Channel Active. Send OF_13 Hello to {}", ctx.channel().remoteAddress());
    try {
        ofSwitch.sendOfHello(ctx);
        setState(ChannelState.WAIT_HELLO);
    } catch (Throwable cause) {
        log.error("Exception occured because of{}", cause.getMessage());
    }
}
#method_after
@Override
public void channelActive(ChannelHandlerContext ctx) throws Exception {
    this.ctx = ctx;
    log.debug("Channel Active. Send OF_13 Hello to {}", ctx.channel().remoteAddress());
    try {
        ofSwitch.sendOfHello(ctx.channel());
        setState(ChannelState.WAIT_HELLO);
    } catch (Throwable cause) {
        log.error("Exception occured because of{}", cause.getMessage());
    }
}
#end_block

#method_before
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    log.debug("ChannelRead event in OFChannelHandler occured");
    try {
        if (msg instanceof List) {
            ((List) msg).forEach(ofm -> {
                state.processOFMessage(this, (OFMessage) ofm);
                log.debug("OpenFlow message {} received", ((OFMessage) ofm).getType().toString());
            });
        } else {
            state.processOFMessage(this, (OFMessage) msg);
            log.debug("OpenFlow message {} received", ((OFMessage) msg).getType().toString());
        }
    } catch (Throwable cause) {
        log.error("Exception occured {}", cause.getMessage());
    }
}
#method_after
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    try {
        if (msg instanceof List) {
            ((List) msg).forEach(ofm -> {
                state.processOFMessage(this, (OFMessage) ofm);
            });
        } else {
            state.processOFMessage(this, (OFMessage) msg);
        }
    } catch (Throwable cause) {
        log.error("Exception occured {}", cause.getMessage());
    }
}
#end_block

#method_before
@Override
public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
    log.debug("ChannelReadComplete event in OFChannelHandler occured");
}
#method_after
@Override
public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
}
#end_block

#method_before
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
    if (cause instanceof ReadTimeoutException) {
        log.error("Connection closed because of ReadTimeoutException {}", cause.getMessage());
        ctx.close();
    } else if (cause instanceof ClosedChannelException) {
        log.error("ClosedChannelException occured");
    } else if (cause instanceof RejectedExecutionException) {
        log.error("Could not process message: queue full");
        ctx.close();
    } else if (cause instanceof IOException) {
        log.error("IOException occured");
        ctx.close();
    } else {
        log.error("Error while processing message from switch {}", cause.getMessage());
        ctx.close();
    }
}
#method_after
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
    if (cause instanceof ReadTimeoutException) {
        log.error("Connection closed because of ReadTimeoutException {}", cause.getMessage());
    } else if (cause instanceof ClosedChannelException) {
        log.error("ClosedChannelException occured");
        return;
    } else if (cause instanceof RejectedExecutionException) {
        log.error("Could not process message: queue full");
    } else if (cause instanceof IOException) {
        log.error("IOException occured");
    } else {
        log.error("Error while processing message from switch {}", cause.getMessage());
    }
    ctx.close();
}
#end_block

#method_before
@Override
protected void initChannel(SocketChannel ch) throws Exception {
    // TODO configure OF channel pipeline
    ch.pipeline().addLast(new OFMessageDecoder()).addLast(new OFMessageEncoder()).addLast(new ReadTimeoutHandler(Constants.READ_TIMEOUT)).addLast(new OFChannelHandler(ofSwitch));
}
#method_after
@Override
protected void initChannel(SocketChannel ch) throws Exception {
    ch.pipeline().addLast(new OFMessageDecoder()).addLast(new OFMessageEncoder()).addLast(new ReadTimeoutHandler(READ_TIMEOUT)).addLast(new OFChannelHandler(ofSwitch));
}
#end_block

#method_before
private Ethernet processDhcpPacketFromServer(Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
    // determine the vlanId of the client host - note that this vlan id
    // could be different from the vlan in the packet from the server
    MacAddress dstMac = new MacAddress(dhcpPayload.getClientHardwareAddress());
    Set<Host> hosts = hostService.getHostsByMac(dstMac);
    if (hosts == null || hosts.isEmpty()) {
        log.warn("Cannot determine host for DHCP client: {}. Aborting " + "relay for dhcp packet from server {}", dhcpPayload.getClientHardwareAddress(), ethernetPacket);
        return null;
    } else if (hosts.size() > 1) {
        log.warn("Multiple hosts found for mac:{}. Picking one " + "host out of {}", dstMac, hosts);
    }
    Host host = hosts.iterator().next();
    etherReply.setDestinationMACAddress(dstMac);
    etherReply.setVlanID(host.vlan().toShort());
    // we leave the srcMac from the original packet
    // figure out the relay agent IP corresponding to the original request
    Ip4Address relayAgentIP = getRelayAgentIPv4Address(interfaceService.getInterfacesByPort(host.location()));
    if (relayAgentIP == null) {
        log.warn("Cannot determine relay agent interface Ipv4 addr for host {}. " + "Aborting relay for dhcp packet from server {}", host, ethernetPacket);
        return null;
    }
    // SRC_IP: relay agent IP
    // DST_IP: offered IP
    ipv4Packet.setSourceAddress(relayAgentIP.toInt());
    ipv4Packet.setDestinationAddress(dhcpPayload.getYourIPAddress());
    udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    udpPacket.setPayload(dhcpPayload);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#method_after
private Ethernet processDhcpPacketFromServer(Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
    // determine the vlanId of the client host - note that this vlan id
    // could be different from the vlan in the packet from the server
    MacAddress dstMac = valueOf(dhcpPayload.getClientHardwareAddress());
    Set<Host> hosts = hostService.getHostsByMac(dstMac);
    if (hosts == null || hosts.isEmpty()) {
        log.warn("Cannot determine host for DHCP client: {}. Aborting " + "relay for dhcp packet from server {}", dhcpPayload.getClientHardwareAddress(), ethernetPacket);
        return null;
    } else if (hosts.size() > 1) {
        // XXX  redo to send reply to all hosts found
        log.warn("Multiple hosts found for mac:{}. Picking one " + "host out of {}", dstMac, hosts);
    }
    Host host = hosts.iterator().next();
    etherReply.setDestinationMACAddress(dstMac);
    etherReply.setVlanID(host.vlan().toShort());
    // we leave the srcMac from the original packet
    // figure out the relay agent IP corresponding to the original request
    Ip4Address relayAgentIP = getRelayAgentIPv4Address(interfaceService.getInterfacesByPort(host.location()));
    if (relayAgentIP == null) {
        log.warn("Cannot determine relay agent interface Ipv4 addr for host {}. " + "Aborting relay for dhcp packet from server {}", host, ethernetPacket);
        return null;
    }
    // SRC_IP: relay agent IP
    // DST_IP: offered IP
    ipv4Packet.setSourceAddress(relayAgentIP.toInt());
    ipv4Packet.setDestinationAddress(dhcpPayload.getYourIPAddress());
    udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    udpPacket.setPayload(dhcpPayload);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#end_block

#method_before
private void sendReply(Ethernet ethPacket, DHCP dhcpPayload) {
    MacAddress descMac = new MacAddress(dhcpPayload.getClientHardwareAddress());
    Host host = hostService.getHost(HostId.hostId(descMac, VlanId.vlanId(ethPacket.getVlanID())));
    // Send packet out to requester if the host information is available
    if (host != null) {
        TrafficTreatment t = DefaultTrafficTreatment.builder().setOutput(host.location().port()).build();
        OutboundPacket o = new DefaultOutboundPacket(host.location().deviceId(), t, ByteBuffer.wrap(ethPacket.serialize()));
        if (log.isTraceEnabled()) {
            log.trace("Relaying packet to dhcp client {}", ethPacket);
        }
        packetService.emit(o);
    }
}
#method_after
private void sendReply(Ethernet ethPacket, DHCP dhcpPayload) {
    MacAddress descMac = valueOf(dhcpPayload.getClientHardwareAddress());
    Host host = hostService.getHost(HostId.hostId(descMac, VlanId.vlanId(ethPacket.getVlanID())));
    // Send packet out to requester if the host information is available
    if (host != null) {
        TrafficTreatment t = DefaultTrafficTreatment.builder().setOutput(host.location().port()).build();
        OutboundPacket o = new DefaultOutboundPacket(host.location().deviceId(), t, ByteBuffer.wrap(ethPacket.serialize()));
        if (log.isTraceEnabled()) {
            log.trace("Relaying packet to dhcp client {}", ethPacket);
        }
        packetService.emit(o);
    }
}
#end_block

#method_before
public TrafficLink tagMods(Set<Mod> mods) {
    this.mods.addAll(mods);
    return this;
}
#method_after
public TrafficLink tagMods(Set<Mod> mods) {
    if (mods != null) {
        this.mods.addAll(mods);
    }
    return this;
}
#end_block

#method_before
// =======================================================================
private Highlights protectedIntentHighlights() {
    Highlights highlights = new Highlights();
    TrafficLinkMap linkMap = new TrafficLinkMap();
    if (selectedIntent != null) {
        List<Intent> installables = servicesBundle.intentService().getInstallableIntents(selectedIntent.key());
        Set<Link> primary = new HashSet<>();
        Set<Link> backup = new HashSet<>();
        if (installables != null) {
            // ProtectionEndpointIntent for each ProtectedTransportIntent.
            for (Intent installable : installables) {
                if (installable instanceof FlowRuleIntent) {
                    handleFlowRuleIntent(primary, backup, (FlowRuleIntent) installable);
                } else if (installable instanceof ProtectionEndpointIntent) {
                    handleProtectionEndpointIntent(primary, backup, (ProtectionEndpointIntent) installable);
                } else {
                    log.warn("Intent {} is not an expected installable type {} " + "related to ProtectedTransportIntent", installable.id(), installable.getClass().getSimpleName());
                    stopMonitoring();
                }
            }
            boolean isOptical = selectedIntent instanceof OpticalConnectivityIntent;
            // Flavor is swapped so green is primary path.
            if (usingBackup(primary)) {
                // the backup becomes in use so we have a dotted line
                processLinks(linkMap, backup, Flavor.PRIMARY_HIGHLIGHT, isOptical, true, ImmutableSet.of(protectedIntentMod));
            } else {
                processLinks(linkMap, primary, Flavor.PRIMARY_HIGHLIGHT, isOptical, true, ImmutableSet.of());
                processLinks(linkMap, backup, Flavor.SECONDARY_HIGHLIGHT, isOptical, false, ImmutableSet.of(protectedIntentMod));
            }
            updateHighlights(highlights, primary);
            updateHighlights(highlights, backup);
            colorLinks(highlights, linkMap);
            highlights.subdueAllElse(Highlights.Amount.MINIMALLY);
        } else {
            log.debug("Selected Intent has no installables intents");
        }
    } else {
        log.debug("Selected Intent is null");
    }
    return highlights;
}
#method_after
// =======================================================================
private Highlights protectedIntentHighlights() {
    Highlights highlights = new Highlights();
    TrafficLinkMap linkMap = new TrafficLinkMap();
    if (selectedIntent != null) {
        List<Intent> installables = servicesBundle.intentService().getInstallableIntents(selectedIntent.key());
        Set<Link> primary = new HashSet<>();
        Set<Link> backup = new HashSet<>();
        if (installables != null) {
            // ProtectionEndpointIntent for each ProtectedTransportIntent.
            for (Intent installable : installables) {
                if (installable instanceof FlowRuleIntent) {
                    handleFlowRuleIntent(primary, backup, (FlowRuleIntent) installable);
                } else if (installable instanceof ProtectionEndpointIntent) {
                    handleProtectionEndpointIntent(primary, backup, (ProtectionEndpointIntent) installable);
                } else {
                    log.warn("Intent {} is not an expected installable type {} " + "related to ProtectedTransportIntent", installable.id(), installable.getClass().getSimpleName());
                    stopMonitoring();
                }
            }
            boolean isOptical = selectedIntent instanceof OpticalConnectivityIntent;
            // Flavor is swapped so green is primary path.
            if (usingBackup(primary)) {
                // the backup becomes in use so we have a dotted line
                processLinks(linkMap, backup, Flavor.PRIMARY_HIGHLIGHT, isOptical, true, PROTECTED_MOD_BACKUP_SET);
            } else {
                processLinks(linkMap, primary, Flavor.PRIMARY_HIGHLIGHT, isOptical, true, PROTECTED_MOD_PRIMARY_SET);
                processLinks(linkMap, backup, Flavor.SECONDARY_HIGHLIGHT, isOptical, false, PROTECTED_MOD_BACKUP_SET);
            }
            updateHighlights(highlights, primary);
            updateHighlights(highlights, backup);
            colorLinks(highlights, linkMap);
            highlights.subdueAllElse(Highlights.Amount.MINIMALLY);
        } else {
            log.debug("Selected Intent has no installables intents");
        }
    } else {
        log.debug("Selected Intent is null");
    }
    return highlights;
}
#end_block

#method_before
private void processLinks(TrafficLinkMap linkMap, Iterable<Link> links, Flavor flavor, boolean isOptical, boolean showTraffic, Set<Mod> mods) {
    if (links != null) {
        for (Link link : links) {
            TrafficLink tlink = linkMap.add(link);
            tlink.tagFlavor(flavor);
            tlink.optical(isOptical);
            if (showTraffic) {
                tlink.antMarch(true);
            }
            if (!mods.isEmpty()) {
                tlink.tagMods(mods);
            }
        }
    }
}
#method_after
private void processLinks(TrafficLinkMap linkMap, Iterable<Link> links, Flavor flavor, boolean isOptical, boolean showTraffic, Set<Mod> mods) {
    if (links != null) {
        for (Link link : links) {
            TrafficLink tlink = linkMap.add(link);
            tlink.tagFlavor(flavor);
            tlink.optical(isOptical);
            if (showTraffic) {
                tlink.antMarch(true);
            }
            tlink.tagMods(mods);
        }
    }
}
#end_block

#method_before
@Override
public void enterDataNode(DataNode dataNode, DataNodeSiblingPositionType siblingType) {
    String nodeName = getNodeNameWithNamespace(dataNode.key().schemaId());
    switch(dataNode.type()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            if (siblingType == FIRST_INSTANCE || siblingType == SINGLE_INSTANCE_IN_MULTI_NODE) {
                jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.ARRAY);
            }
            jsonBuilder.addNodeTopHalf("", JsonNodeType.OBJECT);
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeWithValueTopHalf(nodeName, ((LeafNode) dataNode).value().toString());
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            if (siblingType == FIRST_INSTANCE || siblingType == SINGLE_INSTANCE_IN_MULTI_NODE) {
                jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.ARRAY);
            }
            jsonBuilder.addValueToLeafListNode(((LeafNode) dataNode).value().toString());
            break;
        default:
            break;
    }
}
#method_after
@Override
public void enterDataNode(DataNode dataNode, DataNodeSiblingPositionType siblingType) {
    String nodeName = getNodeNameWithNamespace(dataNode.key().schemaId());
    switch(dataNode.type()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            if (siblingType == FIRST_INSTANCE || siblingType == SINGLE_INSTANCE_IN_MULTI_NODE) {
                jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.ARRAY);
            }
            jsonBuilder.addNodeTopHalf("", JsonNodeType.OBJECT);
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            LeafNode sLeafNode = (LeafNode) dataNode;
            jsonBuilder.addNodeWithValueTopHalf(nodeName, sLeafNode.asString());
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            if (siblingType == FIRST_INSTANCE || siblingType == SINGLE_INSTANCE_IN_MULTI_NODE) {
                jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.ARRAY);
            }
            LeafNode mLeafNode = (LeafNode) dataNode;
            jsonBuilder.addValueToLeafListNode(mLeafNode.asString());
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void walkJsonNode(String fieldName, JsonNode jsonNode) {
    JsonNodeType nodeType = jsonNode.getNodeType();
    if (!jsonNode.isContainerNode()) {
        // the node has no children, so add it as leaf node to the data tree.
        addLeafNodeToDataTree(fieldName, jsonNode);
        dataNodeBuilder = SerializerHelper.exitDataNode(dataNodeBuilder);
        return;
    }
    /*
         * For an array node, there are 2 cases:
         *
         * 1. It is a leaflist node
         * 2. It is a multi-instance node.
         */
    if (jsonNode.isArray()) {
        // Let's deal with the leaflist case first.
        if (isJsonNodeLeafList((ArrayNode) jsonNode)) {
            addLeafListNodeToDataTree(fieldName, (ArrayNode) jsonNode);
            // SerializerHelper.exitDataNode(dataNodeBuilder);
            return;
        }
        /*
             * This is a multi-instance node. Each element in the
             * array is an instance of multi-instance node in the data tree.
             */
        Iterator<JsonNode> elements = jsonNode.elements();
        while (elements.hasNext()) {
            JsonNode element = elements.next();
            addMultiInstanceNodeToDataTree(fieldName);
            // Recursively build the subtree of element
            walkJsonNode(null, element);
            // We are done with this array element.
            dataNodeBuilder = SerializerHelper.exitDataNode(dataNodeBuilder);
        }
        // SerializerHelper.exitDataNode(dataNodeBuilder);
        return;
    }
    /*
         * If we reach here, then this node is an object node. An object node
         * has a set of name-value pairs. ("value" can be object node.)
         */
    if (fieldName != null) {
        // If fieldName is null, then the caller does not want to
        // add the node into the data tree. Rather, it just want to add
        // the children nodes to the current node of the data tree.
        addSingleInstanceNodeToDataTree(fieldName);
    }
    Iterator<Map.Entry<String, JsonNode>> fields = jsonNode.fields();
    while (fields.hasNext()) {
        // get the children entry of the node
        Map.Entry<String, JsonNode> currentChild = fields.next();
        String key = currentChild.getKey();
        JsonNode value = currentChild.getValue();
        walkJsonNode(key, value);
    // NOTE: Don't move up, because walkJsonNode will do so.
    // SerializerHelper.exitDataNode(dataNodeBuilder);
    }
    if (fieldName != null) {
        // move up since we finish creating a container node.
        dataNodeBuilder = SerializerHelper.exitDataNode(dataNodeBuilder);
    }
}
#method_after
@Override
public void walkJsonNode(String fieldName, JsonNode jsonNode) {
    if (!jsonNode.isContainerNode()) {
        // the node has no children, so add it as leaf node to the data tree.
        addLeafNodeToDataTree(fieldName, jsonNode);
        dataNodeBuilder = SerializerHelper.exitDataNode(dataNodeBuilder);
        return;
    }
    /*
         * For an array node, there are 2 cases:
         *
         * 1. It is a leaflist node
         * 2. It is a multi-instance node.
         */
    if (jsonNode.isArray()) {
        // Let's deal with the leaflist case first.
        if (isJsonNodeLeafList((ArrayNode) jsonNode)) {
            addLeafListNodeToDataTree(fieldName, (ArrayNode) jsonNode);
            // SerializerHelper.exitDataNode(dataNodeBuilder);
            return;
        }
        /*
             * This is a multi-instance node. Each element in the
             * array is an instance of multi-instance node in the data tree.
             */
        Iterator<JsonNode> elements = jsonNode.elements();
        while (elements.hasNext()) {
            JsonNode element = elements.next();
            addMultiInstanceNodeToDataTree(fieldName);
            // Recursively build the subtree of element
            walkJsonNode(null, element);
            // We are done with this array element.
            dataNodeBuilder = SerializerHelper.exitDataNode(dataNodeBuilder);
        }
        // SerializerHelper.exitDataNode(dataNodeBuilder);
        return;
    }
    /*
         * If we reach here, then this node is an object node. An object node
         * has a set of name-value pairs. ("value" can be object node.)
         */
    if (fieldName != null) {
        // If fieldName is null, then the caller does not want to
        // add the node into the data tree. Rather, it just want to add
        // the children nodes to the current node of the data tree.
        addSingleInstanceNodeToDataTree(fieldName);
    }
    Iterator<Map.Entry<String, JsonNode>> fields = jsonNode.fields();
    while (fields.hasNext()) {
        // get the children entry of the node
        Map.Entry<String, JsonNode> currentChild = fields.next();
        String key = currentChild.getKey();
        JsonNode value = currentChild.getValue();
        walkJsonNode(key, value);
    // NOTE: Don't move up, because walkJsonNode will do so.
    // SerializerHelper.exitDataNode(dataNodeBuilder);
    }
    if (fieldName != null) {
        // move up since we finish creating a container node.
        dataNodeBuilder = SerializerHelper.exitDataNode(dataNodeBuilder);
    }
}
#end_block

#method_before
@Override
public CompositeData decode(CompositeStream compositeStream, YangSerializerContext yangSerializerContext) {
    try {
        ResourceId.Builder rIdBuilder = convertUriToRid(compositeStream.resourceId(), yangSerializerContext);
        ObjectNode rootNode = null;
        if (compositeStream.resourceData() != null) {
            rootNode = (ObjectNode) mapper().readTree(compositeStream.resourceData());
        }
        DataNode dataNode;
        /*
             * initializeDataNode by passing yangSerializerContext is
             * intended to be used in a scenario wherein URL is NULL.
             * initializeDataNode by passing resourceIdBuilder is
             * intended to be used in a scenario when URL is not NULL
             * and in this case the resourceId builder which was constructed
             * for a URL, needs to be given as an Input parameter.
             */
        if (rIdBuilder != null) {
            dataNode = convertJsonToDataNode(rootNode, rIdBuilder);
        } else {
            dataNode = convertJsonToDataNode(rootNode, yangSerializerContext);
        }
        ResourceData resourceData = DefaultResourceData.builder().addDataNode(dataNode).resourceId(rIdBuilder == null ? null : rIdBuilder.build()).build();
        return DefaultCompositeData.builder().resourceData(resourceData).build();
    } catch (JsonProcessingException e) {
        log.error("ERROR: JsonProcessingException {}", e.getMessage());
        log.debug("Exception in decode:", e);
        throw new SerializerException("JSON serializer decode failure");
    } catch (IOException ex) {
        log.error("ERROR: decode ", ex);
        throw new SerializerException("JSON serializer decode failure");
    }
}
#method_after
@Override
public CompositeData decode(CompositeStream compositeStream, YangSerializerContext yangSerializerContext) {
    try {
        ResourceId.Builder rIdBuilder = convertUriToRid(compositeStream.resourceId(), yangSerializerContext);
        ObjectNode rootNode = null;
        if (compositeStream.resourceData() != null) {
            rootNode = (ObjectNode) mapper().readTree(compositeStream.resourceData());
        }
        DataNode dataNode;
        /*
             * initializeDataNode by passing yangSerializerContext is
             * intended to be used in a scenario wherein URL is NULL.
             * initializeDataNode by passing resourceIdBuilder is
             * intended to be used in a scenario when URL is not NULL
             * and in this case the resourceId builder which was constructed
             * for a URL, needs to be given as an Input parameter.
             */
        if (rIdBuilder != null) {
            dataNode = convertJsonToDataNode(rootNode, rIdBuilder);
        } else {
            dataNode = convertJsonToDataNode(rootNode, yangSerializerContext);
        }
        ResourceData resourceData = DefaultResourceData.builder().addDataNode(dataNode).resourceId(rIdBuilder == null ? null : rIdBuilder.build()).build();
        return DefaultCompositeData.builder().resourceData(resourceData).build();
    } catch (JsonProcessingException e) {
        log.error("ERROR: JsonProcessingException {}", e.getMessage());
        log.debug("Exception in decode:", e);
        throw new SerializerException(ERROR_INFO);
    } catch (IOException ex) {
        log.error("ERROR: decode ", ex);
        throw new SerializerException(ERROR_INFO);
    }
}
#end_block

#method_before
@Override
public CompositeStream encode(CompositeData compositeData, YangSerializerContext yangSerializerContext) {
    checkNotNull(compositeData, "compositeData cannot be null");
    String uriString = convertRidToUri(compositeData.resourceData().resourceId());
    InputStream inputStream = null;
    ObjectNode rootNode = null;
    if (compositeData.resourceData().dataNodes() != null) {
        rootNode = convertDataNodeToJson(compositeData.resourceData().dataNodes().get(0));
    }
    if (rootNode != null) {
        inputStream = IOUtils.toInputStream(rootNode.toString());
    }
    CompositeStream compositeStream = new DefaultCompositeStream(uriString, inputStream);
    return compositeStream;
}
#method_after
@Override
public CompositeStream encode(CompositeData compositeData, YangSerializerContext yangSerializerContext) {
    checkNotNull(compositeData, "compositeData cannot be null");
    String uriString = convertRidToUri(compositeData.resourceData().resourceId());
    InputStream inputStream = null;
    ObjectNode rootNode = null;
    if (compositeData.resourceData().dataNodes() != null) {
        rootNode = convertDataNodeToJson(compositeData.resourceData().dataNodes().get(0));
    }
    if (rootNode != null) {
        inputStream = IOUtils.toInputStream(rootNode.toString());
    }
    // return a CompositeStream
    return new DefaultCompositeStream(uriString, inputStream);
}
#end_block

#method_before
@Override
public List<Annotation> getProtocolAnnotations() {
    // TODO: anotation arguments
    Annotation annotation = new DefaultAnnotation(XMNLS_NC, NETCONF_NS);
    List<Annotation> protocolAnnotation = new LinkedList<>();
    protocolAnnotation.add(annotation);
    return protocolAnnotation;
}
#method_after
@Override
public List<Annotation> getProtocolAnnotations() {
    Annotation annotation = new DefaultAnnotation(XMNLS_NC, NETCONF_NS);
    List<Annotation> protocolAnnotation = new LinkedList<>();
    protocolAnnotation.add(annotation);
    return protocolAnnotation;
}
#end_block

#method_before
@Override
public ObjectNode runGetOperationOnDataResource(String uri) throws RestconfException {
    InputStream jsonData = null;
    compositeStream = new DefaultCompositeStream(uri, jsonData);
    // CompositeStream --- YangRuntimeService ---> CompositeData
    compositeData = yangRuntimeService.decode(compositeStream, "json");
    resourceData = compositeData.resourceData();
    ResourceId rid = resourceData.resourceId();
    // TODO: define Filter (if there is any requirement)
    Filter filter = new Filter();
    // get data node from dynamic config service
    DataNode dataNode;
    try {
        dataNode = dynamicConfigService.readNode(rid, filter);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
        return null;
    }
    // add dataNode to resourceData
    ResourceData.Builder resourceDataBuilder = DefaultResourceData.builder();
    resourceDataBuilder.addDataNode(dataNode);
    resourceDataBuilder.resourceId(rid);
    // Add DataNode to CompositeData
    CompositeData.Builder compositeDataBuilder = DefaultCompositeData.builder();
    compositeData = compositeDataBuilder.resourceData(resourceData).build();
    // CompositeData --- YangRuntimeService ---> CompositeStream
    compositeStream = yangRuntimeService.encode(compositeData, "json");
    InputStream inputStream = compositeStream.resourceData();
    ObjectNode rootNode = convertInputStreamToObjectNode(inputStream);
    if (rootNode == null) {
        throw new RestconfException("ERROR: InputStream can not be convert to ObjectNode", INTERNAL_SERVER_ERROR);
    }
    return rootNode;
}
#method_after
@Override
public ObjectNode runGetOperationOnDataResource(String uri) throws RestconfException {
    ResourceId rid = convertUriToRid(uri);
    // TODO: define Filter (if there is any requirement).
    Filter filter = new Filter();
    DataNode dataNode;
    try {
        dataNode = DYNAMIC_CONFIG_SERVICE.readNode(rid, filter);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
    ObjectNode rootNode = convertDataNodeToJson(rid, dataNode);
    return rootNode;
}
#end_block

#method_before
@Override
public void runPostOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
    InputStream jsonData = convertObjectNodeToInputStream(rootNode);
    compositeStream = new DefaultCompositeStream(uri, jsonData);
    // CompositeStream --- YangRuntimeService ---> CompositeData
    compositeData = yangRuntimeService.decode(compositeStream, "json");
    // CompositeData --> ResourceData
    resourceData = compositeData.resourceData();
    ResourceId rid = resourceData.resourceId();
    List<DataNode> dataNodeList = resourceData.dataNodes();
    if (dataNodeList.size() > 1) {
        throw new RestconfException("ERROR: There are more than one Data Node can be proceed", INTERNAL_SERVER_ERROR);
    } else {
        DataNode dataNode = dataNodeList.get(0);
        try {
            dynamicConfigService.createNode(rid, dataNode);
        } catch (FailedException e) {
            log.error("ERROR: DynamicConfigService: ", e);
            throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
        }
    }
}
#method_after
@Override
public void runPostOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
    ResourceData resourceData = convertJsonToDataNode(uri, rootNode);
    ResourceId rid = resourceData.resourceId();
    List<DataNode> dataNodeList = resourceData.dataNodes();
    // TODO: Error message needs to be fixed
    if (dataNodeList.size() > 1) {
        log.warn("ERROR: There are more than one Data Node can be proceed");
    }
    DataNode dataNode = dataNodeList.get(0);
    try {
        DYNAMIC_CONFIG_SERVICE.createNode(rid, dataNode);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Override
public void runPutOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
}
#method_after
@Override
public void runPutOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
    runPostOperationOnDataResource(uri, rootNode);
}
#end_block

#method_before
@Override
public void runDeleteOperationOnDataResource(String uri) throws RestconfException {
    InputStream jsonData = null;
    compositeStream = new DefaultCompositeStream(uri, jsonData);
    // CompositeStream --- YangRuntimeService ---> CompositeData
    compositeData = yangRuntimeService.decode(compositeStream, "json");
    resourceData = compositeData.resourceData();
    ResourceId rid = resourceData.resourceId();
    // pass the rid to dynamic config service
    try {
        dynamicConfigService.deleteNode(rid);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runDeleteOperationOnDataResource(String uri) throws RestconfException {
    ResourceId rid = convertUriToRid(uri);
    try {
        DYNAMIC_CONFIG_SERVICE.deleteNode(rid);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
public boolean populateMplsRule(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSwId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    List<ForwardingObjective> fwdObjs = new ArrayList<>();
    Collection<ForwardingObjective> fwdObjsMpls;
    // Generates the transit rules used by the standard "routing".
    fwdObjsMpls = handleMpls(targetSwId, destSwId, nextHops, segmentId, true);
    if (fwdObjsMpls.isEmpty()) {
        return false;
    }
    for (ForwardingObjective fwdObj : fwdObjs) {
        log.debug("Sending MPLS fwd obj {} for SID {}-> next {} in sw: {}", fwdObj.id(), segmentId, fwdObj.nextId(), targetSwId);
        srManager.flowObjectiveService.forward(targetSwId, fwdObj);
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#method_after
public boolean populateMplsRule(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSwId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    List<ForwardingObjective> fwdObjs = new ArrayList<>();
    Collection<ForwardingObjective> fwdObjsMpls;
    // Generates the transit rules used by the standard "routing".
    fwdObjsMpls = handleMpls(targetSwId, destSwId, nextHops, segmentId, true);
    if (fwdObjsMpls.isEmpty()) {
        return false;
    }
    fwdObjs.addAll(fwdObjsMpls);
    for (ForwardingObjective fwdObj : fwdObjs) {
        log.debug("Sending MPLS fwd obj {} for SID {}-> next {} in sw: {}", fwdObj.id(), segmentId, fwdObj.nextId(), targetSwId);
        srManager.flowObjectiveService.forward(targetSwId, fwdObj);
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#end_block

#method_before
@Override
public void write(Kryo kryo, Output output, BitSet bitSet) {
    final int len = bitSet.length();
    output.writeInt(len, true);
    for (int i = 0; i < len; i++) {
        output.writeBoolean(bitSet.get(i));
    }
}
#method_after
@Override
public void write(Kryo kryo, Output output, BitSet bitSet) {
    final int len = bitSet.length();
    output.writeInt(len, true);
    byte[] bytes = bitSet.toByteArray();
    output.writeInt(bytes.length, true);
    output.writeBytes(bitSet.toByteArray());
}
#end_block

#method_before
@Override
public BitSet read(Kryo kryo, Input input, Class<BitSet> aClass) {
    final int len = input.readInt(true);
    final BitSet ret = new BitSet(len);
    for (int i = 0; i < len; i++) {
        ret.set(i, input.readBoolean());
    }
    return ret;
}
#method_after
@Override
public BitSet read(Kryo kryo, Input input, Class<BitSet> aClass) {
    final int len = input.readInt(true);
    int bytesize = input.readInt(true);
    byte[] bytes = input.readBytes(bytesize);
    return BitSet.valueOf(bytes);
}
#end_block

#method_before
@Override
public Driver parent() {
    return parents == null ? null : parents.get(0);
}
#method_after
@Override
public Driver parent() {
    return parents.isEmpty() ? null : parents.get(0);
}
#end_block

#method_before
@Override
public List<Driver> parents() {
    return parents == null ? ImmutableList.of() : parents;
}
#method_after
@Override
public List<Driver> parents() {
    return parents;
}
#end_block

#method_before
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        streamHandler = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl());
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session.", e);
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#method_after
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        streamHandler = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl(), replies);
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session.", e);
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#end_block

#method_before
@Override
@Deprecated
public CompletableFuture<String> request(String request) {
    CompletableFuture<String> ftrep = streamHandler.sendMessage(request);
    // Use the messageId from the request
    Matcher m = msgIdPattern.matcher(request);
    if (m.find()) {
        String[] split = m.group(0).split("\"");
        int messageId = Integer.valueOf(split[1]);
        replies.put(messageId, ftrep);
    }
    return ftrep;
}
#method_after
@Override
@Deprecated
public CompletableFuture<String> request(String request) {
    return streamHandler.sendMessage(request);
}
#end_block

#method_before
private CompletableFuture<String> request(String request, final int messageId) {
    CompletableFuture<String> ftrep = streamHandler.sendMessage(request);
    replies.put(messageId, ftrep);
    return ftrep;
}
#method_after
private CompletableFuture<String> request(String request, int messageId) {
    return streamHandler.sendMessage(request, messageId);
}
#end_block

#method_before
private String formatRequestMessageId(String request, final int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + String.valueOf(messageId) + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + String.valueOf(messageId) + "\"" + ">");
    }
    return request;
}
#method_after
private String formatRequestMessageId(String request, int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"" + ">");
    }
    return request;
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<String> sendMessage(String request) {
    log.debug("Sending message {} to device {}", request, netconfDeviceInfo);
    outputStream.print(request);
    outputStream.flush();
    return new CompletableFuture<>();
}
#method_after
@Override
public CompletableFuture<String> sendMessage(String request) {
    Optional<Integer> messageId = getMsgId(request);
    return sendMessage(request, messageId.get());
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<String> sendMessage(String request) {
    log.debug("Sending message {} to device {}", request, netconfDeviceInfo);
    outputStream.print(request);
    outputStream.flush();
    return new CompletableFuture<>();
}
#method_after
@Override
public CompletableFuture<String> sendMessage(String request, int messageId) {
    log.debug("Sending message {} to device {}", request, netconfDeviceInfo);
    CompletableFuture<String> cf = new CompletableFuture<>();
    replies.put(messageId, cf);
    synchronized (outputStream) {
        outputStream.print(request);
        outputStream.flush();
    }
    return cf;
}
#end_block

#method_before
public static Optional<Integer> getMsgId(String reply) {
    Matcher matcher = MSGID_PATTERN.matcher(reply);
    if (matcher.find()) {
        Integer messageId = Integer.parseInt(matcher.group(1));
        Preconditions.checkNotNull(messageId, "Error in retrieving the message id");
        return Optional.of(messageId);
    }
    if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    return Optional.empty();
}
#method_after
protected static Optional<Integer> getMsgId(String reply) {
    Matcher matcher = MSGID_PATTERN.matcher(reply);
    if (matcher.find()) {
        Integer messageId = Integer.parseInt(matcher.group(1));
        Preconditions.checkNotNull(messageId, "Error in retrieving the message id");
        return Optional.of(messageId);
    }
    if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    return Optional.empty();
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    sshServerNetconf = SshServer.setUpDefaultServer();
    List<NamedFactory<UserAuth>> userAuthFactories = new ArrayList<NamedFactory<UserAuth>>();
    // userAuthFactories.add(new UserAuthNone.Factory());
    userAuthFactories.add(new UserAuthPassword.Factory());
    sshServerNetconf.setUserAuthFactories(userAuthFactories);
    sshServerNetconf.setPasswordAuthenticator(new PasswordAuthenticator() {

        @Override
        public boolean authenticate(String username, String password, ServerSession session) {
            return TEST_USERNAME.equals(username) && TEST_PASSWORD.equals(password);
        }
    });
    sshServerNetconf.setPort(PORT_NUMBER);
    sshServerNetconf.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(TEST_SERFILE));
    sshServerNetconf.setSubsystemFactories(Arrays.<NamedFactory<Command>>asList(new NetconfSshdSubsystem.Factory()));
    sshServerNetconf.open();
    log.info("SSH Server opened on port {}", PORT_NUMBER);
    NetconfDeviceInfo deviceInfo = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    session1 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session1.getSessionId());
    assertTrue(!session1.getSessionId().equalsIgnoreCase("-1"));
    assertTrue(!session1.getSessionId().equalsIgnoreCase("0"));
    session2 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session2.getSessionId());
    assertTrue(!session2.getSessionId().equalsIgnoreCase("-1"));
    assertTrue(!session2.getSessionId().equalsIgnoreCase("0"));
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    sshServerNetconf = SshServer.setUpDefaultServer();
    List<NamedFactory<UserAuth>> userAuthFactories = new ArrayList<NamedFactory<UserAuth>>();
    userAuthFactories.add(new UserAuthPassword.Factory());
    sshServerNetconf.setUserAuthFactories(userAuthFactories);
    sshServerNetconf.setPasswordAuthenticator(new PasswordAuthenticator() {

        @Override
        public boolean authenticate(String username, String password, ServerSession session) {
            return TEST_USERNAME.equals(username) && TEST_PASSWORD.equals(password);
        }
    });
    sshServerNetconf.setPort(PORT_NUMBER);
    sshServerNetconf.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(TEST_SERFILE));
    sshServerNetconf.setSubsystemFactories(Arrays.<NamedFactory<Command>>asList(new NetconfSshdTestSubsystem.Factory()));
    sshServerNetconf.open();
    log.info("SSH Server opened on port {}", PORT_NUMBER);
    NetconfDeviceInfo deviceInfo = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    session1 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session1.getSessionId());
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("0"));
    session2 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session2.getSessionId());
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("0"));
}
#end_block

#method_before
@Test
public void testEditConfigRequest() {
    log.info("Starting edit-config async");
    assertNotNull(session1.getSessionId());
    try {
        assertTrue(session1.editConfig("running", null, SAMPLE_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail(e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#method_after
@Test
public void testEditConfigRequest() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig("running", null, SAMPLE_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#end_block

#method_before
@Test
public void testCopyConfigRequest() {
    log.info("Starting copy-config async");
    assertNotNull(session1.getSessionId());
    try {
        assertTrue(session1.copyConfig("running", "candidate"));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail(e.getMessage());
    }
    log.info("Finishing copy-config async");
}
#method_after
@Test
public void testCopyConfigRequest() {
    log.info("Starting copy-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.copyConfig("running", "candidate"));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing copy-config async");
}
#end_block

#method_before
@Test
public void testConcurrentSameSessionAccess() {
    NCCopyConfigCallable testCopyConfig1 = new NCCopyConfigCallable(session1, "running", "candidate");
    NCCopyConfigCallable testCopyConfig2 = new NCCopyConfigCallable(session1, "candidate", "startup");
    FutureTask<Boolean> futureCopyConfig1 = new FutureTask<Boolean>(testCopyConfig1);
    FutureTask<Boolean> futureCopyConfig2 = new FutureTask<Boolean>(testCopyConfig2);
    ExecutorService executor = Executors.newFixedThreadPool(2);
    log.info("Starting concurrent execution of copy-config through same session");
    executor.execute(futureCopyConfig1);
    executor.execute(futureCopyConfig2);
    while (true) {
        if (futureCopyConfig1.isDone() && futureCopyConfig2.isDone()) {
            executor.shutdown();
            log.info("Finished concurrent same session execution");
            return;
        }
    }
}
#method_after
@Test
public void testConcurrentSameSessionAccess() throws InterruptedException {
    NCCopyConfigCallable testCopyConfig1 = new NCCopyConfigCallable(session1, "running", "candidate");
    NCCopyConfigCallable testCopyConfig2 = new NCCopyConfigCallable(session1, "candidate", "startup");
    FutureTask<Boolean> futureCopyConfig1 = new FutureTask<Boolean>(testCopyConfig1);
    FutureTask<Boolean> futureCopyConfig2 = new FutureTask<Boolean>(testCopyConfig2);
    ExecutorService executor = Executors.newFixedThreadPool(2);
    log.info("Starting concurrent execution of copy-config through same session");
    executor.execute(futureCopyConfig1);
    executor.execute(futureCopyConfig2);
    int count = 0;
    while (count < 10) {
        if (futureCopyConfig1.isDone() && futureCopyConfig2.isDone()) {
            executor.shutdown();
            log.info("Finished concurrent same session execution");
            return;
        }
        Thread.sleep(100L);
        count++;
    }
    fail("NETCONF test failed to complete.");
}
#end_block

#method_before
@Test
public void test2SessionAccess() {
    NCCopyConfigCallable testCopySession1 = new NCCopyConfigCallable(session1, "running", "candidate");
    NCCopyConfigCallable testCopySession2 = new NCCopyConfigCallable(session2, "running", "candidate");
    FutureTask<Boolean> futureCopySession1 = new FutureTask<Boolean>(testCopySession1);
    FutureTask<Boolean> futureCopySession2 = new FutureTask<Boolean>(testCopySession2);
    ExecutorService executor = Executors.newFixedThreadPool(2);
    log.info("Starting concurrent execution of copy-config through 2 different sessions");
    executor.execute(futureCopySession1);
    executor.execute(futureCopySession2);
    while (true) {
        if (futureCopySession1.isDone() && futureCopySession2.isDone()) {
            executor.shutdown();
            log.info("Finished concurrent 2 session execution");
            return;
        }
    }
}
#method_after
@Test
public void test2SessionAccess() throws InterruptedException {
    NCCopyConfigCallable testCopySession1 = new NCCopyConfigCallable(session1, "running", "candidate");
    NCCopyConfigCallable testCopySession2 = new NCCopyConfigCallable(session2, "running", "candidate");
    FutureTask<Boolean> futureCopySession1 = new FutureTask<Boolean>(testCopySession1);
    FutureTask<Boolean> futureCopySession2 = new FutureTask<Boolean>(testCopySession2);
    ExecutorService executor = Executors.newFixedThreadPool(2);
    log.info("Starting concurrent execution of copy-config through 2 different sessions");
    executor.execute(futureCopySession1);
    executor.execute(futureCopySession2);
    int count = 0;
    while (count < 10) {
        if (futureCopySession1.isDone() && futureCopySession2.isDone()) {
            executor.shutdown();
            log.info("Finished concurrent 2 session execution");
            return;
        }
        Thread.sleep(100L);
        count++;
    }
    fail("NETCONF test failed to complete.");
}
#end_block

#method_before
public FlowEntry build(FlowEntryState... state) {
    FlowRule.Builder builder;
    try {
        switch(this.type) {
            case STAT:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).makeTemporary(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
                if (stat.getVersion() != OFVersion.OF_10) {
                    builder.forTable(stat.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(stat.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(stat.getDurationSec()) + stat.getDurationNsec(), NANOSECONDS, liveType, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                }
            case REMOVED:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).makeTemporary(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue()).withReason(FlowRule.FlowRemoveReason.parseShort(removed.getReason()));
                if (removed.getVersion() != OFVersion.OF_10) {
                    builder.forTable(removed.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(removed.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(removed.getDurationSec()) + removed.getDurationNsec(), NANOSECONDS, liveType, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                }
            case MOD:
                FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).makeTemporary(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue());
                if (flowMod.getVersion() != OFVersion.OF_10) {
                    builder.forTable(flowMod.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = FlowEntry.FlowLiveType.IMMEDIATE;
                    return new DefaultFlowEntry(builder.build(), flowState, 0, liveType, 0, 0);
                } else {
                    return new DefaultFlowEntry(builder.build(), flowState, 0, 0, 0);
                }
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#method_after
public FlowEntry build(FlowEntryState... state) {
    FlowRule.Builder builder;
    try {
        switch(this.type) {
            case STAT:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).withIdleTimeout(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
                if (stat.getVersion() != OFVersion.OF_10) {
                    builder.forTable(stat.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(stat.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(stat.getDurationSec()) + stat.getDurationNsec(), NANOSECONDS, liveType, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                }
            case REMOVED:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).withIdleTimeout(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue()).withReason(FlowRule.FlowRemoveReason.parseShort(removed.getReason()));
                if (removed.getVersion() != OFVersion.OF_10) {
                    builder.forTable(removed.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(removed.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(removed.getDurationSec()) + removed.getDurationNsec(), NANOSECONDS, liveType, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                }
            case MOD:
                FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).withIdleTimeout(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue());
                if (flowMod.getVersion() != OFVersion.OF_10) {
                    builder.forTable(flowMod.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = FlowEntry.FlowLiveType.IMMEDIATE;
                    return new DefaultFlowEntry(builder.build(), flowState, 0, liveType, 0, 0);
                } else {
                    return new DefaultFlowEntry(builder.build(), flowState, 0, 0, 0);
                }
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#end_block

#method_before
@Override
public void requestPackets(NetworkId networkId, PacketRequest request) {
    requests.computeIfAbsent(networkId, k -> Maps.newConcurrentMap());
    requests.get(networkId).compute(request.selector(), (s, existingRequests) -> {
        if (existingRequests == null) {
            return ImmutableSet.of(request);
        } else if (!existingRequests.contains(request)) {
            if (hasDelegate(networkId)) {
                delegateMap.get(networkId).requestPackets(request);
            }
            return ImmutableSet.<PacketRequest>builder().addAll(existingRequests).add(request).build();
        } else {
            return existingRequests;
        }
    });
}
#method_after
@Override
public void requestPackets(NetworkId networkId, PacketRequest request) {
    requests.computeIfAbsent(networkId, k -> Maps.newConcurrentMap());
    requests.get(networkId).compute(request.selector(), (s, existingRequests) -> {
        if (existingRequests == null) {
            if (hasDelegate(networkId)) {
                delegateMap.get(networkId).requestPackets(request);
            }
            return ImmutableSet.of(request);
        } else if (!existingRequests.contains(request)) {
            if (hasDelegate(networkId)) {
                delegateMap.get(networkId).requestPackets(request);
            }
            return ImmutableSet.<PacketRequest>builder().addAll(existingRequests).add(request).build();
        } else {
            return existingRequests;
        }
    });
}
#end_block

#method_before
@Override
public void cancelPackets(NetworkId networkId, PacketRequest request) {
    requests.get(networkId).computeIfPresent(request.selector(), (s, existingRequests) -> {
        if (existingRequests.contains(request)) {
            HashSet<PacketRequest> newRequests = Sets.newHashSet(existingRequests);
            newRequests.remove(request);
            if (newRequests.size() > 0) {
                return ImmutableSet.copyOf(newRequests);
            } else {
                if (hasDelegate(networkId)) {
                    delegateMap.get(networkId).cancelPackets(request);
                }
                return null;
            }
        } else {
            return existingRequests;
        }
    });
}
#method_after
@Override
public void cancelPackets(NetworkId networkId, PacketRequest request) {
    requests.get(networkId).computeIfPresent(request.selector(), (s, existingRequests) -> {
        if (existingRequests.contains(request)) {
            HashSet<PacketRequest> newRequests = Sets.newHashSet(existingRequests);
            newRequests.remove(request);
            if (hasDelegate(networkId)) {
                delegateMap.get(networkId).cancelPackets(request);
            }
            if (newRequests.size() > 0) {
                return ImmutableSet.copyOf(newRequests);
            } else {
                return null;
            }
        } else {
            return existingRequests;
        }
    });
}
#end_block

#method_before
private void setProperties(Analyzer analyzer) {
    analyzer.setProperty(Analyzer.BUNDLE_NAME, bundleName);
    analyzer.setProperty(Analyzer.BUNDLE_SYMBOLICNAME, bundleSymbolicName);
    analyzer.setProperty(Analyzer.BUNDLE_VERSION, bundleVersion.replace('-', '.'));
    if (bundleDescription != null) {
        analyzer.setProperty(Analyzer.BUNDLE_DESCRIPTION, bundleDescription);
    }
    if (bundleLicense != null) {
        analyzer.setProperty(Analyzer.BUNDLE_LICENSE, bundleLicense);
    }
    // TODO consider using stricter version policy
    // analyzer.setProperty("-provider-policy", "${range;[===,==+)}");
    // analyzer.setProperty("-consumer-policy", "${range;[===,==+)}");
    // There are no good defaults so make sure you set the Import-Package
    analyzer.setProperty(Analyzer.IMPORT_PACKAGE, importPackages);
    analyzer.setProperty(Analyzer.PRIVATE_PACKAGE, privatePackages);
    analyzer.setProperty(Analyzer.REMOVEHEADERS, "Private-Package,Include-Resource");
    analyzer.setProperty(Analyzer.DYNAMICIMPORT_PACKAGE, dynamicimportPackages);
    // TODO we may need INCLUDE_RESOURCE, or that might be done by Buck
    if (includeResources != null) {
        analyzer.setProperty(Analyzer.INCLUDE_RESOURCE, includeResources);
    }
    if (isWab()) {
        analyzer.setProperty(Analyzer.WAB, "src/main/webapp/");
        analyzer.setProperty("Web-ContextPath", webContext);
        analyzer.setProperty(Analyzer.IMPORT_PACKAGE, "*,org.glassfish.jersey.servlet,org.jvnet.mimepull\n");
    }
}
#method_after
private void setProperties(Analyzer analyzer) {
    analyzer.setProperty(Analyzer.BUNDLE_NAME, bundleName);
    analyzer.setProperty(Analyzer.BUNDLE_SYMBOLICNAME, bundleSymbolicName);
    analyzer.setProperty(Analyzer.BUNDLE_VERSION, bundleVersion.replace('-', '.'));
    if (bundleDescription != null) {
        analyzer.setProperty(Analyzer.BUNDLE_DESCRIPTION, bundleDescription);
    }
    if (bundleLicense != null) {
        analyzer.setProperty(Analyzer.BUNDLE_LICENSE, bundleLicense);
    }
    // TODO consider using stricter version policy
    // analyzer.setProperty("-provider-policy", "${range;[===,==+)}");
    // analyzer.setProperty("-consumer-policy", "${range;[===,==+)}");
    // There are no good defaults so make sure you set the Import-Package
    analyzer.setProperty(Analyzer.IMPORT_PACKAGE, importPackages);
    if (privatePackages != null) {
        analyzer.setProperty(Analyzer.PRIVATE_PACKAGE, privatePackages);
    }
    analyzer.setProperty(Analyzer.REMOVEHEADERS, "Private-Package,Include-Resource");
    analyzer.setProperty(Analyzer.DYNAMICIMPORT_PACKAGE, dynamicimportPackages);
    // TODO we may need INCLUDE_RESOURCE, or that might be done by Buck
    if (includeResources != null) {
        analyzer.setProperty(Analyzer.INCLUDE_RESOURCE, includeResources);
    }
    if (isWab()) {
        analyzer.setProperty(Analyzer.WAB, "src/main/webapp/");
        analyzer.setProperty("Web-ContextPath", webContext);
        analyzer.setProperty(Analyzer.IMPORT_PACKAGE, "*,org.glassfish.jersey.servlet,org.jvnet.mimepull\n");
    }
}
#end_block

#method_before
public boolean execute() {
    Builder analyzer = new Builder();
    try {
        // where our data is
        Jar jar = new Jar(inputJar.toFile());
        // give bnd the contents
        analyzer.setJar(jar);
        // You can provide additional class path entries to allow
        // bnd to pickup export version from the packageinfo file,
        // Version annotation, or their manifests.
        analyzer.addClasspath(classpath);
        setProperties(analyzer);
        // analyzer.setBase(classesDir.toFile());
        // analyzer.setProperty("DESTDIR");
        // analyzer.setBase();
        // ------------- let's begin... -------------------------
        // Analyze the target JAR first
        addLocalPackages(new File(classesDir.toString()), analyzer);
        // analyzer.analyze();
        // Scan the JAR for Felix SCR annotations and generate XML files
        Map<String, String> properties = Maps.newHashMap();
        properties.put("destdir", classesDir.toAbsolutePath().toString());
        SCRDescriptorBndPlugin scrDescriptorBndPlugin = new SCRDescriptorBndPlugin();
        scrDescriptorBndPlugin.setProperties(properties);
        scrDescriptorBndPlugin.setReporter(analyzer);
        scrDescriptorBndPlugin.analyzeJar(analyzer);
        if (includeResources != null) {
            doIncludeResources(analyzer);
        }
        // Repack the JAR as a WAR
        doWabStaging(analyzer);
        if (analyzer.isOk()) {
            analyzer.build();
            Manifest manifest = analyzer.calcManifest();
            analyzer.getJar().setManifest(manifest);
            if (analyzer.save(outputJar.toFile(), true)) {
                log("Saved!\n");
            } else {
                warn("Failed to create jar \n");
                return false;
            }
        } else {
            warn("Analyzer Errors:\n%s\n", analyzer.getErrors());
            return false;
        }
        analyzer.close();
        return true;
    } catch (Exception e) {
        e.printStackTrace();
        return false;
    }
}
#method_after
public boolean execute() {
    Builder analyzer = new Builder();
    try {
        // where our data is
        Jar jar = new Jar(inputJar.toFile());
        // give bnd the contents
        analyzer.setJar(jar);
        // You can provide additional class path entries to allow
        // bnd to pickup export version from the packageinfo file,
        // Version annotation, or their manifests.
        analyzer.addClasspath(classpath);
        setProperties(analyzer);
        // analyzer.setBase(classesDir.toFile());
        // analyzer.setProperty("DESTDIR");
        // analyzer.setBase();
        // ------------- let's begin... -------------------------
        // Add local packges to jar file.
        addLocalPackages(new File(classesDir.toString()), analyzer);
        // add resources.
        if (includeResources != null) {
            doIncludeResources(analyzer);
        }
        // Repack the JAR as a WAR
        doWabStaging(analyzer);
        if (analyzer.isOk()) {
            // Build the jar files
            analyzer.build();
            Map<String, String> properties = Maps.newHashMap();
            // Scan the JAR for Felix SCR annotations and generate XML files
            properties.put("destdir", classesDir.toAbsolutePath().toString());
            SCRDescriptorBndPlugin scrDescriptorBndPlugin = new SCRDescriptorBndPlugin();
            scrDescriptorBndPlugin.setProperties(properties);
            scrDescriptorBndPlugin.setReporter(analyzer);
            scrDescriptorBndPlugin.analyzeJar(analyzer);
            // add calculated manifest file.
            Manifest manifest = analyzer.calcManifest();
            analyzer.getJar().setManifest(manifest);
            if (analyzer.save(outputJar.toFile(), true)) {
                log("Saved!\n");
            } else {
                warn("Failed to create jar \n");
                return false;
            }
        } else {
            warn("Analyzer Errors:\n%s\n", analyzer.getErrors());
            return false;
        }
        analyzer.close();
        return true;
    } catch (Exception e) {
        e.printStackTrace();
        return false;
    }
}
#end_block

#method_before
private void handleRemoveRequest(DeviceId did) {
    try {
        DeviceEvent event = removeDevice(did);
        if (event != null) {
            log.info("Device {} administratively removed", did);
            notifyDelegateIfNotNull(event);
        }
    } catch (Exception e) {
        log.warn("Exception thrown handling device remove", e);
    }
}
#method_after
private void handleRemoveRequest(DeviceId did) {
    try {
        DeviceEvent event = removeDevice(did);
        notifyDelegateIfNotNull(event);
    } catch (Exception e) {
        log.warn("Exception thrown handling device remove", e);
    }
}
#end_block

#method_before
@Override
public void exitDataNode(DataNode dataNode) {
    if (!elementStack.isEmpty() && elementStack.peek().equals(rootElement)) {
        xmlData = xmlData + rootElement.asXML();
    }
    if (!isRootDataNode(dataNode)) {
        elementStack.pop();
        rIdBuilder.traverseToParent();
    }
}
#method_after
@Override
public void exitDataNode(DataNode dataNode) {
    if (!elementStack.isEmpty() && elementStack.peek().equals(rootElement)) {
        xmlData = xmlData + rootElement.asXML();
    }
    if (!isRootDataNode(dataNode)) {
        elementStack.pop();
        rIdBuilder.removeLastKey();
    }
}
#end_block

#method_before
private void handleReportMessage(int srpId, PcepLspObject lspObj, PcepStateReport stateRpt) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepTunnelData pcepTunnelData = pcepTunnelApiMapper.getDataFromTunnelRequestQueue(srpId);
    // store the values required from report message
    pcepTunnelData.setPlspId(lspObj.getPlspId());
    pcepTunnelData.setLspAFlag(lspObj.getAFlag());
    pcepTunnelData.setLspOFlag(lspObj.getOFlag());
    pcepTunnelData.setLspDFlag(lspObj.getDFlag());
    StatefulIPv4LspIdentifiersTlv ipv4LspTlv = null;
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        if (tlv.getType() == StatefulIPv4LspIdentifiersTlv.TYPE) {
            ipv4LspTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
            break;
        }
    }
    if (ipv4LspTlv != null) {
        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspTlv);
    }
    Path path = pcepTunnelData.path();
    Tunnel tunnel = pcepTunnelData.tunnel();
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.putAll(pcepTunnelData.tunnel().annotations());
    // PCRpt in response to PCInitate msg will carry PLSP id allocated by PCC.
    if (tunnel.annotations().value(PLSP_ID) == null) {
        annotationBuilder.set(PLSP_ID, String.valueOf(lspObj.getPlspId()));
    }
    // Signalled LSPs will carry local LSP id allocated by signalling protocol(PCC).
    if (tunnel.annotations().value(LOCAL_LSP_ID) == null) {
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(ipv4LspTlv.getLspId()));
    }
    if (tunnel.annotations().value(PCC_TUNNEL_ID) == null) {
        annotationBuilder.set(PCC_TUNNEL_ID, String.valueOf(ipv4LspTlv.getTunnelId()));
    }
    SparseAnnotations annotations = annotationBuilder.build();
    DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, tunnel.resource(), annotations);
    if (CREATE == pcepTunnelData.requestType()) {
        pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        pcepTunnelApiMapper.handleCreateTunnelRequestQueue(srpId, pcepTunnelData);
    } else if (DELETE == pcepTunnelData.requestType()) {
        pcepTunnelApiMapper.handleRemoveFromTunnelRequestQueue(srpId, pcepTunnelData);
    } else if (UPDATE == pcepTunnelData.requestType()) {
        pcepTunnelData.setRptFlag(true);
        pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        pcepTunnelApiMapper.handleUpdateTunnelRequestQueue(srpId, pcepTunnelData);
    }
    PcepLspStatus pcepLspStatus = PcepLspStatus.values()[lspObj.getOFlag()];
    if (lspObj.getRFlag()) {
        tunnelRemoved(td);
    } else {
        State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(pcepLspStatus);
        tunnelUpdated(td, tunnelState);
    }
    // though there are no labels to download for SR-TE.
    if (((pcepLspStatus == PcepLspStatus.GOING_UP) && (LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)) == SR_WITHOUT_SIGNALLING)) || // For PCInit tunnel up, few PCC expects PCUpd message after PCInit message,
    ((tunnel.state() == State.INIT) && (pcepLspStatus == PcepLspStatus.DOWN) && (tunnel.annotations().value(PCE_INIT) != null && tunnel.annotations().value(PCE_INIT).equals("true")))) {
        // Query again to get latest tunnel updated with protocol values from PCRpt msg.
        updateTunnel(service.tunnelQueryById(tunnel.tunnelId()), tunnel.path());
    }
}
#method_after
private void handleReportMessage(int srpId, PcepLspObject lspObj, PcepStateReport stateRpt) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepTunnelData pcepTunnelData = pcepTunnelApiMapper.getDataFromTunnelRequestQueue(srpId);
    // store the values required from report message
    pcepTunnelData.setPlspId(lspObj.getPlspId());
    pcepTunnelData.setLspAFlag(lspObj.getAFlag());
    pcepTunnelData.setLspOFlag(lspObj.getOFlag());
    pcepTunnelData.setLspDFlag(lspObj.getDFlag());
    StatefulIPv4LspIdentifiersTlv ipv4LspTlv = null;
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        if (tlv.getType() == StatefulIPv4LspIdentifiersTlv.TYPE) {
            ipv4LspTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
            break;
        }
    }
    if (ipv4LspTlv != null) {
        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspTlv);
    }
    Path path = pcepTunnelData.path();
    Tunnel tunnel = pcepTunnelData.tunnel();
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.putAll(pcepTunnelData.tunnel().annotations());
    // PCRpt in response to PCInitate msg will carry PLSP id allocated by PCC.
    if (tunnel.annotations().value(PLSP_ID) == null) {
        annotationBuilder.set(PLSP_ID, String.valueOf(lspObj.getPlspId()));
    }
    // Signalled LSPs will carry local LSP id allocated by signalling protocol(PCC).
    if (tunnel.annotations().value(LOCAL_LSP_ID) == null) {
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(ipv4LspTlv.getLspId()));
    }
    if (tunnel.annotations().value(PCC_TUNNEL_ID) == null) {
        annotationBuilder.set(PCC_TUNNEL_ID, String.valueOf(ipv4LspTlv.getTunnelId()));
    }
    SparseAnnotations annotations = annotationBuilder.build();
    DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, tunnel.resource(), annotations);
    if (CREATE == pcepTunnelData.requestType()) {
        pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        pcepTunnelApiMapper.handleCreateTunnelRequestQueue(srpId, pcepTunnelData);
    } else if (DELETE == pcepTunnelData.requestType()) {
        pcepTunnelApiMapper.handleRemoveFromTunnelRequestQueue(srpId, pcepTunnelData);
    } else if (UPDATE == pcepTunnelData.requestType()) {
        pcepTunnelData.setRptFlag(true);
        pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        pcepTunnelApiMapper.handleUpdateTunnelRequestQueue(srpId, pcepTunnelData);
    }
    PcepLspStatus pcepLspStatus = PcepLspStatus.values()[lspObj.getOFlag()];
    if (lspObj.getRFlag()) {
        tunnelRemoved(td);
    } else {
        State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(pcepLspStatus);
        tunnelUpdated(td, tunnelState);
    }
    // though there are no labels to download for SR-TE.
    if (((pcepLspStatus == PcepLspStatus.GOING_UP) && (LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)) == SR_WITHOUT_SIGNALLING)) || // For PCInit tunnel up, few PCC expects PCUpd message after PCInit message,
    ((tunnel.state() == State.INIT) && (pcepLspStatus == PcepLspStatus.DOWN) && (tunnel.annotations().value(PCE_INIT) != null && tunnel.annotations().value(PCE_INIT).equals("true")) && (LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)) == WITH_SIGNALLING))) {
        // Query again to get latest tunnel updated with protocol values from PCRpt msg.
        updateTunnel(service.tunnelQueryById(tunnel.tunnelId()), tunnel.path());
    }
}
#end_block

#method_before
@Override
public void hostDetected(HostId hostId, HostDescription hostDescription, boolean replaceIps) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    hostDescription = validateHost(hostDescription, hostId);
    Host existingHost = store.getHost(hostId);
    // Disallow overriding existing, configured hosts
    if (existingHost != null && existingHost.configured()) {
        return;
    }
    if (!allowDuplicateIps) {
        removeDuplicates(hostId, hostDescription);
    }
    store.createOrUpdateHost(provider().id(), hostId, hostDescription, replaceIps);
    if (monitorHosts) {
        hostDescription.ipAddress().forEach(ip -> {
            monitor.addMonitoringFor(ip);
        });
    }
    // overwrite the learnt information with the configured informations.
    if (greedyLearningIpv6) {
        // Auto-generation of the IPv6 link local address
        // using the mac address
        Ip6Address targetIp6Address = Ip6Address.valueOf(getLinkLocalAddress(hostId.mac().toBytes()));
        // If we already know this guy we don't need to do other
        if (!hostDescription.ipAddress().contains(targetIp6Address)) {
            Host host = store.getHost(hostId);
            // Configured host, skip it.
            if (host != null && host.configured()) {
                return;
            }
            // Host does not exist in the store or the target is not known
            if ((host == null || !host.ipAddresses().contains(targetIp6Address))) {
                // We generate ONOS ip from the ONOS default mac
                // We could use the mac generated for the link
                // discovery but maybe does not worth
                MacAddress onosMacAddress = MacAddress.valueOf(DEFAULT_MAC);
                Ip6Address onosIp6Address = Ip6Address.valueOf(getLinkLocalAddress(onosMacAddress.toBytes()));
                // We send a probe using the monitoring service
                monitor.sendProbe(hostDescription.location(), targetIp6Address, onosIp6Address, onosMacAddress, hostId.vlanId());
            }
        }
    }
}
#method_after
@Override
public void hostDetected(HostId hostId, HostDescription hostDescription, boolean replaceIps) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    hostDescription = validateHost(hostDescription, hostId);
    if (!allowDuplicateIps) {
        removeDuplicates(hostId, hostDescription);
    }
    store.createOrUpdateHost(provider().id(), hostId, hostDescription, replaceIps);
    if (monitorHosts) {
        hostDescription.ipAddress().forEach(ip -> {
            monitor.addMonitoringFor(ip);
        });
    }
    // overwrite the learnt information with the configured informations.
    if (greedyLearningIpv6) {
        // Auto-generation of the IPv6 link local address
        // using the mac address
        Ip6Address targetIp6Address = Ip6Address.valueOf(getLinkLocalAddress(hostId.mac().toBytes()));
        // If we already know this guy we don't need to do other
        if (!hostDescription.ipAddress().contains(targetIp6Address)) {
            Host host = store.getHost(hostId);
            // Configured host, skip it.
            if (host != null && host.configured()) {
                return;
            }
            // Host does not exist in the store or the target is not known
            if ((host == null || !host.ipAddresses().contains(targetIp6Address))) {
                // We generate ONOS ip from the ONOS default mac
                // We could use the mac generated for the link
                // discovery but maybe does not worth
                MacAddress onosMacAddress = MacAddress.valueOf(DEFAULT_MAC);
                Ip6Address onosIp6Address = Ip6Address.valueOf(getLinkLocalAddress(onosMacAddress.toBytes()));
                // We send a probe using the monitoring service
                monitor.sendProbe(hostDescription.location(), targetIp6Address, onosIp6Address, onosMacAddress, hostId.vlanId());
            }
        }
    }
}
#end_block

#method_before
private void createFlowObjectives(CarrierEthernetForwardingConstruct fc, CarrierEthernetNetworkInterface ingressNi, Set<CarrierEthernetNetworkInterface> egressNiSet) {
    // ///////////////////////////////////////
    // Prepare and submit filtering objective
    // ///////////////////////////////////////
    FilteringObjective.Builder filteringObjectiveBuilder = DefaultFilteringObjective.builder().permit().fromApp(appId).withPriority(PRIORITY).withKey(Criteria.matchInPort(ingressNi.cp().port()));
    TrafficTreatment.Builder filterTreatmentBuilder = DefaultTrafficTreatment.builder();
    // In general, nodes would match on the VLAN tag assigned to the EVC/FC
    Criterion filterVlanIdCriterion = Criteria.matchVlanId(fc.vlanId());
    if ((ingressNi.type().equals(CarrierEthernetNetworkInterface.Type.INNI)) || (ingressNi.type().equals(CarrierEthernetNetworkInterface.Type.ENNI))) {
        // TODO: Check TPID? Also: Is is possible to receive untagged pkts at an INNI/ENNI?
        // Source node of an FC should match on S-TAG if it's an INNI/ENNI
        filterVlanIdCriterion = Criteria.matchVlanId(ingressNi.sVlanId());
        // Translate S-TAG to the one used in the current FC
        filterTreatmentBuilder.setVlanId(fc.vlanId());
    } else if (ingressNi.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
        // Source node of an FC should match on CE-VLAN ID (if present) if it's a UNI
        filterVlanIdCriterion = Criteria.matchVlanId(ingressNi.ceVlanId());
        // Obtain related Meter (if it exists) and add it in the treatment in case it may be used
        deviceMeterIdMap.get(fc.id()).forEach(deviceMeterId -> {
            if (deviceMeterId.deviceId().equals(ingressNi.cp().deviceId())) {
                filterTreatmentBuilder.meter(deviceMeterId.meterId());
            }
        });
        // Push S-TAG of current FC on top of existing CE-VLAN ID
        filterTreatmentBuilder.pushVlan(EtherType.QINQ.ethType()).setVlanId(fc.vlanId());
    }
    filteringObjectiveBuilder.addCondition(filterVlanIdCriterion);
    // Do not add meta if there are no instructions (i.e. if not first)
    if (!(ingressNi.type().equals(CarrierEthernetNetworkInterface.Type.GENERIC))) {
        filteringObjectiveBuilder.withMeta(filterTreatmentBuilder.build());
    }
    flowObjectiveService.filter(ingressNi.cp().deviceId(), filteringObjectiveBuilder.add());
    flowObjectiveMap.get(fc.id()).addFirst(Pair.of(ingressNi.cp().deviceId(), filteringObjectiveBuilder.add()));
    // //////////////////////////////////////////////////
    // Prepare and submit next and forwarding objectives
    // //////////////////////////////////////////////////
    TrafficSelector fwdSelector = DefaultTrafficSelector.builder().matchVlanId(fc.vlanId()).matchInPort(ingressNi.cp().port()).build();
    Integer nextId = flowObjectiveService.allocateNextId();
    NextObjective.Type nextType = egressNiSet.size() == 1 ? NextObjective.Type.SIMPLE : NextObjective.Type.BROADCAST;
    // Setting higher priority to fwd/next objectives to bypass filter in case of match conflict in OVS switches
    NextObjective.Builder nextObjectiveBuider = DefaultNextObjective.builder().fromApp(appId).makePermanent().withType(nextType).withPriority(PRIORITY + 1).withMeta(fwdSelector).withId(nextId);
    egressNiSet.forEach(egressNi -> {
        // TODO: Check if ingressNi and egressNi are on the same device?
        TrafficTreatment.Builder nextTreatmentBuilder = DefaultTrafficTreatment.builder();
        // keep the existing S-TAG - it will be translated at the entrance of the next FC
        if (egressNi.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
            nextTreatmentBuilder.popVlan();
        }
        Instruction outInstruction = Instructions.createOutput(egressNi.cp().port());
        nextTreatmentBuilder.add(outInstruction);
        nextObjectiveBuider.addTreatment(nextTreatmentBuilder.build());
    });
    NextObjective nextObjective = nextObjectiveBuider.add();
    // Setting higher priority to fwd/next objectives to bypass filter in case of match conflict in OVS switches
    ForwardingObjective forwardingObjective = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY + 1).withSelector(fwdSelector).nextStep(nextId).add();
    flowObjectiveService.next(ingressNi.cp().deviceId(), nextObjective);
    // Add all NextObjectives at the end of the list so that they will be removed last
    flowObjectiveMap.get(fc.id()).addLast(Pair.of(ingressNi.cp().deviceId(), nextObjective));
    flowObjectiveService.forward(ingressNi.cp().deviceId(), forwardingObjective);
    flowObjectiveMap.get(fc.id()).addFirst(Pair.of(ingressNi.cp().deviceId(), forwardingObjective));
}
#method_after
private void createFlowObjectives(CarrierEthernetForwardingConstruct fc, CarrierEthernetNetworkInterface ingressNi, Set<CarrierEthernetNetworkInterface> egressNiSet) {
    // ///////////////////////////////////////
    // Prepare and submit filtering objective
    // ///////////////////////////////////////
    FilteringObjective.Builder filteringObjectiveBuilder = DefaultFilteringObjective.builder().permit().fromApp(appId).withPriority(PRIORITY).withKey(Criteria.matchInPort(ingressNi.cp().port()));
    TrafficTreatment.Builder filterTreatmentBuilder = DefaultTrafficTreatment.builder();
    // In general, nodes would match on the VLAN tag assigned to the EVC/FC
    Criterion filterVlanIdCriterion = Criteria.matchVlanId(fc.vlanId());
    if ((ingressNi.type().equals(CarrierEthernetNetworkInterface.Type.INNI)) || (ingressNi.type().equals(CarrierEthernetNetworkInterface.Type.ENNI))) {
        // TODO: Check TPID? Also: Is is possible to receive untagged pkts at an INNI/ENNI?
        // Source node of an FC should match on S-TAG if it's an INNI/ENNI
        filterVlanIdCriterion = Criteria.matchVlanId(ingressNi.sVlanId());
        // Translate S-TAG to the one used in the current FC
        filterTreatmentBuilder.setVlanId(fc.vlanId());
    } else if (ingressNi.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
        // Source node of an FC should match on CE-VLAN ID (if present) if it's a UNI
        filterVlanIdCriterion = Criteria.matchVlanId(ingressNi.ceVlanId());
        // Obtain related Meter (if it exists) and add it in the treatment in case it may be used
        deviceMeterIdMap.get(fc.id()).forEach(deviceMeterId -> {
            if (deviceMeterId.deviceId().equals(ingressNi.cp().deviceId())) {
                filterTreatmentBuilder.meter(deviceMeterId.meterId());
            }
        });
        // otherwise push it on as a C-tag
        if (ingressNi.ceVlanId() != null && ingressNi.ceVlanId() != VlanId.NONE) {
            filterTreatmentBuilder.pushVlan(EtherType.QINQ.ethType()).setVlanId(fc.vlanId());
        } else {
            filterTreatmentBuilder.pushVlan().setVlanId(fc.vlanId());
        }
    }
    filteringObjectiveBuilder.addCondition(filterVlanIdCriterion);
    // Do not add meta if there are no instructions (i.e. if not first)
    if (!(ingressNi.type().equals(CarrierEthernetNetworkInterface.Type.GENERIC))) {
        filteringObjectiveBuilder.withMeta(filterTreatmentBuilder.build());
    }
    flowObjectiveService.filter(ingressNi.cp().deviceId(), filteringObjectiveBuilder.add());
    flowObjectiveMap.get(fc.id()).addFirst(Pair.of(ingressNi.cp().deviceId(), filteringObjectiveBuilder.add()));
    // //////////////////////////////////////////////////
    // Prepare and submit next and forwarding objectives
    // //////////////////////////////////////////////////
    TrafficSelector fwdSelector = DefaultTrafficSelector.builder().matchVlanId(fc.vlanId()).matchInPort(ingressNi.cp().port()).build();
    Integer nextId = flowObjectiveService.allocateNextId();
    NextObjective.Type nextType = egressNiSet.size() == 1 ? NextObjective.Type.SIMPLE : NextObjective.Type.BROADCAST;
    // Setting higher priority to fwd/next objectives to bypass filter in case of match conflict in OVS switches
    NextObjective.Builder nextObjectiveBuider = DefaultNextObjective.builder().fromApp(appId).makePermanent().withType(nextType).withPriority(PRIORITY + 1).withMeta(fwdSelector).withId(nextId);
    egressNiSet.forEach(egressNi -> {
        // TODO: Check if ingressNi and egressNi are on the same device?
        TrafficTreatment.Builder nextTreatmentBuilder = DefaultTrafficTreatment.builder();
        // keep the existing S-TAG - it will be translated at the entrance of the next FC
        if (egressNi.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
            nextTreatmentBuilder.popVlan();
        }
        Instruction outInstruction = Instructions.createOutput(egressNi.cp().port());
        nextTreatmentBuilder.add(outInstruction);
        nextObjectiveBuider.addTreatment(nextTreatmentBuilder.build());
    });
    NextObjective nextObjective = nextObjectiveBuider.add();
    // Setting higher priority to fwd/next objectives to bypass filter in case of match conflict in OVS switches
    ForwardingObjective forwardingObjective = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY + 1).withSelector(fwdSelector).nextStep(nextId).add();
    flowObjectiveService.next(ingressNi.cp().deviceId(), nextObjective);
    // Add all NextObjectives at the end of the list so that they will be removed last
    flowObjectiveMap.get(fc.id()).addLast(Pair.of(ingressNi.cp().deviceId(), nextObjective));
    flowObjectiveService.forward(ingressNi.cp().deviceId(), forwardingObjective);
    flowObjectiveMap.get(fc.id()).addFirst(Pair.of(ingressNi.cp().deviceId(), forwardingObjective));
}
#end_block

#method_before
@Override
public void handleOutgoingMessage(LispRouterId routerId, LispMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(routerId.toString());
    switch(msg.getType()) {
        case LISP_MAP_REPLY:
            LispMapReply reply = (LispMapReply) msg;
            reply.getMapRecords().forEach(r -> {
                MappingEntry me = new MappingEntryBuilder(deviceId, r).build();
                providerService.mappingAdded(me, MAP_CACHE);
            });
            break;
        case LISP_MAP_NOTIFY:
            LispMapNotify notify = (LispMapNotify) msg;
            notify.getMapRecords().forEach(r -> {
                MappingEntry me = new MappingEntryBuilder(deviceId, r).build();
                providerService.mappingAdded(me, MAP_DATABASE);
            });
            break;
        default:
            log.warn("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleOutgoingMessage(LispRouterId routerId, LispMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(routerId.toString());
    switch(msg.getType()) {
        case LISP_MAP_REPLY:
            LispMapReply reply = (LispMapReply) msg;
            processMappings(deviceId, reply.getMapRecords(), MAP_CACHE);
            break;
        case LISP_MAP_NOTIFY:
            LispMapNotify notify = (LispMapNotify) msg;
            processMappings(deviceId, notify.getMapRecords(), MAP_DATABASE);
            break;
        default:
            log.warn("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
private MappingKey buildKey() {
    MappingKey.Builder builder = DefaultMappingKey.builder();
    if (address != null) {
        builder.withAddress(address);
    }
    return builder.build();
}
#method_after
private MappingKey buildKey() {
    MappingKey.Builder builder = DefaultMappingKey.builder();
    builder.withAddress(address);
    return builder.build();
}
#end_block

#method_before
private MappingAddress getAddress(LispAfiAddress address, int length) {
    if (address == null) {
        return null;
    }
    switch(address.getAfi()) {
        case IP4:
            IpAddress ipv4Address = ((LispIpv4Address) address).getAddress();
            IpPrefix ipv4Prefix = IpPrefix.valueOf(ipv4Address, length);
            return MappingAddresses.ipv4MappingAddress(ipv4Prefix);
        case IP6:
            IpAddress ipv6Address = ((LispIpv6Address) address).getAddress();
            IpPrefix ipv6Prefix = IpPrefix.valueOf(ipv6Address, length);
            return MappingAddresses.ipv6MappingAddress(ipv6Prefix);
        case AS:
            int asNum = ((LispAsAddress) address).getASNum();
            return MappingAddresses.asMappingAddress(String.valueOf(asNum));
        case DISTINGUISHED_NAME:
            String dn = ((LispDistinguishedNameAddress) address).getDistinguishedName();
            return MappingAddresses.dnMappingAddress(dn);
        case MAC:
            MacAddress macAddress = ((LispMacAddress) address).getAddress();
            return MappingAddresses.ethMappingAddress(macAddress);
        case LCAF:
            // TODO: need to use extension address to abstract LCAF address
            break;
        default:
            log.warn("Unsupported address type {}", address.getAfi());
            break;
    }
    return null;
}
#method_after
private MappingAddress getAddress(LispAfiAddress address, int length) {
    if (address == null) {
        log.warn("Address is not specified.");
        return null;
    }
    switch(address.getAfi()) {
        case IP4:
            IpAddress ipv4Address = ((LispIpv4Address) address).getAddress();
            IpPrefix ipv4Prefix = IpPrefix.valueOf(ipv4Address, length);
            return MappingAddresses.ipv4MappingAddress(ipv4Prefix);
        case IP6:
            IpAddress ipv6Address = ((LispIpv6Address) address).getAddress();
            IpPrefix ipv6Prefix = IpPrefix.valueOf(ipv6Address, length);
            return MappingAddresses.ipv6MappingAddress(ipv6Prefix);
        case AS:
            int asNum = ((LispAsAddress) address).getASNum();
            return MappingAddresses.asMappingAddress(String.valueOf(asNum));
        case DISTINGUISHED_NAME:
            String dn = ((LispDistinguishedNameAddress) address).getDistinguishedName();
            return MappingAddresses.dnMappingAddress(dn);
        case MAC:
            MacAddress macAddress = ((LispMacAddress) address).getAddress();
            return MappingAddresses.ethMappingAddress(macAddress);
        case LCAF:
            // TODO: need to use extension address to abstract LCAF address
            break;
        default:
            log.warn("Unsupported address type {}", address.getAfi());
            break;
    }
    return null;
}
#end_block

#method_before
@Override
public void startDriverHandshake() {
    log.warn("Starting driver handshake for sw {}", getStringId());
    if (startDriverHandshakeCalled) {
        throw new SwitchDriverSubHandshakeAlreadyStarted();
    }
    startDriverHandshakeCalled = true;
    try {
        sendHandshakeOFExperimenterPortDescRequest();
    } catch (IOException e) {
        log.error("OPLK ROADM exception while sending experimenter port desc:", e);
    }
}
#method_after
@Override
public void startDriverHandshake() {
    log.info("Starting driver handshake for sw {}", getStringId());
    if (startDriverHandshakeCalled) {
        throw new SwitchDriverSubHandshakeAlreadyStarted();
    }
    startDriverHandshakeCalled = true;
    try {
        sendHandshakeOFExperimenterPortDescRequest();
    } catch (IOException e) {
        log.error("OPLK ROADM exception while sending experimenter port desc:", e);
    }
}
#end_block

#method_before
private OpenFlowSwitch getOpenFlowDevice() {
    final DriverHandler handler = behaviour.handler();
    final OpenFlowController controller = handler.get(OpenFlowController.class);
    final Dpid dpid = Dpid.dpid(handler.data().deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null || !sw.isConnected()) {
        log.warn("OpenFlow handshaker driver not found or device is not connected");
        return null;
    }
    return sw;
}
#method_after
private OpenFlowSwitch getOpenFlowDevice() {
    final DriverHandler handler = behaviour.handler();
    final OpenFlowController controller = handler.get(OpenFlowController.class);
    final Dpid dpid = Dpid.dpid(handler.data().deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null || !sw.isConnected()) {
        log.warn("OpenFlow handshaker driver not found or device is not connected, dpid = {}", dpid);
        return null;
    }
    return sw;
}
#end_block

#method_before
private Range<Long> getTargetPortPowerRange(PortNumber portNum) {
    OpenFlowSwitch ofs = getOpenFlowDevice();
    if (ofs == null) {
        return null;
    }
    PortDescType portType = getPortDescType((OpenFlowOpticalSwitch) ofs, portNum);
    Type devType = ofs.deviceType();
    // The power range will be obtained from physical device in the future.
    switch(devType) {
        case OPTICAL_AMPLIFIER:
            if (portType == PortDescType.PA_LINE_OUT || portType == PortDescType.BA_LINE_OUT) {
                return Range.closed(EDFA_POWER_OUT_LOW_THRES, EDFA_POWER_OUT_HIGH_THRES);
            }
            break;
        case ROADM:
            if (portType == PortDescType.PA_LINE_OUT) {
                return Range.closed(ROADM_POWER_LINE_OUT_LOW_THRES, ROADM_POWER_LINE_OUT_HIGH_THRES);
            } else if (portType == PortDescType.EXP_OUT || portType == PortDescType.EXP_OUT) {
                return Range.closed(ROADM_POWER_OTHER_OUT_LOW_THRES, ROADM_POWER_OTHER_OUT_HIGH_THRES);
            }
            break;
        default:
            log.warn("Unexpected device type: {}", devType);
            break;
    }
    // Unexpected port or device type. Do not need warning here for port polling.
    return null;
}
#method_after
private Range<Long> getTargetPortPowerRange(PortNumber portNum) {
    OpenFlowSwitch ofs = getOpenFlowDevice();
    if (ofs == null) {
        return null;
    }
    PortDescType portType = getPortDescType((OpenFlowOpticalSwitch) ofs, portNum);
    Type devType = ofs.deviceType();
    // The power range will be obtained from physical device in the future.
    switch(devType) {
        case OPTICAL_AMPLIFIER:
            if (portType == PortDescType.PA_LINE_OUT || portType == PortDescType.BA_LINE_OUT) {
                return Range.closed(EDFA_POWER_OUT_LOW_THRES, EDFA_POWER_OUT_HIGH_THRES);
            }
            break;
        case ROADM:
            if (portType == PortDescType.PA_LINE_OUT) {
                return Range.closed(ROADM_POWER_LINE_OUT_LOW_THRES, ROADM_POWER_LINE_OUT_HIGH_THRES);
            } else if (portType == PortDescType.EXP_OUT || portType == PortDescType.AUX_OUT) {
                return Range.closed(ROADM_POWER_OTHER_OUT_LOW_THRES, ROADM_POWER_OTHER_OUT_HIGH_THRES);
            }
            break;
        default:
            log.warn("Unexpected device type: {}", devType);
            break;
    }
    // Unexpected port or device type. Do not need warning here for port polling.
    return null;
}
#end_block

#method_before
private void addAttenuation(FlowEntry flowEntry, long power) {
    FlowRule.Builder flowBuilder = new DefaultFlowRule.Builder();
    flowBuilder.withCookie(flowEntry.id().value());
    flowBuilder.withPriority(flowEntry.priority());
    flowBuilder.forDevice(flowEntry.deviceId());
    flowBuilder.forTable(flowEntry.tableId());
    if (flowEntry.isPermanent()) {
        flowBuilder.makePermanent();
    } else {
        flowBuilder.makeTemporary(flowEntry.timeout());
    }
    flowBuilder.withSelector(flowEntry.selector());
    // Copy original instructions and add attenuation instruction
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    flowEntry.treatment().allInstructions().forEach(ins -> treatmentBuilder.add(ins));
    final DriverHandler handler = behaviour.handler();
    treatmentBuilder.add(Instructions.extension(new OplinkAttenuation((int) power), handler.data().deviceId()));
    flowBuilder.withTreatment(treatmentBuilder.build());
    FlowRuleService service = handler.get(FlowRuleService.class);
    service.applyFlowRules(flowBuilder.build());
}
#method_after
private void addAttenuation(FlowEntry flowEntry, long power) {
    FlowRule.Builder flowBuilder = new DefaultFlowRule.Builder().withCookie(flowEntry.id().value()).withPriority(flowEntry.priority()).forDevice(flowEntry.deviceId()).forTable(flowEntry.tableId());
    if (flowEntry.isPermanent()) {
        flowBuilder.makePermanent();
    } else {
        flowBuilder.makeTemporary(flowEntry.timeout());
    }
    flowBuilder.withSelector(flowEntry.selector());
    // Copy original instructions and add attenuation instruction
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    flowEntry.treatment().allInstructions().forEach(ins -> treatmentBuilder.add(ins));
    final DriverHandler handler = behaviour.handler();
    treatmentBuilder.add(Instructions.extension(new OplinkAttenuation((int) power), handler.data().deviceId()));
    flowBuilder.withTreatment(treatmentBuilder.build());
    FlowRuleService service = handler.get(FlowRuleService.class);
    service.applyFlowRules(flowBuilder.build());
}
#end_block

#method_before
private Pair<OchPort, OchPort> findPorts(ConnectPoint src, ConnectPoint dst, CltSignalType signalType) {
    // Sorting can be skipped if OduSignalType values always assumed to be in increasing bitrate
    return Arrays.asList(OduSignalType.values()).stream().sorted(OduSignalType.comparator()).filter(oduSignalType -> oduSignalType.bitRate() >= signalType.bitRate()).map(oduSignalType -> findPorts(src, dst, oduSignalType)).filter(optionalOchPortPair -> optionalOchPortPair.isPresent()).map(optionalOchPortPair -> optionalOchPortPair.get()).findFirst().orElse(null);
}
#method_after
private Pair<OchPort, OchPort> findPorts(ConnectPoint src, ConnectPoint dst, CltSignalType signalType) {
    // According to the OpticalCircuitIntent's signalType find OCH ports with available TributarySlots resources
    return Arrays.asList(OduSignalType.values()).stream().sorted(Comparator.comparingLong(OduSignalType::bitRate)).filter(oduSignalType -> oduSignalType.bitRate() >= signalType.bitRate()).map(oduSignalType -> findPorts(src, dst, oduSignalType)).flatMap(Tools::stream).findFirst().orElse(null);
}
#end_block

#method_before
@Test
public void addToDataListTest() throws IOException {
    ResourceId.Builder rIdBlr = initializeResourceId(context);
    dBlr = initializeDataNode(rIdBlr);
    dBlr = addDataNode(dBlr, "l1", LNS, value, null);
    value = "1";
    dBlr = addDataNode(dBlr, "k1", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "2";
    dBlr = addDataNode(dBlr, "k2", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "c1", null, value, null);
    value = "0";
    dBlr = addDataNode(dBlr, "l1", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    id = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    ResourceId id1 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    value = "3";
    dBlr = addDataNode(dBlr, "k3", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    ResourceId id2 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    // Tree validation
    nA = new String[] { "/", "l1", "k1", "k2", "k3", "c1", "l1" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3", "0" };
    validateResourceId(nA, nsA, valA, id);
    nA = new String[] { "/", "l1", "k1", "k2", "k3", "c1" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3" };
    validateResourceId(nA, nsA, valA, id1);
    nA = new String[] { "/", "l1", "k1", "k2", "k3" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3" };
    validateResourceId(nA, nsA, valA, id2);
    // Validating the data node.
    DataNode node = dBlr.build();
    validateDataNode(node, "l1", LNS, MULTI_INSTANCE_NODE, true, null);
    Iterator<KeyLeaf> keyIt = ((ListKey) node.key()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "k1", LNS, "1");
    validateLeafDataNode(keyIt.next(), "k2", LNS, "2");
    validateLeafDataNode(keyIt.next(), "k3", LNS, "3");
    Iterator<Map.Entry<NodeKey, DataNode>> it1;
    it1 = ((InnerNode) node).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "k1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "1");
    validateDataNode(it1.next().getValue(), "k2", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "2");
    DataNode n1 = it1.next().getValue();
    validateDataNode(n1, "c1", LNS, SINGLE_INSTANCE_NODE, true, null);
    validateDataNode(it1.next().getValue(), "k3", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "3");
    Iterator<Map.Entry<NodeKey, DataNode>> it2;
    it2 = ((InnerNode) n1).childNodes().entrySet().iterator();
    validateDataNode(it2.next().getValue(), "l1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "0");
}
#method_after
@Test
public void addToDataListTest() throws IOException {
    ResourceId.Builder rIdBlr = initializeResourceId(context);
    dBlr = initializeDataNode(rIdBlr);
    dBlr = addDataNode(dBlr, "l1", LNS, value, null);
    value = "1";
    dBlr = addDataNode(dBlr, "k1", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "2";
    dBlr = addDataNode(dBlr, "k2", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "c1", null, value, null);
    value = "0";
    dBlr = addDataNode(dBlr, "leaf_c1", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    id = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    ResourceId id1 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    value = "3";
    dBlr = addDataNode(dBlr, "k3", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    ResourceId id2 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    // Tree validation
    nA = new String[] { "/", "l1", "k1", "k2", "k3", "c1", "leaf_c1" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3", "0" };
    validateResourceId(nA, nsA, valA, id);
    nA = new String[] { "/", "l1", "k1", "k2", "k3", "c1" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3" };
    validateResourceId(nA, nsA, valA, id1);
    nA = new String[] { "/", "l1", "k1", "k2", "k3" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3" };
    validateResourceId(nA, nsA, valA, id2);
    // Validating the data node.
    DataNode node = dBlr.build();
    validateDataNode(node, "l1", LNS, MULTI_INSTANCE_NODE, true, null);
    Iterator<KeyLeaf> keyIt = ((ListKey) node.key()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "k1", LNS, "1");
    validateLeafDataNode(keyIt.next(), "k2", LNS, "2");
    validateLeafDataNode(keyIt.next(), "k3", LNS, "3");
    Iterator<Map.Entry<NodeKey, DataNode>> it1;
    it1 = ((InnerNode) node).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "k1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "1");
    validateDataNode(it1.next().getValue(), "k2", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "2");
    DataNode n1 = it1.next().getValue();
    validateDataNode(n1, "c1", LNS, SINGLE_INSTANCE_NODE, true, null);
    validateDataNode(it1.next().getValue(), "k3", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "3");
    Iterator<Map.Entry<NodeKey, DataNode>> it2;
    it2 = ((InnerNode) n1).childNodes().entrySet().iterator();
    validateDataNode(it2.next().getValue(), "leaf_c1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "0");
    walkINTree(node, EXPECTED);
}
#end_block

#method_before
@Test
public void addToDataLeafListTest() {
    ResourceId.Builder rIdBlr = initializeResourceId(context);
    dBlr = initializeDataNode(rIdBlr);
    value = "0";
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    info = (HelperContext) dBlr.appInfo();
    id = getResourceId(dBlr);
    // Tree validation
    nA = new String[] { "/", "leaf1" };
    nsA = new String[] { null, LNS };
    valA = new String[] { "0" };
    validateResourceId(nA, nsA, valA, id);
    DataNode node = dBlr.build();
    validateDataNode(node, "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "0");
}
#method_after
@Test
public void addToDataLeafListTest() {
    ResourceId.Builder rIdBlr = initializeResourceId(context);
    dBlr = initializeDataNode(rIdBlr);
    value = "0";
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    info = (HelperContext) dBlr.appInfo();
    id = getResourceId(dBlr);
    // Tree validation
    nA = new String[] { "/", "leaf1" };
    nsA = new String[] { null, LNS };
    valA = new String[] { "0" };
    validateResourceId(nA, nsA, valA, id);
    DataNode node = dBlr.build();
    validateDataNode(node, "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "0");
    walkINTree(node, EXPECTED);
}
#end_block

#method_before
@Test
public void addToDataTest() {
    dBlr = getLogisticModuleDataNode();
    // Validating the data node.
    DataNode node = dBlr.build();
    validateDataNode(node, "/", null, SINGLE_INSTANCE_NODE, true, null);
    Map<NodeKey, DataNode> childMap = ((InnerNode) node).childNodes();
    Iterator<Map.Entry<NodeKey, DataNode>> it = childMap.entrySet().iterator();
    Map.Entry<NodeKey, DataNode> n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Customs-supervisor", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Merchandiser-supervisor", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = null;
    validateDataNode(n.getValue(), "Material-supervisor", LMNG, MULTI_INSTANCE_NODE, true, value);
    Iterator<KeyLeaf> keyIt = ((ListKey) n.getKey()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "name", LMNG, "abc");
    Iterator<Map.Entry<NodeKey, DataNode>> it1;
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "name", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "abc");
    validateDataNode(it1.next().getValue(), "departmentId", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "dep-1");
    n = it.next();
    value = null;
    validateDataNode(n.getValue(), "Material-supervisor", LMNG, MULTI_INSTANCE_NODE, true, value);
    keyIt = ((ListKey) n.getKey()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "name", LMNG, "abc1");
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "name", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "abc1");
    validateDataNode(it1.next().getValue(), "departmentId", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "dep-1");
    n = it.next();
    value = null;
    validateDataNode(n.getValue(), "Material-supervisor", LMNG, MULTI_INSTANCE_NODE, true, value);
    keyIt = ((ListKey) n.getKey()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "name", LMNG, "abc2");
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "name", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "abc2");
    validateDataNode(it1.next().getValue(), "departmentId", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "dep-1");
    n = it.next();
    value = null;
    validateDataNode(n.getValue(), "Purchasing-supervisor", LMNG, SINGLE_INSTANCE_NODE, true, value);
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "purchasing-specialist", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "xyz");
    validateDataNode(it1.next().getValue(), "support", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "helpdesk");
    validateDataNode(it1.next().getValue(), "support", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "helpdesk1");
    validateDataNode(it1.next().getValue(), "support", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "helpdesk2");
    n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Warehouse-supervisor", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "2";
    validateDataNode(n.getValue(), "Warehouse-supervisor", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "3";
    validateDataNode(n.getValue(), "Warehouse-supervisor", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "4";
    validateDataNode(n.getValue(), "Warehouse-supervisor", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Trading-supervisor", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Employee-id", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "2";
    validateDataNode(n.getValue(), "Employee-id", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "3";
    validateDataNode(n.getValue(), "Employee-id", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "4";
    validateDataNode(n.getValue(), "Employee-id", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
}
#method_after
@Test
public void addToDataTest() {
    dBlr = getLogisticModuleDataNode();
    walkINTree(dBlr.build(), EXPECTED);
    // Validating the data node.
    DataNode node = dBlr.build();
    validateDataNode(node, "/", null, SINGLE_INSTANCE_NODE, true, null);
    Map<NodeKey, DataNode> childMap = ((InnerNode) node).childNodes();
    Iterator<Map.Entry<NodeKey, DataNode>> it = childMap.entrySet().iterator();
    Map.Entry<NodeKey, DataNode> n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Customs-supervisor", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Merchandiser-supervisor", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = null;
    validateDataNode(n.getValue(), "Material-supervisor", LMNG, MULTI_INSTANCE_NODE, true, value);
    Iterator<KeyLeaf> keyIt = ((ListKey) n.getKey()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "name", LMNG, "abc");
    Iterator<Map.Entry<NodeKey, DataNode>> it1;
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "name", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "abc");
    validateDataNode(it1.next().getValue(), "departmentId", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "dep-1");
    n = it.next();
    value = null;
    validateDataNode(n.getValue(), "Material-supervisor", LMNG, MULTI_INSTANCE_NODE, true, value);
    keyIt = ((ListKey) n.getKey()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "name", LMNG, "abc1");
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "name", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "abc1");
    validateDataNode(it1.next().getValue(), "departmentId", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "dep-1");
    n = it.next();
    value = null;
    validateDataNode(n.getValue(), "Material-supervisor", LMNG, MULTI_INSTANCE_NODE, true, value);
    keyIt = ((ListKey) n.getKey()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "name", LMNG, "abc2");
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "name", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "abc2");
    validateDataNode(it1.next().getValue(), "departmentId", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "dep-1");
    n = it.next();
    value = null;
    validateDataNode(n.getValue(), "Purchasing-supervisor", LMNG, SINGLE_INSTANCE_NODE, true, value);
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "purchasing-specialist", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "xyz");
    validateDataNode(it1.next().getValue(), "support", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "helpdesk");
    validateDataNode(it1.next().getValue(), "support", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "helpdesk1");
    validateDataNode(it1.next().getValue(), "support", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "helpdesk2");
    n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Warehouse-supervisor", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "2";
    validateDataNode(n.getValue(), "Warehouse-supervisor", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "3";
    validateDataNode(n.getValue(), "Warehouse-supervisor", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "4";
    validateDataNode(n.getValue(), "Warehouse-supervisor", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Trading-supervisor", LMNG, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "1";
    validateDataNode(n.getValue(), "Employee-id", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "2";
    validateDataNode(n.getValue(), "Employee-id", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "3";
    validateDataNode(n.getValue(), "Employee-id", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
    n = it.next();
    value = "4";
    validateDataNode(n.getValue(), "Employee-id", LMNG, MULTI_INSTANCE_LEAF_VALUE_NODE, false, value);
}
#end_block

#method_before
@Test
public void addToDataListTest() {
    ResourceId.Builder rIdBlr = initializeResourceId(context);
    rIdBlr = addToResourceId(rIdBlr, "l1", LNS, value);
    rIdBlr = addToResourceId(rIdBlr, "c1", LNS, value);
    dBlr = initializeDataNode(rIdBlr);
    value = null;
    dBlr = addDataNode(dBlr, "l1", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    id = getResourceId(dBlr);
    // Tree validation
    nA = new String[] { "/", "l1", "c1", "l1" };
    nsA = new String[] { null, LNS, LNS, LNS };
    valA = new String[] { null };
    validateResourceId(nA, nsA, valA, id);
    DataNode node = dBlr.build();
    validateDataNode(node, "l1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, null);
}
#method_after
@Test
public void addToDataListTest() {
    ResourceId.Builder rIdBlr = initializeResourceId(context);
    rIdBlr = addToResourceId(rIdBlr, "l1", LNS, value);
    rIdBlr = addToResourceId(rIdBlr, "c1", LNS, value);
    dBlr = initializeDataNode(rIdBlr);
    value = null;
    dBlr = addDataNode(dBlr, "leaf_c1", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    id = getResourceId(dBlr);
    // Tree validation
    nA = new String[] { "/", "l1", "c1", "leaf_c1" };
    nsA = new String[] { null, LNS, LNS, LNS };
    valA = new String[] { null };
    validateResourceId(nA, nsA, valA, id);
    DataNode node = dBlr.build();
    validateDataNode(node, "leaf_c1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, null);
}
#end_block

#method_before
@Test
public void addToDataListTest() throws IOException {
    dBlr = initializeDataNode(context);
    dBlr = addDataNode(dBlr, "l1", LNS, value, null);
    value = "1";
    dBlr = addDataNode(dBlr, "k1", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "2";
    dBlr = addDataNode(dBlr, "k2", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "c1", null, value, null);
    value = "0";
    dBlr = addDataNode(dBlr, "l1", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    id = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    ResourceId id1 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    value = "3";
    dBlr = addDataNode(dBlr, "k3", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    ResourceId id2 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    // Checking leaf list
    value = "1";
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    dBlr = exitDataNode(dBlr);
    value = "2";
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    dBlr = exitDataNode(dBlr);
    value = "3";
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    ResourceId id3 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    // Tree validation
    nA = new String[] { "/", "l1", "k1", "k2", "k3", "c1", "l1" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3", "0" };
    validateResourceId(nA, nsA, valA, id);
    nA = new String[] { "/", "l1", "k1", "k2", "k3", "c1" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3" };
    validateResourceId(nA, nsA, valA, id1);
    nA = new String[] { "/", "l1", "k1", "k2", "k3" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3" };
    validateResourceId(nA, nsA, valA, id2);
    nA = new String[] { "/", "leaf1" };
    nsA = new String[] { null, LNS };
    valA = new String[] { null };
    validateResourceId(nA, nsA, valA, id3);
    // Validating the data node.
    DataNode node = dBlr.build();
    validateDataNode(node, "/", null, SINGLE_INSTANCE_NODE, true, null);
    Map<NodeKey, DataNode> childMap = ((InnerNode) node).childNodes();
    Iterator<Map.Entry<NodeKey, DataNode>> it = childMap.entrySet().iterator();
    Map.Entry<NodeKey, DataNode> n = it.next();
    validateDataNode(n.getValue(), "l1", LNS, MULTI_INSTANCE_NODE, true, null);
    Iterator<KeyLeaf> keyIt = ((ListKey) n.getKey()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "k1", LNS, "1");
    validateLeafDataNode(keyIt.next(), "k2", LNS, "2");
    validateLeafDataNode(keyIt.next(), "k3", LNS, "3");
    Iterator<Map.Entry<NodeKey, DataNode>> it1;
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "k1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "1");
    validateDataNode(it1.next().getValue(), "k2", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "2");
    DataNode n1 = it1.next().getValue();
    validateDataNode(n1, "c1", LNS, SINGLE_INSTANCE_NODE, true, null);
    validateDataNode(it1.next().getValue(), "k3", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "3");
    Iterator<Map.Entry<NodeKey, DataNode>> it2;
    it2 = ((InnerNode) n1).childNodes().entrySet().iterator();
    validateDataNode(it2.next().getValue(), "l1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "0");
    validateDataNode(it.next().getValue(), "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "1");
    validateDataNode(it.next().getValue(), "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "2");
    validateDataNode(it.next().getValue(), "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "3");
    validateDataNode(it.next().getValue(), "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, null);
}
#method_after
@Test
public void addToDataListTest() throws IOException {
    ResourceId id;
    dBlr = initializeDataNode(context);
    dBlr = addDataNode(dBlr, "l1", LNS, value, null);
    value = "1";
    dBlr = addDataNode(dBlr, "k1", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "2";
    dBlr = addDataNode(dBlr, "k2", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "c1", null, value, null);
    value = "0";
    dBlr = addDataNode(dBlr, "leaf_c1", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    id = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    ResourceId id1 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    value = "3";
    dBlr = addDataNode(dBlr, "k3", null, value, null);
    info = (HelperContext) dBlr.appInfo();
    ResourceId id2 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    // Checking leaf list
    value = "1";
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    dBlr = exitDataNode(dBlr);
    value = "2";
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    dBlr = exitDataNode(dBlr);
    value = "3";
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "leaf1", LNS, value, null);
    ResourceId id3 = getResourceId(dBlr);
    dBlr = exitDataNode(dBlr);
    // Tree validation
    nA = new String[] { "/", "l1", "k1", "k2", "k3", "c1", "leaf_c1" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3", "0" };
    validateResourceId(nA, nsA, valA, id);
    nA = new String[] { "/", "l1", "k1", "k2", "k3", "c1" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3" };
    validateResourceId(nA, nsA, valA, id1);
    nA = new String[] { "/", "l1", "k1", "k2", "k3" };
    nsA = new String[] { null, LNS, LNS, LNS, LNS };
    valA = new String[] { "1", "2", "3" };
    validateResourceId(nA, nsA, valA, id2);
    nA = new String[] { "/", "leaf1" };
    nsA = new String[] { null, LNS };
    valA = new String[] { null };
    validateResourceId(nA, nsA, valA, id3);
    // Validating the data node.
    DataNode node = dBlr.build();
    validateDataNode(node, "/", null, SINGLE_INSTANCE_NODE, true, null);
    Map<NodeKey, DataNode> childMap = ((InnerNode) node).childNodes();
    Iterator<Map.Entry<NodeKey, DataNode>> it = childMap.entrySet().iterator();
    Map.Entry<NodeKey, DataNode> n = it.next();
    validateDataNode(n.getValue(), "l1", LNS, MULTI_INSTANCE_NODE, true, null);
    Iterator<KeyLeaf> keyIt = ((ListKey) n.getKey()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "k1", LNS, "1");
    validateLeafDataNode(keyIt.next(), "k2", LNS, "2");
    validateLeafDataNode(keyIt.next(), "k3", LNS, "3");
    Iterator<Map.Entry<NodeKey, DataNode>> it1;
    it1 = ((InnerNode) n.getValue()).childNodes().entrySet().iterator();
    validateDataNode(it1.next().getValue(), "k1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "1");
    validateDataNode(it1.next().getValue(), "k2", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "2");
    DataNode n1 = it1.next().getValue();
    validateDataNode(n1, "c1", LNS, SINGLE_INSTANCE_NODE, true, null);
    validateDataNode(it1.next().getValue(), "k3", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "3");
    Iterator<Map.Entry<NodeKey, DataNode>> it2;
    it2 = ((InnerNode) n1).childNodes().entrySet().iterator();
    validateDataNode(it2.next().getValue(), "leaf_c1", LNS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "0");
    validateDataNode(it.next().getValue(), "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "1");
    validateDataNode(it.next().getValue(), "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "2");
    validateDataNode(it.next().getValue(), "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, "3");
    validateDataNode(it.next().getValue(), "leaf1", LNS, MULTI_INSTANCE_LEAF_VALUE_NODE, false, null);
    walkINTree(dBlr.build(), EXPECTED);
}
#end_block

#method_before
protected void processHostUpdatedEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    HostLocation prevLocation = event.prevSubject().location();
    DeviceId prevDeviceId = prevLocation.deviceId();
    PortNumber prevPort = prevLocation.port();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    HostLocation newLocation = event.subject().location();
    DeviceId newDeviceId = newLocation.deviceId();
    PortNumber newPort = newLocation.port();
    Set<IpAddress> newIps = event.subject().ipAddresses();
    log.info("Host {}/{} is updated", mac, vlanId);
    Set<IpAddress> commonIps = new HashSet<>(prevIps);
    commonIps.retainAll(newIps);
    if (accepted(event.prevSubject())) {
        // Revoke previous IP table entry
        prevIps.forEach(ip -> {
            if (srManager.deviceConfiguration.inSameSubnet(prevLocation, ip) && !commonIps.contains(ip)) {
                log.info("revoking previous IP rule:{}", ip);
                srManager.routingRulePopulator.revokeRoute(prevDeviceId, ip.toIpPrefix(), mac, prevPort);
            }
        });
    }
    if (accepted(event.subject())) {
        // Populate new IP table entry
        newIps.forEach(ip -> {
            if (srManager.deviceConfiguration.inSameSubnet(newLocation, ip) && !commonIps.contains(ip)) {
                log.info("populating new IP rule:{}", ip);
                srManager.routingRulePopulator.populateRoute(newDeviceId, ip.toIpPrefix(), mac, newPort);
            }
        });
    }
}
#method_after
protected void processHostUpdatedEvent(HostEvent event) {
    MacAddress mac = event.subject().mac();
    VlanId vlanId = event.subject().vlan();
    HostLocation prevLocation = event.prevSubject().location();
    DeviceId prevDeviceId = prevLocation.deviceId();
    PortNumber prevPort = prevLocation.port();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    HostLocation newLocation = event.subject().location();
    DeviceId newDeviceId = newLocation.deviceId();
    PortNumber newPort = newLocation.port();
    Set<IpAddress> newIps = event.subject().ipAddresses();
    log.info("Host {}/{} is updated", mac, vlanId);
    if (accepted(event.prevSubject())) {
        // Revoke previous IP table entry
        Sets.difference(prevIps, newIps).forEach(ip -> {
            if (srManager.deviceConfiguration.inSameSubnet(prevLocation, ip)) {
                log.info("revoking previous IP rule:{}", ip);
                srManager.routingRulePopulator.revokeRoute(prevDeviceId, ip.toIpPrefix(), mac, prevPort);
            }
        });
    }
    if (accepted(event.subject())) {
        // Populate new IP table entry
        Sets.difference(newIps, prevIps).forEach(ip -> {
            if (srManager.deviceConfiguration.inSameSubnet(newLocation, ip)) {
                log.info("populating new IP rule:{}", ip);
                srManager.routingRulePopulator.populateRoute(newDeviceId, ip.toIpPrefix(), mac, newPort);
            }
        });
    }
}
#end_block

#method_before
private DeviceEvent removePort(DeviceId deviceId, PortNumber portNumber) {
    Port port = devicePorts.get(deviceId).remove(portNumber);
    return port == null ? null : new DeviceEvent(PORT_REMOVED, getDevice(deviceId), port);
}
#method_after
private DeviceEvent removePort(DeviceId deviceId, PortNumber portNumber) {
    log.info("Deleted port: " + deviceId.toString() + "/" + portNumber.toString());
    Port deletedPort = devicePorts.get(deviceId).remove(portNumber);
    return new DeviceEvent(PORT_REMOVED, getDevice(deviceId), deletedPort);
}
#end_block

#method_before
private DeviceEvent updatePortStatusInternal(ProviderId providerId, DeviceId deviceId, Timestamped<PortDescription> deltaDesc) {
    Device device = devices.get(deviceId);
    checkArgument(device != null, DEVICE_NOT_FOUND, deviceId);
    Map<ProviderId, DeviceDescriptions> descsMap = deviceDescs.get(deviceId);
    checkArgument(descsMap != null, DEVICE_NOT_FOUND, deviceId);
    synchronized (descsMap) {
        if (isDeviceRemoved(deviceId, deltaDesc.timestamp())) {
            log.debug("Ignoring outdated event: {}", deltaDesc);
            return null;
        }
        DeviceDescriptions descs = descsMap.get(providerId);
        // assuming all providers must to give DeviceDescription
        verify(descs != null, "Device description for Device ID %s from Provider %s was not found", deviceId, providerId);
        ConcurrentMap<PortNumber, Port> ports = getPortMap(deviceId);
        final PortNumber number = deltaDesc.value().portNumber();
        final Port oldPort = ports.get(number);
        final Port newPort;
        final Timestamped<PortDescription> existingPortDesc = descs.getPortDesc(number);
        if (deltaDesc.value().isRemoved() && deltaDesc.isNewer(existingPortDesc)) {
            return removePort(deviceId, number);
        } else {
            if (existingPortDesc == null || deltaDesc.isNewer(existingPortDesc)) {
                // on new port or valid update
                // update description
                descs.putPortDesc(deltaDesc);
                newPort = composePort(device, number, descsMap);
            } else {
                // same or outdated event, ignored.
                log.trace("ignore same or outdated {} >= {}", existingPortDesc, deltaDesc);
                return null;
            }
            if (oldPort == null) {
                return createPort(device, newPort, ports);
            } else {
                return updatePort(device, oldPort, newPort, ports);
            }
        }
    }
}
#method_after
private DeviceEvent updatePortStatusInternal(ProviderId providerId, DeviceId deviceId, Timestamped<PortDescription> deltaDesc) {
    Device device = devices.get(deviceId);
    checkArgument(device != null, DEVICE_NOT_FOUND, deviceId);
    Map<ProviderId, DeviceDescriptions> descsMap = deviceDescs.get(deviceId);
    checkArgument(descsMap != null, DEVICE_NOT_FOUND, deviceId);
    synchronized (descsMap) {
        if (isDeviceRemoved(deviceId, deltaDesc.timestamp())) {
            log.debug("Ignoring outdated event: {}", deltaDesc);
            return null;
        }
        DeviceDescriptions descs = descsMap.get(providerId);
        // assuming all providers must to give DeviceDescription
        verify(descs != null, "Device description for Device ID %s from Provider %s was not found", deviceId, providerId);
        ConcurrentMap<PortNumber, Port> ports = getPortMap(deviceId);
        final PortNumber number = deltaDesc.value().portNumber();
        final Port oldPort = ports.get(number);
        final Port newPort;
        final Timestamped<PortDescription> existingPortDesc = descs.getPortDesc(number);
        boolean toDelete = false;
        if (existingPortDesc == null || deltaDesc.isNewer(existingPortDesc)) {
            // on new port or valid update
            // update description
            descs.putPortDesc(deltaDesc);
            newPort = composePort(device, number, descsMap);
            toDelete = deltaDesc.value().isRemoved();
        } else {
            // same or outdated event, ignored.
            log.trace("ignore same or outdated {} >= {}", existingPortDesc, deltaDesc);
            return null;
        }
        if (oldPort == null) {
            return createPort(device, newPort, ports);
        } else {
            return toDelete ? removePort(deviceId, number) : updatePort(device, oldPort, newPort, ports);
        }
    }
}
#end_block

#method_before
@Override
public void portChanged(Dpid dpid, OFPortStatus status) {
    LOG.debug("portChanged({},{})", dpid, status);
    PortDescription portDescription = buildPortDescription(status);
    providerService.portStatusChanged(deviceId(uri(dpid)), portDescription);
}
#method_after
@Override
public void portChanged(Dpid dpid, OFPortStatus status) {
    LOG.debug("portChanged({},{})", dpid, status);
    PortDescription portDescription = buildPortDescription(status);
    if (status.getReason() != OFPortReason.DELETE) {
        providerService.portStatusChanged(deviceId(uri(dpid)), portDescription);
    } else {
        providerService.deletePort(deviceId(uri(dpid)), portDescription);
    }
}
#end_block

#method_before
private List<PortDescription> buildPortDescriptions(OpenFlowSwitch sw) {
    final List<PortDescription> portDescs = new ArrayList<>(sw.getPorts().size());
    if (!((Device.Type.ROADM.equals(sw.deviceType())) || (Device.Type.OTN.equals(sw.deviceType())))) {
        sw.getPorts().forEach(port -> portDescs.add(buildPortDescription(port)));
    }
    OpenFlowOpticalSwitch opsw;
    switch(sw.deviceType()) {
        case ROADM:
        case OTN:
            opsw = (OpenFlowOpticalSwitch) sw;
            List<OFPortDesc> ports = opsw.getPorts();
            LOG.debug("SW ID {} , ETH- ODU CLT Ports {}", opsw.getId(), ports);
            // ODU client ports are reported as ETH
            ports.forEach(port -> portDescs.add(buildOduCltPortDescription(port)));
            opsw.getPortTypes().forEach(type -> {
                List<? extends OFObject> portsOf = opsw.getPortsOf(type);
                LOG.debug("Ports Of{}", portsOf);
                portsOf.forEach(op -> {
                    portDescs.add(buildPortDescription(type, op, opsw));
                });
            });
            break;
        case FIBER_SWITCH:
            opsw = (OpenFlowOpticalSwitch) sw;
            opsw.getPortTypes().forEach(type -> {
                opsw.getPortsOf(type).forEach(op -> {
                    portDescs.add(buildPortDescription((OFCalientPortDescStatsEntry) op));
                });
            });
            break;
        default:
            break;
    }
    return portDescs;
}
#method_after
private List<PortDescription> buildPortDescriptions(OpenFlowSwitch sw) {
    final List<PortDescription> portDescs = new ArrayList<>(sw.getPorts().size());
    if (!((Device.Type.ROADM.equals(sw.deviceType())) || (Device.Type.OTN.equals(sw.deviceType())) || (Device.Type.OPTICAL_AMPLIFIER.equals(sw.deviceType())))) {
        sw.getPorts().forEach(port -> portDescs.add(buildPortDescription(port)));
    }
    OpenFlowOpticalSwitch opsw;
    switch(sw.deviceType()) {
        case ROADM:
        case OTN:
        case OPTICAL_AMPLIFIER:
            opsw = (OpenFlowOpticalSwitch) sw;
            List<OFPortDesc> ports = opsw.getPorts();
            LOG.debug("SW ID {} , ETH- ODU CLT Ports {}", opsw.getId(), ports);
            // ODU client ports are reported as ETH
            ports.forEach(port -> portDescs.add(buildOduCltPortDescription(port)));
            opsw.getPortTypes().forEach(type -> {
                List<? extends OFObject> portsOf = opsw.getPortsOf(type);
                LOG.debug("Ports Of{}", portsOf);
                portsOf.forEach(op -> {
                    portDescs.add(buildPortDescription(type, op, opsw));
                });
            });
            break;
        case FIBER_SWITCH:
            opsw = (OpenFlowOpticalSwitch) sw;
            opsw.getPortTypes().forEach(type -> {
                opsw.getPortsOf(type).forEach(op -> {
                    portDescs.add(buildPortDescription((OFCalientPortDescStatsEntry) op));
                });
            });
            break;
        default:
            break;
    }
    return portDescs;
}
#end_block

#method_before
@Override
protected void execute() {
    CoreService coreService = get(CoreService.class);
    DeviceService deviceService = get(DeviceService.class);
    FlowRuleService service = get(FlowRuleService.class);
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    compilePredicate();
    SortedMap<Device, List<FlowEntry>> flows = getSortedFlows(deviceService, service, coreService);
    // Remove flows
    if (remove != null) {
        flows.values().forEach(flowList -> {
            if (!remove.isEmpty()) {
                filter.add(remove);
                contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
            }
            if (!filter.isEmpty() || (remove != null && !remove.isEmpty())) {
                flowList = filterFlows(flowList);
                flowList.forEach(service::removeFlowRules);
            }
        });
        return;
    }
    // Show flows
    if (outputJson()) {
        print("%s", json(flows.keySet(), flows));
    } else {
        flows.forEach((device, flow) -> printFlows(device, flow, coreService));
    }
}
#method_after
@Override
protected void execute() {
    CoreService coreService = get(CoreService.class);
    DeviceService deviceService = get(DeviceService.class);
    FlowRuleService service = get(FlowRuleService.class);
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    compilePredicate();
    SortedMap<Device, List<FlowEntry>> flows = getSortedFlows(deviceService, service, coreService);
    // Remove flows
    if (remove != null) {
        flows.values().forEach(flowList -> {
            if (!remove.isEmpty()) {
                filter.add(remove);
                contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
            }
            if (!filter.isEmpty() || (remove != null && !remove.isEmpty())) {
                flowList = filterFlows(flowList);
                this.removeFlowsInteractive(flowList, service, coreService);
            }
        });
        return;
    }
    // Show flows
    if (outputJson()) {
        print("%s", json(flows.keySet(), flows));
    } else {
        flows.forEach((device, flow) -> printFlows(device, flow, coreService));
    }
}
#end_block

#method_before
public void purgeIntents(Iterable<Intent> intents) {
    IntentService intentService = get(IntentService.class);
    this.purgeAfterRemove = true;
    removeIntentsByAppId(intentService, intents, null);
}
#method_after
private void purgeIntents(Iterable<Intent> intents) {
    IntentService intentService = get(IntentService.class);
    this.purgeAfterRemove = true;
    removeIntentsByAppId(intentService, intents, null);
}
#end_block

#method_before
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    // Remove intents
    if (remove != null && !remove.isEmpty()) {
        if (!remove.isEmpty()) {
            filter.add(remove);
        }
        contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
        List<Intent> intents = filterIntents(service);
        IntentRemoveCommand intentRemoveCmd = new IntentRemoveCommand();
        if (!remove.isEmpty()) {
            intentRemoveCmd.purgeIntents(intents);
        }
        return;
    }
    // Show detailed intents
    if (!intentIds.isEmpty()) {
        IntentDetailsCommand intentDetailsCmd = new IntentDetailsCommand();
        intentDetailsCmd.detailIntents(intentIds);
        return;
    }
    // Show intents
    if (intentsSummary) {
        IntentSummaries intentSummaries = new IntentSummaries();
        intentSummaries.collectIntentSummary(service, service.getIntents());
        if (outputJson()) {
            print("%s", intentSummaries.json());
        } else {
            print(intentSummaries.summary());
        }
        return;
    } else if (pending) {
        if (outputJson()) {
            print("%s", json(service.getPending()));
        } else {
            Tools.stream(service.getPending()).filter(intent -> contentFilter.filter(intent)).forEach(intent -> print(fullFormat(intent)));
        }
        return;
    }
    if (outputJson()) {
        print("%s", json(service.getIntents()));
    } else {
        printIntents(service);
    }
}
#method_after
@Override
protected void execute() {
    service = get(IntentService.class);
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    Iterable<Intent> intents;
    if (pending) {
        intents = service.getPending();
    } else {
        intents = service.getIntents();
    }
    // Remove intents
    if (remove != null && !remove.isEmpty()) {
        filter.add(remove);
        contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
        IntentRemoveCommand intentRemoveCmd = new IntentRemoveCommand();
        if (!remove.isEmpty()) {
            intentRemoveCmd.purgeIntentsInteractive(filterIntents(service));
        }
        return;
    }
    // Show detailed intents
    if (!intentIds.isEmpty()) {
        IntentDetailsCommand intentDetailsCmd = new IntentDetailsCommand();
        intentDetailsCmd.detailIntents(intentIds);
        return;
    }
    // Show brief intents
    if (intentsSummary || miniSummary) {
        Map<String, IntentSummary> summarized = summarize(intents);
        if (outputJson()) {
            ObjectNode summaries = mapper().createObjectNode();
            summarized.forEach((n, s) -> summaries.set(uncapitalize(n), s.json(mapper())));
            print("%s", summaries);
        } else if (miniSummary) {
            StringBuilder builder = new StringBuilder();
            builder.append(summarized.remove("All").miniSummary());
            summarized.values().forEach(s -> builder.append(s.miniSummary()));
            print("%s", builder.toString());
        } else {
            StringBuilder builder = new StringBuilder();
            builder.append(SUMMARY_TITLES);
            builder.append('\n').append(SEPARATOR);
            builder.append(summarized.remove("All").summary());
            summarized.values().forEach(s -> builder.append(s.summary()));
            print("%s", builder.toString());
        }
        return;
    }
    // JSON or default output
    if (outputJson()) {
        print("%s", json(intents));
    } else {
        for (Intent intent : intents) {
            IntentState state = service.getIntentState(intent.key());
            StringBuilder intentFormat = fullFormat(intent, state);
            StringBuilder detailsIntentFormat = detailsFormat(intent, state);
            String formatted = intentFormat.append(detailsIntentFormat).toString();
            if (contentFilter.filter(formatted)) {
                print("%s\n", formatted);
            }
        }
    }
}
#end_block

#method_before
private List<Intent> filterIntents(IntentService service) {
    return Tools.stream(service.getIntents()).filter(i -> contentFilter.filter(i)).collect(Collectors.toList());
}
#method_after
private List<Intent> filterIntents(IntentService service) {
    return filterIntents(service.getIntents());
}
#end_block

#method_before
private List<Intent> filterIntents(IntentService service) {
    return Tools.stream(service.getIntents()).filter(i -> contentFilter.filter(i)).collect(Collectors.toList());
}
#method_after
private List<Intent> filterIntents(Iterable<Intent> intents) {
    return Tools.stream(intents).filter(i -> contentFilter.filter(i)).collect(Collectors.toList());
}
#end_block

#method_before
String summary() {
    StringBuilder builder = new StringBuilder();
    builder.append(String.format("\n%1s%s%14d%14d%14d%14d%14d%14d%14d%14d%14d%14d", BOLD + intentType + RESET, Strings.padStart(String.valueOf(total), (32 - intentType.length()), ' '), installed, withdrawn, failed, installReq, compiling, installing, recompiling, withdrawReq, withdrawing, unknownState));
    builder.append("\n" + SEPARATOR);
    return builder.toString();
}
#method_after
StringBuilder summary() {
    StringBuilder builder = new StringBuilder();
    builder.append(format("\n%1s%s%14d%14d%14d%14d%14d%14d%14d%14d%14d%14d", BOLD + intentType + RESET, Strings.padStart(String.valueOf(total), (32 - intentType.length()), ' '), installed, withdrawn, failed, installReq, compiling, installing, recompiling, withdrawReq, withdrawing, unknownState));
    builder.append('\n').append(SEPARATOR);
    return builder;
}
#end_block

#method_before
private String detailsFormat(IntentService service, Intent intent) {
    StringBuilder builder = new StringBuilder();
    if (!intent.resources().isEmpty()) {
        builder.append("\n" + String.format(RESOURCES, intent.resources()));
    }
    if (intent instanceof ConnectivityIntent) {
        ConnectivityIntent ci = (ConnectivityIntent) intent;
        if (!ci.selector().criteria().isEmpty()) {
            builder.append("\n" + String.format(COMMON_SELECTOR, formatSelector(ci.selector())));
        }
        if (!ci.treatment().allInstructions().isEmpty()) {
            builder.append("\n" + String.format(TREATMENT, ci.treatment().allInstructions()));
        }
        if (ci.constraints() != null && !ci.constraints().isEmpty()) {
            builder.append("\n" + String.format(CONSTRAINTS, ci.constraints()));
        }
    }
    if (intent instanceof HostToHostIntent) {
        HostToHostIntent pi = (HostToHostIntent) intent;
        builder.append("\n" + String.format(SRC + HOST, pi.one()));
        builder.append("\n" + String.format(DST + HOST, pi.two()));
    } else if (intent instanceof PointToPointIntent) {
        PointToPointIntent pi = (PointToPointIntent) intent;
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredIngressPoint()), INGRESS));
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredEgressPoint()), EGRESS));
    } else if (intent instanceof MultiPointToSinglePointIntent) {
        MultiPointToSinglePointIntent pi = (MultiPointToSinglePointIntent) intent;
        builder.append("\n" + formatFilteredCps(pi.filteredIngressPoints(), INGRESS));
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredEgressPoint()), EGRESS));
    } else if (intent instanceof SinglePointToMultiPointIntent) {
        SinglePointToMultiPointIntent pi = (SinglePointToMultiPointIntent) intent;
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredIngressPoint()), INGRESS));
        builder.append("\n" + formatFilteredCps(pi.filteredEgressPoints(), EGRESS));
    } else if (intent instanceof PathIntent) {
        PathIntent pi = (PathIntent) intent;
        builder.append(String.format("path=%s, cost=%f", pi.path().links(), pi.path().cost()));
    } else if (intent instanceof LinkCollectionIntent) {
        LinkCollectionIntent li = (LinkCollectionIntent) intent;
        builder.append("\n" + String.format("links=%s", li.links()));
        builder.append("\n" + String.format(CP, li.egressPoints()));
    } else if (intent instanceof OpticalCircuitIntent) {
        OpticalCircuitIntent ci = (OpticalCircuitIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    } else if (intent instanceof OpticalConnectivityIntent) {
        OpticalConnectivityIntent ci = (OpticalConnectivityIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    } else if (intent instanceof OpticalOduIntent) {
        OpticalOduIntent ci = (OpticalOduIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    }
    List<Intent> installable = service.getInstallableIntents(intent.key());
    installable.stream().filter(i -> contentFilter.filter(i));
    if (showInstallable && installable != null && !installable.isEmpty()) {
        builder.append("\n" + String.format(INSTALLABLE, installable));
    }
    return builder.toString();
}
#method_after
private StringBuilder detailsFormat(Intent intent, IntentState state) {
    StringBuilder builder = new StringBuilder();
    if (state == null) {
        return builder;
    }
    if (!intent.resources().isEmpty()) {
        builder.append('\n').append(format(RESOURCES, intent.resources()));
    }
    if (intent instanceof ConnectivityIntent) {
        ConnectivityIntent ci = (ConnectivityIntent) intent;
        if (!ci.selector().criteria().isEmpty()) {
            builder.append('\n').append(format(COMMON_SELECTOR, formatSelector(ci.selector())));
        }
        if (!ci.treatment().allInstructions().isEmpty()) {
            builder.append('\n').append(format(TREATMENT, ci.treatment().allInstructions()));
        }
        if (ci.constraints() != null && !ci.constraints().isEmpty()) {
            builder.append('\n').append(format(CONSTRAINTS, ci.constraints()));
        }
    }
    if (intent instanceof HostToHostIntent) {
        HostToHostIntent pi = (HostToHostIntent) intent;
        builder.append('\n').append(format(SRC + HOST, pi.one()));
        builder.append('\n').append(format(DST + HOST, pi.two()));
    } else if (intent instanceof PointToPointIntent) {
        PointToPointIntent pi = (PointToPointIntent) intent;
        builder.append('\n').append(formatFilteredCps(Sets.newHashSet(pi.filteredIngressPoint()), INGRESS));
        builder.append('\n').append(formatFilteredCps(Sets.newHashSet(pi.filteredEgressPoint()), EGRESS));
    } else if (intent instanceof MultiPointToSinglePointIntent) {
        MultiPointToSinglePointIntent pi = (MultiPointToSinglePointIntent) intent;
        builder.append('\n').append(formatFilteredCps(pi.filteredIngressPoints(), INGRESS));
        builder.append('\n').append(formatFilteredCps(Sets.newHashSet(pi.filteredEgressPoint()), EGRESS));
    } else if (intent instanceof SinglePointToMultiPointIntent) {
        SinglePointToMultiPointIntent pi = (SinglePointToMultiPointIntent) intent;
        builder.append('\n').append(formatFilteredCps(Sets.newHashSet(pi.filteredIngressPoint()), INGRESS));
        builder.append('\n').append(formatFilteredCps(pi.filteredEgressPoints(), EGRESS));
    } else if (intent instanceof PathIntent) {
        PathIntent pi = (PathIntent) intent;
        builder.append(format("path=%s, cost=%f", pi.path().links(), pi.path().cost()));
    } else if (intent instanceof LinkCollectionIntent) {
        LinkCollectionIntent li = (LinkCollectionIntent) intent;
        builder.append('\n').append(format("links=%s", li.links()));
        builder.append('\n').append(format(CP, li.egressPoints()));
    } else if (intent instanceof OpticalCircuitIntent) {
        OpticalCircuitIntent ci = (OpticalCircuitIntent) intent;
        builder.append('\n').append(format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    } else if (intent instanceof OpticalConnectivityIntent) {
        OpticalConnectivityIntent ci = (OpticalConnectivityIntent) intent;
        builder.append('\n').append(format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    } else if (intent instanceof OpticalOduIntent) {
        OpticalOduIntent ci = (OpticalOduIntent) intent;
        builder.append('\n').append(format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    }
    List<Intent> installable = service.getInstallableIntents(intent.key());
    installable.stream().filter(i -> contentFilter.filter(i));
    if (showInstallable && installable != null && !installable.isEmpty()) {
        builder.append('\n').append(format(INSTALLABLE, installable));
    }
    return builder;
}
#end_block

#method_before
private String formatFilteredCps(Set<FilteredConnectPoint> fCps, String prefix) {
    StringBuilder builder = new StringBuilder();
    builder.append(prefix);
    builder.append(FILTERED_CPS);
    fCps.forEach(fCp -> builder.append("\n" + String.format(formatFilteredCp(fCp))));
    return builder.toString();
}
#method_after
private StringBuilder formatFilteredCps(Set<FilteredConnectPoint> fCps, String prefix) {
    StringBuilder builder = new StringBuilder();
    builder.append(prefix);
    builder.append(FILTERED_CPS);
    fCps.forEach(fCp -> builder.append('\n').append(formatFilteredCp(fCp)));
    return builder;
}
#end_block

#method_before
private String formatFilteredCp(FilteredConnectPoint fCp) {
    ConnectPoint connectPoint = fCp.connectPoint();
    TrafficSelector selector = fCp.trafficSelector();
    StringBuilder builder = new StringBuilder();
    builder.append(INDENTATION + String.format(CP, connectPoint));
    builder.append(SPACE + String.format(SELECTOR, formatSelector(selector)));
    return builder.toString();
}
#method_after
private StringBuilder formatFilteredCp(FilteredConnectPoint fCp) {
    ConnectPoint connectPoint = fCp.connectPoint();
    TrafficSelector selector = fCp.trafficSelector();
    StringBuilder builder = new StringBuilder();
    builder.append(INDENTATION).append(format(CP, connectPoint));
    builder.append(SPACE).append(format(SELECTOR, formatSelector(selector)));
    return builder;
}
#end_block

#method_before
private String formatSelector(TrafficSelector ts) {
    StringBuilder builder = new StringBuilder();
    List<Criterion> criteria = Lists.newArrayList(ts.criteria());
    if (criteria == null || criteria.isEmpty()) {
        builder.append(INHERITED);
        return builder.toString();
    }
    criteria.forEach(c -> {
        builder.append(c.toString());
        if (criteria.indexOf(c) < criteria.size() - 1) {
            builder.append(", ");
        }
    });
    return builder.toString();
}
#method_after
private StringBuilder formatSelector(TrafficSelector ts) {
    StringBuilder builder = new StringBuilder();
    List<Criterion> criteria = Lists.newArrayList(ts.criteria());
    if (criteria == null || criteria.isEmpty()) {
        builder.append(INHERITED);
        return builder;
    }
    criteria.forEach(c -> {
        builder.append(c.toString());
        if (criteria.indexOf(c) < criteria.size() - 1) {
            builder.append(", ");
        }
    });
    return builder;
}
#end_block

#method_before
private String fullFormat(Intent intent, String state) {
    StringBuilder builder = new StringBuilder();
    builder.append(String.format(ID, intent.id()));
    if (state != null) {
        builder.append("\n" + String.format(STATE, state));
    }
    builder.append("\n" + String.format(KEY, intent.key()));
    builder.append("\n" + String.format(TYPE, intent.getClass().getSimpleName()));
    builder.append("\n" + String.format(APP_ID, intent.appId().name()));
    return builder.toString();
}
#method_after
private StringBuilder fullFormat(Intent intent, IntentState state) {
    StringBuilder builder = new StringBuilder();
    builder.append(format(ID, intent.id()));
    if (state != null) {
        builder.append('\n').append(format(STATE, state));
    }
    builder.append('\n').append(format(KEY, intent.key()));
    builder.append('\n').append(format(TYPE, intent.getClass().getSimpleName()));
    builder.append('\n').append(format(APP_ID, intent.appId().name()));
    return builder;
}
#end_block

#method_before
private void addMapParameters(ObjectNode result, String mapId) {
    // TODO: This ought to be written more efficiently.
    // ALSO: Should retrieving a UiTopoMap by ID be something that
    // the UiExtensionService provides, along with other
    // useful lookups?
    // 
    // Or should it remain very basic / general?
    // 
    // return uiextService.getTopoMap(String mapId);
    final UiTopoMap[] map = { null };
    uiextService.getExtensions().forEach(ext -> {
        UiTopoMapFactory factory = ext.topoMapFactory();
        if (map[0] == null && factory != null) {
            List<UiTopoMap> topoMaps = factory.geoMaps();
            topoMaps.forEach(m -> {
                if (map[0] == null && m.id().equals(mapId)) {
                    map[0] = m;
                }
            });
        }
    });
    UiTopoMap m = map[0];
    if (m != null) {
        result.put("bgDesc", m.description()).put("bgFilePath", m.filePath()).put("bgDefaultScale", m.scale());
    } else {
        result.put("bgWarn", "no map registered with id: " + mapId);
    }
}
#method_after
private void addMapParameters(ObjectNode result, String mapId) {
    // TODO: This ought to be written more efficiently.
    // ALSO: Should retrieving a UiTopoMap by ID be something that
    // the UiExtensionService provides, along with other
    // useful lookups?
    // 
    // Or should it remain very basic / general?
    // 
    // return uiextService.getTopoMap(String mapId);
    final UiTopoMap[] map = { null };
    uiextService.getExtensions().forEach(ext -> {
        UiTopoMapFactory factory = ext.topoMapFactory();
        // TODO: use .stream().filter(...) here
        if (map[0] == null && factory != null) {
            List<UiTopoMap> topoMaps = factory.geoMaps();
            topoMaps.forEach(m -> {
                if (map[0] == null && m.id().equals(mapId)) {
                    map[0] = m;
                }
            });
        }
    });
    UiTopoMap m = map[0];
    if (m != null) {
        result.put("bgDesc", m.description()).put("bgFilePath", m.filePath()).put("bgDefaultScale", m.scale());
    } else {
        result.put("bgWarn", "no map registered with id: " + mapId);
    }
}
#end_block

#method_before
@Activate
public void activate() {
    cfgService.registerProperties(getClass());
    KryoNamespace.Builder kryoBuilder = new KryoNamespace.Builder().register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).register(DefaultGroup.class, DefaultGroupBucket.class, DefaultGroupDescription.class, DefaultGroupKey.class, GroupDescription.Type.class, Group.GroupState.class, GroupBuckets.class, GroupStoreMessage.class, GroupStoreMessage.Type.class, UpdateType.class, GroupStoreMessageSubjects.class, MultiValuedTimestamp.class, GroupStoreKeyMapKey.class, GroupStoreIdMapKey.class, GroupStoreMapKey.class);
    clusterMsgSerializer = kryoBuilder.build("GroupStore");
    Serializer serializer = Serializer.using(clusterMsgSerializer);
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/group", "message-handlers", log));
    clusterCommunicator.addSubscriber(GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, clusterMsgSerializer::deserialize, this::process, messageHandlingExecutor);
    log.debug("Creating Consistent map onos-group-store-keymap");
    groupStoreEntriesByKey = storageService.<GroupStoreKeyMapKey, StoredGroupEntry>consistentMapBuilder().withName("onos-group-store-keymap").withSerializer(serializer).build();
    groupStoreEntriesByKey.addListener(mapListener);
    log.debug("Current size of groupstorekeymap:{}", groupStoreEntriesByKey.size());
    log.debug("Creating groupstoreId map from groupstorekeymap");
    matchGroupEntries();
    executor = newSingleThreadScheduledExecutor(groupedThreads("onos/group", "store", log));
    statusChangeListener = status -> {
        if (status == Status.ACTIVE) {
            executor.execute(this::matchGroupEntries);
        }
    };
    groupStoreEntriesByKey.addStatusChangeListener(statusChangeListener);
    log.debug("Creating Consistent map pendinggroupkeymap");
    auditPendingReqQueue = storageService.<GroupStoreKeyMapKey, StoredGroupEntry>consistentMapBuilder().withName("onos-pending-group-keymap").withSerializer(serializer).build();
    log.debug("Current size of pendinggroupkeymap:{}", auditPendingReqQueue.size());
    groupTopic = getOrCreateGroupTopic(serializer);
    groupTopic.subscribe(this::processGroupMessage);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    cfgService.registerProperties(getClass());
    KryoNamespace.Builder kryoBuilder = new KryoNamespace.Builder().register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).register(DefaultGroup.class, DefaultGroupBucket.class, DefaultGroupDescription.class, DefaultGroupKey.class, GroupDescription.Type.class, Group.GroupState.class, GroupBuckets.class, GroupStoreMessage.class, GroupStoreMessage.Type.class, UpdateType.class, GroupStoreMessageSubjects.class, MultiValuedTimestamp.class, GroupStoreKeyMapKey.class, GroupStoreIdMapKey.class, GroupStoreMapKey.class);
    clusterMsgSerializer = kryoBuilder.build("GroupStore");
    Serializer serializer = Serializer.using(clusterMsgSerializer);
    messageHandlingExecutor = Executors.newFixedThreadPool(MESSAGE_HANDLER_THREAD_POOL_SIZE, groupedThreads("onos/store/group", "message-handlers", log));
    clusterCommunicator.addSubscriber(GroupStoreMessageSubjects.REMOTE_GROUP_OP_REQUEST, clusterMsgSerializer::deserialize, this::process, messageHandlingExecutor);
    log.debug("Creating Consistent map onos-group-store-keymap");
    groupStoreEntriesByKey = storageService.<GroupStoreKeyMapKey, StoredGroupEntry>consistentMapBuilder().withName("onos-group-store-keymap").withSerializer(serializer).build();
    groupStoreEntriesByKey.addListener(mapListener);
    log.debug("Current size of groupstorekeymap:{}", groupStoreEntriesByKey.size());
    log.debug("Creating GroupStoreId Map From GroupStoreKey Map");
    matchGroupEntries();
    executor = newSingleThreadScheduledExecutor(groupedThreads("onos/group", "store", log));
    statusChangeListener = status -> {
        if (status == Status.ACTIVE) {
            executor.execute(this::matchGroupEntries);
        }
    };
    groupStoreEntriesByKey.addStatusChangeListener(statusChangeListener);
    log.debug("Creating Consistent map pendinggroupkeymap");
    auditPendingReqQueue = storageService.<GroupStoreKeyMapKey, StoredGroupEntry>consistentMapBuilder().withName("onos-pending-group-keymap").withSerializer(serializer).build();
    log.debug("Current size of pendinggroupkeymap:{}", auditPendingReqQueue.size());
    groupTopic = getOrCreateGroupTopic(serializer);
    groupTopic.subscribe(this::processGroupMessage);
    log.info("Started");
}
#end_block

#method_before
@Override
public String format(Object value) {
    FlowEntry flow = (FlowEntry) value;
    List<Instruction> instructionsim = flow.treatment().immediate();
    List<Instruction> instructionsdef = flow.treatment().deferred();
    if (instructionsim.isEmpty() && instructionsdef.isEmpty() && flow.treatment().metered() == null && flow.treatment().tableTransition() == null) {
        return "(No traffic treatment instructions for this flow)";
    }
    StringBuilder sb = new StringBuilder("Treatment Instructions: ");
    if (!instructionsim.isEmpty()) {
        sb.append("immediate:");
        for (Instruction i : instructionsim) {
            sb.append(i).append(COMMA);
        }
    }
    if (!instructionsdef.isEmpty()) {
        sb.append("deferred:");
        for (Instruction j : instructionsdef) {
            sb.append(j).append(COMMA);
        }
    }
    if (flow.treatment().metered() != null) {
        sb.append("metered:");
        sb.append(flow.treatment().metered().toString()).append(COMMA);
    }
    if (flow.treatment().tableTransition() != null) {
        sb.append("transition:");
        sb.append(flow.treatment().tableTransition().toString()).append(COMMA);
    }
    if (flow.treatment().writeMetadata() != null) {
        sb.append("metadata:");
        sb.append(flow.treatment().writeMetadata().toString()).append(COMMA);
    }
    sb.append("cleared:");
    sb.append(flow.treatment().clearedDeferred()).append(COMMA);
    removeTrailingComma(sb);
    return sb.toString();
}
#method_after
@Override
public String format(Object value) {
    FlowEntry flow = (FlowEntry) value;
    TrafficTreatment treatment = flow.treatment();
    List<Instruction> imm = treatment.immediate();
    List<Instruction> def = treatment.deferred();
    if (imm.isEmpty() && def.isEmpty() && treatment.metered() == null && treatment.tableTransition() == null) {
        return "(No traffic treatment instructions for this flow)";
    }
    StringBuilder sb = new StringBuilder("Treatment Instructions: ");
    formatInstructs(sb, imm, "immediate:");
    formatInstructs(sb, def, "deferred:");
    if (treatment.metered() != null) {
        sb.append("metered:").append(treatment.metered()).append(COMMA);
    }
    if (treatment.tableTransition() != null) {
        sb.append("transition:").append(treatment.tableTransition()).append(COMMA);
    }
    if (treatment.writeMetadata() != null) {
        sb.append("metadata:").append(treatment.writeMetadata()).append(COMMA);
    }
    sb.append("cleared:").append(treatment.clearedDeferred());
    return sb.toString();
}
#end_block

#method_before
private String getCriteriaString(FlowRule flow) {
    Set<Criterion> criteria = flow.selector().criteria();
    StringBuilder sb = new StringBuilder();
    for (Criterion c : criteria) {
        sb.append(c).append(COMMA);
    }
    int pos = sb.lastIndexOf(COMMA);
    sb.delete(pos, sb.length());
    return sb.toString();
}
#method_after
private String getCriteriaString(FlowRule flow) {
    Set<Criterion> criteria = flow.selector().criteria();
    StringBuilder sb = new StringBuilder();
    for (Criterion c : criteria) {
        sb.append(c).append(COMMA);
    }
    removeTrailingComma(sb);
    return sb.toString();
}
#end_block

#method_before
private String getTreatmentString(FlowRule flow) {
    List<Instruction> instructions = flow.treatment().allInstructions();
    StringBuilder sb = new StringBuilder();
    for (Instruction inst : instructions) {
        sb.append(inst).append(COMMA);
    }
    if (flow.treatment().metered() != null) {
        sb.append(flow.treatment().metered().toString()).append(COMMA);
    }
    if (flow.treatment().tableTransition() != null) {
        sb.append(flow.treatment().tableTransition().toString()).append(COMMA);
    }
    int pos = sb.lastIndexOf(COMMA);
    sb.delete(pos, sb.length());
    return sb.toString();
}
#method_after
private String getTreatmentString(FlowRule flow) {
    List<Instruction> instructions = flow.treatment().allInstructions();
    StringBuilder sb = new StringBuilder();
    for (Instruction inst : instructions) {
        sb.append(inst).append(COMMA);
    }
    if (flow.treatment().metered() != null) {
        sb.append(flow.treatment().metered()).append(COMMA);
    }
    if (flow.treatment().tableTransition() != null) {
        sb.append(flow.treatment().tableTransition()).append(COMMA);
    }
    removeTrailingComma(sb);
    return sb.toString();
}
#end_block

#method_before
@Override
public String supportsFormat() {
    return null;
}
#method_after
@Override
public String supportsFormat() {
    return JSON_FORMAT;
}
#end_block

#method_before
@Override
public CompositeData decode(CompositeStream compositeStream, YangSerializerContext yangSerializerContext) {
    try {
        ResourceId rid = convertUriToRid(compositeStream.resourceId(), yangSerializerContext);
        ResourceId.Builder ridBuilder = new ResourceId.Builder(rid);
        ObjectNode rootNode = (ObjectNode) mapper().readTree(compositeStream.resourceData());
        DataNode dataNode = convertJsonToDataNode(rootNode, ridBuilder);
        ResourceData resourceData = DefaultResourceData.builder().addDataNode(dataNode).resourceId(rid).build();
        return DefaultCompositeData.builder().resourceData(resourceData).build();
    } catch (CloneNotSupportedException e) {
        log.error("ERROR: CloneNotSupportedException {}", e.getMessage());
        log.debug("Exception in decode:", e);
        return null;
    } catch (JsonProcessingException e) {
        log.error("ERROR: JsonProcessingException {}", e.getMessage());
        log.debug("Exception in decode:", e);
        return null;
    } catch (IOException ex) {
        log.error("ERROR: decode ", ex);
        return null;
    }
}
#method_after
@Override
public CompositeData decode(CompositeStream compositeStream, YangSerializerContext yangSerializerContext) {
    try {
        ResourceId rid = convertUriToRid(compositeStream.resourceId(), yangSerializerContext);
        ObjectNode rootNode = null;
        if (compositeStream.resourceData() != null) {
            rootNode = (ObjectNode) mapper().readTree(compositeStream.resourceData());
        }
        DataNode dataNode;
        /*
             * initializeDataNode by passing yangSerializerContext is
             * intended to be used in a scenario wherein URL is NULL.
             * initializeDataNode by passing resourceIdBuilder is
             * intended to be used in a scenario when URL is not NULL
             * and in this case the resourceId builder which was constructed
             * for a URL, needs to be given as an Input parameter.
             */
        if (rid != null) {
            dataNode = convertJsonToDataNode(rootNode, new ResourceId.Builder(rid));
        } else {
            dataNode = convertJsonToDataNode(rootNode, yangSerializerContext);
        }
        ResourceData resourceData = DefaultResourceData.builder().addDataNode(dataNode).resourceId(rid).build();
        return DefaultCompositeData.builder().resourceData(resourceData).build();
    } catch (CloneNotSupportedException e) {
        log.error("ERROR: JsonProcessingException {}", e.getMessage());
        log.debug("Exception in decode:", e);
        throw new SerializerException("JSON serializer decode failure");
    } catch (JsonProcessingException e) {
        log.error("ERROR: JsonProcessingException {}", e.getMessage());
        log.debug("Exception in decode:", e);
        throw new SerializerException("JSON serializer decode failure");
    } catch (IOException ex) {
        log.error("ERROR: decode ", ex);
        throw new SerializerException("JSON serializer decode failure");
    }
}
#end_block

#method_before
@Override
public CompositeStream encode(CompositeData compositeData, YangSerializerContext yangSerializerContext) {
    checkNotNull(compositeData, "compositeData cannot be null");
    String uriString = convertRidToUri(compositeData.resourceData().resourceId());
    ObjectNode rootNode = convertDataNodeToJson(compositeData.resourceData().dataNodes().get(0));
    InputStream inputStream = IOUtils.toInputStream(rootNode.toString());
    CompositeStream compositeStream = new DefaultCompositeStream(uriString, inputStream);
    return compositeStream;
}
#method_after
@Override
public CompositeStream encode(CompositeData compositeData, YangSerializerContext yangSerializerContext) {
    checkNotNull(compositeData, "compositeData cannot be null");
    String uriString = convertRidToUri(compositeData.resourceData().resourceId());
    InputStream inputStream = null;
    ObjectNode rootNode = null;
    if (compositeData.resourceData().dataNodes() != null) {
        rootNode = convertDataNodeToJson(compositeData.resourceData().dataNodes().get(0));
    }
    if (rootNode != null) {
        inputStream = IOUtils.toInputStream(rootNode.toString());
    }
    CompositeStream compositeStream = new DefaultCompositeStream(uriString, inputStream);
    return compositeStream;
}
#end_block

#method_before
@Override
public void enterDataNode(DataNode dataNode) {
    String nodeName = getNodeNameWithNamespace(dataNode.key().schemaId());
    switch(dataNode.type()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            if (isFirstSibling((InnerNode) dataNode)) {
                jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.ARRAY);
            }
            jsonBuilder.addNodeTopHalf("", JsonNodeType.OBJECT);
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeWithValueTopHalf(nodeName, ((LeafNode) dataNode).value().toString());
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeWithSetTopHalf(nodeName, new HashSet<String>((Integer) ((LeafNode) dataNode).value()));
            break;
        default:
            break;
    }
}
#method_after
@Override
public void enterDataNode(DataNode dataNode, DataNodeSiblingPositionType siblingType) {
    String nodeName = getNodeNameWithNamespace(dataNode.key().schemaId());
    switch(dataNode.type()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            if (siblingType == FIRST_INSTANCE || siblingType == SINGLE_INSTANCE_IN_MULTI_NODE) {
                jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.ARRAY);
            }
            jsonBuilder.addNodeTopHalf("", JsonNodeType.OBJECT);
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeWithValueTopHalf(nodeName, ((LeafNode) dataNode).value().toString());
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            if (siblingType == FIRST_INSTANCE || siblingType == SINGLE_INSTANCE_IN_MULTI_NODE) {
                jsonBuilder.addNodeTopHalf(nodeName, JsonNodeType.ARRAY);
            }
            jsonBuilder.addValueToLeafListNode(((LeafNode) dataNode).value().toString());
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void exitDataNode(DataNode dataNode) {
    switch(dataNode.type()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
            if (isLastSibling((InnerNode) dataNode)) {
                jsonBuilder.addNodeBottomHalf(JsonNodeType.ARRAY);
            }
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.STRING);
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.ARRAY);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void exitDataNode(DataNode dataNode, DataNodeSiblingPositionType siblingType) {
    switch(dataNode.type()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
            if (siblingType == LAST_INSTANCE || siblingType == SINGLE_INSTANCE_IN_MULTI_NODE) {
                jsonBuilder.addNodeBottomHalf(JsonNodeType.ARRAY);
            }
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.STRING);
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.STRING);
            if (siblingType == LAST_INSTANCE || siblingType == SINGLE_INSTANCE_IN_MULTI_NODE) {
                jsonBuilder.addNodeBottomHalf(JsonNodeType.ARRAY);
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
public static ResourceId convertUriToRid(String uriString, YangSerializerContext yangSerializerContext) {
    checkNotNull(uriString, "uri identifier should not be null");
    List<String> paths = urlPathArgsDecode(SLASH_SPLITTER.split(uriString));
    if (!paths.isEmpty()) {
        ResourceId.Builder ridBuilder = SerializerHelper.initializeResourceId(yangSerializerContext);
        processPathSegments(paths, ridBuilder);
        return ridBuilder.build();
    }
    return null;
}
#method_after
public static ResourceId convertUriToRid(String uriString, YangSerializerContext context) {
    if (uriString == null || uriString.isEmpty()) {
        return null;
    }
    List<String> paths = urlPathArgsDecode(SLASH_SPLITTER.split(uriString));
    if (!paths.isEmpty()) {
        ResourceId.Builder ridBuilder = SerializerHelper.initializeResourceId(context);
        processPathSegments(paths, ridBuilder);
        return ridBuilder.build();
    }
    return null;
}
#end_block

#method_before
public static DataNode convertJsonToDataNode(ObjectNode rootNode, ResourceId.Builder ridBuilder) {
    checkNotNull(rootNode, "Input JSON data should not be null");
    checkNotNull(ridBuilder, "RID builder should not be null");
    DataNode.Builder dataNodeBuilder = SerializerHelper.initializeDataNode(ridBuilder);
    JsonWalker jsonWalker = new DefaultJsonWalker(dataNodeBuilder);
    jsonWalker.walkJsonNode(null, rootNode);
    return dataNodeBuilder.build();
}
#method_after
public static DataNode convertJsonToDataNode(ObjectNode rootNode, YangSerializerContext context) {
    if (rootNode == null || context == null) {
        return null;
    }
    DataNode.Builder dataNodeBuilder = SerializerHelper.initializeDataNode(context);
    JsonWalker jsonWalker = new DefaultJsonWalker(dataNodeBuilder);
    jsonWalker.walkJsonNode(null, rootNode);
    return dataNodeBuilder.build();
}
#end_block

#method_before
public static DataNode convertJsonToDataNode(ObjectNode rootNode, ResourceId.Builder ridBuilder) {
    checkNotNull(rootNode, "Input JSON data should not be null");
    checkNotNull(ridBuilder, "RID builder should not be null");
    DataNode.Builder dataNodeBuilder = SerializerHelper.initializeDataNode(ridBuilder);
    JsonWalker jsonWalker = new DefaultJsonWalker(dataNodeBuilder);
    jsonWalker.walkJsonNode(null, rootNode);
    return dataNodeBuilder.build();
}
#method_after
public static DataNode convertJsonToDataNode(ObjectNode rootNode, ResourceId.Builder ridBuilder) {
    if (rootNode == null || ridBuilder == null) {
        return null;
    }
    DataNode.Builder dataNodeBuilder = SerializerHelper.initializeDataNode(ridBuilder);
    JsonWalker jsonWalker = new DefaultJsonWalker(dataNodeBuilder);
    jsonWalker.walkJsonNode(null, rootNode);
    return dataNodeBuilder.build();
}
#end_block

#method_before
public static List<String> urlPathArgsDecode(Iterable<String> paths) {
    try {
        List<String> decodedPathArgs = new ArrayList<>();
        for (String pathArg : paths) {
            String decode = URLDecoder.decode(pathArg, URI_ENCODING_CHAR_SET);
            decodedPathArgs.add(decode);
        }
        return decodedPathArgs;
    } catch (UnsupportedEncodingException e) {
        throw new JsonParseException("Invalid URL path arg '" + paths + "': ", e);
    }
}
#method_after
public static List<String> urlPathArgsDecode(Iterable<String> paths) {
    try {
        List<String> decodedPathArgs = new ArrayList<>();
        for (String pathArg : paths) {
            String decode = URLDecoder.decode(pathArg, URI_ENCODING_CHAR_SET);
            decodedPathArgs.add(decode);
        }
        return decodedPathArgs;
    } catch (UnsupportedEncodingException e) {
        throw new SerializerException("Invalid URL path arg '" + paths + "': ", e);
    }
}
#end_block

#method_before
private static void addListOrLeafList(String path, String namespace, ResourceId.Builder builder) {
    String nodeName = getPreSegment(path, EQUAL);
    String keyStr = getLatterSegment(path, EQUAL);
    if (keyStr == null) {
        throw new JsonParseException(ERROR_LIST_MSG);
    }
    if (keyStr.contains(COMMA)) {
        List<String> keys = Lists.newArrayList(COMMA_SPLITTER.split(keyStr));
        SerializerHelper.addToResourceId(builder, nodeName, namespace, keys);
    } else {
        SerializerHelper.addToResourceId(builder, nodeName, namespace, Lists.newArrayList(keyStr));
    }
}
#method_after
private static void addListOrLeafList(String path, String namespace, ResourceId.Builder builder) {
    String nodeName = getPreSegment(path, EQUAL);
    String keyStr = getLatterSegment(path, EQUAL);
    if (keyStr == null) {
        throw new SerializerException(ERROR_LIST_MSG);
    }
    if (keyStr.contains(COMMA)) {
        List<String> keys = Lists.newArrayList(COMMA_SPLITTER.split(keyStr));
        SerializerHelper.addToResourceId(builder, nodeName, namespace, keys);
    } else {
        SerializerHelper.addToResourceId(builder, nodeName, namespace, Lists.newArrayList(keyStr));
    }
}
#end_block

#method_before
public static String convertRidToUri(ResourceId rid) {
    checkNotNull(rid, "Resource ID cannot be null");
    StringBuilder uriBuilder = new StringBuilder();
    List<NodeKey> nodeKeyList = rid.nodeKeys();
    String curNameSpace = null;
    for (NodeKey key : nodeKeyList) {
        curNameSpace = addNodeKeyToUri(key, curNameSpace, uriBuilder);
    }
    return uriBuilder.toString();
}
#method_after
public static String convertRidToUri(ResourceId rid) {
    if (rid == null) {
        return null;
    }
    StringBuilder uriBuilder = new StringBuilder();
    List<NodeKey> nodeKeyList = rid.nodeKeys();
    String curNameSpace = null;
    for (NodeKey key : nodeKeyList) {
        curNameSpace = addNodeKeyToUri(key, curNameSpace, uriBuilder);
    }
    return uriBuilder.toString();
}
#end_block

#method_before
private static String addNodeKeyToUri(NodeKey key, String curNameSpace, StringBuilder uriBuilder) {
    String newNameSpace = null;
    if (key instanceof LeafListKey) {
        newNameSpace = addLeafListNodeToUri((LeafListKey) key, curNameSpace, uriBuilder);
    } else if (key instanceof ListKey) {
        newNameSpace = addListNodeToUri((ListKey) key, curNameSpace, uriBuilder);
    } else {
        uriBuilder.append(SLASH);
        newNameSpace = addNodeNameToUri(key, curNameSpace, uriBuilder);
    }
    return newNameSpace;
}
#method_after
private static String addNodeKeyToUri(NodeKey key, String curNameSpace, StringBuilder uriBuilder) {
    String newNameSpace;
    if (key instanceof LeafListKey) {
        newNameSpace = addLeafListNodeToUri((LeafListKey) key, curNameSpace, uriBuilder);
    } else if (key instanceof ListKey) {
        newNameSpace = addListNodeToUri((ListKey) key, curNameSpace, uriBuilder);
    } else {
        uriBuilder.append(SLASH);
        newNameSpace = addNodeNameToUri(key, curNameSpace, uriBuilder);
    }
    return newNameSpace;
}
#end_block

#method_before
public static ObjectNode convertDataNodeToJson(DataNode dataNode) {
    checkNotNull(dataNode, "data node cannot be null");
    JsonBuilder jsonBuilder = new DefaultJsonBuilder();
    DataNodeVisitor treeNodeListener = new DataNodeJsonVisitor(jsonBuilder);
    walkDataNodeTree(treeNodeListener, dataNode);
    ObjectNode resultData = jsonBuilder.getTreeNode();
    return resultData;
}
#method_after
public static ObjectNode convertDataNodeToJson(DataNode dataNode) {
    checkNotNull(dataNode, "data node cannot be null");
    JsonBuilder jsonBuilder = new DefaultJsonBuilder();
    DataNodeVisitor treeNodeListener = new DataNodeJsonVisitor(jsonBuilder);
    DataNodeSiblingPositionType siblingType = NOT_MULTI_INSTANCE_NODE;
    walkDataNodeTree(treeNodeListener, dataNode, siblingType);
    ObjectNode resultData = jsonBuilder.getTreeNode();
    return resultData;
}
#end_block

#method_before
private static void walkDataNodeTree(DataNodeVisitor treeNodeListener, DataNode dataNode) {
    checkNotNull(dataNode, "data tree cannot be null");
    checkNotNull(treeNodeListener, "treeNodeListener cannot be null");
    // depth-first walk of the data node tree
    treeNodeListener.enterDataNode(dataNode);
    if (dataNode.type() == DataNode.Type.SINGLE_INSTANCE_NODE || dataNode.type() == DataNode.Type.MULTI_INSTANCE_NODE) {
        for (DataNode child : ((InnerNode) dataNode).childNodes().values()) {
            walkDataNodeTree(treeNodeListener, child);
        }
    }
    treeNodeListener.exitDataNode(dataNode);
}
#method_after
private static void walkDataNodeTree(DataNodeVisitor dataNodeVisitor, DataNode dataNode, DataNodeSiblingPositionType siblingType) {
    checkNotNull(dataNode, "data tree cannot be null");
    checkNotNull(dataNodeVisitor, "dataNodeVisitor cannot be null");
    // depth-first walk of the data node tree
    dataNodeVisitor.enterDataNode(dataNode, siblingType);
    if (dataNode.type() == SINGLE_INSTANCE_NODE || dataNode.type() == MULTI_INSTANCE_NODE) {
        // Walk through every child on the children list
        walkChildNodeList(dataNodeVisitor, dataNode);
    }
    dataNodeVisitor.exitDataNode(dataNode, siblingType);
}
#end_block

#method_before
private void addSingleInstanceNodeToDataTree(String fieldName) {
    addNoneLeafDataNode(fieldName, DataNode.Type.SINGLE_INSTANCE_NODE);
}
#method_after
private void addSingleInstanceNodeToDataTree(String fieldName) {
    addNoneLeafDataNode(fieldName, SINGLE_INSTANCE_NODE);
}
#end_block

#method_before
private void addMultiInstanceNodeToDataTree(String fieldName) {
    addNoneLeafDataNode(fieldName, DataNode.Type.MULTI_INSTANCE_NODE);
}
#method_after
private void addMultiInstanceNodeToDataTree(String fieldName) {
    addNoneLeafDataNode(fieldName, MULTI_INSTANCE_NODE);
}
#end_block

#method_before
private void addLeafNodeToDataTree(String fieldName, JsonNode jsonNode) {
    String value = jsonNode.asText();
    addLeafDataNode(fieldName, value, DataNode.Type.SINGLE_INSTANCE_LEAF_VALUE_NODE);
}
#method_after
private void addLeafNodeToDataTree(String fieldName, JsonNode jsonNode) {
    String value = jsonNode.asText();
    addLeafDataNode(fieldName, value, SINGLE_INSTANCE_LEAF_VALUE_NODE);
}
#end_block

#method_before
private void addLeafListNodeToDataTree(String fieldName, ArrayNode jsonNode) {
    Iterator<JsonNode> elements = jsonNode.elements();
    while (elements.hasNext()) {
        JsonNode element = elements.next();
        JsonNodeType eleType = element.getNodeType();
        if (eleType == JsonNodeType.STRING || eleType == JsonNodeType.NUMBER) {
            addLeafDataNode(fieldName, element.asText(), DataNode.Type.MULTI_INSTANCE_LEAF_VALUE_NODE);
            SerializerHelper.exitDataNode(dataNodeBuilder);
        }
    }
}
#method_after
private void addLeafListNodeToDataTree(String fieldName, ArrayNode jsonNode) {
    Iterator<JsonNode> elements = jsonNode.elements();
    while (elements.hasNext()) {
        JsonNode element = elements.next();
        JsonNodeType eleType = element.getNodeType();
        if (eleType == JsonNodeType.STRING || eleType == JsonNodeType.NUMBER) {
            addLeafDataNode(fieldName, element.asText(), MULTI_INSTANCE_LEAF_VALUE_NODE);
            SerializerHelper.exitDataNode(dataNodeBuilder);
        }
    }
}
#end_block

#method_before
private LinkDescription createOrUpdateLinkInternal(LinkDescription current, LinkDescription updated) {
    if (current != null) {
        // we only allow transition from INDIRECT -> DIRECT
        Type type;
        if (current.type() == DIRECT && updated.type() == Type.INDIRECT) {
            type = Type.DIRECT;
        } else {
            type = updated.type();
        }
        return new DefaultLinkDescription(current.src(), current.dst(), type, current.isExpected(), union(current.annotations(), updated.annotations()));
    }
    return updated;
}
#method_after
private LinkDescription createOrUpdateLinkInternal(LinkDescription current, LinkDescription updated) {
    if (current != null) {
        Type type;
        if (current.type() == DIRECT && updated.type() == Type.INDIRECT) {
            // mask transition from DIRECT -> INDIRECT, likely to be triggered by BDDP
            type = Type.DIRECT;
        } else {
            type = updated.type();
        }
        return new DefaultLinkDescription(current.src(), current.dst(), type, current.isExpected(), union(current.annotations(), updated.annotations()));
    }
    return updated;
}
#end_block

#method_before
protected CodecContext getJsonCodecContext() {
    if (codecContext != null)
        return codecContext;
    codecContext = new MessageCodecContext();
    return codecContext;
}
#method_after
protected CodecContext getJsonCodecContext() {
    if (codecContext != null) {
        return codecContext;
    }
    codecContext = new MessageCodecContext();
    return codecContext;
}
#end_block

#method_before
@Override
public void groupOperationFailed(NetworkId networkId, DeviceId deviceId, GroupOperation operation) {
    store.groupOperationFailed(networkId(), deviceId, operation);
}
#method_after
@Override
public void groupOperationFailed(DeviceId deviceId, GroupOperation operation) {
    store.groupOperationFailed(networkId(), deviceId, operation);
}
#end_block

#method_before
@Override
public void pushGroupMetrics(NetworkId networkId, DeviceId deviceId, Collection<Group> groupEntries) {
    log.trace("Received group metrics from device {}", deviceId);
    checkValidity();
    store.pushGroupMetrics(networkId(), deviceId, groupEntries);
}
#method_after
@Override
public void pushGroupMetrics(DeviceId deviceId, Collection<Group> groupEntries) {
    log.trace("Received group metrics from device {}", deviceId);
    checkValidity();
    store.pushGroupMetrics(networkId(), deviceId, groupEntries);
}
#end_block

#method_before
@Override
public void notifyOfFailovers(NetworkId networkId, Collection<Group> failoverGroups) {
    store.notifyOfFailovers(networkId(), failoverGroups);
}
#method_after
@Override
public void notifyOfFailovers(Collection<Group> failoverGroups) {
    store.notifyOfFailovers(networkId(), failoverGroups);
}
#end_block

#method_before
@Override
public Group getGroup(NetworkId networkId, DeviceId deviceId, GroupKey appCookie) {
    return (groupEntriesByKey.get(networkId).get(deviceId) != null) ? groupEntriesByKey.get(networkId).get(deviceId).get(appCookie) : null;
}
#method_after
@Override
public Group getGroup(NetworkId networkId, DeviceId deviceId, GroupKey appCookie) {
    if (groupEntriesByKey.get(networkId) != null && groupEntriesByKey.get(networkId).get(deviceId) != null) {
        return groupEntriesByKey.get(networkId).get(deviceId).get(appCookie);
    }
    return null;
}
#end_block

#method_before
@Override
public Group getGroup(NetworkId networkId, DeviceId deviceId, GroupId groupId) {
    return (groupEntriesById.get(networkId).get(deviceId) != null) ? groupEntriesById.get(networkId).get(deviceId).get(groupId) : null;
}
#method_after
@Override
public Group getGroup(NetworkId networkId, DeviceId deviceId, GroupId groupId) {
    if (groupEntriesById.get(networkId) != null && groupEntriesById.get(networkId).get(deviceId) != null) {
        return groupEntriesById.get(networkId).get(deviceId).get(groupId);
    }
    return null;
}
#end_block

#method_before
private int getFreeGroupIdValue(NetworkId networkId, DeviceId deviceId) {
    int freeId = groupIdGen.incrementAndGet();
    while (true) {
        Group existing = (groupEntriesById.get(networkId).get(deviceId) != null) ? groupEntriesById.get(networkId).get(deviceId).get(new DefaultGroupId(freeId)) : null;
        if (existing == null) {
            existing = (extraneousGroupEntriesById.get(networkId).get(deviceId) != null) ? extraneousGroupEntriesById.get(networkId).get(deviceId).get(new DefaultGroupId(freeId)) : null;
        }
        if (existing != null) {
            freeId = groupIdGen.incrementAndGet();
        } else {
            break;
        }
    }
    return freeId;
}
#method_after
private int getFreeGroupIdValue(NetworkId networkId, DeviceId deviceId) {
    int freeId = groupIdGen.incrementAndGet();
    while (true) {
        Group existing = null;
        if (groupEntriesById.get(networkId) != null && groupEntriesById.get(networkId).get(deviceId) != null) {
            existing = groupEntriesById.get(networkId).get(deviceId).get(new DefaultGroupId(freeId));
        }
        if (existing == null) {
            if (extraneousGroupEntriesById.get(networkId) != null && extraneousGroupEntriesById.get(networkId).get(deviceId) != null) {
                existing = extraneousGroupEntriesById.get(networkId).get(deviceId).get(new DefaultGroupId(freeId));
            }
        }
        if (existing != null) {
            freeId = groupIdGen.incrementAndGet();
        } else {
            break;
        }
    }
    return freeId;
}
#end_block

#method_before
@Override
public void removeGroupEntry(NetworkId networkId, Group group) {
}
#method_after
@Override
public void removeGroupEntry(NetworkId networkId, Group group) {
    StoredGroupEntry existing = null;
    if (groupEntriesById.get(networkId) != null && groupEntriesById.get(networkId).get(group.deviceId()) != null) {
        existing = groupEntriesById.get(networkId).get(group.deviceId()).get(group.id());
    }
    if (existing != null) {
        ConcurrentMap<GroupKey, StoredGroupEntry> keyTable = getGroupKeyTable(networkId, existing.deviceId());
        ConcurrentMap<GroupId, StoredGroupEntry> idTable = getGroupIdTable(networkId, existing.deviceId());
        idTable.remove(existing.id());
        keyTable.remove(existing.appCookie());
        notifyDelegate(networkId, new GroupEvent(GroupEvent.Type.GROUP_REMOVED, existing));
    }
}
#end_block

#method_before
@Override
public void purgeGroupEntry(NetworkId networkId, DeviceId deviceId) {
}
#method_after
@Override
public void purgeGroupEntry(NetworkId networkId, DeviceId deviceId) {
    if (groupEntriesById.get(networkId) != null) {
        Set<Map.Entry<GroupId, StoredGroupEntry>> entryPendingRemove = groupEntriesById.get(networkId).get(deviceId).entrySet();
        groupEntriesById.get(networkId).remove(deviceId);
        groupEntriesByKey.get(networkId).remove(deviceId);
        entryPendingRemove.forEach(entry -> {
            notifyDelegate(networkId, new GroupEvent(GroupEvent.Type.GROUP_REMOVED, entry.getValue()));
        });
    }
}
#end_block

#method_before
@Override
public void addOrUpdateExtraneousGroupEntry(NetworkId networkId, Group group) {
}
#method_after
@Override
public void addOrUpdateExtraneousGroupEntry(NetworkId networkId, Group group) {
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(networkId, group.deviceId());
    extraneousIdTable.put(group.id(), group);
    // Check the reference counter
    if (group.referenceCount() == 0) {
        notifyDelegate(networkId, new GroupEvent(GroupEvent.Type.GROUP_REMOVE_REQUESTED, group));
    }
}
#end_block

#method_before
@Override
public void removeExtraneousGroupEntry(NetworkId networkId, Group group) {
}
#method_after
@Override
public void removeExtraneousGroupEntry(NetworkId networkId, Group group) {
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(networkId, group.deviceId());
    extraneousIdTable.remove(group.id());
}
#end_block

#method_before
@Override
public Iterable<Group> getExtraneousGroups(NetworkId networkId, DeviceId deviceId) {
    return null;
}
#method_after
@Override
public Iterable<Group> getExtraneousGroups(NetworkId networkId, DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    return FluentIterable.from(getExtraneousGroupIdTable(networkId, deviceId).values());
}
#end_block

#method_before
@Override
public void deviceInitialAuditCompleted(NetworkId networkId, DeviceId deviceId, boolean completed) {
}
#method_after
@Override
public void deviceInitialAuditCompleted(NetworkId networkId, DeviceId deviceId, boolean completed) {
    deviceAuditStatus.computeIfAbsent(networkId, k -> new HashMap<>());
    HashMap<DeviceId, Boolean> deviceAuditStatusByNetwork = deviceAuditStatus.get(networkId);
    synchronized (deviceAuditStatusByNetwork) {
        if (completed) {
            log.debug("deviceInitialAuditCompleted: AUDIT " + "completed for device {}", deviceId);
            deviceAuditStatusByNetwork.put(deviceId, true);
            // Execute all pending group requests
            ConcurrentMap<GroupKey, StoredGroupEntry> pendingGroupRequests = getPendingGroupKeyTable(networkId, deviceId);
            for (Group group : pendingGroupRequests.values()) {
                GroupDescription tmp = new DefaultGroupDescription(group.deviceId(), group.type(), group.buckets(), group.appCookie(), group.givenGroupId(), group.appId());
                storeGroupDescriptionInternal(networkId, tmp);
            }
            getPendingGroupKeyTable(networkId, deviceId).clear();
        } else {
            if (deviceAuditStatusByNetwork.get(deviceId)) {
                log.debug("deviceInitialAuditCompleted: Clearing AUDIT " + "status for device {}", deviceId);
                deviceAuditStatusByNetwork.put(deviceId, false);
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean deviceInitialAuditStatus(NetworkId networkId, DeviceId deviceId) {
    return false;
}
#method_after
@Override
public boolean deviceInitialAuditStatus(NetworkId networkId, DeviceId deviceId) {
    deviceAuditStatus.computeIfAbsent(networkId, k -> new HashMap<>());
    HashMap<DeviceId, Boolean> deviceAuditStatusByNetwork = deviceAuditStatus.get(networkId);
    synchronized (deviceAuditStatusByNetwork) {
        return (deviceAuditStatusByNetwork.get(deviceId) != null) ? deviceAuditStatusByNetwork.get(deviceId) : false;
    }
}
#end_block

#method_before
@Override
public void groupOperationFailed(NetworkId networkId, DeviceId deviceId, GroupOperation operation) {
}
#method_after
@Override
public void groupOperationFailed(NetworkId networkId, DeviceId deviceId, GroupOperation operation) {
    StoredGroupEntry existing = null;
    if (groupEntriesById.get(networkId) != null && groupEntriesById.get(networkId).get(deviceId) != null) {
        existing = groupEntriesById.get(networkId).get(deviceId).get(operation.groupId());
    }
    if (existing == null) {
        log.warn("No group entry with ID {} found ", operation.groupId());
        return;
    }
    switch(operation.opType()) {
        case ADD:
            notifyDelegate(networkId, new GroupEvent(GroupEvent.Type.GROUP_ADD_FAILED, existing));
            break;
        case MODIFY:
            notifyDelegate(networkId, new GroupEvent(GroupEvent.Type.GROUP_UPDATE_FAILED, existing));
            break;
        case DELETE:
            notifyDelegate(networkId, new GroupEvent(GroupEvent.Type.GROUP_REMOVE_FAILED, existing));
            break;
        default:
            log.warn("Unknown group operation type {}", operation.opType());
    }
    ConcurrentMap<GroupKey, StoredGroupEntry> keyTable = getGroupKeyTable(networkId, existing.deviceId());
    ConcurrentMap<GroupId, StoredGroupEntry> idTable = getGroupIdTable(networkId, existing.deviceId());
    idTable.remove(existing.id());
    keyTable.remove(existing.appCookie());
}
#end_block

#method_before
@Override
public void pushGroupMetrics(NetworkId networkId, DeviceId deviceId, Collection<Group> groupEntries) {
}
#method_after
@Override
public void pushGroupMetrics(NetworkId networkId, DeviceId deviceId, Collection<Group> groupEntries) {
    boolean deviceInitialAuditStatus = deviceInitialAuditStatus(networkId, deviceId);
    Set<Group> southboundGroupEntries = Sets.newHashSet(groupEntries);
    Set<Group> storedGroupEntries = Sets.newHashSet(getGroups(networkId, deviceId));
    Set<Group> extraneousStoredEntries = Sets.newHashSet(getExtraneousGroups(networkId, deviceId));
    if (log.isTraceEnabled()) {
        log.trace("pushGroupMetrics: Displaying all ({}) " + "southboundGroupEntries for device {}", southboundGroupEntries.size(), deviceId);
        for (Group group : southboundGroupEntries) {
            log.trace("Group {} in device {}", group, deviceId);
        }
        log.trace("Displaying all ({}) stored group entries for device {}", storedGroupEntries.size(), deviceId);
        for (Group group : storedGroupEntries) {
            log.trace("Stored Group {} for device {}", group, deviceId);
        }
    }
    for (Iterator<Group> it2 = southboundGroupEntries.iterator(); it2.hasNext(); ) {
        Group group = it2.next();
        if (storedGroupEntries.remove(group)) {
            // we both have the group, let's update some info then.
            log.trace("Group AUDIT: group {} exists " + "in both planes for device {}", group.id(), deviceId);
            groupAdded(networkId, group);
            it2.remove();
        }
    }
    for (Group group : southboundGroupEntries) {
        if (getGroup(networkId, group.deviceId(), group.id()) != null) {
            // in progress while we got a stale info from switch
            if (!storedGroupEntries.remove(getGroup(networkId, group.deviceId(), group.id()))) {
                log.warn("Group AUDIT: Inconsistent state:" + "Group exists in ID based table while " + "not present in key based table");
            }
        } else {
            // there are groups in the switch that aren't in the store
            log.trace("Group AUDIT: extraneous group {} exists " + "in data plane for device {}", group.id(), deviceId);
            extraneousStoredEntries.remove(group);
            extraneousGroup(networkId, group);
        }
    }
    for (Group group : storedGroupEntries) {
        // there are groups in the store that aren't in the switch
        log.trace("Group AUDIT: group {} missing " + "in data plane for device {}", group.id(), deviceId);
        groupMissing(networkId, group);
    }
    for (Group group : extraneousStoredEntries) {
        // there are groups in the extraneous store that
        // aren't in the switch
        log.trace("Group AUDIT: clearing extransoeus group {} " + "from store for device {}", group.id(), deviceId);
        removeExtraneousGroupEntry(networkId, group);
    }
    if (!deviceInitialAuditStatus) {
        log.debug("Group AUDIT: Setting device {} initial " + "AUDIT completed", deviceId);
        deviceInitialAuditCompleted(networkId, deviceId, true);
    }
}
#end_block

#method_before
@Override
public void notifyOfFailovers(NetworkId networkId, Collection<Group> failoverGroups) {
}
#method_after
@Override
public void notifyOfFailovers(NetworkId networkId, Collection<Group> failoverGroups) {
    List<GroupEvent> failoverEvents = new ArrayList<>();
    failoverGroups.forEach(group -> {
        if (group.type() == Group.Type.FAILOVER) {
            failoverEvents.add(new GroupEvent(GroupEvent.Type.GROUP_BUCKET_FAILOVER, group));
        }
    });
    notifyDelegate(networkId, failoverEvents);
}
#end_block

#method_before
@Override
public String getPortUuid(String portName, String bridgeUuid) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Row bridgeRow = getRow(DATABASENAME, BRIDGE, bridgeUuid);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    if (bridge != null) {
        OvsdbSet setPorts = (OvsdbSet) bridge.getPortsColumn().data();
        @SuppressWarnings("unchecked")
        Set<Uuid> ports = setPorts.set();
        if (ports == null || ports.size() == 0) {
            log.warn("The port uuid is null");
            return null;
        }
        for (Uuid uuid : ports) {
            Row portRow = getRow(DATABASENAME, PORT, uuid.value());
            Port port = (Port) TableGenerator.getTable(dbSchema, portRow, OvsdbTable.PORT);
            if (port != null && portName.equalsIgnoreCase(port.getName())) {
                return uuid.value();
            }
        }
    }
    return null;
}
#method_after
@Override
public String getPortUuid(String portName, String bridgeUuid) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Row bridgeRow = getRow(DATABASENAME, BRIDGE, bridgeUuid);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    if (bridge != null) {
        OvsdbSet setPorts = (OvsdbSet) bridge.getPortsColumn().data();
        @SuppressWarnings("unchecked")
        Set<Uuid> ports = setPorts.set();
        if (ports == null || ports.isEmpty()) {
            log.warn("The port uuid is null");
            return null;
        }
        for (Uuid uuid : ports) {
            Row portRow = getRow(DATABASENAME, PORT, uuid.value());
            Port port = (Port) TableGenerator.getTable(dbSchema, portRow, OvsdbTable.PORT);
            if (port != null && portName.equalsIgnoreCase(port.getName())) {
                return uuid.value();
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean createQos(String portName, OvsdbQos ovsdbQos) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Qos qos = (Qos) TableGenerator.createTable(dbSchema, OvsdbTable.QOS);
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, PORT);
    if (rowStore == null) {
        log.error("The port table is null");
        return false;
    }
    ConcurrentMap<String, Row> ovsTableRows = rowStore.getRowStore();
    Row portRow = ovsTableRows.values().stream().filter(r -> r.getColumn("name").data().equals(portName)).findFirst().orElse(null);
    if (portRow == null) {
        log.warn("Couldn't find port {} in ovsdb port table.", portName);
        return false;
    }
    Uuid portUuid = portRow.uuid();
    String qosUuid;
    if (!((OvsdbSet) portRow.getColumn(PORT_QOS).data()).set().stream().findAny().isPresent()) {
        ArrayList<Operation> operations = Lists.newArrayList();
        Map<String, String> otherConfigs = Maps.newHashMap();
        Set<String> types = Sets.newHashSet();
        Map<Long, Uuid> queues = Maps.newHashMap();
        types.add(ovsdbQos.qosType().toString());
        otherConfigs.put(MAX_RATE, ovsdbQos.qosMaxRate().toString());
        for (Map.Entry<Long, String> entry : ovsdbQos.qosQueues().entrySet()) {
            queues.put(entry.getKey(), Uuid.uuid(entry.getValue()));
        }
        qos.setOtherConfig(otherConfigs);
        qos.setType(types);
        qos.setQueues(queues);
        Insert qosInsert = new Insert(dbSchema.getTableSchema(QOS), QOS, qos.getRow());
        operations.add(qosInsert);
        List<OperationResult> results;
        try {
            results = transactConfig(DATABASENAME, operations).get();
            qosUuid = results.get(0).getUuid().value();
        } catch (InterruptedException | ExecutionException e) {
            return false;
        }
    } else {
        log.debug("The port already has a Qos configuration");
        return true;
    }
    Map<String, Column> columns = new HashMap<>();
    Row newPortRow = new Row(PORT, portUuid, columns);
    Port newport = new Port(dbSchema, newPortRow);
    Set<Uuid> qoses = new HashSet<>();
    qoses.add(Uuid.uuid(qosUuid));
    columns.put(Port.PortColumn.QOS.columnName(), newport.getQosColumn());
    newport.setQos(qoses);
    updateConfig(PORT, UUID, portUuid.value(), newport.getRow());
    return true;
}
#method_after
@Override
public boolean createQos(OvsdbQos ovsdbQos) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Qos qos = (Qos) TableGenerator.createTable(dbSchema, OvsdbTable.QOS);
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, QOS);
    if (rowStore == null) {
        log.debug("The qos uuid is null");
        return false;
    }
    ArrayList<Operation> operations = Lists.newArrayList();
    Set<String> types = Sets.newHashSet();
    Map<Long, Uuid> queues = Maps.newHashMap();
    types.add(ovsdbQos.qosType());
    qos.setOtherConfig(ovsdbQos.otherConfigs());
    qos.setExternalIds(ovsdbQos.externalIds());
    qos.setType(types);
    if (ovsdbQos.qosQueues().isPresent()) {
        for (Map.Entry<Long, String> entry : ovsdbQos.qosQueues().get().entrySet()) {
            OvsdbRowStore queueRowStore = getRowStore(DATABASENAME, QUEUE);
            if (queueRowStore != null) {
                ConcurrentMap<String, Row> queueTableRows = queueRowStore.getRowStore();
                Row queueRow = queueTableRows.values().stream().filter(r -> {
                    OvsdbMap ovsdbMap = (OvsdbMap) (r.getColumn(EXTERNAL_ID).data());
                    return entry.getValue().equals(ovsdbMap.map().get(QUEUE_EXTERNAL_ID_KEY));
                }).findFirst().orElse(null);
                if (queueRow != null) {
                    queues.put(entry.getKey(), queueRow.uuid());
                }
            }
        }
        qos.setQueues(queues);
    }
    Insert qosInsert = new Insert(dbSchema.getTableSchema(QOS), QOS, qos.getRow());
    operations.add(qosInsert);
    try {
        transactConfig(DATABASENAME, operations).get();
    } catch (InterruptedException | ExecutionException e) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void dropQos(String portName) {
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, PORT);
    if (rowStore == null) {
        log.error("The port table is null");
        return;
    }
    ConcurrentMap<String, Row> portTableRows = rowStore.getRowStore();
    Row portRow = portTableRows.values().stream().filter(r -> r.getColumn("name").data().equals(portName)).findFirst().orElse(null);
    if (portRow == null) {
        log.warn("Couldn't find port {} in ovsdb port table.", portName);
        return;
    }
    OvsdbRowStore qosRowStore = getRowStore(DATABASENAME, QOS);
    if (qosRowStore == null) {
        log.error("The qos table is null");
        return;
    }
    Uuid qosUuid = (Uuid) ((OvsdbSet) portRow.getColumn(PORT_QOS).data()).set().stream().findFirst().orElse(null);
    if (qosUuid == null) {
        log.warn("There is no related qos in port {}.", portName);
        return;
    }
    Row qosRow = getRow(DATABASENAME, QOS, qosUuid.value());
    Map<Long, Uuid> queues = ((OvsdbMap) qosRow.getColumn(Qos.QosColumn.QUEUES.columnName()).data()).map();
    Map<Long, Uuid> queue = new HashMap<>();
    for (Map.Entry<Long, Uuid> entry : queues.entrySet()) {
        queue.put(entry.getKey(), entry.getValue());
        deleteConfig(QUEUE, UUID, entry.getValue().value(), QOS, QUEUES, OvsdbMap.ovsdbMap(queue));
    }
    deleteConfig(QOS, UUID, qosUuid.value(), PORT, PORT_QOS, qosUuid);
}
#method_after
@Override
public void dropQos(QosId qosId) {
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, QOS);
    if (rowStore != null) {
        ConcurrentMap<String, Row> qosTableRows = rowStore.getRowStore();
        Row qosRow = qosTableRows.values().stream().filter(r -> {
            OvsdbMap ovsdbMap = (OvsdbMap) (r.getColumn(EXTERNAL_ID).data());
            return qosId.name().equals(ovsdbMap.map().get(QOS_EXTERNAL_ID_KEY));
        }).findFirst().orElse(null);
        if (qosRow != null) {
            deleteConfig(QOS, UUID, qosRow.uuid().value(), PORT, PORT_QOS, qosRow.uuid());
        }
    }
}
#end_block

#method_before
private String createQueue(OvsdbQueue ovsdbQueue) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Queue queue = (Queue) TableGenerator.createTable(dbSchema, OvsdbTable.QUEUE);
    ArrayList<Operation> operations = Lists.newArrayList();
    Map<String, String> otherConfigs = Maps.newHashMap();
    otherConfigs.put(MAX_RATE, ovsdbQueue.getMaxRate().toString());
    otherConfigs.put(MIN_RATE, ovsdbQueue.getMinRate().toString());
    otherConfigs.put(BURST, ovsdbQueue.getBurst().toString());
    otherConfigs.put(PRIORITY, ovsdbQueue.getPriority().toString());
    queue.setOtherConfig(otherConfigs);
    Insert queueInsert = new Insert(dbSchema.getTableSchema(QUEUE), QUEUE, queue.getRow());
    operations.add(queueInsert);
    List<OperationResult> results;
    try {
        results = transactConfig(DATABASENAME, operations).get();
        return results.get(0).getUuid().value();
    } catch (InterruptedException | ExecutionException e) {
        log.error("createQueue transactConfig get exception !");
    }
    return null;
}
#method_after
@Override
public boolean createQueue(OvsdbQueue ovsdbQueue) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Queue queue = (Queue) TableGenerator.createTable(dbSchema, OvsdbTable.QUEUE);
    ArrayList<Operation> operations = Lists.newArrayList();
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, QUEUE);
    if (rowStore == null) {
        log.debug("The queue uuid is null");
        return false;
    }
    if (ovsdbQueue.dscp().isPresent()) {
        queue.setDscp(ImmutableSet.of(ovsdbQueue.dscp().get()));
    }
    queue.setOtherConfig(ovsdbQueue.otherConfigs());
    queue.setExternalIds(ovsdbQueue.externalIds());
    Insert queueInsert = new Insert(dbSchema.getTableSchema(QUEUE), QUEUE, queue.getRow());
    operations.add(queueInsert);
    try {
        transactConfig(DATABASENAME, operations).get();
    } catch (InterruptedException | ExecutionException e) {
        log.error("createQueue transactConfig get exception !");
    }
    return true;
}
#end_block

#method_before
@Override
public boolean createMirror(String bridgeName, OvsdbMirror mirror) {
    /**
     * Retrieves bridge's uuid. It is necessary to update
     * Bridge table.
     */
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Couldn't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return false;
    }
    OvsdbMirror.Builder mirrorBuilder = OvsdbMirror.builder();
    mirrorBuilder.mirroringName(mirror.mirroringName());
    mirrorBuilder.selectAll(mirror.selectAll());
    /**
     * Retrieves the uuid of the monitored dst ports.
     */
    mirrorBuilder.monitorDstPorts(mirror.monitorDstPorts().parallelStream().map(dstPort -> {
        String dstPortUuid = getPortUuid(dstPort.value(), bridgeUuid);
        if (dstPortUuid != null) {
            return Uuid.uuid(dstPortUuid);
        }
        log.warn("Couldn't find port {} in {}", dstPort.value(), nodeId.getIpAddress());
        return null;
    }).filter(Objects::nonNull).collect(Collectors.toSet()));
    /**
     * Retrieves the uuid of the monitored src ports.
     */
    mirrorBuilder.monitorSrcPorts(mirror.monitorSrcPorts().parallelStream().map(srcPort -> {
        String srcPortUuid = getPortUuid(srcPort.value(), bridgeUuid);
        if (srcPortUuid != null) {
            return Uuid.uuid(srcPortUuid);
        }
        log.warn("Couldn't find port {} in {}", srcPort.value(), nodeId.getIpAddress());
        return null;
    }).filter(Objects::nonNull).collect(Collectors.toSet()));
    mirrorBuilder.monitorVlans(mirror.monitorVlans());
    mirrorBuilder.mirrorPort(mirror.mirrorPort());
    mirrorBuilder.mirrorVlan(mirror.mirrorVlan());
    mirrorBuilder.externalIds(mirror.externalIds());
    mirror = mirrorBuilder.build();
    if (mirror.monitorDstPorts().size() == 0 && mirror.monitorSrcPorts().size() == 0 && mirror.monitorVlans().size() == 0) {
        log.warn("Invalid monitoring data");
        return false;
    }
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Mirror mirrorEntry = (Mirror) TableGenerator.createTable(dbSchema, OvsdbTable.MIRROR);
    mirrorEntry.setName(mirror.mirroringName());
    mirrorEntry.setSelectDstPort(mirror.monitorDstPorts());
    mirrorEntry.setSelectSrcPort(mirror.monitorSrcPorts());
    mirrorEntry.setSelectVlan(mirror.monitorVlans());
    mirrorEntry.setExternalIds(mirror.externalIds());
    /**
     * If mirror port, retrieves the uuid of the mirror port.
     */
    if (mirror.mirrorPort() != null) {
        String outputPortUuid = getPortUuid(mirror.mirrorPort().value(), bridgeUuid);
        if (outputPortUuid == null) {
            log.warn("Couldn't find port {} in {}", mirror.mirrorPort().value(), nodeId.getIpAddress());
            return false;
        }
        mirrorEntry.setOutputPort(Uuid.uuid(outputPortUuid));
    } else if (mirror.mirrorVlan() != null) {
        mirrorEntry.setOutputVlan(mirror.mirrorVlan());
    } else {
        log.warn("Invalid mirror, no mirror port and no mirror vlan");
        return false;
    }
    ArrayList<Operation> operations = Lists.newArrayList();
    Insert mirrorInsert = new Insert(dbSchema.getTableSchema("Mirror"), "Mirror", mirrorEntry.getRow());
    operations.add(mirrorInsert);
    // update the bridge table
    Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(bridgeUuid));
    Mutation mutation = MutationUtil.insert(MIRRORS, Uuid.uuid("Mirror"));
    List<Condition> conditions = Lists.newArrayList(condition);
    List<Mutation> mutations = Lists.newArrayList(mutation);
    operations.add(new Mutate(dbSchema.getTableSchema("Bridge"), conditions, mutations));
    transactConfig(DATABASENAME, operations);
    log.info("Created mirror {}", mirror.mirroringName());
    return true;
}
#method_after
@Override
public boolean createMirror(String bridgeName, OvsdbMirror mirror) {
    /**
     * Retrieves bridge's uuid. It is necessary to update
     * Bridge table.
     */
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Couldn't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return false;
    }
    OvsdbMirror.Builder mirrorBuilder = OvsdbMirror.builder();
    mirrorBuilder.mirroringName(mirror.mirroringName());
    mirrorBuilder.selectAll(mirror.selectAll());
    /**
     * Retrieves the uuid of the monitored dst ports.
     */
    mirrorBuilder.monitorDstPorts(mirror.monitorDstPorts().parallelStream().map(dstPort -> {
        String dstPortUuid = getPortUuid(dstPort.value(), bridgeUuid);
        if (dstPortUuid != null) {
            return Uuid.uuid(dstPortUuid);
        }
        log.warn("Couldn't find port {} in {}", dstPort.value(), nodeId.getIpAddress());
        return null;
    }).filter(Objects::nonNull).collect(Collectors.toSet()));
    /**
     * Retrieves the uuid of the monitored src ports.
     */
    mirrorBuilder.monitorSrcPorts(mirror.monitorSrcPorts().parallelStream().map(srcPort -> {
        String srcPortUuid = getPortUuid(srcPort.value(), bridgeUuid);
        if (srcPortUuid != null) {
            return Uuid.uuid(srcPortUuid);
        }
        log.warn("Couldn't find port {} in {}", srcPort.value(), nodeId.getIpAddress());
        return null;
    }).filter(Objects::nonNull).collect(Collectors.toSet()));
    mirrorBuilder.monitorVlans(mirror.monitorVlans());
    mirrorBuilder.mirrorPort(mirror.mirrorPort());
    mirrorBuilder.mirrorVlan(mirror.mirrorVlan());
    mirrorBuilder.externalIds(mirror.externalIds());
    mirror = mirrorBuilder.build();
    if (mirror.monitorDstPorts().isEmpty() && mirror.monitorSrcPorts().isEmpty() && mirror.monitorVlans().isEmpty()) {
        log.warn("Invalid monitoring data");
        return false;
    }
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Mirror mirrorEntry = (Mirror) TableGenerator.createTable(dbSchema, OvsdbTable.MIRROR);
    mirrorEntry.setName(mirror.mirroringName());
    mirrorEntry.setSelectDstPort(mirror.monitorDstPorts());
    mirrorEntry.setSelectSrcPort(mirror.monitorSrcPorts());
    mirrorEntry.setSelectVlan(mirror.monitorVlans());
    mirrorEntry.setExternalIds(mirror.externalIds());
    /**
     * If mirror port, retrieves the uuid of the mirror port.
     */
    if (mirror.mirrorPort() != null) {
        String outputPortUuid = getPortUuid(mirror.mirrorPort().value(), bridgeUuid);
        if (outputPortUuid == null) {
            log.warn("Couldn't find port {} in {}", mirror.mirrorPort().value(), nodeId.getIpAddress());
            return false;
        }
        mirrorEntry.setOutputPort(Uuid.uuid(outputPortUuid));
    } else if (mirror.mirrorVlan() != null) {
        mirrorEntry.setOutputVlan(mirror.mirrorVlan());
    } else {
        log.warn("Invalid mirror, no mirror port and no mirror vlan");
        return false;
    }
    ArrayList<Operation> operations = Lists.newArrayList();
    Insert mirrorInsert = new Insert(dbSchema.getTableSchema("Mirror"), "Mirror", mirrorEntry.getRow());
    operations.add(mirrorInsert);
    // update the bridge table
    Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(bridgeUuid));
    Mutation mutation = MutationUtil.insert(MIRRORS, Uuid.uuid("Mirror"));
    List<Condition> conditions = Lists.newArrayList(condition);
    List<Mutation> mutations = Lists.newArrayList(mutation);
    operations.add(new Mutate(dbSchema.getTableSchema("Bridge"), conditions, mutations));
    transactConfig(DATABASENAME, operations);
    log.info("Created mirror {}", mirror.mirroringName());
    return true;
}
#end_block

#method_before
private void deleteConfig(String childTableName, String childColumnName, String childUuid, String parentTableName, String parentColumnName, Object parentData) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema childTableSchema = dbSchema.getTableSchema(childTableName);
    ArrayList<Operation> operations = Lists.newArrayList();
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.delete(parentColumnSchema.name(), parentData);
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.includes(parentColumnName, parentData);
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    List<Condition> conditions = Lists.newArrayList();
    Condition condition = ConditionUtil.isEqual(childColumnName, Uuid.uuid(childUuid));
    conditions.add(condition);
    Delete del = new Delete(childTableSchema, conditions);
    operations.add(del);
    transactConfig(DATABASENAME, operations);
}
#method_after
private void deleteConfig(String childTableName, String childColumnName, String childUuid, String parentTableName, String parentColumnName, Object referencedValue) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema childTableSchema = dbSchema.getTableSchema(childTableName);
    ArrayList<Operation> operations = Lists.newArrayList();
    if (parentTableName != null && parentColumnName != null && referencedValue != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.delete(parentColumnSchema.name(), referencedValue);
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.includes(parentColumnName, referencedValue);
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    List<Condition> conditions = Lists.newArrayList();
    Condition condition = ConditionUtil.isEqual(childColumnName, Uuid.uuid(childUuid));
    conditions.add(condition);
    Delete del = new Delete(childTableSchema, conditions);
    operations.add(del);
    transactConfig(DATABASENAME, operations);
}
#end_block

#method_before
private String insertConfig(String childTableName, String childColumnName, String parentTableName, String parentColumnName, String parentUuid, Row row) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema tableSchema = dbSchema.getTableSchema(childTableName);
    Insert insert = new Insert(tableSchema, childTableName, row);
    ArrayList<Operation> operations = Lists.newArrayList();
    operations.add(insert);
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.insert(parentColumnSchema.name(), Uuid.uuid(childTableName));
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(parentUuid));
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    if (childTableName.equalsIgnoreCase(PORT)) {
        log.debug("Handle port insert");
        Insert intfInsert = handlePortInsertTable(row);
        if (intfInsert != null) {
            operations.add(intfInsert);
        }
        Insert ins = (Insert) operations.get(0);
        ins.getRow().put("interfaces", Uuid.uuid(INTERFACE));
    }
    List<OperationResult> results;
    try {
        results = transactConfig(DATABASENAME, operations).get();
        return results.get(0).getUuid().value();
    } catch (InterruptedException e) {
        log.warn("Interrupted while waiting to get result");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
        log.error("Exception thrown while to get result");
    }
    return null;
}
#method_after
private String insertConfig(String childTableName, String childColumnName, String parentTableName, String parentColumnName, String parentUuid, Row row) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema tableSchema = dbSchema.getTableSchema(childTableName);
    Insert insert = new Insert(tableSchema, childTableName, row);
    ArrayList<Operation> operations = Lists.newArrayList();
    operations.add(insert);
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.insert(parentColumnSchema.name(), Uuid.uuid(childTableName));
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(parentUuid));
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    if (childTableName.equalsIgnoreCase(PORT)) {
        log.debug("Handle port insert");
        Insert intfInsert = handlePortInsertTable(row);
        if (intfInsert != null) {
            operations.add(intfInsert);
        }
        Insert ins = (Insert) operations.get(0);
        ins.getRow().put("interfaces", Uuid.uuid(INTERFACE));
    }
    List<OperationResult> results;
    try {
        results = transactConfig(DATABASENAME, operations).get(TRANSACTCONFIG_TIMEOUT, TimeUnit.SECONDS);
        return results.get(0).getUuid().value();
    } catch (TimeoutException e) {
        log.warn("TimeoutException thrown while to get result");
    } catch (InterruptedException e) {
        log.warn("Interrupted while waiting to get result");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
        log.error("Exception thrown while to get result");
    }
    return null;
}
#end_block

#method_before
@Override
public ListenableFuture<List<JsonNode>> transact(DatabaseSchema dbSchema, List<Operation> operations) {
    String id = java.util.UUID.randomUUID().toString();
    String transactString = JsonRpcWriterUtil.transactStr(id, dbSchema, operations);
    SettableFuture<List<JsonNode>> sf = SettableFuture.create();
    requestResult.put(id, sf);
    requestMethod.put(id, "transact");
    log.info(transactString);
    channel.writeAndFlush(transactString);
    return sf;
}
#method_after
@Override
public ListenableFuture<List<JsonNode>> transact(DatabaseSchema dbSchema, List<Operation> operations) {
    String id = java.util.UUID.randomUUID().toString();
    String transactString = JsonRpcWriterUtil.transactStr(id, dbSchema, operations);
    SettableFuture<List<JsonNode>> sf = SettableFuture.create();
    requestResult.put(id, sf);
    requestMethod.put(id, "transact");
    channel.writeAndFlush(transactString);
    return sf;
}
#end_block

#method_before
private OvsdbBridge getOvsdbBridge(Row row) {
    DatabaseSchema dbSchema = getDatabaseSchema(DATABASENAME);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, row, OvsdbTable.BRIDGE);
    if (bridge == null) {
        return null;
    }
    OvsdbSet datapathIdSet = (OvsdbSet) bridge.getDatapathIdColumn().data();
    @SuppressWarnings("unchecked")
    Set<String> datapathIds = datapathIdSet.set();
    if (datapathIds == null || datapathIds.size() == 0) {
        return null;
    }
    String datapathId = (String) datapathIds.toArray()[0];
    String bridgeName = bridge.getName();
    if ((datapathId == null) || (bridgeName == null)) {
        return null;
    }
    return OvsdbBridge.builder().name(bridgeName).datapathId(datapathId).build();
}
#method_after
private OvsdbBridge getOvsdbBridge(Row row) {
    DatabaseSchema dbSchema = getDatabaseSchema(DATABASENAME);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, row, OvsdbTable.BRIDGE);
    if (bridge == null) {
        return null;
    }
    OvsdbSet datapathIdSet = (OvsdbSet) bridge.getDatapathIdColumn().data();
    @SuppressWarnings("unchecked")
    Set<String> datapathIds = datapathIdSet.set();
    if (datapathIds == null || datapathIds.isEmpty()) {
        return null;
    }
    String datapathId = (String) datapathIds.toArray()[0];
    String bridgeName = bridge.getName();
    if ((datapathId == null) || (bridgeName == null)) {
        return null;
    }
    return OvsdbBridge.builder().name(bridgeName).datapathId(datapathId).build();
}
#end_block

#method_before
private long getOfPort(Interface intf) {
    OvsdbSet ofPortSet = (OvsdbSet) intf.getOpenFlowPortColumn().data();
    @SuppressWarnings("unchecked")
    Set<Integer> ofPorts = ofPortSet.set();
    if (ofPorts == null || ofPorts.size() <= 0) {
        log.debug("The ofport is null in {}", intf.getName());
        return -1;
    }
    // return (long) ofPorts.toArray()[0];
    Iterator<Integer> it = ofPorts.iterator();
    return Long.parseLong(it.next().toString());
}
#method_after
private long getOfPort(Interface intf) {
    OvsdbSet ofPortSet = (OvsdbSet) intf.getOpenFlowPortColumn().data();
    @SuppressWarnings("unchecked")
    Set<Integer> ofPorts = ofPortSet.set();
    if (ofPorts == null || ofPorts.isEmpty()) {
        log.debug("The ofport is null in {}", intf.getName());
        return -1;
    }
    // return (long) ofPorts.toArray()[0];
    Iterator<Integer> it = ofPorts.iterator();
    return Long.parseLong(it.next().toString());
}
#end_block

#method_before
@Override
public Long maxRate() {
    return maxRate;
}
#method_after
@Override
public Optional<Bandwidth> maxRate() {
    return maxRate;
}
#end_block

#method_before
@Override
public Integer cir() {
    return cir;
}
#method_after
@Override
public Optional<Long> cir() {
    return cir;
}
#end_block

#method_before
@Override
public Integer cbs() {
    return cbs;
}
#method_after
@Override
public Optional<Long> cbs() {
    return cbs;
}
#end_block

#method_before
@Override
public Map<Long, String> queues() {
    return queues;
}
#method_after
@Override
public Optional<Map<Long, QueueDescription>> queues() {
    return queues;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("type", type()).add("maxRate", maxRate()).add("cir", cir()).add("cbs", cbs()).add("queues", queues()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("qosId", qosId()).add("type", type()).add("maxRate", maxRate().orElse(null)).add("cir", cir().orElse(0L)).add("cbs", cbs().orElse(0L)).add("queues", queues().orElse(null)).toString();
}
#end_block

#method_before
public static QosDescription.Builder builder() {
    return new Builder();
}
#method_after
public static Builder builder() {
    return new Builder();
}
#end_block

#method_before
@Override
public QosDescription build() {
    return new DefaultQosDescription(type, maxRate, cir, cbs, queues);
}
#method_after
@Override
public QosDescription build() {
    return new DefaultQosDescription(qosId, type, maxRate, cir, cbs, queues);
}
#end_block

#method_before
@Override
public DefaultQosDescription.Builder type(Type type) {
    this.type = type;
    return this;
}
#method_after
@Override
public Builder type(Type type) {
    this.type = type;
    return this;
}
#end_block

#method_before
@Override
public DefaultQosDescription.Builder maxRate(Long maxRate) {
    this.maxRate = maxRate;
    return this;
}
#method_after
@Override
public Builder maxRate(Bandwidth maxRate) {
    this.maxRate = Optional.ofNullable(maxRate);
    return this;
}
#end_block

#method_before
@Override
public DefaultQosDescription.Builder cir(Integer cir) {
    this.cir = cir;
    return this;
}
#method_after
@Override
public Builder cir(Long cir) {
    this.cir = Optional.ofNullable(cir);
    return this;
}
#end_block

#method_before
@Override
public DefaultQosDescription.Builder cbs(Integer cbs) {
    this.cbs = cbs;
    return this;
}
#method_after
@Override
public Builder cbs(Long cbs) {
    this.cbs = Optional.ofNullable(cbs);
    return this;
}
#end_block

#method_before
@Override
public DefaultQosDescription.Builder queues(Map<Long, String> queues) {
    this.queues = queues;
    return this;
}
#method_after
@Override
public Builder queues(Map<Long, QueueDescription> queues) {
    this.queues = Optional.ofNullable(queues);
    return this;
}
#end_block

#method_before
@Override
public boolean createQos(String portName, OvsdbQos ovsdbQos) {
    return false;
}
#method_after
@Override
public boolean createQos(OvsdbQos ovsdbQos) {
    return false;
}
#end_block

#method_before
@Override
public void dropQos(String portName) {
}
#method_after
@Override
public void dropQos(QosId qosId) {
}
#end_block

#method_before
public static QueueDescription.Builder builder() {
    return new Builder();
}
#method_after
public static Builder builder() {
    return new Builder();
}
#end_block

#method_before
@Override
public DefaultQueueDescription.Builder queueId(UnsignedInteger queueId) {
    this.queueId = queueId;
    return this;
}
#method_after
@Override
public Builder queueId(QueueId queueId) {
    this.queueId = queueId;
    return this;
}
#end_block

#method_before
@Override
public DefaultQueueDescription.Builder dscp(UnsignedInteger dscp) {
    this.dscp = dscp;
    return this;
}
#method_after
@Override
public Builder dscp(Integer dscp) {
    this.dscp = Optional.ofNullable(dscp);
    return this;
}
#end_block

#method_before
@Override
public DefaultQueueDescription.Builder type(Type type) {
    this.type = type;
    return this;
}
#method_after
@Override
public Builder type(EnumSet<Type> type) {
    this.type = type;
    return this;
}
#end_block

#method_before
@Override
public DefaultQueueDescription.Builder maxRate(Long maxRate) {
    this.maxRate = maxRate;
    return this;
}
#method_after
@Override
public Builder maxRate(Bandwidth maxRate) {
    this.maxRate = Optional.ofNullable(maxRate);
    return this;
}
#end_block

#method_before
@Override
public DefaultQueueDescription.Builder minRate(Long minRate) {
    this.minRate = minRate;
    return this;
}
#method_after
@Override
public Builder minRate(Bandwidth minRate) {
    this.minRate = Optional.ofNullable(minRate);
    return this;
}
#end_block

#method_before
@Override
public DefaultQueueDescription.Builder burst(Long burst) {
    this.burst = burst;
    return this;
}
#method_after
@Override
public Builder burst(Long burst) {
    this.burst = Optional.ofNullable(burst);
    return this;
}
#end_block

#method_before
@Override
public DefaultQueueDescription.Builder priority(Long priority) {
    this.priority = priority;
    return this;
}
#method_after
@Override
public Builder priority(Long priority) {
    this.priority = Optional.ofNullable(priority);
    return this;
}
#end_block

#method_before
public Type qosType() {
    return type;
}
#method_after
public String qosType() {
    return type;
}
#end_block

#method_before
public Map<Long, String> qosQueues() {
    return queues;
}
#method_after
public Optional<Map<Long, String>> qosQueues() {
    return queues;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(type, maxRate, cir, cbs, queues, externalIds);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type, queues, externalIds);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OvsdbQos) {
        final OvsdbQos other = (OvsdbQos) obj;
        return Objects.equals(this.type, other.type) && Objects.equals(this.maxRate, other.maxRate) && Objects.equals(this.cir, other.cir) && Objects.equals(this.cbs, other.cbs) && Objects.equals(this.queues, other.queues) && Objects.equals(this.externalIds, other.externalIds);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OvsdbQos) {
        final OvsdbQos other = (OvsdbQos) obj;
        return Objects.equals(this.type, other.type) && Objects.equals(this.otherConfigs, other.otherConfigs) && Objects.equals(this.queues, other.queues) && Objects.equals(this.externalIds, other.externalIds);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("qosType", qosType()).add("qosMaxRate", qosMaxRate()).add("qosCir", qosCir()).add("qosCbs", qosCbs()).add("qosQueues", qosQueues()).add("externalIds", externalIds()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("qosType", qosType()).add("qosQueues", qosQueues()).add("otherConfigs", otherConfigs()).add("externalIds", externalIds()).toString();
}
#end_block

#method_before
public static OvsdbQos.Builder builder(QosDescription qosDesc) {
    return new OvsdbQos.Builder(qosDesc);
}
#method_after
public static Builder builder(QosDescription qosDesc) {
    return new Builder(qosDesc);
}
#end_block

#method_before
public OvsdbQos build() {
    return new OvsdbQos(type, maxRate, cir, cbs, queues, externalIds);
}
#method_after
public OvsdbQos build() {
    return new OvsdbQos(type, queues, otherConfigs, externalIds);
}
#end_block

#method_before
public OvsdbQos.Builder qosType(Type type) {
    this.type = type;
    return this;
}
#method_after
public Builder qosType(String type) {
    this.type = type;
    return this;
}
#end_block

#method_before
public OvsdbQos.Builder queues(Map<Long, String> queues) {
    this.queues = queues;
    return this;
}
#method_after
public Builder queues(Map<Long, String> queues) {
    this.queues = Optional.ofNullable(queues);
    return this;
}
#end_block

#method_before
public OvsdbQos.Builder externalIds(Map<String, String> ids) {
    this.externalIds = ids;
    return this;
}
#method_after
public Builder externalIds(Map<String, String> ids) {
    this.externalIds = ids;
    return this;
}
#end_block

#method_before
@Override
public List<QueueDescription> getQueues() {
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public Collection<QueueDescription> getQueues() {
    OvsdbClientService ovsdbClient = getOvsdbClient(handler());
    if (ovsdbClient == null) {
        return Collections.emptyList();
    }
    Set<OvsdbQueue> queues = ovsdbClient.getQueues();
    return queues.stream().map(q -> DefaultQueueDescription.builder().queueId(QueueId.queueId(q.externalIds().get(QUEUE_EXTERNAL_ID_KEY))).type(types(q)).dscp(q.dscp().isPresent() ? q.dscp().get().intValue() : null).maxRate(q.otherConfigs().get(MAX_RATE) != null ? Bandwidth.bps(Long.parseLong(q.otherConfigs().get(MAX_RATE))) : Bandwidth.bps(0L)).minRate(q.otherConfigs().get(MIN_RATE) != null ? Bandwidth.bps(Long.parseLong(q.otherConfigs().get(MIN_RATE))) : Bandwidth.bps(0L)).burst(q.otherConfigs().get(BURST) != null ? Long.valueOf(q.otherConfigs().get(BURST)) : 0L).priority(q.otherConfigs().get(PRIORITY) != null ? Long.valueOf(q.otherConfigs().get(PRIORITY)) : 0L).build()).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public QueueDescription getQueue(DeviceId deviceId, PortNumber portNumber, UnsignedInteger queueId) {
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public QueueDescription getQueue(QueueDescription queueDesc) {
    OvsdbClientService ovsdbClient = getOvsdbClient(handler());
    if (ovsdbClient == null) {
        return null;
    }
    OvsdbQueue queue = ovsdbClient.getQueue(queueDesc.queueId());
    if (queue == null) {
        return null;
    }
    return DefaultQueueDescription.builder().queueId(QueueId.queueId(queue.externalIds().get(QUEUE_EXTERNAL_ID_KEY))).type(types(queue)).dscp(queue.dscp().isPresent() ? queue.dscp().get().intValue() : null).maxRate(queue.otherConfigs().get(MAX_RATE) != null ? Bandwidth.bps(Long.parseLong(queue.otherConfigs().get(MAX_RATE))) : Bandwidth.bps(0L)).minRate(queue.otherConfigs().get(MIN_RATE) != null ? Bandwidth.bps(Long.parseLong(queue.otherConfigs().get(MIN_RATE))) : Bandwidth.bps(0L)).burst(queue.otherConfigs().get(BURST) != null ? Long.valueOf(queue.otherConfigs().get(BURST)) : 0L).priority(queue.otherConfigs().get(PRIORITY) != null ? Long.valueOf(queue.otherConfigs().get(PRIORITY)) : 0L).build();
}
#end_block

#method_before
@Override
public List<QosDescription> getQoses() {
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public Collection<QosDescription> getQoses() {
    OvsdbClientService ovsdbClient = getOvsdbClient(handler());
    if (ovsdbClient == null) {
        return null;
    }
    Set<OvsdbQos> qoses = ovsdbClient.getQoses();
    return qoses.stream().map(qos -> DefaultQosDescription.builder().qosId(QosId.qosId(qos.externalIds().get(QOS_EXTERNAL_ID_KEY))).type(QOS_EGRESS_POLICER.equals(qos.qosType()) ? QosDescription.Type.EGRESS_POLICER : QosDescription.Type.valueOf(qos.qosType().replace(QOS_TYPE_PREFIX, "").toUpperCase())).maxRate(qos.otherConfigs().get(MAX_RATE) != null ? Bandwidth.bps(Long.parseLong(qos.otherConfigs().get(MAX_RATE))) : Bandwidth.bps(0L)).cbs(qos.otherConfigs().get(CBS) != null ? Long.valueOf(qos.otherConfigs().get(CBS)) : null).cir(qos.otherConfigs().get(CIR) != null ? Long.valueOf(qos.otherConfigs().get(CIR)) : null).build()).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public QosDescription getQos(DeviceId deviceId, PortNumber portNumber) {
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public QosDescription getQos(QosDescription qosDesc) {
    OvsdbClientService ovsdbClient = getOvsdbClient(handler());
    if (ovsdbClient == null) {
        return null;
    }
    OvsdbQos qos = ovsdbClient.getQos(qosDesc.qosId());
    if (qos == null) {
        return null;
    }
    return DefaultQosDescription.builder().qosId(QosId.qosId(qos.externalIds().get(QOS_EXTERNAL_ID_KEY))).type(QOS_EGRESS_POLICER.equals(qos.qosType()) ? QosDescription.Type.EGRESS_POLICER : QosDescription.Type.valueOf(qos.qosType().replace(QOS_TYPE_PREFIX, "").toUpperCase())).maxRate(qos.otherConfigs().get(MAX_RATE) != null ? Bandwidth.bps(Long.parseLong(qos.otherConfigs().get(MAX_RATE))) : Bandwidth.bps(0L)).cbs(qos.otherConfigs().get(CBS) != null ? Long.valueOf(qos.otherConfigs().get(CBS)) : null).cir(qos.otherConfigs().get(CIR) != null ? Long.valueOf(qos.otherConfigs().get(CIR)) : null).build();
}
#end_block

#method_before
public UnsignedInteger dscp() {
    return dscp;
}
#method_after
public Optional<Long> dscp() {
    return dscp;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(queueId, dscp, maxRate, minRate, burst, priority, externalIds);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(dscp, otherConfigs, externalIds);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OvsdbQueue) {
        final OvsdbQueue other = (OvsdbQueue) obj;
        return Objects.equals(this.queueId, other.queueId) && Objects.equals(this.dscp, other.dscp) && Objects.equals(this.maxRate, other.maxRate) && Objects.equals(this.minRate, other.minRate) && Objects.equals(this.burst, other.burst) && Objects.equals(this.priority, other.priority) && Objects.equals(this.externalIds, other.externalIds);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OvsdbQueue) {
        final OvsdbQueue other = (OvsdbQueue) obj;
        return Objects.equals(this.dscp, other.dscp) && Objects.equals(this.otherConfigs, other.otherConfigs) && Objects.equals(this.externalIds, other.externalIds);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("queueId", queueId()).add("dscp", dscp()).add("maxRate", getMaxRate()).add("minRate", getMinRate()).add("burst", getBurst()).add("priority", getPriority()).add("externalIds", externalIds()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("dscp", dscp()).add("maxRate", otherConfigs()).add("externalIds", externalIds()).toString();
}
#end_block

#method_before
public static OvsdbQueue.Builder builder(QueueDescription queueDescription) {
    return new OvsdbQueue.Builder(queueDescription);
}
#method_after
public static Builder builder(QueueDescription queueDescription) {
    return new Builder(queueDescription);
}
#end_block

#method_before
public OvsdbQueue build() {
    return new OvsdbQueue(queueId, dscp, maxRate, minRate, burst, priority, externalIds);
}
#method_after
public OvsdbQueue build() {
    return new OvsdbQueue(dscp, otherConfigs, externalIds);
}
#end_block

#method_before
public OvsdbQueue.Builder dscp(UnsignedInteger dscp) {
    this.dscp = dscp;
    return this;
}
#method_after
public Builder dscp(Long dscp) {
    this.dscp = Optional.ofNullable(dscp);
    return this;
}
#end_block

#method_before
public OvsdbQueue.Builder externalIds(Map<String, String> ids) {
    this.externalIds = ids;
    return this;
}
#method_after
public Builder externalIds(Map<String, String> ids) {
    this.externalIds = ids;
    return this;
}
#end_block

#method_before
private PointToPointIntent makeIntent(String ingressIdString, String egressIdString, List<Constraint> constraints) {
    return PointToPointIntent.builder().appId(APPID).selector(selector).treatment(treatment).filteredIngressPoint(new FilteredConnectPoint(connectPoint(ingressIdString, 1))).filteredEgressPoint(new FilteredConnectPoint(connectPoint(egressIdString, 2))).constraints(constraints).build();
}
#method_after
private PointToPointIntent makeIntent(ConnectPoint ingress, ConnectPoint egress) {
    return PointToPointIntent.builder().appId(APPID).selector(selector).treatment(treatment).filteredIngressPoint(new FilteredConnectPoint(ingress)).filteredEgressPoint(new FilteredConnectPoint(egress)).build();
}
#end_block

#method_before
@Test
public void testForwardPathCompilation() {
    PointToPointIntent intent = makeIntent("d1", "d8");
    String[] hops = { "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8" };
    PointToPointIntentCompiler compiler = makeCompiler(hops);
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(1));
    Intent forwardResultIntent = result.get(0);
    assertThat(forwardResultIntent instanceof LinkCollectionIntent, is(true));
    if (forwardResultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent forwardIntent = (LinkCollectionIntent) forwardResultIntent;
        FilteredConnectPoint ingressPoint = new FilteredConnectPoint(connectPoint("d1", 1));
        FilteredConnectPoint egressPoint = new FilteredConnectPoint(connectPoint("d8", 1));
        // 7 links for the hops, plus one default lnk on ingress and egress
        assertThat(forwardIntent.links(), hasSize(hops.length - 1));
        assertThat(forwardIntent.links(), linksHasPath("d1", "d2"));
        assertThat(forwardIntent.links(), linksHasPath("d2", "d3"));
        assertThat(forwardIntent.links(), linksHasPath("d3", "d4"));
        assertThat(forwardIntent.links(), linksHasPath("d4", "d5"));
        assertThat(forwardIntent.links(), linksHasPath("d5", "d6"));
        assertThat(forwardIntent.links(), linksHasPath("d6", "d7"));
        assertThat(forwardIntent.links(), linksHasPath("d7", "d8"));
        assertThat(forwardIntent.filteredIngressPoints(), is(ImmutableSet.of(ingressPoint)));
        assertThat(forwardIntent.filteredEgressPoints(), is(ImmutableSet.of(egressPoint)));
    }
    assertThat("key is inherited", forwardResultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testForwardPathCompilation() {
    PointToPointIntent intent = makeIntent(new ConnectPoint(DID_1, PORT_1), new ConnectPoint(DID_8, PORT_1));
    String[] hops = { S1, S2, S3, S4, S5, S6, S7, S8 };
    PointToPointIntentCompiler compiler = makeCompiler(hops);
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(1));
    Intent forwardResultIntent = result.get(0);
    assertThat(forwardResultIntent instanceof LinkCollectionIntent, is(true));
    if (forwardResultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent forwardIntent = (LinkCollectionIntent) forwardResultIntent;
        FilteredConnectPoint ingressPoint = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1));
        FilteredConnectPoint egressPoint = new FilteredConnectPoint(new ConnectPoint(DID_8, PORT_1));
        // 7 links for the hops, plus one default lnk on ingress and egress
        assertThat(forwardIntent.links(), hasSize(hops.length - 1));
        assertThat(forwardIntent.links(), linksHasPath(S1, S2));
        assertThat(forwardIntent.links(), linksHasPath(S2, S3));
        assertThat(forwardIntent.links(), linksHasPath(S3, S4));
        assertThat(forwardIntent.links(), linksHasPath(S4, S5));
        assertThat(forwardIntent.links(), linksHasPath(S5, S6));
        assertThat(forwardIntent.links(), linksHasPath(S6, S7));
        assertThat(forwardIntent.links(), linksHasPath(S7, S8));
        assertThat(forwardIntent.filteredIngressPoints(), is(ImmutableSet.of(ingressPoint)));
        assertThat(forwardIntent.filteredEgressPoints(), is(ImmutableSet.of(egressPoint)));
    }
    assertThat("key is inherited", forwardResultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testReversePathCompilation() {
    PointToPointIntent intent = makeIntent("d8", "d1");
    String[] hops = { "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8" };
    PointToPointIntentCompiler compiler = makeCompiler(hops);
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(1));
    Intent reverseResultIntent = result.get(0);
    assertThat(reverseResultIntent instanceof LinkCollectionIntent, is(true));
    if (reverseResultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent reverseLinkCollectionIntent = (LinkCollectionIntent) reverseResultIntent;
        FilteredConnectPoint egressPoint = new FilteredConnectPoint(connectPoint("d1", 1));
        FilteredConnectPoint ingressPoint = new FilteredConnectPoint(connectPoint("d8", 1));
        assertThat(reverseLinkCollectionIntent.links(), hasSize(hops.length - 1));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("d2", "d1"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("d3", "d2"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("d4", "d3"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("d5", "d4"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("d6", "d5"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("d7", "d6"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("d8", "d7"));
        assertThat(reverseLinkCollectionIntent.filteredIngressPoints(), is(ImmutableSet.of(ingressPoint)));
        assertThat(reverseLinkCollectionIntent.filteredEgressPoints(), is(ImmutableSet.of(egressPoint)));
    }
    assertThat("key is inherited", reverseResultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testReversePathCompilation() {
    PointToPointIntent intent = makeIntent(new ConnectPoint(DID_8, PORT_1), new ConnectPoint(DID_1, PORT_1));
    String[] hops = { S1, S2, S3, S4, S5, S6, S7, S8 };
    PointToPointIntentCompiler compiler = makeCompiler(hops);
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(1));
    Intent reverseResultIntent = result.get(0);
    assertThat(reverseResultIntent instanceof LinkCollectionIntent, is(true));
    if (reverseResultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent reverseLinkCollectionIntent = (LinkCollectionIntent) reverseResultIntent;
        FilteredConnectPoint egressPoint = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1));
        FilteredConnectPoint ingressPoint = new FilteredConnectPoint(new ConnectPoint(DID_8, PORT_1));
        assertThat(reverseLinkCollectionIntent.links(), hasSize(hops.length - 1));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath(S2, S1));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath(S3, S2));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath(S4, S3));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath(S5, S4));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath(S6, S5));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath(S7, S6));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath(S8, S7));
        assertThat(reverseLinkCollectionIntent.filteredIngressPoints(), is(ImmutableSet.of(ingressPoint)));
        assertThat(reverseLinkCollectionIntent.filteredEgressPoints(), is(ImmutableSet.of(egressPoint)));
    }
    assertThat("key is inherited", reverseResultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testSameSwitchDifferentPortsIntentCompilation() {
    FilteredConnectPoint src = new FilteredConnectPoint(new ConnectPoint(deviceId("1"), portNumber(1)));
    FilteredConnectPoint dst = new FilteredConnectPoint(new ConnectPoint(deviceId("1"), portNumber(2)));
    PointToPointIntent intent = PointToPointIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).filteredIngressPoint(src).filteredEgressPoint(dst).build();
    String[] hops = { "1" };
    PointToPointIntentCompiler sut = makeCompiler(hops);
    List<Intent> compiled = sut.compile(intent, null);
    assertThat("key is inherited", compiled.stream().map(Intent::key).collect(Collectors.toList()), everyItem(is(intent.key())));
    assertThat(compiled, hasSize(1));
    assertThat(compiled.get(0), is(instanceOf(LinkCollectionIntent.class)));
    LinkCollectionIntent linkCollectionIntent = (LinkCollectionIntent) compiled.get(0);
    Set<Link> links = linkCollectionIntent.links();
    assertThat(links, hasSize(0));
    assertThat(linkCollectionIntent.filteredIngressPoints(), is(ImmutableSet.of(src)));
    assertThat(linkCollectionIntent.filteredEgressPoints(), is(ImmutableSet.of(dst)));
}
#method_after
@Test
public void testSameSwitchDifferentPortsIntentCompilation() {
    FilteredConnectPoint src = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1));
    FilteredConnectPoint dst = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_2));
    PointToPointIntent intent = makeIntent(new ConnectPoint(DID_1, PORT_1), new ConnectPoint(DID_1, PORT_2));
    String[] hops = { S1 };
    PointToPointIntentCompiler compiler = makeCompiler(hops);
    List<Intent> compiled = compiler.compile(intent, null);
    assertThat("key is inherited", compiled.stream().map(Intent::key).collect(Collectors.toList()), everyItem(is(intent.key())));
    assertThat(compiled, hasSize(1));
    assertThat(compiled.get(0), is(instanceOf(LinkCollectionIntent.class)));
    LinkCollectionIntent linkCollectionIntent = (LinkCollectionIntent) compiled.get(0);
    Set<Link> links = linkCollectionIntent.links();
    assertThat(links, hasSize(0));
    assertThat(linkCollectionIntent.filteredIngressPoints(), is(ImmutableSet.of(src)));
    assertThat(linkCollectionIntent.filteredEgressPoints(), is(ImmutableSet.of(dst)));
}
#end_block

#method_before
@Test
public void testBandwidthConstrainedIntentSuccess() {
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(1000.0);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(100.0)));
    final PointToPointIntent intent = makeIntent("s1", "s3", constraints);
    String[] hops = { "s1", "s2", "s3" };
    final PointToPointIntentCompiler compiler = makeCompiler(hops, resourceService);
    final List<Intent> compiledIntents = compiler.compile(intent, null);
    assertThat(compiledIntents, Matchers.notNullValue());
    assertThat(compiledIntents, hasSize(1));
    assertThat("key is inherited", compiledIntents.stream().map(Intent::key).collect(Collectors.toList()), everyItem(is(intent.key())));
}
#method_after
@Test
public void testBandwidthConstrainedIntentSuccess() {
    final double bpsTotal = 1000.0;
    final double bpsToReserve = 100.0;
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(bpsTotal);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(bpsToReserve)));
    final PointToPointIntent intent = makeIntent(new ConnectPoint(DID_1, PORT_1), new ConnectPoint(DID_3, PORT_2), constraints);
    String[] hops = { S1, S2, S3 };
    final PointToPointIntentCompiler compiler = makeCompiler(hops, resourceService);
    final List<Intent> compiledIntents = compiler.compile(intent, null);
    assertThat(compiledIntents, Matchers.notNullValue());
    assertThat(compiledIntents, hasSize(1));
    assertThat("key is inherited", compiledIntents.stream().map(Intent::key).collect(Collectors.toList()), everyItem(is(intent.key())));
}
#end_block

#method_before
@Test
public void testBandwidthConstrainedIntentFailure() {
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(10.0);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(100.0)));
    try {
        final PointToPointIntent intent = makeIntent("s1", "s3", constraints);
        String[] hops = { "s1", "s2", "s3" };
        final PointToPointIntentCompiler compiler = makeCompiler(hops, resourceService);
        compiler.compile(intent, null);
        fail("Point to Point compilation with insufficient bandwidth does " + "not throw exception.");
    } catch (PathNotFoundException noPath) {
        assertThat(noPath.getMessage(), containsString("No path"));
    }
}
#method_after
@Test
public void testBandwidthConstrainedIntentFailure() {
    final double bpsTotal = 10.0;
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(bpsTotal);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(BPS_TO_RESERVE)));
    try {
        final PointToPointIntent intent = makeIntent(new ConnectPoint(DID_1, PORT_1), new ConnectPoint(DID_3, PORT_2), constraints);
        String[] hops = { S1, S2, S3 };
        final PointToPointIntentCompiler compiler = makeCompiler(hops, resourceService);
        compiler.compile(intent, null);
        fail("Point to Point compilation with insufficient bandwidth does " + "not throw exception.");
    } catch (PathNotFoundException noPath) {
        assertThat(noPath.getMessage(), containsString("No path"));
    }
}
#end_block

#method_before
@Test
public void testBandwidthConstrainedIntentAllocation() {
    double bpsToReserve = 100.0;
    DeviceId deviceId1 = DeviceId.deviceId("of:s1");
    DeviceId deviceId2 = DeviceId.deviceId("of:s2");
    DeviceId deviceId3 = DeviceId.deviceId("of:s3");
    PortNumber port1 = PortNumber.portNumber(1);
    PortNumber port2 = PortNumber.portNumber(2);
    ContinuousResource resourceSw1P1 = Resources.continuous(deviceId1, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw1P2 = Resources.continuous(deviceId1, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P1 = Resources.continuous(deviceId2, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P2 = Resources.continuous(deviceId2, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P1 = Resources.continuous(deviceId3, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P2 = Resources.continuous(deviceId3, port2, Bandwidth.class).resource(bpsToReserve);
    String[] hops = { "s1", "s2", "s3" };
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(1000.0);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(bpsToReserve)));
    final PointToPointIntent intent = makeIntent("s1", "s3", constraints);
    PointToPointIntentCompiler compiler = makeCompiler(hops, resourceService);
    compiler.compile(intent, null);
    IntentId intentId = intent.id();
    ResourceAllocation rAOne = new ResourceAllocation(resourceSw1P1, intentId);
    ResourceAllocation rATwo = new ResourceAllocation(resourceSw1P2, intentId);
    ResourceAllocation rAThree = new ResourceAllocation(resourceSw2P1, intentId);
    ResourceAllocation rAFour = new ResourceAllocation(resourceSw2P2, intentId);
    ResourceAllocation rAFive = new ResourceAllocation(resourceSw3P1, intentId);
    ResourceAllocation rASix = new ResourceAllocation(resourceSw3P2, intentId);
    Set<ResourceAllocation> expectedresourceAllocations = Sets.newHashSet(rAOne, rATwo, rAThree, rAFour, rAFive, rASix);
    Set<ResourceAllocation> resourceAllocations = Sets.newHashSet(resourceService.getResourceAllocations(intent.id()));
    assertThat(resourceAllocations, hasSize(6));
    assertEquals(expectedresourceAllocations, resourceAllocations);
}
#method_after
@Test
public void testBandwidthConstrainedIntentAllocation() {
    final double bpsTotal = 1000.0;
    String[] hops = { S1, S2, S3 };
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(bpsTotal);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(BPS_TO_RESERVE)));
    final PointToPointIntent intent = makeIntent(new ConnectPoint(DID_1, PORT_1), new ConnectPoint(DID_3, PORT_2), constraints);
    PointToPointIntentCompiler compiler = makeCompiler(hops, resourceService);
    compiler.compile(intent, null);
    Key intentKey = intent.key();
    ResourceAllocation rAOne = new ResourceAllocation(RESOURCE_SW1_P1, intentKey);
    ResourceAllocation rATwo = new ResourceAllocation(RESOURCE_SW1_P2, intentKey);
    ResourceAllocation rAThree = new ResourceAllocation(RESOURCE_SW2_P1, intentKey);
    ResourceAllocation rAFour = new ResourceAllocation(RESOURCE_SW2_P2, intentKey);
    ResourceAllocation rAFive = new ResourceAllocation(RESOURCE_SW3_P1, intentKey);
    ResourceAllocation rASix = new ResourceAllocation(RESOURCE_SW3_P2, intentKey);
    Set<ResourceAllocation> expectedresourceAllocations = ImmutableSet.of(rAOne, rATwo, rAThree, rAFour, rAFive, rASix);
    Set<ResourceAllocation> resourceAllocations = ImmutableSet.copyOf(resourceService.getResourceAllocations(intentKey));
    assertThat(resourceAllocations, hasSize(6));
    assertEquals(expectedresourceAllocations, resourceAllocations);
}
#end_block

#method_before
@Override
public List<Intent> compile(PointToPointIntent intent, List<Intent> installable) {
    log.trace("compiling {} {}", intent, installable);
    ConnectPoint ingressPoint = intent.ingressPoint();
    ConnectPoint egressPoint = intent.egressPoint();
    if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
        return createZeroHopLinkCollectionIntent(intent);
    }
    // proceed with no protected paths
    if (!ProtectionConstraint.requireProtectedPath(intent)) {
        return createUnprotectedLinkCollectionIntent(intent);
    }
    try {
        // attempt to compute and implement backup path
        return createProtectedIntent(ingressPoint, egressPoint, intent, installable);
    } catch (PathNotFoundException e) {
        log.warn("Could not find disjoint Path for {}", intent);
        // no disjoint path extant -- maximum one path exists between devices
        return createSinglePathIntent(ingressPoint, egressPoint, intent, installable);
    }
}
#method_after
@Override
public List<Intent> compile(PointToPointIntent intent, List<Intent> installable) {
    log.trace("compiling {} {}", intent, installable);
    ConnectPoint ingressPoint = intent.filteredIngressPoint().connectPoint();
    ConnectPoint egressPoint = intent.filteredEgressPoint().connectPoint();
    if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
        return createZeroHopLinkCollectionIntent(intent);
    }
    // proceed with no protected paths
    if (!ProtectionConstraint.requireProtectedPath(intent)) {
        return createUnprotectedLinkCollectionIntent(intent);
    }
    try {
        // attempt to compute and implement backup path
        return createProtectedIntent(ingressPoint, egressPoint, intent, installable);
    } catch (PathNotFoundException e) {
        log.warn("Could not find disjoint Path for {}", intent);
        // no disjoint path extant -- maximum one path exists between devices
        return createSinglePathIntent(ingressPoint, egressPoint, intent, installable);
    }
}
#end_block

#method_before
private List<Intent> createProtectedIntent(ConnectPoint ingressPoint, ConnectPoint egressPoint, PointToPointIntent intent, List<Intent> installable) {
    log.trace("createProtectedIntent");
    DisjointPath path = getDisjointPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
    List<Intent> reusableIntents = null;
    if (installable != null) {
        reusableIntents = filterInvalidSubIntents(installable, intent);
        if (reusableIntents.size() == installable.size()) {
            // all old paths are still viable
            return installable;
        }
    }
    List<Intent> intentList = new ArrayList<>();
    // primary path intent
    List<Link> links = new ArrayList<>();
    links.addAll(path.links());
    links.add(createEdgeLink(egressPoint, false));
    // backup path intent
    List<Link> backupLinks = new ArrayList<>();
    backupLinks.addAll(path.backup().links());
    backupLinks.add(createEdgeLink(egressPoint, false));
    /*
         * One of the old paths is still entirely intact. This old path has
         * already been made primary, so we must add a backup path intent
         * and modify the failover group treatment accordingly.
         */
    if (reusableIntents != null && reusableIntents.size() > 1) {
        /*
             * Ensures that the egress port on source device is different than
             * that of existing path so that failover group will be useful
             * (would not be useful if both output ports in group bucket were
             * the same). Does not necessarily ensure that the new backup path
             * is entirely disjoint from the old path.
             */
        PortNumber primaryPort = getPrimaryPort(intent);
        if (primaryPort != null && !links.get(0).src().port().equals(primaryPort)) {
            reusableIntents.add(createPathIntent(new DefaultPath(PID, links, path.cost(), path.annotations()), intent, PathIntent.ProtectionType.BACKUP));
            updateFailoverGroup(intent, links);
            return reusableIntents;
        } else {
            reusableIntents.add(createPathIntent(new DefaultPath(PID, backupLinks, path.backup().cost(), path.backup().annotations()), intent, PathIntent.ProtectionType.BACKUP));
            updateFailoverGroup(intent, backupLinks);
            return reusableIntents;
        }
    }
    intentList.add(createPathIntent(new DefaultPath(PID, links, path.cost(), path.annotations()), intent, PathIntent.ProtectionType.PRIMARY));
    intentList.add(createPathIntent(new DefaultPath(PID, backupLinks, path.backup().cost(), path.backup().annotations()), intent, PathIntent.ProtectionType.BACKUP));
    // add contents appropriately.
    if (groupService.getGroup(ingressPoint.deviceId(), makeGroupKey(intent.id())) == null) {
        // manufactured fast failover flow rule intent
        createFailoverTreatmentGroup(path.links(), path.backup().links(), intent);
        FlowRuleIntent frIntent = new FlowRuleIntent(intent.appId(), intent.key(), createFailoverFlowRules(intent), asList(ingressPoint.deviceId()), PathIntent.ProtectionType.FAILOVER);
        intentList.add(frIntent);
    } else {
        updateFailoverGroup(intent, links);
        updateFailoverGroup(intent, backupLinks);
    }
    return intentList;
}
#method_after
private List<Intent> createProtectedIntent(ConnectPoint ingressPoint, ConnectPoint egressPoint, PointToPointIntent intent, List<Intent> installable) {
    log.trace("createProtectedIntent");
    DisjointPath path = getDisjointPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
    List<Intent> reusableIntents = null;
    if (installable != null) {
        reusableIntents = filterInvalidSubIntents(installable, intent);
        if (reusableIntents.size() == installable.size()) {
            // all old paths are still viable
            return installable;
        }
    }
    List<Intent> intentList = new ArrayList<>();
    // primary path intent
    List<Link> links = new ArrayList<>();
    links.addAll(path.links());
    links.add(createEdgeLink(egressPoint, false));
    // backup path intent
    List<Link> backupLinks = new ArrayList<>();
    backupLinks.addAll(path.backup().links());
    backupLinks.add(createEdgeLink(egressPoint, false));
    /*
         * One of the old paths is still entirely intact. This old path has
         * already been made primary, so we must add a backup path intent
         * and modify the failover group treatment accordingly.
         */
    if (reusableIntents != null && reusableIntents.size() > 1) {
        /*
             * Ensures that the egress port on source device is different than
             * that of existing path so that failover group will be useful
             * (would not be useful if both output ports in group bucket were
             * the same). Does not necessarily ensure that the new backup path
             * is entirely disjoint from the old path.
             */
        PortNumber primaryPort = getPrimaryPort(intent);
        if (primaryPort != null && !links.get(0).src().port().equals(primaryPort)) {
            reusableIntents.add(createPathIntent(new DefaultPath(PID, links, path.cost(), path.annotations()), intent, PathIntent.ProtectionType.BACKUP));
            updateFailoverGroup(intent, links);
            return reusableIntents;
        } else {
            reusableIntents.add(createPathIntent(new DefaultPath(PID, backupLinks, path.backup().cost(), path.backup().annotations()), intent, PathIntent.ProtectionType.BACKUP));
            updateFailoverGroup(intent, backupLinks);
            return reusableIntents;
        }
    }
    intentList.add(createPathIntent(new DefaultPath(PID, links, path.cost(), path.annotations()), intent, PathIntent.ProtectionType.PRIMARY));
    intentList.add(createPathIntent(new DefaultPath(PID, backupLinks, path.backup().cost(), path.backup().annotations()), intent, PathIntent.ProtectionType.BACKUP));
    // add contents appropriately.
    if (groupService.getGroup(ingressPoint.deviceId(), makeGroupKey(intent.id())) == null) {
        // manufactured fast failover flow rule intent
        createFailoverTreatmentGroup(path.links(), path.backup().links(), intent);
        FlowRuleIntent frIntent = new FlowRuleIntent(intent.appId(), intent.key(), createFailoverFlowRules(intent), asList(ingressPoint.deviceId()), PathIntent.ProtectionType.FAILOVER, intent.resourceGroup());
        intentList.add(frIntent);
    } else {
        updateFailoverGroup(intent, links);
        updateFailoverGroup(intent, backupLinks);
    }
    return intentList;
}
#end_block

#method_before
private Intent createPathIntent(Path path, PointToPointIntent intent, PathIntent.ProtectionType type) {
    return PathIntent.builder().appId(intent.appId()).key(intent.key()).selector(intent.selector()).treatment(intent.treatment()).path(path).constraints(intent.constraints()).priority(intent.priority()).setType(type).build();
}
#method_after
private Intent createPathIntent(Path path, PointToPointIntent intent, PathIntent.ProtectionType type) {
    return PathIntent.builder().appId(intent.appId()).key(intent.key()).selector(intent.selector()).treatment(intent.treatment()).path(path).constraints(intent.constraints()).priority(intent.priority()).setType(type).resourceGroup(intent.resourceGroup()).build();
}
#end_block

#method_before
private Intent createLinkCollectionIntent(Set<Link> links, double cost, PointToPointIntent intent) {
    return LinkCollectionIntent.builder().key(intent.key()).appId(intent.appId()).selector(intent.selector()).treatment(intent.treatment()).links(ImmutableSet.copyOf(links)).filteredIngressPoints(ImmutableSet.of(intent.filteredIngressPoint())).filteredEgressPoints(ImmutableSet.of(intent.filteredEgressPoint())).applyTreatmentOnEgress(true).constraints(intent.constraints()).priority(intent.priority()).cost(cost).build();
}
#method_after
private Intent createLinkCollectionIntent(Set<Link> links, double cost, PointToPointIntent intent) {
    return LinkCollectionIntent.builder().key(intent.key()).appId(intent.appId()).selector(intent.selector()).treatment(intent.treatment()).links(ImmutableSet.copyOf(links)).filteredIngressPoints(ImmutableSet.of(intent.filteredIngressPoint())).filteredEgressPoints(ImmutableSet.of(intent.filteredEgressPoint())).applyTreatmentOnEgress(true).constraints(intent.constraints()).priority(intent.priority()).cost(cost).resourceGroup(intent.resourceGroup()).build();
}
#end_block

#method_before
@Test
public void testSingleLongPathCompilation() {
    HostToHostIntent intent = makeIntent(HOST_ONE, HOST_TWO);
    assertThat(intent, is(notNullValue()));
    String[] hops = { HOST_ONE, S1, S2, S3, S4, S5, S6, S7, S8, HOST_TWO };
    HostToHostIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(2));
    Intent forwardIntent = result.get(0);
    assertThat(forwardIntent instanceof LinkCollectionIntent, is(true));
    Intent reverseIntent = result.get(1);
    assertThat(reverseIntent instanceof LinkCollectionIntent, is(true));
    LinkCollectionIntent forwardLCIntent = (LinkCollectionIntent) forwardIntent;
    Set<Link> links = forwardLCIntent.links();
    assertThat(links, hasSize(7));
    Set<FilteredConnectPoint> ingressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint(S1, PORT_1)));
    assertThat(forwardLCIntent.filteredIngressPoints(), is(ingressPoints));
    assertThat(links, linksHasPath(S1, S2));
    assertThat(links, linksHasPath(S2, S3));
    assertThat(links, linksHasPath(S3, S4));
    assertThat(links, linksHasPath(S4, S5));
    assertThat(links, linksHasPath(S5, S6));
    assertThat(links, linksHasPath(S6, S7));
    assertThat(links, linksHasPath(S7, S8));
    Set<FilteredConnectPoint> egressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint(S8, PORT_2)));
    assertThat(forwardLCIntent.filteredEgressPoints(), is(egressPoints));
    LinkCollectionIntent reverseLCIntent = (LinkCollectionIntent) reverseIntent;
    links = reverseLCIntent.links();
    assertThat(reverseLCIntent.links(), hasSize(7));
    ingressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint(S8, PORT_2)));
    assertThat(reverseLCIntent.filteredIngressPoints(), is(ingressPoints));
    assertThat(links, linksHasPath(S2, S1));
    assertThat(links, linksHasPath(S3, S2));
    assertThat(links, linksHasPath(S4, S3));
    assertThat(links, linksHasPath(S5, S4));
    assertThat(links, linksHasPath(S6, S5));
    assertThat(links, linksHasPath(S7, S6));
    assertThat(links, linksHasPath(S8, S7));
    egressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint(S1, PORT_1)));
    assertThat(reverseLCIntent.filteredEgressPoints(), is(egressPoints));
    assertThat("key is inherited", result.stream().map(Intent::key).collect(Collectors.toList()), everyItem(is(intent.key())));
}
#method_after
@Test
public void testSingleLongPathCompilation() {
    HostToHostIntent intent = makeIntent(HOST_ONE, HOST_TWO);
    assertThat(intent, is(notNullValue()));
    String[] hops = { HOST_ONE, S1, S2, S3, S4, S5, S6, S7, S8, HOST_TWO };
    HostToHostIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(2));
    Intent forwardIntent = result.get(0);
    assertThat(forwardIntent instanceof LinkCollectionIntent, is(true));
    Intent reverseIntent = result.get(1);
    assertThat(reverseIntent instanceof LinkCollectionIntent, is(true));
    LinkCollectionIntent forwardLCIntent = (LinkCollectionIntent) forwardIntent;
    Set<Link> links = forwardLCIntent.links();
    assertThat(links, hasSize(7));
    Set<FilteredConnectPoint> ingressPoints = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_S1, PORT_1)));
    assertThat(forwardLCIntent.filteredIngressPoints(), is(ingressPoints));
    assertThat(links, linksHasPath(S1, S2));
    assertThat(links, linksHasPath(S2, S3));
    assertThat(links, linksHasPath(S3, S4));
    assertThat(links, linksHasPath(S4, S5));
    assertThat(links, linksHasPath(S5, S6));
    assertThat(links, linksHasPath(S6, S7));
    assertThat(links, linksHasPath(S7, S8));
    Set<FilteredConnectPoint> egressPoints = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_S8, PORT_2)));
    assertThat(forwardLCIntent.filteredEgressPoints(), is(egressPoints));
    LinkCollectionIntent reverseLCIntent = (LinkCollectionIntent) reverseIntent;
    links = reverseLCIntent.links();
    assertThat(reverseLCIntent.links(), hasSize(7));
    ingressPoints = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_S8, PORT_2)));
    assertThat(reverseLCIntent.filteredIngressPoints(), is(ingressPoints));
    assertThat(links, linksHasPath(S2, S1));
    assertThat(links, linksHasPath(S3, S2));
    assertThat(links, linksHasPath(S4, S3));
    assertThat(links, linksHasPath(S5, S4));
    assertThat(links, linksHasPath(S6, S5));
    assertThat(links, linksHasPath(S7, S6));
    assertThat(links, linksHasPath(S8, S7));
    egressPoints = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_S1, PORT_1)));
    assertThat(reverseLCIntent.filteredEgressPoints(), is(egressPoints));
    assertThat("key is inherited", result.stream().map(Intent::key).collect(Collectors.toList()), everyItem(is(intent.key())));
}
#end_block

#method_before
@Test
public void testBandwidthConstrainedIntentAllocation() {
    double bpsToReserve = 100.0;
    DeviceId deviceId1 = DeviceId.deviceId("of:s1");
    DeviceId deviceId2 = DeviceId.deviceId("of:s2");
    DeviceId deviceId3 = DeviceId.deviceId("of:s3");
    PortNumber port1 = PortNumber.portNumber(1);
    PortNumber port2 = PortNumber.portNumber(2);
    ContinuousResource resourceSw1P1 = Resources.continuous(deviceId1, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw1P2 = Resources.continuous(deviceId1, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P1 = Resources.continuous(deviceId2, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P2 = Resources.continuous(deviceId2, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P1 = Resources.continuous(deviceId3, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P2 = Resources.continuous(deviceId3, port2, Bandwidth.class).resource(bpsToReserve);
    String[] hops = { HOST_ONE, S1, S2, S3, HOST_TWO };
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(1000.0);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(bpsToReserve)));
    final HostToHostIntent intent = makeIntent(HOST_ONE, HOST_TWO, constraints);
    HostToHostIntentCompiler compiler = makeCompiler(hops, resourceService);
    compiler.compile(intent, null);
    IntentId intentId = intent.id();
    ResourceAllocation rAOne = new ResourceAllocation(resourceSw1P1, intentId);
    ResourceAllocation rATwo = new ResourceAllocation(resourceSw1P2, intentId);
    ResourceAllocation rAThree = new ResourceAllocation(resourceSw2P1, intentId);
    ResourceAllocation rAFour = new ResourceAllocation(resourceSw2P2, intentId);
    ResourceAllocation rAFive = new ResourceAllocation(resourceSw3P1, intentId);
    ResourceAllocation rASix = new ResourceAllocation(resourceSw3P2, intentId);
    Set<ResourceAllocation> expectedresourceAllocations = Sets.newHashSet(rAOne, rATwo, rAThree, rAFour, rAFive, rASix);
    Set<ResourceAllocation> resourceAllocations = Sets.newHashSet(resourceService.getResourceAllocations(intent.id()));
    assertThat(resourceAllocations, hasSize(6));
    assertEquals(expectedresourceAllocations, resourceAllocations);
}
#method_after
@Test
public void testBandwidthConstrainedIntentAllocation() {
    final double bpsTotal = 1000.0;
    final double bpsToReserve = 100.0;
    ContinuousResource resourceSw1P1 = Resources.continuous(DID_S1, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw1P2 = Resources.continuous(DID_S1, PORT_2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P1 = Resources.continuous(DID_S2, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P2 = Resources.continuous(DID_S2, PORT_2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P1 = Resources.continuous(DID_S3, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P2 = Resources.continuous(DID_S3, PORT_2, Bandwidth.class).resource(bpsToReserve);
    String[] hops = { HOST_ONE, S1, S2, S3, HOST_TWO };
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(bpsTotal);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(bpsToReserve)));
    final HostToHostIntent intent = makeIntent(HOST_ONE, HOST_TWO, constraints);
    HostToHostIntentCompiler compiler = makeCompiler(hops, resourceService);
    compiler.compile(intent, null);
    Key intentKey = intent.key();
    ResourceAllocation rAOne = new ResourceAllocation(resourceSw1P1, intentKey);
    ResourceAllocation rATwo = new ResourceAllocation(resourceSw1P2, intentKey);
    ResourceAllocation rAThree = new ResourceAllocation(resourceSw2P1, intentKey);
    ResourceAllocation rAFour = new ResourceAllocation(resourceSw2P2, intentKey);
    ResourceAllocation rAFive = new ResourceAllocation(resourceSw3P1, intentKey);
    ResourceAllocation rASix = new ResourceAllocation(resourceSw3P2, intentKey);
    Set<ResourceAllocation> expectedresourceAllocations = ImmutableSet.of(rAOne, rATwo, rAThree, rAFour, rAFive, rASix);
    Set<ResourceAllocation> resourceAllocations = ImmutableSet.copyOf(resourceService.getResourceAllocations(intentKey));
    assertThat(resourceAllocations, hasSize(6));
    assertEquals(expectedresourceAllocations, resourceAllocations);
}
#end_block

#method_before
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeight weight) {
    final Set<Path> paths = getPaths(src, dst);
    for (Path path : paths) {
        final DeviceId srcDevice = path.src().elementId() instanceof DeviceId ? path.src().deviceId() : null;
        final DeviceId dstDevice = path.dst().elementId() instanceof DeviceId ? path.dst().deviceId() : null;
        if (srcDevice != null && dstDevice != null) {
            final TopologyVertex srcVertex = new DefaultTopologyVertex(srcDevice);
            final TopologyVertex dstVertex = new DefaultTopologyVertex(dstDevice);
            final Link link = link(src.toString(), 1, dst.toString(), 1);
            final double weightValue = weight.weight(new DefaultTopologyEdge(srcVertex, dstVertex, link));
            if (weightValue < 0) {
                return new HashSet<>();
            }
        }
    }
    return paths;
}
#method_after
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    Set<Path> paths = getPaths(src, dst);
    for (Path path : paths) {
        DeviceId srcDevice = path.src().elementId() instanceof DeviceId ? path.src().deviceId() : null;
        DeviceId dstDevice = path.dst().elementId() instanceof DeviceId ? path.dst().deviceId() : null;
        if (srcDevice != null && dstDevice != null) {
            TopologyVertex srcVertex = new DefaultTopologyVertex(srcDevice);
            TopologyVertex dstVertex = new DefaultTopologyVertex(dstDevice);
            Link link = link(src.toString(), 1, dst.toString(), 1);
            Weight weightValue = weigher.weight(new DefaultTopologyEdge(srcVertex, dstVertex, link));
            if (weightValue.isNegative()) {
                return new HashSet<>();
            }
        }
    }
    return paths;
}
#end_block

#method_before
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeight weight) {
    final Set<Path> paths = getPaths(src, dst);
    for (Path path : paths) {
        final DeviceId srcDevice = path.src().elementId() instanceof DeviceId ? path.src().deviceId() : null;
        final DeviceId dstDevice = path.dst().elementId() instanceof DeviceId ? path.dst().deviceId() : null;
        if (srcDevice != null && dstDevice != null) {
            final TopologyVertex srcVertex = new DefaultTopologyVertex(srcDevice);
            final TopologyVertex dstVertex = new DefaultTopologyVertex(dstDevice);
            final Link link = link(src.toString(), 1, dst.toString(), 1);
            final double weightValue = weight.weight(new DefaultTopologyEdge(srcVertex, dstVertex, link));
            if (weightValue < 0) {
                return new HashSet<>();
            }
        }
    }
    return paths;
}
#method_after
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    final Set<Path> paths = getPaths(src, dst);
    for (Path path : paths) {
        final DeviceId srcDevice = path.src().elementId() instanceof DeviceId ? path.src().deviceId() : null;
        final DeviceId dstDevice = path.dst().elementId() instanceof DeviceId ? path.dst().deviceId() : null;
        if (srcDevice != null && dstDevice != null) {
            final TopologyVertex srcVertex = new DefaultTopologyVertex(srcDevice);
            final TopologyVertex dstVertex = new DefaultTopologyVertex(dstDevice);
            final Link link = link(src.toString(), 1, dst.toString(), 1);
            final Weight weightValue = weigher.weight(new DefaultTopologyEdge(srcVertex, dstVertex, link));
            if (weightValue.isNegative()) {
                return new HashSet<>();
            }
        }
    }
    return paths;
}
#end_block

#method_before
@Override
public Set<Path> getPaths(ElementId src, ElementId dst) {
    List<Link> links = new ArrayList<>();
    Set<Path> result = new HashSet<>();
    ProviderId providerId = new ProviderId("of", "foo");
    DefaultPath path;
    if (src.toString().equals("of:s1") && dst.toString().equals("of:s4")) {
        links.add(NetTestTools.linkNoPrefixes(src.toString(), 2, pathHops[0], 1));
        links.add(NetTestTools.linkNoPrefixes(pathHops[0], 2, dst.toString(), 1));
    } else if (src.toString().equals("of:s2") && dst.toString().equals("of:s4")) {
        links.add(NetTestTools.linkNoPrefixes(src.toString(), 2, pathHops[0], 3));
        links.add(NetTestTools.linkNoPrefixes(pathHops[0], 2, dst.toString(), 1));
    } else if (src.toString().equals("of:s4") && dst.toString().equals("of:s1")) {
        links.add(NetTestTools.linkNoPrefixes(src.toString(), 2, pathHops[0], 1));
        links.add(NetTestTools.linkNoPrefixes(pathHops[0], 2, dst.toString(), 1));
    } else if (src.toString().equals("of:s4") && dst.toString().equals("of:s2")) {
        links.add(NetTestTools.linkNoPrefixes(src.toString(), 2, pathHops[0], 1));
        links.add(NetTestTools.linkNoPrefixes(pathHops[0], 3, dst.toString(), 1));
    }
    path = new DefaultPath(providerId, links, 3);
    result.add(path);
    return result;
}
#method_after
@Override
public Set<Path> getPaths(ElementId src, ElementId dst) {
    List<Link> links = new ArrayList<>();
    Set<Path> result = new HashSet<>();
    ProviderId providerId = new ProviderId("of", "foo");
    DefaultPath path;
    if (src.toString().equals(DPID_1) && dst.toString().equals(DPID_4)) {
        links.add(NetTestTools.linkNoPrefixes(src.toString(), 2, pathHops[0], 1));
        links.add(NetTestTools.linkNoPrefixes(pathHops[0], 2, dst.toString(), 1));
    } else if (src.toString().equals(DPID_2) && dst.toString().equals(DPID_4)) {
        links.add(NetTestTools.linkNoPrefixes(src.toString(), 2, pathHops[0], 3));
        links.add(NetTestTools.linkNoPrefixes(pathHops[0], 2, dst.toString(), 1));
    } else if (src.toString().equals(DPID_4) && dst.toString().equals(DPID_1)) {
        links.add(NetTestTools.linkNoPrefixes(src.toString(), 2, pathHops[0], 1));
        links.add(NetTestTools.linkNoPrefixes(pathHops[0], 2, dst.toString(), 1));
    } else if (src.toString().equals(DPID_4) && dst.toString().equals(DPID_2)) {
        links.add(NetTestTools.linkNoPrefixes(src.toString(), 2, pathHops[0], 1));
        links.add(NetTestTools.linkNoPrefixes(pathHops[0], 3, dst.toString(), 1));
    } else {
        return result;
    }
    path = new DefaultPath(providerId, links, 3);
    result.add(path);
    return result;
}
#end_block

#method_before
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeight weight) {
    // In this tests we don't take care of link weights
    return getPaths(src, dst);
}
#method_after
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    final Set<Path> paths = getPaths(src, dst);
    for (Path path : paths) {
        final DeviceId srcDevice = path.src().elementId() instanceof DeviceId ? path.src().deviceId() : null;
        final DeviceId dstDevice = path.dst().elementId() instanceof DeviceId ? path.dst().deviceId() : null;
        if (srcDevice != null && dstDevice != null) {
            final TopologyVertex srcVertex = new DefaultTopologyVertex(srcDevice);
            final TopologyVertex dstVertex = new DefaultTopologyVertex(dstDevice);
            final Link link = link(src.toString(), 1, dst.toString(), 1);
            final Weight weightValue = weigher.weight(new DefaultTopologyEdge(srcVertex, dstVertex, link));
            if (weightValue.isNegative()) {
                return new HashSet<>();
            }
        }
    }
    return paths;
}
#end_block

#method_before
protected Path getPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<Path> paths = pathService.getPaths(one, two, weight(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<Path> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        return null;
    }
    // TODO: let's be more intelligent about this eventually
    return filtered.iterator().next();
}
#method_after
protected Path getPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<Path> paths = pathService.getPaths(one, two, weigher(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<Path> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        return null;
    }
    if (constraints.stream().anyMatch(c -> c instanceof HashedPathSelectionConstraint)) {
        return filtered.get(intent.hashCode() % filtered.size());
    }
    return filtered.iterator().next();
}
#end_block

#method_before
protected DisjointPath getDisjointPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<DisjointPath> paths = pathService.getDisjointPaths(one, two, weight(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<DisjointPath> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        throw new PathNotFoundException(one, two);
    }
    // TODO: let's be more intelligent about this eventually
    return filtered.iterator().next();
}
#method_after
protected DisjointPath getDisjointPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<DisjointPath> paths = pathService.getDisjointPaths(one, two, weigher(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<DisjointPath> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        throw new PathNotFoundException(one, two);
    }
    if (constraints.stream().anyMatch(c -> c instanceof HashedPathSelectionConstraint)) {
        return filtered.get(intent.hashCode() % filtered.size());
    }
    return filtered.iterator().next();
}
#end_block

#method_before
protected void allocateBandwidth(ConnectivityIntent intent, List<ConnectPoint> connectPoints) {
    // Retrieve bandwidth constraint if exists
    List<Constraint> constraints = intent.constraints();
    if (constraints == null) {
        return;
    }
    Constraint constraint = constraints.stream().filter(c -> c instanceof BandwidthConstraint).findAny().orElseGet(() -> null);
    // If there is no bandwidth constraint continue
    if (constraint == null) {
        return;
    }
    BandwidthConstraint bwConstraint = (BandwidthConstraint) constraint;
    Double bw = bwConstraint.bandwidth().bps();
    IntentId intentId = intent.id();
    // Create the list of bandwidth resources to allocate from the list of links
    List<Resource> resources = connectPoints.stream().filter(cp -> isAValidDevice(cp.elementId())).map(cp -> Resources.continuous(cp.deviceId(), cp.port(), Bandwidth.class).resource(bw)).collect(Collectors.toList());
    // Allocate the bandwidth resources
    log.debug("Allocating bandwidth for intent {}: {} bps", intentId, resources);
    List<ResourceAllocation> allocations = resourceService.allocate(intentId, resources);
    if (allocations.isEmpty()) {
        log.warn("Failed to allocate bandwidth {} bps for intent {}", bw, intentId);
    // TODO backoff? Any recovery?
    }
    log.debug("Done allocating bandwidth for intent {}", intentId);
}
#method_after
protected void allocateBandwidth(ConnectivityIntent intent, List<ConnectPoint> connectPoints) {
    // Retrieve bandwidth constraint if exists
    List<Constraint> constraints = intent.constraints();
    if (constraints == null) {
        return;
    }
    Constraint constraint = constraints.stream().filter(c -> c instanceof BandwidthConstraint).findAny().orElseGet(() -> null);
    // If there is no bandwidth constraint continue
    if (constraint == null) {
        return;
    }
    BandwidthConstraint bwConstraint = (BandwidthConstraint) constraint;
    Double bw = bwConstraint.bandwidth().bps();
    // If a resource group is set on the intent, the resource consumer is
    // set equal to it. Otherwise it's set to the intent key
    ResourceConsumer newResourceConsumer = intent.resourceGroup() != null ? intent.resourceGroup() : intent.key();
    // Get the list of current resource allocations
    Collection<ResourceAllocation> resourceAllocations = resourceService.getResourceAllocations(newResourceConsumer);
    // Get the list of resources already allocated from resource allocations
    List<Resource> resourcesAllocated = resourcesFromAllocations(resourceAllocations);
    // Get the list of resource ids for resources already allocated
    List<ResourceId> idsResourcesAllocated = resourceIds(resourcesAllocated);
    // Create the list of incoming resources requested
    List<Resource> incomingResources = resources(connectPoints, bw);
    // Make sure resources are not allocated twice. Remove resources that
    // are already present in the list of resources already allocated
    List<Resource> resourcesToDoNotAllocate = incomingResources.stream().filter(resourcesAllocated::contains).collect(Collectors.toList());
    incomingResources.removeAll(resourcesToDoNotAllocate);
    if (incomingResources.size() == 0) {
        return;
    }
    // Create the list of resources to be added, meaning their key is not
    // present in the resources already allocated
    List<Resource> resourcesToAdd = incomingResources.stream().filter(r -> !idsResourcesAllocated.contains(r.id())).collect(Collectors.toList());
    // Resources to updated are all the new valid resources except the
    // resources to be added
    List<Resource> resourcesToUpdate = Lists.newArrayList(incomingResources);
    resourcesToUpdate.removeAll(resourcesToAdd);
    // If there are no resources to update skip update procedures
    if (resourcesToUpdate.size() > 0) {
        // Remove old resources that need to be updated
        // TODO: use transaction updates when available in the resource service
        List<ResourceAllocation> resourceAllocationsToUpdate = resourceAllocations.stream().filter(rA -> resourceIds(resourcesToUpdate).contains(rA.resource().id())).collect(Collectors.toList());
        log.debug("Releasing bandwidth for intent {}: {} bps", newResourceConsumer, resourcesToUpdate);
        resourceService.release(resourceAllocationsToUpdate);
        // Update resourcesToAdd with the list of both the new resources and
        // the resources to update
        resourcesToAdd.addAll(resourcesToUpdate);
    }
    // remove them
    if (intent.resourceGroup() != null) {
        // Get the list of current resource allocations made by intent key
        Collection<ResourceAllocation> resourceAllocationsByKey = resourceService.getResourceAllocations(intent.key());
        resourceService.release(Lists.newArrayList(resourceAllocationsByKey));
    }
    // Allocate resources
    log.debug("Allocating bandwidth for intent {}: {} bps", newResourceConsumer, resourcesToAdd);
    List<ResourceAllocation> allocations = resourceService.allocate(newResourceConsumer, resourcesToAdd);
    if (allocations.isEmpty()) {
        log.debug("No resources allocated for intent {}", newResourceConsumer);
    }
    log.debug("Done allocating bandwidth for intent {}", newResourceConsumer);
}
#end_block

#method_before
private SinglePointToMultiPointIntent makeIntent(String ingressId, String[] egressIds) {
    ConnectPoint ingressPoint = connectPoint(ingressId, 2);
    Set<ConnectPoint> egressPoints = new HashSet<>();
    for (String egressId : egressIds) {
        egressPoints.add(connectPoint(egressId, 1));
    }
    return SinglePointToMultiPointIntent.builder().appId(APPID).selector(selector).treatment(treatment).ingressPoint(ingressPoint).egressPoints(egressPoints).build();
}
#method_after
private SinglePointToMultiPointIntent makeIntent(FilteredConnectPoint ingress, Set<FilteredConnectPoint> egress) {
    return makeIntent(ingress, egress, selector);
}
#end_block

#method_before
private SinglePointToMultiPointIntentCompiler makeCompiler(String[] hops, PathService pathService, ResourceService resourceService) {
    SinglePointToMultiPointIntentCompiler compiler = new SinglePointToMultiPointIntentCompiler();
    if (pathService == null) {
        compiler.pathService = new IntentTestsMocks.Mp2MpMockPathService(hops);
    } else {
        compiler.pathService = pathService;
    }
    if (resourceService == null) {
        compiler.resourceService = new MockResourceService();
    } else {
        compiler.resourceService = resourceService;
    }
    return compiler;
}
#method_after
private SinglePointToMultiPointIntentCompiler makeCompiler(String[] hops, PathService pathService, ResourceService resourceService) {
    SinglePointToMultiPointIntentCompiler compiler = new SinglePointToMultiPointIntentCompiler();
    compiler.deviceService = new IntentTestsMocks.MockDeviceService();
    if (pathService == null) {
        compiler.pathService = new IntentTestsMocks.Mp2MpMockPathService(hops);
    } else {
        compiler.pathService = pathService;
    }
    if (resourceService == null) {
        compiler.resourceService = new MockResourceService();
    } else {
        compiler.resourceService = resourceService;
    }
    return compiler;
}
#end_block

#method_before
@Test
public void testSingleLongPathCompilation() {
    String ingress = "ingress";
    String[] egress = { "egress" };
    SinglePointToMultiPointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    String[] hops = { "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8" };
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent instanceof LinkCollectionIntent, is(true));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(9));
        assertThat(linkIntent.links(), linksHasPath("ingress", "h1"));
        assertThat(linkIntent.links(), linksHasPath("h1", "h2"));
        assertThat(linkIntent.links(), linksHasPath("h2", "h3"));
        assertThat(linkIntent.links(), linksHasPath("h4", "h5"));
        assertThat(linkIntent.links(), linksHasPath("h5", "h6"));
        assertThat(linkIntent.links(), linksHasPath("h7", "h8"));
        assertThat(linkIntent.links(), linksHasPath("h8", "egress"));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testSingleLongPathCompilation() {
    FilteredConnectPoint ingress = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1));
    Set<FilteredConnectPoint> egress = Sets.newHashSet(new FilteredConnectPoint(new ConnectPoint(DID_8, PORT_2)));
    SinglePointToMultiPointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    String[] hops = { S2, S3, S4, S5, S6, S7 };
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent instanceof LinkCollectionIntent, is(true));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(7));
        assertThat(linkIntent.links(), linksHasPath(S1, S2));
        assertThat(linkIntent.links(), linksHasPath(S2, S3));
        assertThat(linkIntent.links(), linksHasPath(S3, S4));
        assertThat(linkIntent.links(), linksHasPath(S4, S5));
        assertThat(linkIntent.links(), linksHasPath(S5, S6));
        assertThat(linkIntent.links(), linksHasPath(S6, S7));
        assertThat(linkIntent.links(), linksHasPath(S7, S8));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testSameDeviceCompilation() {
    String ingress = "i1";
    String[] egress = { "i2", "i3" };
    SinglePointToMultiPointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    final String[] hops = {};
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(egress.length));
        assertThat(linkIntent.links(), linksHasPath("i1", "i2"));
        assertThat(linkIntent.links(), linksHasPath("i1", "i3"));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testSameDeviceCompilation() {
    FilteredConnectPoint ingress = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1));
    Set<FilteredConnectPoint> egress = Sets.newHashSet(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_2)), new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_3)));
    SinglePointToMultiPointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    final String[] hops = {};
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(0));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testFilteredConnectPointIntent() {
    FilteredConnectPoint ingress = new FilteredConnectPoint(connectPoint("of1", 1));
    Set<FilteredConnectPoint> egress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("of3", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("of4", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    SinglePointToMultiPointIntent intent = makeFilteredConnectPointIntent(ingress, egress, selector);
    String[] hops = { "of2" };
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath("of1", "of2"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of4"));
        Set<FilteredConnectPoint> ingressPoints = linkIntent.filteredIngressPoints();
        assertThat("Link collection ingress points do not match base intent", ingressPoints.size() == 1 && ingressPoints.contains(intent.filteredIngressPoint()));
        assertThat("Link collection egress points do not match base intent", linkIntent.filteredEgressPoints().equals(intent.filteredEgressPoints()));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testFilteredConnectPointIntent() {
    FilteredConnectPoint ingress = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1));
    Set<FilteredConnectPoint> egress = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_3, PORT_1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(new ConnectPoint(DID_4, PORT_1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    SinglePointToMultiPointIntent intent = makeIntent(ingress, egress, selector);
    String[] hops = { S2 };
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath(S1, S2));
        assertThat(linkIntent.links(), linksHasPath(S2, S3));
        assertThat(linkIntent.links(), linksHasPath(S2, S4));
        Set<FilteredConnectPoint> ingressPoints = linkIntent.filteredIngressPoints();
        assertThat("Link collection ingress points do not match base intent", ingressPoints.size() == 1 && ingressPoints.contains(intent.filteredIngressPoint()));
        assertThat("Link collection egress points do not match base intent", linkIntent.filteredEgressPoints().equals(intent.filteredEgressPoints()));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testNonTrivialSelectorsIntent() {
    FilteredConnectPoint ingress = new FilteredConnectPoint(connectPoint("of1", 1));
    Set<FilteredConnectPoint> egress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("of3", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("of4", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    SinglePointToMultiPointIntent intent = makeFilteredConnectPointIntent(ingress, egress, ipPrefixSelector);
    String[] hops = { "of2" };
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath("of1", "of2"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of4"));
        Set<FilteredConnectPoint> ingressPoints = linkIntent.filteredIngressPoints();
        assertThat("Link collection ingress points do not match base intent", ingressPoints.size() == 1 && ingressPoints.contains(intent.filteredIngressPoint()));
        assertThat("Link collection egress points do not match base intent", linkIntent.filteredEgressPoints().equals(intent.filteredEgressPoints()));
        assertThat(linkIntent.selector(), is(ipPrefixSelector));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testNonTrivialSelectorsIntent() {
    FilteredConnectPoint ingress = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1));
    Set<FilteredConnectPoint> egress = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_3, PORT_1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(new ConnectPoint(DID_4, PORT_1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    SinglePointToMultiPointIntent intent = makeIntent(ingress, egress, ipPrefixSelector);
    String[] hops = { S2 };
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath(S1, S2));
        assertThat(linkIntent.links(), linksHasPath(S2, S3));
        assertThat(linkIntent.links(), linksHasPath(S2, S4));
        Set<FilteredConnectPoint> ingressPoints = linkIntent.filteredIngressPoints();
        assertThat("Link collection ingress points do not match base intent", ingressPoints.size() == 1 && ingressPoints.contains(intent.filteredIngressPoint()));
        assertThat("Link collection egress points do not match base intent", linkIntent.filteredEgressPoints().equals(intent.filteredEgressPoints()));
        assertThat(linkIntent.selector(), is(ipPrefixSelector));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testBandwidthConstrainedIntentAllocation() {
    double bpsToReserve = 100.0;
    DeviceId deviceId1 = DeviceId.deviceId("of:s1");
    DeviceId deviceId2 = DeviceId.deviceId("of:s2");
    DeviceId deviceId3 = DeviceId.deviceId("of:s3");
    DeviceId deviceId4 = DeviceId.deviceId("of:s4");
    PortNumber port1 = PortNumber.portNumber(1);
    PortNumber port2 = PortNumber.portNumber(2);
    PortNumber port3 = PortNumber.portNumber(3);
    ContinuousResource resourceSw1P1 = Resources.continuous(deviceId1, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw1P2 = Resources.continuous(deviceId1, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P1 = Resources.continuous(deviceId2, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P2 = Resources.continuous(deviceId2, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P1 = Resources.continuous(deviceId3, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P2 = Resources.continuous(deviceId3, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P3 = Resources.continuous(deviceId3, port3, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw4P1 = Resources.continuous(deviceId4, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw4P2 = Resources.continuous(deviceId4, port2, Bandwidth.class).resource(bpsToReserve);
    String[] hops = { deviceId3.toString() };
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(1000.0);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(bpsToReserve)));
    FilteredConnectPoint ingress = new FilteredConnectPoint(connectPoint("s4", 1));
    Set<FilteredConnectPoint> egress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("s1", 2), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("s2", 2), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    SinglePointToMultiPointIntent intent = makeFilteredConnectPointIntent(ingress, egress, ipPrefixSelector, constraints);
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(null, new IntentTestsMocks.FixedMP2MPMockPathService(hops), resourceService);
    compiler.compile(intent, null);
    IntentId intentId = intent.id();
    ResourceAllocation rA1 = new ResourceAllocation(resourceSw1P1, intentId);
    ResourceAllocation rA2 = new ResourceAllocation(resourceSw1P2, intentId);
    ResourceAllocation rA3 = new ResourceAllocation(resourceSw2P1, intentId);
    ResourceAllocation rA4 = new ResourceAllocation(resourceSw2P2, intentId);
    ResourceAllocation rA5 = new ResourceAllocation(resourceSw3P1, intentId);
    ResourceAllocation rA6 = new ResourceAllocation(resourceSw3P2, intentId);
    ResourceAllocation rA7 = new ResourceAllocation(resourceSw3P3, intentId);
    ResourceAllocation rA8 = new ResourceAllocation(resourceSw4P1, intentId);
    ResourceAllocation rA9 = new ResourceAllocation(resourceSw4P2, intentId);
    Set<ResourceAllocation> expectedResourceAllocations = Sets.newHashSet(rA1, rA2, rA3, rA4, rA5, rA6, rA7, rA8, rA9);
    Set<ResourceAllocation> resourceAllocations = Sets.newHashSet(resourceService.getResourceAllocations(intent.id()));
    assertThat(resourceAllocations, hasSize(9));
    assertEquals(expectedResourceAllocations, resourceAllocations);
}
#method_after
@Test
public void testBandwidthConstrainedIntentAllocation() {
    final double bpsTotal = 1000.0;
    final double bpsToReserve = 100.0;
    ContinuousResource resourceSw1P1 = Resources.continuous(DID_1, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw1P2 = Resources.continuous(DID_1, PORT_2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P1 = Resources.continuous(DID_2, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P2 = Resources.continuous(DID_2, PORT_2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P1 = Resources.continuous(DID_3, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P2 = Resources.continuous(DID_3, PORT_2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P3 = Resources.continuous(DID_3, PORT_3, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw4P1 = Resources.continuous(DID_4, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw4P2 = Resources.continuous(DID_4, PORT_2, Bandwidth.class).resource(bpsToReserve);
    String[] hops = { DID_3.toString() };
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(bpsTotal);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(bpsToReserve)));
    FilteredConnectPoint ingress = new FilteredConnectPoint(new ConnectPoint(DID_4, PORT_1));
    Set<FilteredConnectPoint> egress = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_2)), new FilteredConnectPoint(new ConnectPoint(DID_2, PORT_2)));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    SinglePointToMultiPointIntent intent = makeIntent(ingress, egress, ipPrefixSelector, constraints);
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(null, new IntentTestsMocks.FixedMP2MPMockPathService(hops), resourceService);
    compiler.compile(intent, null);
    Key intentKey = intent.key();
    ResourceAllocation rA1 = new ResourceAllocation(resourceSw1P1, intentKey);
    ResourceAllocation rA2 = new ResourceAllocation(resourceSw1P2, intentKey);
    ResourceAllocation rA3 = new ResourceAllocation(resourceSw2P1, intentKey);
    ResourceAllocation rA4 = new ResourceAllocation(resourceSw2P2, intentKey);
    ResourceAllocation rA5 = new ResourceAllocation(resourceSw3P1, intentKey);
    ResourceAllocation rA6 = new ResourceAllocation(resourceSw3P2, intentKey);
    ResourceAllocation rA7 = new ResourceAllocation(resourceSw3P3, intentKey);
    ResourceAllocation rA8 = new ResourceAllocation(resourceSw4P1, intentKey);
    ResourceAllocation rA9 = new ResourceAllocation(resourceSw4P2, intentKey);
    Set<ResourceAllocation> expectedResourceAllocations = ImmutableSet.of(rA1, rA2, rA3, rA4, rA5, rA6, rA7, rA8, rA9);
    Set<ResourceAllocation> resourceAllocations = ImmutableSet.copyOf(resourceService.getResourceAllocations(intentKey));
    assertThat(resourceAllocations, hasSize(9));
    assertEquals(expectedResourceAllocations, resourceAllocations);
}
#end_block

#method_before
@Override
public List<Intent> compile(MultiPointToSinglePointIntent intent, List<Intent> installable) {
    Map<DeviceId, Link> links = new HashMap<>();
    ConnectPoint egressPoint = intent.egressPoint();
    final boolean allowMissingPaths = intentAllowsPartialFailure(intent);
    boolean hasPaths = false;
    boolean missingSomePaths = false;
    for (ConnectPoint ingressPoint : intent.ingressPoints()) {
        if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
            if (deviceService.isAvailable(ingressPoint.deviceId())) {
                hasPaths = true;
            } else {
                missingSomePaths = true;
            }
            continue;
        }
        Path path = getPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
        if (path != null) {
            hasPaths = true;
            for (Link link : path.links()) {
                if (links.containsKey(link.dst().deviceId())) {
                    // We've already reached the existing tree with the first
                    // part of this path. Add the merging point with different
                    // incoming port, but don't add the remainder of the path
                    // in case it differs from the path we already have.
                    links.put(link.src().deviceId(), link);
                    break;
                }
                links.put(link.src().deviceId(), link);
            }
        } else {
            missingSomePaths = true;
        }
    }
    // Allocate bandwidth on existing paths if a bandwidth constraint is set
    List<ConnectPoint> ingressCPs = intent.filteredIngressPoints().stream().map(fcp -> fcp.connectPoint()).collect(Collectors.toList());
    ConnectPoint egressCP = intent.filteredEgressPoint().connectPoint();
    List<ConnectPoint> pathCPs = links.values().stream().flatMap(l -> Stream.of(l.src(), l.dst())).collect(Collectors.toList());
    pathCPs.addAll(ingressCPs);
    pathCPs.add(egressCP);
    allocateBandwidth(intent, pathCPs);
    if (!hasPaths) {
        throw new IntentException("Cannot find any path between ingress and egress points.");
    } else if (!allowMissingPaths && missingSomePaths) {
        throw new IntentException("Missing some paths between ingress and egress points.");
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).key(intent.key()).treatment(intent.treatment()).selector(intent.selector()).links(Sets.newHashSet(links.values())).filteredIngressPoints(intent.filteredIngressPoints()).filteredEgressPoints(ImmutableSet.of(intent.filteredEgressPoint())).priority(intent.priority()).constraints(intent.constraints()).build();
    return Collections.singletonList(result);
}
#method_after
@Override
public List<Intent> compile(MultiPointToSinglePointIntent intent, List<Intent> installable) {
    Map<DeviceId, Link> links = new HashMap<>();
    ConnectPoint egressPoint = intent.egressPoint();
    final boolean allowMissingPaths = intentAllowsPartialFailure(intent);
    boolean hasPaths = false;
    boolean missingSomePaths = false;
    for (ConnectPoint ingressPoint : intent.ingressPoints()) {
        if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
            if (deviceService.isAvailable(ingressPoint.deviceId())) {
                hasPaths = true;
            } else {
                missingSomePaths = true;
            }
            continue;
        }
        Path path = getPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
        if (path != null) {
            hasPaths = true;
            for (Link link : path.links()) {
                if (links.containsKey(link.dst().deviceId())) {
                    // We've already reached the existing tree with the first
                    // part of this path. Add the merging point with different
                    // incoming port, but don't add the remainder of the path
                    // in case it differs from the path we already have.
                    links.put(link.src().deviceId(), link);
                    break;
                }
                links.put(link.src().deviceId(), link);
            }
        } else {
            missingSomePaths = true;
        }
    }
    // Allocate bandwidth on existing paths if a bandwidth constraint is set
    List<ConnectPoint> ingressCPs = intent.filteredIngressPoints().stream().map(fcp -> fcp.connectPoint()).collect(Collectors.toList());
    ConnectPoint egressCP = intent.filteredEgressPoint().connectPoint();
    List<ConnectPoint> pathCPs = links.values().stream().flatMap(l -> Stream.of(l.src(), l.dst())).collect(Collectors.toList());
    pathCPs.addAll(ingressCPs);
    pathCPs.add(egressCP);
    allocateBandwidth(intent, pathCPs);
    if (!hasPaths) {
        throw new IntentException("Cannot find any path between ingress and egress points.");
    } else if (!allowMissingPaths && missingSomePaths) {
        throw new IntentException("Missing some paths between ingress and egress points.");
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).key(intent.key()).treatment(intent.treatment()).selector(intent.selector()).links(Sets.newHashSet(links.values())).filteredIngressPoints(intent.filteredIngressPoints()).filteredEgressPoints(ImmutableSet.of(intent.filteredEgressPoint())).priority(intent.priority()).constraints(intent.constraints()).resourceGroup(intent.resourceGroup()).build();
    return Collections.singletonList(result);
}
#end_block

#method_before
private MultiPointToSinglePointIntent makeIntent(String[] ingressIds, String egressId) {
    return makeIntent(ingressIds, egressId, Lists.newArrayList());
}
#method_after
private MultiPointToSinglePointIntent makeIntent(Set<FilteredConnectPoint> ingress, FilteredConnectPoint egress) {
    return makeIntent(ingress, egress, Lists.newArrayList());
}
#end_block

#method_before
@Test
public void testSingleLongPathCompilation() {
    String[] ingress = { "ingress" };
    String egress = "egress";
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    String[] hops = { "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8" };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent instanceof LinkCollectionIntent, is(true));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(9));
        assertThat(linkIntent.links(), linksHasPath("ingress", "h1"));
        assertThat(linkIntent.links(), linksHasPath("h1", "h2"));
        assertThat(linkIntent.links(), linksHasPath("h2", "h3"));
        assertThat(linkIntent.links(), linksHasPath("h4", "h5"));
        assertThat(linkIntent.links(), linksHasPath("h5", "h6"));
        assertThat(linkIntent.links(), linksHasPath("h7", "h8"));
        assertThat(linkIntent.links(), linksHasPath("h8", "egress"));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testSingleLongPathCompilation() {
    Set<FilteredConnectPoint> ingress = Sets.newHashSet(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1)));
    FilteredConnectPoint egress = new FilteredConnectPoint(new ConnectPoint(DID_8, PORT_1));
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    String[] hops = { S2, S3, S4, S5, S6, S7 };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent instanceof LinkCollectionIntent, is(true));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(7));
        assertThat(linkIntent.links(), linksHasPath(S1, S2));
        assertThat(linkIntent.links(), linksHasPath(S2, S3));
        assertThat(linkIntent.links(), linksHasPath(S3, S4));
        assertThat(linkIntent.links(), linksHasPath(S4, S5));
        assertThat(linkIntent.links(), linksHasPath(S5, S6));
        assertThat(linkIntent.links(), linksHasPath(S6, S7));
        assertThat(linkIntent.links(), linksHasPath(S7, S8));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testTwoIngressCompilation() {
    String[] ingress = { "ingress1", "ingress2" };
    String egress = "egress";
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    final String[] hops = { "inner1", "inner2" };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent instanceof LinkCollectionIntent, is(true));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(4));
        assertThat(linkIntent.links(), linksHasPath("ingress1", "inner1"));
        assertThat(linkIntent.links(), linksHasPath("ingress2", "inner1"));
        assertThat(linkIntent.links(), linksHasPath("inner1", "inner2"));
        assertThat(linkIntent.links(), linksHasPath("inner2", "egress"));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testTwoIngressCompilation() {
    Set<FilteredConnectPoint> ingress = Sets.newHashSet(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1)), new FilteredConnectPoint(new ConnectPoint(DID_2, PORT_1)));
    FilteredConnectPoint egress = new FilteredConnectPoint(new ConnectPoint(DID_4, PORT_1));
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    final String[] hops = { S3 };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent instanceof LinkCollectionIntent, is(true));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath(S1, S3));
        assertThat(linkIntent.links(), linksHasPath(S2, S3));
        assertThat(linkIntent.links(), linksHasPath(S3, S4));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testMultiIngressCompilation() {
    String[] ingress = { "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "i9", "i10" };
    String egress = "e";
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    final String[] hops = { "n1" };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent instanceof LinkCollectionIntent, is(true));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(ingress.length + 1));
        for (String ingressToCheck : ingress) {
            assertThat(linkIntent.links(), linksHasPath(ingressToCheck, "n1"));
        }
        assertThat(linkIntent.links(), linksHasPath("n1", egress));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testMultiIngressCompilation() {
    Set<FilteredConnectPoint> ingress = Sets.newHashSet(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1)), new FilteredConnectPoint(new ConnectPoint(DID_2, PORT_1)), new FilteredConnectPoint(new ConnectPoint(DID_3, PORT_1)));
    FilteredConnectPoint egress = new FilteredConnectPoint(new ConnectPoint(DID_5, PORT_1));
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    final String[] hops = { S4 };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent instanceof LinkCollectionIntent, is(true));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(4));
        assertThat(linkIntent.links(), linksHasPath(S1, S4));
        assertThat(linkIntent.links(), linksHasPath(S2, S4));
        assertThat(linkIntent.links(), linksHasPath(S3, S4));
        assertThat(linkIntent.links(), linksHasPath(S4, S5));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testSameDeviceCompilation() {
    String[] ingress = { "i1", "i2" };
    String egress = "i3";
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    final String[] hops = {};
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(ingress.length));
        assertThat(linkIntent.links(), linksHasPath("i1", "i3"));
        assertThat(linkIntent.links(), linksHasPath("i2", "i3"));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testSameDeviceCompilation() {
    Set<FilteredConnectPoint> ingress = Sets.newHashSet(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1)), new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_2)));
    FilteredConnectPoint egress = new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_3));
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress);
    assertThat(intent, is(notNullValue()));
    final String[] hops = {};
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(0));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testFilteredConnectPointIntent() {
    Set<FilteredConnectPoint> ingress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("of1", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("of2", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    FilteredConnectPoint egress = new FilteredConnectPoint(connectPoint("of4", 1));
    MultiPointToSinglePointIntent intent = makeFilteredConnectPointIntent(ingress, egress, selector);
    String[] hops = { "of3" };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath("of1", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of3", "of4"));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testFilteredConnectPointIntent() {
    Set<FilteredConnectPoint> ingress = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(new ConnectPoint(DID_2, PORT_1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    FilteredConnectPoint egress = new FilteredConnectPoint(new ConnectPoint(DID_4, PORT_2));
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress, selector);
    String[] hops = { S3 };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath(S1, S3));
        assertThat(linkIntent.links(), linksHasPath(S2, S3));
        assertThat(linkIntent.links(), linksHasPath(S3, S4));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testNonTrivialSelectorsIntent() {
    Set<FilteredConnectPoint> ingress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("of1", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("of2", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    FilteredConnectPoint egress = new FilteredConnectPoint(connectPoint("of4", 1));
    MultiPointToSinglePointIntent intent = makeFilteredConnectPointIntent(ingress, egress, ipPrefixSelector);
    String[] hops = { "of3" };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath("of1", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of3", "of4"));
        assertThat(linkIntent.selector(), is(ipPrefixSelector));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#method_after
@Test
public void testNonTrivialSelectorsIntent() {
    Set<FilteredConnectPoint> ingress = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(new ConnectPoint(DID_2, PORT_1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    FilteredConnectPoint egress = new FilteredConnectPoint(new ConnectPoint(DID_4, PORT_2));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress, ipPrefixSelector);
    String[] hops = { S3 };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath(S1, S3));
        assertThat(linkIntent.links(), linksHasPath(S2, S3));
        assertThat(linkIntent.links(), linksHasPath(S3, S4));
        assertThat(linkIntent.selector(), is(ipPrefixSelector));
    }
    assertThat("key is inherited", resultIntent.key(), is(intent.key()));
}
#end_block

#method_before
@Test
public void testBandwidthConstrainedIntentAllocation() {
    double bpsToReserve = 100.0;
    DeviceId deviceId1 = DeviceId.deviceId("of:s1");
    DeviceId deviceId2 = DeviceId.deviceId("of:s2");
    DeviceId deviceId3 = DeviceId.deviceId("of:s3");
    DeviceId deviceId4 = DeviceId.deviceId("of:s4");
    PortNumber port1 = PortNumber.portNumber(1);
    PortNumber port2 = PortNumber.portNumber(2);
    PortNumber port3 = PortNumber.portNumber(3);
    ContinuousResource resourceSw1P1 = Resources.continuous(deviceId1, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw1P2 = Resources.continuous(deviceId1, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P1 = Resources.continuous(deviceId2, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P2 = Resources.continuous(deviceId2, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P1 = Resources.continuous(deviceId3, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P2 = Resources.continuous(deviceId3, port2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P3 = Resources.continuous(deviceId3, port3, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw4P1 = Resources.continuous(deviceId4, port1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw4P2 = Resources.continuous(deviceId4, port2, Bandwidth.class).resource(bpsToReserve);
    String[] hops = { deviceId3.toString() };
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(1000.0);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(bpsToReserve)));
    Set<FilteredConnectPoint> ingress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("s1", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("s2", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    FilteredConnectPoint egress = new FilteredConnectPoint(connectPoint("s4", 2));
    MultiPointToSinglePointIntent intent = makeFilteredConnectPointIntent(ingress, egress, ipPrefixSelector, constraints);
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(null, new IntentTestsMocks.FixedMP2MPMockPathService(hops), resourceService);
    compiler.compile(intent, null);
    IntentId intentId = intent.id();
    ResourceAllocation rA1 = new ResourceAllocation(resourceSw1P1, intentId);
    ResourceAllocation rA2 = new ResourceAllocation(resourceSw1P2, intentId);
    ResourceAllocation rA3 = new ResourceAllocation(resourceSw2P1, intentId);
    ResourceAllocation rA4 = new ResourceAllocation(resourceSw2P2, intentId);
    ResourceAllocation rA5 = new ResourceAllocation(resourceSw3P1, intentId);
    ResourceAllocation rA6 = new ResourceAllocation(resourceSw3P2, intentId);
    ResourceAllocation rA7 = new ResourceAllocation(resourceSw3P3, intentId);
    ResourceAllocation rA8 = new ResourceAllocation(resourceSw4P1, intentId);
    ResourceAllocation rA9 = new ResourceAllocation(resourceSw4P2, intentId);
    Set<ResourceAllocation> expectedResourceAllocations = Sets.newHashSet(rA1, rA2, rA3, rA4, rA5, rA6, rA7, rA8, rA9);
    Set<ResourceAllocation> resourceAllocations = Sets.newHashSet(resourceService.getResourceAllocations(intent.id()));
    assertThat(resourceAllocations, hasSize(9));
    assertEquals(expectedResourceAllocations, resourceAllocations);
}
#method_after
@Test
public void testBandwidthConstrainedIntentAllocation() {
    final double bpsTotal = 1000.0;
    final double bpsToReserve = 100.0;
    ContinuousResource resourceSw1P1 = Resources.continuous(DID_1, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw1P2 = Resources.continuous(DID_1, PORT_2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P1 = Resources.continuous(DID_2, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw2P2 = Resources.continuous(DID_2, PORT_2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P1 = Resources.continuous(DID_3, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P2 = Resources.continuous(DID_3, PORT_2, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw3P3 = Resources.continuous(DID_3, PORT_3, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw4P1 = Resources.continuous(DID_4, PORT_1, Bandwidth.class).resource(bpsToReserve);
    ContinuousResource resourceSw4P2 = Resources.continuous(DID_4, PORT_2, Bandwidth.class).resource(bpsToReserve);
    String[] hops = { DID_3.toString() };
    final ResourceService resourceService = MockResourceService.makeCustomBandwidthResourceService(bpsTotal);
    final List<Constraint> constraints = Collections.singletonList(new BandwidthConstraint(Bandwidth.bps(bpsToReserve)));
    Set<FilteredConnectPoint> ingress = ImmutableSet.of(new FilteredConnectPoint(new ConnectPoint(DID_1, PORT_1)), new FilteredConnectPoint(new ConnectPoint(DID_2, PORT_1)));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    FilteredConnectPoint egress = new FilteredConnectPoint(new ConnectPoint(DID_4, PORT_2));
    MultiPointToSinglePointIntent intent = makeIntent(ingress, egress, ipPrefixSelector, constraints);
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(null, new IntentTestsMocks.FixedMP2MPMockPathService(hops), resourceService);
    compiler.compile(intent, null);
    Key intentKey = intent.key();
    ResourceAllocation rA1 = new ResourceAllocation(resourceSw1P1, intentKey);
    ResourceAllocation rA2 = new ResourceAllocation(resourceSw1P2, intentKey);
    ResourceAllocation rA3 = new ResourceAllocation(resourceSw2P1, intentKey);
    ResourceAllocation rA4 = new ResourceAllocation(resourceSw2P2, intentKey);
    ResourceAllocation rA5 = new ResourceAllocation(resourceSw3P1, intentKey);
    ResourceAllocation rA6 = new ResourceAllocation(resourceSw3P2, intentKey);
    ResourceAllocation rA7 = new ResourceAllocation(resourceSw3P3, intentKey);
    ResourceAllocation rA8 = new ResourceAllocation(resourceSw4P1, intentKey);
    ResourceAllocation rA9 = new ResourceAllocation(resourceSw4P2, intentKey);
    Set<ResourceAllocation> expectedResourceAllocations = ImmutableSet.of(rA1, rA2, rA3, rA4, rA5, rA6, rA7, rA8, rA9);
    Set<ResourceAllocation> resourceAllocations = ImmutableSet.copyOf(resourceService.getResourceAllocations(intentKey));
    assertThat(resourceAllocations, hasSize(9));
    assertEquals(expectedResourceAllocations, resourceAllocations);
}
#end_block

#method_before
@Override
public List<Intent> compile(SinglePointToMultiPointIntent intent, List<Intent> installable) {
    Set<Link> links = new HashSet<>();
    final boolean allowMissingPaths = intentAllowsPartialFailure(intent);
    boolean hasPaths = false;
    boolean missingSomePaths = false;
    for (ConnectPoint egressPoint : intent.egressPoints()) {
        if (egressPoint.deviceId().equals(intent.ingressPoint().deviceId())) {
            // devices are the same.
            if (deviceService.isAvailable(egressPoint.deviceId())) {
                hasPaths = true;
            } else {
                missingSomePaths = true;
            }
            continue;
        }
        Path path = getPath(intent, intent.ingressPoint().deviceId(), egressPoint.deviceId());
        if (path != null) {
            hasPaths = true;
            links.addAll(path.links());
        } else {
            missingSomePaths = true;
        }
    }
    // Allocate bandwidth if a bandwidth constraint is set
    ConnectPoint ingressCP = intent.filteredIngressPoint().connectPoint();
    List<ConnectPoint> egressCPs = intent.filteredEgressPoints().stream().map(fcp -> fcp.connectPoint()).collect(Collectors.toList());
    List<ConnectPoint> pathCPs = links.stream().flatMap(l -> Stream.of(l.src(), l.dst())).collect(Collectors.toList());
    pathCPs.add(ingressCP);
    pathCPs.addAll(egressCPs);
    allocateBandwidth(intent, pathCPs);
    if (!hasPaths) {
        throw new IntentException("Cannot find any path between ingress and egress points.");
    } else if (!allowMissingPaths && missingSomePaths) {
        throw new IntentException("Missing some paths between ingress and egress points.");
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).key(intent.key()).selector(intent.selector()).treatment(intent.treatment()).links(links).filteredIngressPoints(ImmutableSet.of(intent.filteredIngressPoint())).filteredEgressPoints(intent.filteredEgressPoints()).priority(intent.priority()).applyTreatmentOnEgress(true).constraints(intent.constraints()).build();
    return Collections.singletonList(result);
}
#method_after
@Override
public List<Intent> compile(SinglePointToMultiPointIntent intent, List<Intent> installable) {
    Set<Link> links = new HashSet<>();
    final boolean allowMissingPaths = intentAllowsPartialFailure(intent);
    boolean hasPaths = false;
    boolean missingSomePaths = false;
    for (ConnectPoint egressPoint : intent.egressPoints()) {
        if (egressPoint.deviceId().equals(intent.ingressPoint().deviceId())) {
            // devices are the same.
            if (deviceService.isAvailable(egressPoint.deviceId())) {
                hasPaths = true;
            } else {
                missingSomePaths = true;
            }
            continue;
        }
        Path path = getPath(intent, intent.ingressPoint().deviceId(), egressPoint.deviceId());
        if (path != null) {
            hasPaths = true;
            links.addAll(path.links());
        } else {
            missingSomePaths = true;
        }
    }
    // Allocate bandwidth if a bandwidth constraint is set
    ConnectPoint ingressCP = intent.filteredIngressPoint().connectPoint();
    List<ConnectPoint> egressCPs = intent.filteredEgressPoints().stream().map(fcp -> fcp.connectPoint()).collect(Collectors.toList());
    List<ConnectPoint> pathCPs = links.stream().flatMap(l -> Stream.of(l.src(), l.dst())).collect(Collectors.toList());
    pathCPs.add(ingressCP);
    pathCPs.addAll(egressCPs);
    allocateBandwidth(intent, pathCPs);
    if (!hasPaths) {
        throw new IntentException("Cannot find any path between ingress and egress points.");
    } else if (!allowMissingPaths && missingSomePaths) {
        throw new IntentException("Missing some paths between ingress and egress points.");
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).key(intent.key()).selector(intent.selector()).treatment(intent.treatment()).links(links).filteredIngressPoints(ImmutableSet.of(intent.filteredIngressPoint())).filteredEgressPoints(intent.filteredEgressPoints()).priority(intent.priority()).applyTreatmentOnEgress(true).constraints(intent.constraints()).resourceGroup(intent.resourceGroup()).build();
    return Collections.singletonList(result);
}
#end_block

#method_before
private Intent createLinkCollectionIntent(Path path, Host src, Host dst, HostToHostIntent intent) {
    // Try to allocate bandwidth
    List<ConnectPoint> pathCPs = path.links().stream().flatMap(l -> Stream.of(l.src(), l.dst())).collect(Collectors.toList());
    allocateBandwidth(intent, pathCPs);
    Link ingressLink = path.links().get(0);
    Link egressLink = path.links().get(path.links().size() - 1);
    FilteredConnectPoint ingressPoint = getFilteredPointFromLink(ingressLink);
    FilteredConnectPoint egressPoint = getFilteredPointFromLink(egressLink);
    TrafficSelector selector = builder(intent.selector()).matchEthSrc(src.mac()).matchEthDst(dst.mac()).build();
    /*
         * The path contains also the edge links, these are not necessary
         * for the LinkCollectionIntent.
         */
    Set<Link> coreLinks = path.links().stream().filter(link -> !link.type().equals(EDGE)).collect(Collectors.toSet());
    return LinkCollectionIntent.builder().key(intent.key()).appId(intent.appId()).selector(selector).treatment(intent.treatment()).links(coreLinks).filteredIngressPoints(ImmutableSet.of(ingressPoint)).filteredEgressPoints(ImmutableSet.of(egressPoint)).applyTreatmentOnEgress(true).constraints(intent.constraints()).priority(intent.priority()).build();
}
#method_after
private Intent createLinkCollectionIntent(Path path, Host src, Host dst, HostToHostIntent intent) {
    // Try to allocate bandwidth
    List<ConnectPoint> pathCPs = path.links().stream().flatMap(l -> Stream.of(l.src(), l.dst())).collect(Collectors.toList());
    allocateBandwidth(intent, pathCPs);
    Link ingressLink = path.links().get(0);
    Link egressLink = path.links().get(path.links().size() - 1);
    FilteredConnectPoint ingressPoint = getFilteredPointFromLink(ingressLink);
    FilteredConnectPoint egressPoint = getFilteredPointFromLink(egressLink);
    TrafficSelector selector = builder(intent.selector()).matchEthSrc(src.mac()).matchEthDst(dst.mac()).build();
    /*
         * The path contains also the edge links, these are not necessary
         * for the LinkCollectionIntent.
         */
    Set<Link> coreLinks = path.links().stream().filter(link -> !link.type().equals(EDGE)).collect(Collectors.toSet());
    return LinkCollectionIntent.builder().key(intent.key()).appId(intent.appId()).selector(selector).treatment(intent.treatment()).links(coreLinks).filteredIngressPoints(ImmutableSet.of(ingressPoint)).filteredEgressPoints(ImmutableSet.of(egressPoint)).applyTreatmentOnEgress(true).constraints(intent.constraints()).priority(intent.priority()).resourceGroup(intent.resourceGroup()).build();
}
#end_block

#method_before
@Override
public List<? extends OFObject> getPortsOf(PortDescPropertyType type) {
    return ImmutableList.copyOf(opticalPorts);
}
#method_after
@Override
public List<? extends OFObject> getPortsOf(PortDescPropertyType type) {
    // Expected type is OPTICAL_TRANSPORT
    if (type == PortDescPropertyType.OPTICAL_TRANSPORT) {
        return ImmutableList.copyOf(opticalPorts);
    }
    // Any other type, return empty
    log.warn("Unexpected port description property type: {}", type);
    return ImmutableList.of();
}
#end_block

#method_before
@Override
public /**
 * Returns a list of standard (Ethernet) ports.
 *
 * @return List of ports
 */
List<OFPortDesc> getPorts() {
    return Collections.EMPTY_LIST;
}
#method_after
@Override
public List<OFPortDesc> getPorts() {
    return ImmutableList.of();
}
#end_block

#method_before
@Override
public Device.Type deviceType() {
    return Device.Type.OPTICAL_AMPLIFIER;
}
#method_after
@Override
public Device.Type deviceType() {
    return Type.OPTICAL_AMPLIFIER;
}
#end_block

#method_before
@Override
public final void sendMsg(OFMessage m) {
    List<OFMessage> messages = new ArrayList<>();
    messages.add(m);
    if (m.getType() == OFType.STATS_REQUEST) {
        OFStatsRequest sr = (OFStatsRequest) m;
        log.debug("OPLK EDFA rebuilding stats request type {}", sr.getStatsType());
        switch(sr.getStatsType()) {
            case PORT:
                // add Oplink experiment message to get the port's current power
                OFOplinkPortPowerRequest powerRequest = this.factory().buildOplinkPortPowerRequest().setXid(sr.getXid()).setFlags(sr.getFlags()).build();
                messages.add(powerRequest);
                // add experiment message to get adjacent ports
                OFExpPortAdjacencyRequest adjacencyRequest = this.factory().buildExpPortAdjacencyRequest().setXid(sr.getXid()).setFlags(sr.getFlags()).build();
                messages.add(adjacencyRequest);
                break;
            default:
                break;
        }
    } else {
        log.debug("OPLK EDFA sends msg:{}, as is", m.getType());
    }
    super.sendMsg(messages);
}
#method_after
@Override
public final void sendMsg(OFMessage m) {
    List<OFMessage> messages = new ArrayList<>();
    messages.add(m);
    if (m.getType() == OFType.STATS_REQUEST) {
        OFStatsRequest sr = (OFStatsRequest) m;
        log.debug("OPLK EDFA rebuilding stats request type {}", sr.getStatsType());
        switch(sr.getStatsType()) {
            case PORT:
                // add Oplink experiment message to get the port's current power
                messages.add(oplinkUtil.buildPortPowerRequest());
                // add experiment message to get adjacent ports
                messages.add(oplinkUtil.buildPortAdjacencyRequest());
                break;
            default:
                break;
        }
    } else {
        log.debug("OPLK EDFA sends msg:{}, as is", m.getType());
    }
    super.sendMsg(messages);
}
#end_block

#method_before
@Override
public List<PortDescription> processExpPortStats(OFMessage msg) {
    if (msg instanceof OFOplinkPortPowerReply) {
        return buildPortPowerDescriptions(((OFOplinkPortPowerReply) msg).getEntries());
    } else if (msg instanceof OFExpPortAdjacencyReply) {
        return buildPortAdjacencyDescriptions(((OFExpPortAdjacencyReply) msg).getEntries());
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<PortDescription> processExpPortStats(OFMessage msg) {
    if (msg instanceof OFOplinkPortPowerReply) {
        return oplinkUtil.buildPortPowerDescriptions(((OFOplinkPortPowerReply) msg).getEntries());
    } else if (msg instanceof OFExpPortAdjacencyReply) {
        return oplinkUtil.buildPortAdjacencyDescriptions(((OFExpPortAdjacencyReply) msg).getEntries());
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void sendHandshakeOFExperimenterPortDescRequest() throws IOException {
    // Send multipart message for port description for optical switches
    OFCircuitPortsRequest circuitPortsRequest = factory().buildCircuitPortsRequest().setXid(getNextTransactionId()).build();
    log.debug("OPLK EDFA : Sending experimented port description message {}", circuitPortsRequest);
    sendHandshakeMessage(circuitPortsRequest);
}
#method_after
private void sendHandshakeOFExperimenterPortDescRequest() throws IOException {
    // Send multipart message for port description for optical switches
    OFCircuitPortsRequest circuitPortsRequest = oplinkUtil.buildCircuitPortsRequest();
    log.debug("OPLK EDFA : Sending experimented port description message {}", circuitPortsRequest);
    sendHandshakeMessage(circuitPortsRequest);
}
#end_block

#method_before
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    return IntStream.rangeClosed(1, LAMBDA_COUNT).mapToObj(x -> OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, x - CENTER_OFFSET)).collect(Collectors.toSet());
}
#method_after
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    return IntStream.rangeClosed(MIN_CHANNEL, MAX_CHANNEL).mapToObj(x -> OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, x)).collect(Collectors.toSet());
}
#end_block

#method_before
private OpenFlowSwitch getOpenFlowDevice() {
    final OpenFlowController controller = this.handler().get(OpenFlowController.class);
    final Dpid dpid = Dpid.dpid(this.data().deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null || !sw.isConnected()) {
        return null;
    }
    return sw;
}
#method_after
private OpenFlowSwitch getOpenFlowDevice() {
    final OpenFlowController controller = handler().get(OpenFlowController.class);
    final Dpid dpid = Dpid.dpid(data().deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null || !sw.isConnected()) {
        log.warn("OpenFlow handshaker driver not found or device is not connected");
        return null;
    }
    return sw;
}
#end_block

#method_before
private Long getTargetPortPower(PortNumber portNum) {
    // which is obsolete.
    if (getOpenFlowDevice() == null) {
        log.warn("OpenFlow handshaker driver not found or device is not connected");
        return null;
    }
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Port port = deviceService.getPort(this.data().deviceId(), portNum);
    if (port == null) {
        return null;
    }
    String currentPower = port.annotations().value(OpticalAnnotations.TARGET_POWER);
    if (currentPower == null) {
        return null;
    }
    return Long.valueOf(currentPower);
}
#method_after
private Long getTargetPortPower(PortNumber portNum) {
    return getPowerFromPort(portNum, OpticalAnnotations.TARGET_POWER);
}
#end_block

#method_before
private Long getCurrentPortPower(PortNumber portNum) {
    // which is obsolete.
    if (getOpenFlowDevice() == null) {
        log.warn("OpenFlow handshaker driver not found or device is not connected");
        return null;
    }
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Port port = deviceService.getPort(this.data().deviceId(), portNum);
    if (port == null) {
        return null;
    }
    String currentPower = port.annotations().value(OpticalAnnotations.CURRENT_POWER);
    if (currentPower == null) {
        return null;
    }
    return Long.valueOf(currentPower);
}
#method_after
private Long getCurrentPortPower(PortNumber portNum) {
    return getPowerFromPort(portNum, OpticalAnnotations.CURRENT_POWER);
}
#end_block

#method_before
private void setTargetPortPower(PortNumber portNum, long power) {
    OpenFlowSwitch device = getOpenFlowDevice();
    // which is obsolete.
    if (device == null) {
        log.warn("OpenFlow handshaker driver not found or device is not connected");
        return;
    }
    device.sendMsg(device.factory().buildOplinkPortPowerSet().setXid(0).setPort((int) portNum.toLong()).setPowerValue((int) power).build());
}
#method_after
private void setTargetPortPower(PortNumber portNum, long power) {
    OpenFlowSwitch device = getOpenFlowDevice();
    // Check if switch is connected, otherwise do not return value in store, which is obsolete.
    if (device == null) {
        // Warning already exists in method getOpenFlowDevice()
        return;
    }
    device.sendMsg(device.factory().buildOplinkPortPowerSet().setXid(xidCounter.getAndIncrement()).setPort((int) portNum.toLong()).setPowerValue((int) power).build());
}
#end_block

#method_before
private Range<Long> getTargetPortPowerRange(PortNumber port) {
    Range<Long> range = null;
    long portNum = port.toLong();
    if (portNum == LINE_OUT_EAST || portNum == LINE_OUT_WEST) {
        range = Range.closed(100L, 2040L);
    }
    return range;
}
#method_after
private Range<Long> getTargetPortPowerRange(PortNumber port) {
    long portNum = port.toLong();
    // And more, the power range will be also obtained from device configuration.
    switch((int) portNum) {
        case LINE_OUT_EAST:
        case LINE_OUT_WEST:
            return Range.closed(POWER_OUT_LOW_THRES, POWER_OUT_HIGH_THRES);
        default:
            // Unexpected port. Do not need warning here for port polling.
            return null;
    }
}
#end_block

#method_before
// Returns the working input power range for an input port, null if the port
private Range<Long> getInputPortPowerRange(PortNumber port) {
    Range<Long> range = null;
    long portNum = port.toLong();
    if (portNum == LINE_IN_EAST || portNum == LINE_IN_WEST) {
        // TODO implement support for IR and ER range
        // only supports LR right now
        range = Range.closed(-2600L, 540L);
    }
    return range;
}
#method_after
// Returns the working input power range for an input port, null if the port
private Range<Long> getInputPortPowerRange(PortNumber port) {
    long portNum = port.toLong();
    // And more, the power range will be also obtained from device configuration.
    switch((int) portNum) {
        case LINE_IN_EAST:
            return Range.closed(POWER_IN_EAST_LOW_THRES, POWER_IN_EAST_HIGH_THRES);
        case LINE_IN_WEST:
            return Range.closed(POWER_IN_WEST_LOW_THRES, POWER_IN_WEST_HIGH_THRES);
        default:
            // Unexpected port. Do not need warning here for port polling.
            return null;
    }
}
#end_block

#method_before
@Override
public NetconfDevice connectDevice(DeviceId deviceId) throws NetconfException {
    if (netconfDeviceMap.containsKey(deviceId)) {
        log.debug("Device {} is already present", deviceId);
        return netconfDeviceMap.get(deviceId);
    } else {
        log.debug("Creating NETCONF device {}", deviceId);
        Device device = deviceService.getDevice(deviceId);
        String ip;
        int port;
        if (device != null) {
            ip = device.annotations().value("ipaddress");
            port = Integer.parseInt(device.annotations().value("port"));
        } else {
            String[] info = deviceId.toString().split(":");
            if (info.length == 3) {
                ip = info[1];
                port = Integer.parseInt(info[2]);
            } else {
                ip = Arrays.asList(info).stream().filter(el -> !el.equals(info[0]) && !el.equals(info[info.length - 1])).reduce((t, u) -> t + ":" + u).get();
                log.debug("ip v6 {}", ip);
                port = Integer.parseInt(info[info.length - 1]);
            }
        }
        try {
            DeviceKey deviceKey = deviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceId.toString()));
            NetconfDeviceInfo deviceInfo = null;
            if (deviceKey.type() == DeviceKey.Type.USERNAME_PASSWORD) {
                UsernamePassword usernamepasswd = deviceKey.asUsernamePassword();
                deviceInfo = new NetconfDeviceInfo(usernamepasswd.username(), usernamepasswd.password(), IpAddress.valueOf(ip), port);
            } else if (deviceKey.type() == DeviceKey.Type.SSL_KEY) {
                String username = deviceKey.annotations().value(AnnotationKeys.USERNAME);
                String password = deviceKey.annotations().value(AnnotationKeys.PASSWORD);
                String sshkey = deviceKey.annotations().value(AnnotationKeys.SSHKEY);
                deviceInfo = new NetconfDeviceInfo(username, password, IpAddress.valueOf(ip), port, sshkey);
            } else {
                log.error("Unknown device type for device {}", deviceId);
            }
            NetconfDevice netconfDevicedevice = createDevice(deviceInfo);
            netconfDevicedevice.getSession().addDeviceOutputListener(downListener);
            return netconfDevicedevice;
        } catch (NullPointerException e) {
            throw new NetconfException("No Device Key for device " + deviceId, e);
        }
    }
}
#method_after
@Override
public NetconfDevice connectDevice(DeviceId deviceId) throws NetconfException {
    if (netconfDeviceMap.containsKey(deviceId)) {
        log.debug("Device {} is already present", deviceId);
        return netconfDeviceMap.get(deviceId);
    } else {
        log.debug("Creating NETCONF device {}", deviceId);
        Device device = deviceService.getDevice(deviceId);
        String ip;
        int port;
        if (device != null) {
            ip = device.annotations().value("ipaddress");
            port = Integer.parseInt(device.annotations().value("port"));
        } else {
            String[] info = deviceId.toString().split(":");
            if (info.length == 3) {
                ip = info[1];
                port = Integer.parseInt(info[2]);
            } else {
                ip = Arrays.asList(info).stream().filter(el -> !el.equals(info[0]) && !el.equals(info[info.length - 1])).reduce((t, u) -> t + ":" + u).get();
                log.debug("ip v6 {}", ip);
                port = Integer.parseInt(info[info.length - 1]);
            }
        }
        try {
            DeviceKey deviceKey = deviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceId.toString()));
            NetconfDeviceInfo deviceInfo = null;
            if (deviceKey.type() == DeviceKey.Type.USERNAME_PASSWORD) {
                UsernamePassword usernamepasswd = deviceKey.asUsernamePassword();
                deviceInfo = new NetconfDeviceInfo(usernamepasswd.username(), usernamepasswd.password(), IpAddress.valueOf(ip), port);
            } else if (deviceKey.type() == DeviceKey.Type.SSL_KEY) {
                String username = deviceKey.annotations().value(AnnotationKeys.USERNAME);
                String password = deviceKey.annotations().value(AnnotationKeys.PASSWORD);
                String sshkey = deviceKey.annotations().value(AnnotationKeys.SSHKEY);
                deviceInfo = new NetconfDeviceInfo(username, password, IpAddress.valueOf(ip), port, sshkey);
            } else {
                log.error("Unknown device key for device {}", deviceId);
            }
            NetconfDevice netconfDevicedevice = createDevice(deviceInfo);
            netconfDevicedevice.getSession().addDeviceOutputListener(downListener);
            return netconfDevicedevice;
        } catch (NullPointerException e) {
            throw new NetconfException("No Device Key for device " + deviceId, e);
        }
    }
}
#end_block

#method_before
private void connectDevices() {
    NetconfProviderConfig cfg = cfgService.getConfig(appId, NetconfProviderConfig.class);
    if (cfg != null) {
        try {
            cfg.getDevicesAddresses().forEach(addr -> {
                DeviceId deviceId = getDeviceId(addr.ip().toString(), addr.port());
                Preconditions.checkNotNull(deviceId, ISNULL);
                // Netconf configuration object
                ChassisId cid = new ChassisId();
                String ipAddress = addr.ip().toString();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(IPADDRESS, ipAddress).set(PORT, String.valueOf(addr.port())).set(AnnotationKeys.PROTOCOL, SCHEME_NAME.toUpperCase()).build();
                DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, false, annotations);
                if (addr.sshkey().equals("")) {
                    deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingUsernamePassword(DeviceKeyId.deviceKeyId(deviceId.toString()), null, addr.name(), addr.password()));
                } else {
                    deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingSshKey(DeviceKeyId.deviceKeyId(deviceId.toString()), null, addr.name(), addr.password(), addr.sshkey()));
                }
                if (deviceService.getDevice(deviceId) == null) {
                    providerService.deviceConnected(deviceId, deviceDescription);
                }
                checkAndUpdateDevice(deviceId, deviceDescription);
            });
        } catch (ConfigException e) {
            log.error("Cannot read config error " + e);
        }
    }
}
#method_after
private void connectDevices() {
    NetconfProviderConfig cfg = cfgService.getConfig(appId, NetconfProviderConfig.class);
    if (cfg != null) {
        try {
            cfg.getDevicesAddresses().forEach(addr -> {
                DeviceId deviceId = getDeviceId(addr.ip().toString(), addr.port());
                Preconditions.checkNotNull(deviceId, ISNULL);
                // Netconf configuration object
                ChassisId cid = new ChassisId();
                String ipAddress = addr.ip().toString();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(IPADDRESS, ipAddress).set(PORT, String.valueOf(addr.port())).set(AnnotationKeys.PROTOCOL, SCHEME_NAME.toUpperCase()).build();
                DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, false, annotations);
                storeDeviceKey(addr, deviceId);
                if (deviceService.getDevice(deviceId) == null) {
                    providerService.deviceConnected(deviceId, deviceDescription);
                }
                checkAndUpdateDevice(deviceId, deviceDescription);
            });
        } catch (ConfigException e) {
            log.error("Cannot read config error " + e);
        }
    }
}
#end_block

#method_before
private void checkAndUpdateDevices() {
    NetconfProviderConfig cfg = cfgService.getConfig(appId, NetconfProviderConfig.class);
    if (cfg != null) {
        log.info("Checking connection to devices in configuration");
        try {
            cfg.getDevicesAddresses().forEach(addr -> {
                DeviceId deviceId = getDeviceId(addr.ip().toString(), addr.port());
                Preconditions.checkNotNull(deviceId, ISNULL);
                // Netconf configuration object
                ChassisId cid = new ChassisId();
                String ipAddress = addr.ip().toString();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(IPADDRESS, ipAddress).set(PORT, String.valueOf(addr.port())).set(AnnotationKeys.PROTOCOL, SCHEME_NAME.toUpperCase()).build();
                DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, false, annotations);
                if (addr.sshkey().equals("")) {
                    deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingUsernamePassword(DeviceKeyId.deviceKeyId(deviceId.toString()), null, addr.name(), addr.password()));
                } else {
                    deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingSshKey(DeviceKeyId.deviceKeyId(deviceId.toString()), null, addr.name(), addr.password(), addr.sshkey()));
                }
                checkAndUpdateDevice(deviceId, deviceDescription);
            });
        } catch (ConfigException e) {
            log.error("Cannot read config error " + e);
        }
    }
}
#method_after
private void checkAndUpdateDevices() {
    NetconfProviderConfig cfg = cfgService.getConfig(appId, NetconfProviderConfig.class);
    if (cfg != null) {
        log.info("Checking connection to devices in configuration");
        try {
            cfg.getDevicesAddresses().forEach(addr -> {
                DeviceId deviceId = getDeviceId(addr.ip().toString(), addr.port());
                Preconditions.checkNotNull(deviceId, ISNULL);
                // Netconf configuration object
                ChassisId cid = new ChassisId();
                String ipAddress = addr.ip().toString();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(IPADDRESS, ipAddress).set(PORT, String.valueOf(addr.port())).set(AnnotationKeys.PROTOCOL, SCHEME_NAME.toUpperCase()).build();
                DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, false, annotations);
                storeDeviceKey(addr, deviceId);
                checkAndUpdateDevice(deviceId, deviceDescription);
            });
        } catch (ConfigException e) {
            log.error("Cannot read config error " + e);
        }
    }
}
#end_block

#method_before
private void startConnection() throws NetconfException {
    if (!connectionActive) {
        netconfConnection = new Connection(deviceInfo.ip().toString(), deviceInfo.port());
        int connectTimeout = NetconfControllerImpl.netconfConnectTimeout;
        try {
            netconfConnection.connect(null, 1000 * connectTimeout, 1000 * connectTimeout);
        } catch (IOException e) {
            throw new NetconfException("Cannot open a connection with device" + deviceInfo, e);
        }
        boolean isAuthenticated;
        try {
            if (deviceInfo.getKey() != null) {
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKey(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else {
                log.debug("Authenticating to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPassword(deviceInfo.name(), deviceInfo.password());
            }
        } catch (IOException e) {
            log.error("Authentication connection to device {} failed", deviceInfo.getDeviceId(), e);
            throw new NetconfException("Authentication connection to device " + deviceInfo.getDeviceId() + " failed", e);
        }
        connectionActive = true;
        Preconditions.checkArgument(isAuthenticated, "Authentication to device %s with username " + "%s failed", deviceInfo.getDeviceId(), deviceInfo.name());
        startSshSession();
    }
}
#method_after
private void startConnection() throws NetconfException {
    if (!connectionActive) {
        netconfConnection = new Connection(deviceInfo.ip().toString(), deviceInfo.port());
        int connectTimeout = NetconfControllerImpl.netconfConnectTimeout;
        try {
            netconfConnection.connect(null, 1000 * connectTimeout, 1000 * connectTimeout);
        } catch (IOException e) {
            throw new NetconfException("Cannot open a connection with device" + deviceInfo, e);
        }
        boolean isAuthenticated;
        try {
            if (deviceInfo.getKey() != null) {
                log.debug("Authenticating with key to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKey(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else {
                log.debug("Authenticating to device {} with username {} with password", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPassword(deviceInfo.name(), deviceInfo.password());
            }
        } catch (IOException e) {
            log.error("Authentication connection to device {} failed", deviceInfo.getDeviceId(), e);
            throw new NetconfException("Authentication connection to device " + deviceInfo.getDeviceId() + " failed", e);
        }
        connectionActive = true;
        Preconditions.checkArgument(isAuthenticated, "Authentication to device %s with username " + "%s failed", deviceInfo.getDeviceId(), deviceInfo.name());
        startSshSession();
    }
}
#end_block

#method_before
@Override
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST || criterion.type() == Criterion.Type.ETH_DST_MASKED) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    // For VLAN cross-connect packets, use the configured VLAN
    if (vidCriterion != null) {
        if (vidCriterion.vlanId() != VlanId.NONE) {
            assignedVlan = vidCriterion.vlanId();
        // For untagged packets, assign a VLAN ID
        } else {
            if (filt.meta() == null) {
                log.error("Missing metadata in filtering objective required " + "for vlan assignment in dev {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
            for (Instruction i : filt.meta().allInstructions()) {
                if (i instanceof ModVlanIdInstruction) {
                    assignedVlan = ((ModVlanIdInstruction) i).vlanId();
                }
            }
            if (assignedVlan == null) {
                log.error("Driver requires an assigned vlan-id to tag incoming " + "untagged packets. Not processing vlan filters on " + "device {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(MacAddress.NONE)) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (ethCriterion == null || vidCriterion == null) {
        log.debug("filtering objective missing dstMac or VLAN, " + "cannot program VLAN Table");
    } else {
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        for (FlowRule rule : allRules) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", rule, deviceId);
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
@Override
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST || criterion.type() == Criterion.Type.ETH_DST_MASKED) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    // For VLAN cross-connect packets, use the configured VLAN
    if (vidCriterion != null) {
        if (vidCriterion.vlanId() != VlanId.NONE) {
            assignedVlan = vidCriterion.vlanId();
        // For untagged packets, assign a VLAN ID
        } else {
            if (filt.meta() == null) {
                log.error("Missing metadata in filtering objective required " + "for vlan assignment in dev {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
            for (Instruction i : filt.meta().allInstructions()) {
                if (i instanceof ModVlanIdInstruction) {
                    assignedVlan = ((ModVlanIdInstruction) i).vlanId();
                }
            }
            if (assignedVlan == null) {
                log.error("Driver requires an assigned vlan-id to tag incoming " + "untagged packets. Not processing vlan filters on " + "device {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (ethCriterion == null || vidCriterion == null) {
        log.debug("filtering objective missing dstMac or VLAN, " + "cannot program VLAN Table");
    } else {
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        for (FlowRule rule : allRules) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", rule, deviceId);
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthDstSpecific(ForwardingObjective fwd) {
    List<FlowRule> rules = new ArrayList<>();
    // Build filtered selector
    TrafficSelector selector = fwd.selector();
    EthCriterion ethCriterion = (EthCriterion) selector.getCriterion(Criterion.Type.ETH_DST);
    VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) selector.getCriterion(Criterion.Type.VLAN_VID);
    if (vlanIdCriterion == null) {
        log.warn("Forwarding objective for bridging requires vlan. Not " + "installing fwd:{} in dev:{}", fwd.id(), deviceId);
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    // Do not match MacAddress for subnet broadcast entry
    if (!ethCriterion.mac().equals(MacAddress.NONE)) {
        filteredSelectorBuilder.matchEthDst(ethCriterion.mac());
        log.debug("processing L2 forwarding objective:{} -> next:{} in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        log.debug("processing L2 Broadcast forwarding objective:{} -> next:{} " + "in dev:{} for vlan:{}", fwd.id(), fwd.nextId(), deviceId, vlanIdCriterion.vlanId());
    }
    filteredSelectorBuilder.matchVlanId(vlanIdCriterion.vlanId());
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    if (fwd.treatment() != null) {
        log.warn("Ignoring traffic treatment in fwd rule {} meant for L2 table" + "for dev:{}. Expecting only nextId", fwd.id(), deviceId);
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group != null) {
                treatmentBuilder.deferred().group(group.id());
            } else {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
        }
    }
    treatmentBuilder.immediate().transition(ACL_TABLE);
    TrafficTreatment filteredTreatment = treatmentBuilder.build();
    // Build bridging table entries
    FlowRule.Builder flowRuleBuilder = DefaultFlowRule.builder();
    flowRuleBuilder.fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(filteredTreatment).forTable(BRIDGING_TABLE);
    if (fwd.permanent()) {
        flowRuleBuilder.makePermanent();
    } else {
        flowRuleBuilder.makeTemporary(fwd.timeout());
    }
    rules.add(flowRuleBuilder.build());
    return rules;
}
#method_after
@Override
protected Collection<FlowRule> processEthDstSpecific(ForwardingObjective fwd) {
    List<FlowRule> rules = new ArrayList<>();
    // Build filtered selector
    TrafficSelector selector = fwd.selector();
    EthCriterion ethCriterion = (EthCriterion) selector.getCriterion(Criterion.Type.ETH_DST);
    VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) selector.getCriterion(Criterion.Type.VLAN_VID);
    if (vlanIdCriterion == null) {
        log.warn("Forwarding objective for bridging requires vlan. Not " + "installing fwd:{} in dev:{}", fwd.id(), deviceId);
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    // Do not match MacAddress for subnet broadcast entry
    if (!ethCriterion.mac().equals(NONE) && !ethCriterion.mac().equals(BROADCAST)) {
        filteredSelectorBuilder.matchEthDst(ethCriterion.mac());
        log.debug("processing L2 forwarding objective:{} -> next:{} in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        log.debug("processing L2 Broadcast forwarding objective:{} -> next:{} " + "in dev:{} for vlan:{}", fwd.id(), fwd.nextId(), deviceId, vlanIdCriterion.vlanId());
    }
    filteredSelectorBuilder.matchVlanId(vlanIdCriterion.vlanId());
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    if (fwd.treatment() != null) {
        log.warn("Ignoring traffic treatment in fwd rule {} meant for L2 table" + "for dev:{}. Expecting only nextId", fwd.id(), deviceId);
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group != null) {
                treatmentBuilder.deferred().group(group.id());
            } else {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
        }
    }
    treatmentBuilder.immediate().transition(ACL_TABLE);
    TrafficTreatment filteredTreatment = treatmentBuilder.build();
    // Build bridging table entries
    FlowRule.Builder flowRuleBuilder = DefaultFlowRule.builder();
    flowRuleBuilder.fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(filteredTreatment).forTable(BRIDGING_TABLE);
    if (fwd.permanent()) {
        flowRuleBuilder.makePermanent();
    } else {
        flowRuleBuilder.makeTemporary(fwd.timeout());
    }
    rules.add(flowRuleBuilder.build());
    return rules;
}
#end_block

#method_before
protected void processPortTable() {
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(VLAN_TABLE);
    FlowRule tmisse = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(PORT_TABLE).build();
    ops = ops.add(tmisse);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized port table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize port table");
        }
    }));
}
#method_after
protected void processPortTable() {
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(VLAN_TABLE);
    FlowRule tmisse = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(PORT_TABLE).build();
    ops = ops.add(tmisse);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized port table on {}", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.warn("Failed to initialize port table on {}", deviceId);
        }
    }));
}
#end_block

#method_before
protected void processVlanTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().wipeDeferred();
    treatment.transition(ACL_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(VLAN_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized vlan table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize vlan table");
        }
    }));
}
#method_after
protected void processVlanTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().wipeDeferred();
    treatment.transition(ACL_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(VLAN_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized vlan table on {}", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.warn("Failed to initialize vlan table on {}", deviceId);
        }
    }));
}
#end_block

#method_before
protected void processTmacTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(BRIDGING_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(TMAC_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized tmac table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize tmac table");
        }
    }));
}
#method_after
protected void processTmacTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(BRIDGING_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(TMAC_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized tmac table on {}", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.warn("Failed to initialize tmac table on {}", deviceId);
        }
    }));
}
#end_block

#method_before
protected void processIpTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(ACL_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(UNICAST_ROUTING_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized IP table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize unicast IP table");
        }
    }));
}
#method_after
protected void processIpTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(ACL_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(UNICAST_ROUTING_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized IP table on {}", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.warn("Failed to initialize unicast IP table on {}", deviceId);
        }
    }));
}
#end_block

#method_before
protected void processMulticastIpTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(ACL_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(MULTICAST_ROUTING_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized multicast IP table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize multicast IP table");
        }
    }));
}
#method_after
protected void processMulticastIpTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(ACL_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(MULTICAST_ROUTING_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized multicast IP table on {}", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.warn("Failed to initialize multicast IP table on {}", deviceId);
        }
    }));
}
#end_block

#method_before
protected void processMplsTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector = DefaultTrafficSelector.builder();
    treatment = DefaultTrafficTreatment.builder();
    treatment.transition(MPLS_TABLE_1);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(MPLS_TABLE_0).build();
    ops = ops.add(rule);
    treatment.transition(ACL_TABLE);
    rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(MPLS_TABLE_1).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized MPLS tables");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize MPLS tables");
        }
    }));
}
#method_after
protected void processMplsTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector = DefaultTrafficSelector.builder();
    treatment = DefaultTrafficTreatment.builder();
    treatment.transition(MPLS_TABLE_1);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(MPLS_TABLE_0).build();
    ops = ops.add(rule);
    treatment.transition(ACL_TABLE);
    rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(MPLS_TABLE_1).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized MPLS tables on {}", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.warn("Failed to initialize MPLS tables on {}", deviceId);
        }
    }));
}
#end_block

#method_before
private void processBridgingTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(ACL_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(BRIDGING_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized Bridging table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize Bridging table");
        }
    }));
}
#method_after
private void processBridgingTable() {
    // table miss entry
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(ACL_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(BRIDGING_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized Bridging table on {}", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.warn("Failed to initialize Bridging table on {}", deviceId);
        }
    }));
}
#end_block

#method_before
protected void processAclTable() {
    // table miss entry - catch all to executed action-set
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(ACL_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized Acl table");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to initialize Acl table");
        }
    }));
}
#method_after
protected void processAclTable() {
    // table miss entry - catch all to executed action-set
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(LOWEST_PRIORITY).fromApp(driverId).makePermanent().forTable(ACL_TABLE).build();
    ops = ops.add(rule);
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Initialized Acl table on {}", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.warn("Failed to initialize Acl table on {}", deviceId);
        }
    }));
}
#end_block

#method_before
public static ResourceId.Builder addToResourceId(ResourceId.Builder builder, String name, String namespace, String value) {
    Object valObject;
    try {
        SchemaContext child = getChildSchemaContext((SchemaContext) builder.appInfo(), name, namespace);
        if (child == null) {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
        }
        DataNode.Type type = child.getType();
        if (value != null) {
            switch(type) {
                case SINGLE_INSTANCE_LEAF_VALUE_NODE:
                    valObject = ((YangLeaf) child).fromString(value);
                    builder.addKeyLeaf(name, child.getSchemaId().namespace(), valObject);
                    break;
                case MULTI_INSTANCE_LEAF_VALUE_NODE:
                    valObject = ((YangLeafList) child).fromString(value);
                    builder.addLeafListBranchPoint(name, child.getSchemaId().namespace(), valObject);
                    break;
                case SINGLE_INSTANCE_NODE:
                case MULTI_INSTANCE_NODE:
                default:
                    throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
            }
        } else {
            addNode(builder, name, value, child, type);
        }
        builder.appInfo(child);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return builder;
}
#method_after
public static ResourceId.Builder addToResourceId(ResourceId.Builder builder, String name, String namespace, String value) {
    try {
        SchemaContext child = getChildSchemaContext((SchemaContext) builder.appInfo(), name, namespace);
        if (child == null) {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
        }
        DataNode.Type type = child.getType();
        updateResourceId(builder, name, value, child, type);
        builder.appInfo(child);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return builder;
}
#end_block

#method_before
public static Builder initializeDataNode(ResourceId.Builder builder) {
    SchemaContext node = (SchemaContext) builder.appInfo();
    return getInnerNodeBuilder(node);
}
#method_after
public static Builder initializeDataNode(ResourceId.Builder builder) {
    if (!(builder instanceof ExtResourceIdBldr)) {
        throw new IllegalArgumentException("Invalid resourceId builder.");
    }
    SchemaContext node = (SchemaContext) builder.appInfo();
    HelperContext info = new HelperContext();
    info.setResourceIdBuilder(null);
    info.setParentResourceIdBldr((ExtResourceIdBldr) builder);
    SchemaId sId = node.getSchemaId();
    InnerNode.Builder dBldr = InnerNode.builder(sId.name(), sId.namespace());
    dBldr.appInfo(info);
    return dBldr;
}
#end_block

#method_before
public static Builder initializeDataNode(YangSerializerContext context) {
    SchemaContext node = context.getContext();
    return getInnerNodeBuilder(node);
}
#method_after
public static Builder initializeDataNode(YangSerializerContext context) {
    SchemaContext node = context.getContext();
    SchemaId sId = node.getSchemaId();
    HelperContext info = new HelperContext();
    ExtResourceIdBldr rId = info.getResourceIdBuilder();
    rId.addBranchPointSchema(sId.name(), sId.namespace());
    rId.appInfo(node);
    info.setResourceIdBuilder(rId);
    // info.setSchemaContext(node);
    InnerNode.Builder dBlr = InnerNode.builder(sId.name(), sId.namespace());
    dBlr.type(SINGLE_INSTANCE_NODE);
    dBlr.appInfo(info);
    return dBlr;
}
#end_block

#method_before
public static Builder addDataNode(Builder builder, String name, String namespace, String value, DataNode type) {
    DataNodeInfo info = (DataNodeInfo) builder.appInfo();
    SchemaContext node = info.getSchemaContext();
    SchemaContext childSchema = getChildSchemaContext(node, name, namespace);
    DataNode.Type nodeType = childSchema.getType();
    if (type != null && !nodeType.equals(type)) {
        throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
    }
    if (value != null) {
        switch(nodeType) {
            case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            case MULTI_INSTANCE_LEAF_VALUE_NODE:
                builder = builder.createChildBuilder(name, namespace, value).type(nodeType);
                break;
            case SINGLE_INSTANCE_NODE:
            case MULTI_INSTANCE_NODE:
            default:
                throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
        }
    } else {
        switch(nodeType) {
            case SINGLE_INSTANCE_NODE:
            case MULTI_INSTANCE_NODE:
                builder = builder.createChildBuilder(name, namespace).type(nodeType);
                break;
            case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            case MULTI_INSTANCE_LEAF_VALUE_NODE:
                builder = builder.createChildBuilder(name, namespace, value).type(nodeType);
                break;
            default:
                throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
        }
    }
    ExtResourceIdBldr rIdBldr = info.getResourceIdBuilder();
    addNode(rIdBldr, name, value, childSchema, nodeType);
    DataNodeInfo nodeInfo = new DataNodeInfo();
    nodeInfo.setParentContext(node);
    nodeInfo.setSchemaContext(childSchema);
    nodeInfo.setResourceIdBuilder(rIdBldr);
    builder.appInfo(nodeInfo);
    return builder;
}
#method_after
public static Builder addDataNode(Builder builder, String name, String namespace, String value, DataNode type) {
    try {
        SchemaContext node;
        ExtResourceIdBldr rIdBldr;
        HelperContext nodeInfo;
        HelperContext info = (HelperContext) builder.appInfo();
        ExtResourceIdBldr curBldr = info.getResourceIdBuilder();
        boolean isCreate = false;
        if (curBldr != null) {
            // node = info.getSchemaContext();
            rIdBldr = info.getResourceIdBuilder();
            node = (SchemaContext) rIdBldr.appInfo();
            isCreate = true;
        } else {
            node = (SchemaContext) info.getParentResourceIdBldr().appInfo();
            rIdBldr = info.getParentResourceIdBldr();
        }
        SchemaContext childSchema = getChildSchemaContext(node, name, namespace);
        DataNode.Type nodeType = childSchema.getType();
        if (type != null && !nodeType.equals(type)) {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
        }
        updateResourceId(rIdBldr, name, value, childSchema, nodeType);
        if (isCreate) {
            switch(nodeType) {
                case SINGLE_INSTANCE_NODE:
                case MULTI_INSTANCE_NODE:
                    builder = builder.createChildBuilder(name, namespace).type(nodeType);
                    break;
                case SINGLE_INSTANCE_LEAF_VALUE_NODE:
                case MULTI_INSTANCE_LEAF_VALUE_NODE:
                    builder = builder.createChildBuilder(name, namespace, value).type(nodeType);
                    break;
                default:
                    throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
            }
            nodeInfo = new HelperContext();
        } else {
            builder.type(nodeType);
            nodeInfo = info;
        }
        // nodeInfo.setSchemaContext(childSchema);
        nodeInfo.setResourceIdBuilder(rIdBldr);
        builder.appInfo(nodeInfo);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return builder;
}
#end_block

#method_before
public static ResourceId getResourceId(Builder builder) {
    DataNodeInfo info = (DataNodeInfo) builder.appInfo();
    return info.getResourceIdBuilder().getResourceId();
}
#method_after
public static ResourceId getResourceId(Builder builder) {
    HelperContext info = (HelperContext) builder.appInfo();
    return info.getResourceIdBuilder().getResourceId();
}
#end_block

#method_before
public static Builder exitDataNode(Builder builder) {
    DataNodeInfo info = (DataNodeInfo) builder.appInfo();
    ExtResourceIdBldr rId = info.getResourceIdBuilder();
    SchemaContext cont = info.getSchemaContext();
    // Deleting the last key entry in resource id.
    if (cont.getType() == SINGLE_INSTANCE_LEAF_VALUE_NODE) {
        if (!((YangLeaf) cont).isKeyLeaf()) {
            rId.traveseToParent();
        }
    } else {
        rId.traveseToParent();
    }
    return builder.exitNode();
}
#method_after
public static Builder exitDataNode(Builder builder) {
    HelperContext info = (HelperContext) builder.appInfo();
    ExtResourceIdBldr rId = info.getResourceIdBuilder();
    SchemaContext cont = (SchemaContext) rId.appInfo();
    // Deleting the last key entry in resource id.
    if (cont.getType() == SINGLE_INSTANCE_LEAF_VALUE_NODE) {
        if (!((YangLeaf) cont).isKeyLeaf()) {
            rId.traveseToParent();
        }
    } else {
        rId.traveseToParent();
    }
    rId.appInfo(cont.getParentContext());
    return builder.exitNode();
}
#end_block

#method_before
private static SchemaContext getChildSchemaContext(SchemaContext context, String name, String namespace) throws IllegalArgumentException {
    SchemaContext child;
    SchemaId parentId = context.getSchemaId();
    if (namespace == null && parentId.name().equals(NAME)) {
        throw new IllegalArgumentException(E_NAMESPACE);
    } else if (namespace == null) {
        namespace = parentId.namespace();
    }
    SchemaId id = new SchemaId(name, namespace);
    child = ((SingleInstanceNodeContext) context).getChildContext(id);
    return child;
}
#method_after
private static SchemaContext getChildSchemaContext(SchemaContext context, String name, String namespace) throws IllegalArgumentException {
    SchemaContext child;
    SchemaId parentId = context.getSchemaId();
    if (namespace == null && parentId.name().equals(SLASH)) {
        throw new IllegalArgumentException(E_NAMESPACE);
    } else if (namespace == null) {
        namespace = parentId.namespace();
    }
    SchemaId id = new SchemaId(name, namespace);
    child = ((SingleInstanceNodeContext) context).getChildContext(id);
    return child;
}
#end_block

#method_before
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    }
    log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST || criterion.type() == Criterion.Type.ETH_DST_MASKED) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(MacAddress.NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vidCriterion == null) {
        // NOTE: it is possible that a filtering objective only has ethCriterion
        log.debug("filtering objective missing dstMac or VLAN, " + "cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
            VlanId vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.debug("adding VLAN assignment rule in VLAN table: {} for dev: {}", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    }
    log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST || criterion.type() == Criterion.Type.ETH_DST_MASKED) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vidCriterion == null) {
        // NOTE: it is possible that a filtering objective only has ethCriterion
        log.debug("filtering objective missing dstMac or VLAN, " + "cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
            VlanId vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.debug("adding VLAN assignment rule in VLAN table: {} for dev: {}", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
protected Collection<FlowRule> processEthDstSpecific(ForwardingObjective fwd) {
    List<FlowRule> rules = new ArrayList<>();
    // Build filtered selector
    TrafficSelector selector = fwd.selector();
    EthCriterion ethCriterion = (EthCriterion) selector.getCriterion(Criterion.Type.ETH_DST);
    VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) selector.getCriterion(Criterion.Type.VLAN_VID);
    if (vlanIdCriterion == null) {
        log.warn("Forwarding objective for bridging requires vlan. Not " + "installing fwd:{} in dev:{}", fwd.id(), deviceId);
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    // Do not match MacAddress for subnet broadcast entry
    if (!ethCriterion.mac().equals(MacAddress.NONE) && !ethCriterion.mac().equals(MacAddress.BROADCAST)) {
        filteredSelectorBuilder.matchEthDst(ethCriterion.mac());
        log.debug("processing L2 forwarding objective:{} -> next:{} in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        log.debug("processing L2 Broadcast forwarding objective:{} -> next:{} " + "in dev:{} for vlan:{}", fwd.id(), fwd.nextId(), deviceId, vlanIdCriterion.vlanId());
    }
    OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vlanIdCriterion.vlanId());
    filteredSelectorBuilder.extension(ofdpaMatchVlanVid, deviceId);
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    if (fwd.treatment() != null) {
        log.warn("Ignoring traffic treatment in fwd rule {} meant for L2 table" + "for dev:{}. Expecting only nextId", fwd.id(), deviceId);
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group != null) {
                treatmentBuilder.deferred().group(group.id());
            } else {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
        }
    }
    treatmentBuilder.immediate().transition(ACL_TABLE);
    TrafficTreatment filteredTreatment = treatmentBuilder.build();
    // Build bridging table entries
    FlowRule.Builder flowRuleBuilder = DefaultFlowRule.builder();
    flowRuleBuilder.fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(filteredTreatment).forTable(BRIDGING_TABLE);
    if (fwd.permanent()) {
        flowRuleBuilder.makePermanent();
    } else {
        flowRuleBuilder.makeTemporary(fwd.timeout());
    }
    rules.add(flowRuleBuilder.build());
    return rules;
}
#method_after
protected Collection<FlowRule> processEthDstSpecific(ForwardingObjective fwd) {
    List<FlowRule> rules = new ArrayList<>();
    // Build filtered selector
    TrafficSelector selector = fwd.selector();
    EthCriterion ethCriterion = (EthCriterion) selector.getCriterion(Criterion.Type.ETH_DST);
    VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) selector.getCriterion(Criterion.Type.VLAN_VID);
    if (vlanIdCriterion == null) {
        log.warn("Forwarding objective for bridging requires vlan. Not " + "installing fwd:{} in dev:{}", fwd.id(), deviceId);
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder filteredSelectorBuilder = DefaultTrafficSelector.builder();
    if (!ethCriterion.mac().equals(NONE) && !ethCriterion.mac().equals(BROADCAST)) {
        filteredSelectorBuilder.matchEthDst(ethCriterion.mac());
        log.debug("processing L2 forwarding objective:{} -> next:{} in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        // Use wildcard DST_MAC if the MacAddress is None or Broadcast
        log.debug("processing L2 Broadcast forwarding objective:{} -> next:{} " + "in dev:{} for vlan:{}", fwd.id(), fwd.nextId(), deviceId, vlanIdCriterion.vlanId());
    }
    OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vlanIdCriterion.vlanId());
    filteredSelectorBuilder.extension(ofdpaMatchVlanVid, deviceId);
    TrafficSelector filteredSelector = filteredSelectorBuilder.build();
    if (fwd.treatment() != null) {
        log.warn("Ignoring traffic treatment in fwd rule {} meant for L2 table" + "for dev:{}. Expecting only nextId", fwd.id(), deviceId);
    }
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group != null) {
                treatmentBuilder.deferred().group(group.id());
            } else {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
        }
    }
    treatmentBuilder.immediate().transition(ACL_TABLE);
    TrafficTreatment filteredTreatment = treatmentBuilder.build();
    // Build bridging table entries
    FlowRule.Builder flowRuleBuilder = DefaultFlowRule.builder();
    flowRuleBuilder.fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector).withTreatment(filteredTreatment).forTable(BRIDGING_TABLE);
    if (fwd.permanent()) {
        flowRuleBuilder.makePermanent();
    } else {
        flowRuleBuilder.makeTemporary(fwd.timeout());
    }
    rules.add(flowRuleBuilder.build());
    return rules;
}
#end_block

#method_before
@Override
public SchemaId getSchemaId() {
    SchemaId schemaId = new SchemaId(this.getName(), this.getNameSpace().getModuleNamespace());
    return schemaId;
}
#method_after
@Override
public SchemaId getSchemaId() {
    SchemaId schemaId = new SchemaId(getName(), getNameSpace().getModuleNamespace());
    return schemaId;
}
#end_block

#method_before
@Override
public LeafType getLeafType() {
    // TODO implementation
    return getLeafTypeByDataType(dataType.getDataType());
}
#method_after
@Override
public LeafType getLeafType() {
    return getLeafTypeByDataType(dataType, dataType.getDataType());
}
#end_block

#method_before
public void setParentContext(SchemaContext schemaContext) {
    this.parentContext = schemaContext;
}
#method_after
public void setParentContext(SchemaContext sc) {
    parentContext = sc;
}
#end_block

#method_before
@Override
public void registerModel(ModelRegistrationParam param) {
    YangModel model = param.getYangModel();
    if (model != null) {
        Set<YangNode> curNodes = getNodes(model);
        setParentContextForModule(curNodes);
        models.add(model);
        AppModuleInfo info;
        Class<?> service;
        for (YangModuleId id : model.getYangModulesId()) {
            info = param.getAppModuleInfo(id);
            if (info != null) {
                service = info.getModuleClass();
                String name = service.getName();
                if (!verifyIfApplicationAlreadyRegistered(service)) {
                    if (!registerClassStore.containsKey(name)) {
                        registerClassStore.put(name, service);
                    }
                    if (curNodes != null && !curNodes.isEmpty()) {
                        processRegistration(service, curNodes);
                    }
                }
            }
        }
    } else {
        throw new RuntimeException("model can not be null.");
    }
}
#method_after
@Override
public void registerModel(ModelRegistrationParam param) {
    YangModel model = param.getYangModel();
    if (model != null) {
        Set<YangNode> curNodes = getNodes(model);
        models.add(model);
        AppModuleInfo info;
        Class<?> service;
        for (YangModuleId id : model.getYangModulesId()) {
            info = param.getAppModuleInfo(id);
            if (info != null) {
                service = info.getModuleClass();
                String name = service.getName();
                if (!verifyIfApplicationAlreadyRegistered(service)) {
                    if (!registerClassStore.containsKey(name)) {
                        registerClassStore.put(name, service);
                    }
                    if (curNodes != null && !curNodes.isEmpty()) {
                        processRegistration(service, curNodes);
                    }
                }
            }
        }
        updateChildContext(curNodes);
    } else {
        throw new RuntimeException("model can not be null.");
    }
}
#end_block

#method_before
public void updateSchemaContextForCaseChild(YangNode curNode) {
    YangNode child = curNode.getChild();
    while (child != null) {
        if (child instanceof YangChoice) {
            updateSchemaContextForChoiceChild(child);
        } else if (child instanceof SchemaDataNode) {
            child.setRootContext(this);
        }
        child = child.getNextSibling();
    }
    ((YangCase) curNode).setLeafParentContext(this);
}
#method_after
public void updateSchemaContextForCaseChild(YangNode curNode) {
    curNode.setLeafRootContext(this);
    YangNode child = curNode.getChild();
    updateContextForChoiceCase(child);
}
#end_block

#method_before
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    if (schemaId.namespace() == null) {
        log.error("node with {} namespace not found.", schemaId.namespace());
    }
    String namespace = schemaId.namespace();
    YangSchemaNode node = this.getForNameSpace(namespace);
    YangNamespace nameSpace = new NameSpace(schemaId.namespace());
    YangSchemaNodeIdentifier id = new YangSchemaNodeIdentifier();
    id.setName(schemaId.name());
    id.setNameSpace(nameSpace);
    try {
        if (node != null) {
            return node.getChildSchema(id).getSchemaNode();
        }
    } catch (DataModelException e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    checkNotNull(schemaId);
    if (schemaId.namespace() == null) {
        log.error("node with {} namespace not found.", schemaId.namespace());
    }
    String namespace = schemaId.namespace();
    YangSchemaNode node = getForNameSpace(namespace);
    YangSchemaNodeIdentifier id = getNodeIdFromSchemaId(schemaId, namespace);
    try {
        if (node != null) {
            return node.getChildSchema(id).getSchemaNode();
        }
    } catch (DataModelException e) {
        e.printStackTrace();
    }
    return null;
}
#end_block

#method_before
public static Object getObject(YangType typeInfo, String leafValue, YangDataTypes dataType) throws IllegalArgumentException {
    YangDataTypes type;
    if (dataType != null) {
        type = dataType;
    } else {
        type = typeInfo.getDataType();
    }
    switch(type) {
        case INT8:
            return Byte.parseByte(leafValue);
        case UINT8:
        case INT16:
            return Short.parseShort(leafValue);
        case UINT16:
        case INT32:
            return Integer.parseInt(leafValue);
        case UINT32:
        case INT64:
            return Long.parseLong(leafValue);
        case UINT64:
            return new BigInteger(leafValue);
        case EMPTY:
            if (leafValue == null || leafValue.equals("")) {
                return true;
            } else {
                throw new IllegalArgumentException("Value is of non Empty" + " type");
            }
        case BOOLEAN:
            return Boolean.parseBoolean(leafValue);
        case BINARY:
            return Base64.getDecoder().decode(leafValue);
        case BITS:
        case IDENTITYREF:
        case ENUMERATION:
        case STRING:
            return leafValue;
        case DECIMAL64:
            return new BigDecimal(leafValue);
        case LEAFREF:
            YangType refType = ((YangLeafRef) typeInfo.getDataTypeExtendedInfo()).getEffectiveDataType();
            return getObject(refType, leafValue, refType.getDataType());
        case DERIVED:
            return getObject(null, leafValue, ((YangDerivedInfo) typeInfo.getDataTypeExtendedInfo()).getEffectiveBuiltInType());
        case UNION:
            return parseUnionTypeInfo(typeInfo, leafValue);
        default:
            throw new IllegalArgumentException("Data type not " + "supported");
    }
}
#method_after
public static Object getObject(YangType typeInfo, String leafValue, YangDataTypes dataType) throws IllegalArgumentException {
    YangDataTypes type;
    if (dataType != null) {
        type = dataType;
    } else {
        type = typeInfo.getDataType();
    }
    switch(type) {
        case INT8:
            return Byte.parseByte(leafValue);
        case UINT8:
        case INT16:
            return Short.parseShort(leafValue);
        case UINT16:
        case INT32:
            return Integer.parseInt(leafValue);
        case UINT32:
        case INT64:
            return Long.parseLong(leafValue);
        case UINT64:
            return new BigInteger(leafValue);
        case EMPTY:
            if (leafValue == null || leafValue.equals("")) {
                return true;
            } else {
                throw new IllegalArgumentException(E_NONEMPTY);
            }
        case BOOLEAN:
            return Boolean.parseBoolean(leafValue);
        case BINARY:
            return Base64.getDecoder().decode(leafValue);
        case BITS:
        case IDENTITYREF:
        case ENUMERATION:
        case STRING:
            return leafValue;
        case DECIMAL64:
            return new BigDecimal(leafValue);
        case LEAFREF:
            YangType refType = ((YangLeafRef) typeInfo.getDataTypeExtendedInfo()).getEffectiveDataType();
            return getObject(refType, leafValue, refType.getDataType());
        case DERIVED:
            return getObject(null, leafValue, ((YangDerivedInfo) typeInfo.getDataTypeExtendedInfo()).getEffectiveBuiltInType());
        case UNION:
            return parseUnionTypeInfo(typeInfo, leafValue);
        default:
            throw new IllegalArgumentException(E_DATATYPE);
    }
}
#end_block

#method_before
@Override
public void setLeafParentContext() {
    // Add parent context for all leafs.
    for (YangLeaf yangLeaf : getListOfLeaf()) {
        yangLeaf.setParentContext(getParentSchemaContext(this));
    }
    // Add parent context for all leaf list.
    for (YangLeafList yangLeafList : getListOfLeafList()) {
        yangLeafList.setParentContext(getParentSchemaContext(this));
    }
}
#method_after
@Override
public void setLeafParentContext() {
    throw new IllegalArgumentException(E_NONDATA);
}
#end_block

#method_before
@Override
public void setLeafParentContext() {
    // Add parent context for all leafs.
    for (YangLeaf yangLeaf : getListOfLeaf()) {
        yangLeaf.setParentContext(getParentSchemaContext(this));
    }
    // Add parent context for all leaf list.
    for (YangLeafList yangLeafList : getListOfLeafList()) {
        yangLeafList.setParentContext(getParentSchemaContext(this));
    }
}
#method_after
@Override
public void setLeafParentContext() {
    throw new IllegalArgumentException(E_NONDATA);
}
#end_block

#method_before
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    YangNamespace nameSpace;
    if (schemaId.namespace() == null) {
        nameSpace = this.getNameSpace();
    } else {
        nameSpace = new NameSpace(schemaId.namespace());
    }
    YangSchemaNodeIdentifier id = new YangSchemaNodeIdentifier();
    id.setName(schemaId.name());
    id.setNameSpace(nameSpace);
    try {
        return this.getChildSchema(id).getSchemaNode();
    } catch (DataModelException e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    checkNotNull(schemaId);
    YangSchemaNodeIdentifier id = getNodeIdFromSchemaId(schemaId, getNameSpace().getModuleNamespace());
    try {
        YangSchemaNode node = getChildSchema(id).getSchemaNode();
        if (node instanceof SchemaDataNode) {
            return node;
        } else {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, schemaId.name(), getName()));
        }
    } catch (DataModelException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    YangNamespace nameSpace;
    if (schemaId.namespace() == null) {
        nameSpace = this.getNameSpace();
    } else {
        nameSpace = new NameSpace(schemaId.namespace());
    }
    YangSchemaNodeIdentifier id = new YangSchemaNodeIdentifier();
    id.setName(schemaId.name());
    id.setNameSpace(nameSpace);
    try {
        return this.getChildSchema(id).getSchemaNode();
    } catch (DataModelException e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    checkNotNull(schemaId);
    YangSchemaNodeIdentifier id = getNodeIdFromSchemaId(schemaId, getNameSpace().getModuleNamespace());
    try {
        YangSchemaNode node = getChildSchema(id).getSchemaNode();
        if (node instanceof SchemaDataNode) {
            return node;
        } else {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, schemaId.name(), getName()));
        }
    } catch (DataModelException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public SchemaId getSchemaId() throws IllegalArgumentException {
    if (schemaId == null) {
        throw new IllegalArgumentException("Method called for other then " + "data node");
    }
    return schemaId;
}
#method_after
@Override
public SchemaId getSchemaId() throws IllegalArgumentException {
    if (schemaId == null) {
        throw new IllegalArgumentException(E_NONDATA);
    }
    return schemaId;
}
#end_block

#method_before
@Override
public DataNode.Type getType() throws IllegalArgumentException {
    if (dataNodeType == null) {
        throw new IllegalArgumentException("Method called for other then " + "data node");
    }
    return dataNodeType;
}
#method_after
@Override
public DataNode.Type getType() throws IllegalArgumentException {
    if (dataNodeType == null) {
        throw new IllegalArgumentException(E_NONDATA);
    }
    return dataNodeType;
}
#end_block

#method_before
@Override
public SchemaContext getParentContext() throws IllegalArgumentException {
    if (parentContext == null) {
        throw new IllegalArgumentException("Method called for other then " + "data node");
    }
    return parentContext;
}
#method_after
@Override
public SchemaContext getParentContext() throws IllegalArgumentException {
    if (parentContext == null) {
        throw new IllegalArgumentException(E_NONDATA);
    }
    return parentContext;
}
#end_block

#method_before
public void setParentContext() {
    if (this instanceof SchemaDataNode) {
        parentContext = getParentSchemaContext(this.getParent());
        // As rpc node is not leaf holder
        if (this.nodeType != RPC_NODE) {
            ((YangLeavesHolder) this).setLeafParentContext();
        }
        // setting the schema Id
        schemaId = new SchemaId(getName(), getNameSpace().getModuleNamespace());
    } else if (this instanceof YangCase) {
        ((YangLeavesHolder) this).setLeafParentContext();
        // setting the schema Id
        schemaId = new SchemaId(getName(), getNameSpace().getModuleNamespace());
    }
}
#method_after
public void setParentContext() {
    if (this instanceof SchemaDataNode) {
        parentContext = getParentSchemaContext(this.getParent());
        // As rpc node is not leaf holder
        if (this.nodeType != RPC_NODE) {
            ((YangLeavesHolder) this).setLeafParentContext();
        }
        // setting the schema Id
        schemaId = new SchemaId(getName(), getNameSpace().getModuleNamespace());
    } else if (this instanceof YangCase) {
        ((YangLeavesHolder) this).setLeafParentContext();
    }
}
#end_block

#method_before
public void setRootContext(SchemaContext context) {
    parentContext = context;
    // As rpc node is not leaf holder
    if (this.nodeType != RPC_NODE) {
        ((YangLeavesHolder) this).setLeafParentContext();
    }
}
#method_after
@Override
public void setRootContext(SchemaContext context) {
    parentContext = context;
}
#end_block

#method_before
public List<String> getKeyList() {
    return keyList;
}
#method_after
public LinkedHashSet<String> getKeyList() {
    return keyList;
}
#end_block

#method_before
private void setKeyList(List<String> keyList) {
    this.keyList = keyList;
}
#method_after
private void setKeyList(LinkedHashSet<String> keyList) {
    this.keyList = keyList;
}
#end_block

#method_before
public void addKey(String key) throws DataModelException {
    if (getKeyList() == null) {
        setKeyList(new LinkedList<>());
    }
    if (getKeyList().contains(key)) {
        throw new DataModelException("A leaf identifier must not appear more than once in the\n" + "   key" + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    }
    getKeyList().add(key);
}
#method_after
public void addKey(String key) throws DataModelException {
    if (getKeyList() == null) {
        setKeyList(new LinkedHashSet<String>());
    }
    if (getKeyList().contains(key)) {
        throw new DataModelException("A leaf identifier must not appear more than once in the\n" + "   key" + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    }
    getKeyList().add(key);
}
#end_block

#method_before
@Override
public void validateDataOnExit() throws DataModelException {
    List<String> keys = getKeyList();
    List<YangLeaf> leaves = getListOfLeaf();
    List<YangLeafList> leafLists = getListOfLeafList();
    validateConfig(leaves, leafLists);
    // A list must have atleast one key leaf if config is true
    if (isConfig && (keys.isEmpty() || leaves.isEmpty()) && !isUsesPresentInList() && !isListPresentInGrouping()) {
        throw new DataModelException("A list must have atleast one key leaf if config is true; " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    } else if (keys != null) {
        validateKey(leaves, keys);
    }
}
#method_after
@Override
public void validateDataOnExit() throws DataModelException {
    LinkedHashSet<String> keys = getKeyList();
    List<YangLeaf> leaves = getListOfLeaf();
    List<YangLeafList> leafLists = getListOfLeafList();
    validateConfig(leaves, leafLists);
    // A list must have atleast one key leaf if config is true
    if (isConfig && (keys.isEmpty() || leaves.isEmpty()) && !isUsesPresentInList() && !isListPresentInGrouping()) {
        throw new DataModelException("A list must have atleast one key leaf if config is true; " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    } else if (keys != null) {
        validateKey(leaves, keys);
    }
}
#end_block

#method_before
private void validateKey(List<YangLeaf> leaves, List<String> keys) throws DataModelException {
    boolean leafFound = false;
    List<YangLeaf> keyLeaves = new LinkedList<>();
    /*
         * 1. Leaf identifier must refer to a child leaf of the list 2. A leaf
         * that is part of the key must not be the built-in type "empty".
         */
    for (String key : keys) {
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                if (key.equals(leaf.getName())) {
                    if (leaf.getDataType().getDataType() == EMPTY) {
                        throw new DataModelException(" A leaf that is part of the key must not be the built-in " + "type \"empty\"." + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
                    }
                    leafFound = true;
                    keyLeaves.add(leaf);
                    break;
                }
            }
        }
        if (!leafFound && !isUsesPresentInList() && !isListPresentInGrouping()) {
            throw new DataModelException("An identifier, in key, must refer to a child leaf of the list" + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
        }
        leafFound = false;
    }
    /*
         * All key leafs in a list MUST have the same value for their "config"
         * as the list itself.
         */
    for (YangLeaf keyLeaf : keyLeaves) {
        if (isConfig != keyLeaf.isConfig()) {
            throw new DataModelException("All key leafs in a list must have the same value for their" + " \"config\" as the list itself." + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
        }
    }
}
#method_after
private void validateKey(List<YangLeaf> leaves, LinkedHashSet<String> keys) throws DataModelException {
    boolean leafFound = false;
    List<YangLeaf> keyLeaves = new LinkedList<>();
    /*
         * 1. Leaf identifier must refer to a child leaf of the list 2. A leaf
         * that is part of the key must not be the built-in type "empty".
         */
    for (String key : keys) {
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                if (key.equals(leaf.getName())) {
                    if (leaf.getDataType().getDataType() == EMPTY) {
                        throw new DataModelException(" A leaf that is part of the key must not be the built-in " + "type \"empty\"." + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
                    }
                    leafFound = true;
                    keyLeaves.add(leaf);
                    break;
                }
            }
        }
        if (!leafFound && !isUsesPresentInList() && !isListPresentInGrouping()) {
            throw new DataModelException("An identifier, in key, must refer to a child leaf of the list" + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
        }
        leafFound = false;
    }
    /*
         * All key leafs in a list MUST have the same value for their "config"
         * as the list itself.
         */
    for (YangLeaf keyLeaf : keyLeaves) {
        if (isConfig != keyLeaf.isConfig()) {
            throw new DataModelException("All key leafs in a list must have the same value for their" + " \"config\" as the list itself." + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
        }
    }
}
#end_block

#method_before
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    YangNamespace nameSpace;
    if (schemaId.namespace() == null) {
        nameSpace = this.getNameSpace();
    } else {
        nameSpace = new NameSpace(schemaId.namespace());
    }
    YangSchemaNodeIdentifier id = new YangSchemaNodeIdentifier();
    id.setName(schemaId.name());
    id.setNameSpace(nameSpace);
    try {
        return this.getChildSchema(id).getSchemaNode();
    } catch (DataModelException e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    checkNotNull(schemaId);
    YangSchemaNodeIdentifier id = getNodeIdFromSchemaId(schemaId, getNameSpace().getModuleNamespace());
    try {
        YangSchemaNode node = getChildSchema(id).getSchemaNode();
        if (node instanceof SchemaDataNode) {
            return node;
        } else {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, schemaId.name(), getName()));
        }
    } catch (DataModelException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    YangNamespace nameSpace;
    if (schemaId.namespace() == null) {
        nameSpace = this.getNameSpace();
    } else {
        nameSpace = new NameSpace(schemaId.namespace());
    }
    YangSchemaNodeIdentifier id = new YangSchemaNodeIdentifier();
    id.setName(schemaId.name());
    id.setNameSpace(nameSpace);
    try {
        return this.getChildSchema(id).getSchemaNode();
    } catch (DataModelException e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    checkNotNull(schemaId);
    YangSchemaNodeIdentifier id = getNodeIdFromSchemaId(schemaId, getNameSpace().getModuleNamespace());
    try {
        YangSchemaNode node = getChildSchema(id).getSchemaNode();
        if (node instanceof SchemaDataNode) {
            return node;
        } else {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, schemaId.name(), getName()));
        }
    } catch (DataModelException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void caseSchemaContTest() throws DataModelException {
    schemaProvider.processSchemaRegistry();
    DefaultYangModelRegistry registry = schemaProvider.registry();
    SchemaId id = new SchemaId("pretzel", CASENS);
    YangLeaf leaf = (YangLeaf) registry.getChildContext(id);
    checkLeafSchemaContext("pretzel", CASENS, "/", null, leaf);
    id = new SchemaId("light", CASENS);
    leaf = (YangLeaf) registry.getChildContext(id);
    checkLeafSchemaContext("light", CASENS, "/", null, leaf);
    id = new SchemaId("potato", CASENS);
    YangLeafList leafList = (YangLeafList) registry.getChildContext(id);
    checkLeafListSchemaContext("potato", CASENS, "/", null, leafList);
    id = new SchemaId("banana", CASENS);
    YangNode child = (YangNode) registry.getChildContext(id);
    checkSchemaContext("banana", CASENS, "/", null, MULTI_INSTANCE_NODE, child);
    id = new SchemaId("cold-drink", CASENS);
    child = (YangNode) registry.getChildContext(id);
    checkSchemaContext("cold-drink", CASENS, "/", null, SINGLE_INSTANCE_NODE, child);
    YangSchemaNodeIdentifier rId = new YangSchemaNodeIdentifier();
    rId.setName("flavor");
    rId.setNameSpace(new NameSpace(CASENS));
    leafList = (YangLeafList) child.getChildSchema(rId).getSchemaNode();
    checkLeafListSchemaContext("flavor", CASENS, "cold-drink", CASENS, leafList);
}
#method_after
@Test
public void caseSchemaContTest() throws DataModelException {
    schemaProvider.processSchemaRegistry();
    DefaultYangModelRegistry registry = schemaProvider.registry();
    SchemaId id = new SchemaId("pretzel", CASENS);
    YangLeaf leaf = (YangLeaf) registry.getChildContext(id);
    checkLeafSchemaContext("pretzel", CASENS, "/", null, leaf);
    id = new SchemaId("light", CASENS);
    leaf = (YangLeaf) registry.getChildContext(id);
    checkLeafSchemaContext("light", CASENS, "/", null, leaf);
    id = new SchemaId("potato", CASENS);
    YangLeafList leafList = (YangLeafList) registry.getChildContext(id);
    checkLeafListSchemaContext("potato", CASENS, "/", null, leafList);
    id = new SchemaId("banana", CASENS);
    YangNode child = (YangNode) registry.getChildContext(id);
    checkSchemaContext("banana", CASENS, "/", null, MULTI_INSTANCE_NODE, child);
    id = new SchemaId("cold-drink", CASENS);
    child = (YangNode) registry.getChildContext(id);
    checkSchemaContext("cold-drink", CASENS, "/", null, SINGLE_INSTANCE_NODE, child);
    YangSchemaNodeIdentifier rId = new YangSchemaNodeIdentifier();
    rId.setName("flavor");
    rId.setNameSpace(new DefaultYangNamespace(CASENS));
    leafList = (YangLeafList) child.getChildSchema(rId).getSchemaNode();
    checkLeafListSchemaContext("flavor", CASENS, "cold-drink", CASENS, leafList);
}
#end_block

#method_before
private void validateConfig(List<YangLeaf> leaves, List<YangLeafList> leafLists) throws DataModelException {
    /*
         * If a node has "config" set to "false", no node underneath it can have
         * "config" set to "true".
         */
    if (!isConfig && leaves != null) {
        for (YangLeaf leaf : leaves) {
            if (leaf.isConfig()) {
                throw new DataModelException("If a container has \"config\" set to \"false\", no node underneath " + "it can have \"config\" set to \"true\"." + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
            }
        }
    }
    if (!isConfig && leafLists != null) {
        for (YangLeafList leafList : leafLists) {
            if (leafList.isConfig()) {
                throw new DataModelException("If a container has \"config\" set to \"false\", no node underneath " + "it can have \"config\" set to \"true\"." + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
            }
        }
    }
}
#method_after
private void validateConfig(List<YangLeaf> leaves, List<YangLeafList> leafLists) throws DataModelException {
    /*
         * If a node has "config" set to "false", no node underneath it can have
         * "config" set to "true".
         */
    if (!isConfig && leaves != null) {
        for (YangLeaf leaf : leaves) {
            if (leaf.isConfig()) {
                throw new DataModelException("If a container has \"config\" set to \"false\", " + "no node underneath it can have " + "\"config\" set to \"true\"." + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
            }
        }
    }
    if (!isConfig && leafLists != null) {
        for (YangLeafList leafList : leafLists) {
            if (leafList.isConfig()) {
                throw new DataModelException("If a container has \"config\" set to \"false\", " + "no node underneath it can have " + "\"config\" set to \"true\"." + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
            }
        }
    }
}
#end_block

#method_before
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (getName().equals(identifierName)) {
        throw new DataModelException("YANG file error: Duplicate input identifier detected, same as container \"" + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    }
}
#method_after
@Override
public void detectSelfCollision(String identifierName, YangConstructType dataType) throws DataModelException {
    if (getName().equals(identifierName)) {
        throw new DataModelException("YANG file error: Duplicate input identifier detected," + " same as container \"" + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    }
}
#end_block

#method_before
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    YangNamespace nameSpace;
    if (schemaId.namespace() == null) {
        nameSpace = this.getNameSpace();
    } else {
        nameSpace = new NameSpace(schemaId.namespace());
    }
    YangSchemaNodeIdentifier id = new YangSchemaNodeIdentifier();
    id.setName(schemaId.name());
    id.setNameSpace(nameSpace);
    try {
        return this.getChildSchema(id).getSchemaNode();
    } catch (DataModelException e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
@Override
public SchemaContext getChildContext(SchemaId schemaId) {
    checkNotNull(schemaId);
    YangSchemaNodeIdentifier id = getNodeIdFromSchemaId(schemaId, getNameSpace().getModuleNamespace());
    try {
        YangSchemaNode node = getChildSchema(id).getSchemaNode();
        if (node instanceof SchemaDataNode) {
            return node;
        } else {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, schemaId.name(), getName()));
        }
    } catch (DataModelException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void leafSchemaContTest() throws DataModelException {
    schemaProvider.processSchemaRegistry();
    DefaultYangModelRegistry registry = schemaProvider.registry();
    SchemaId id = new SchemaId("food", FOODNS);
    YangNode child = (YangNode) registry.getChildContext(id);
    checkSchemaContext("food", FOODNS, "/", null, DataNode.Type.SINGLE_INSTANCE_NODE, child);
    YangSchemaNodeIdentifier rId = new YangSchemaNodeIdentifier();
    rId.setName("pretzel");
    rId.setNameSpace(new NameSpace(FOODNS));
    YangSchemaNode leaf1 = child.getChildSchema(rId).getSchemaNode();
    checkLeafSchemaContext("pretzel", FOODNS, "food", FOODNS, (YangLeaf) leaf1);
    rId.setName("redbull");
    leaf1 = child.getChildSchema(rId).getSchemaNode();
    checkLeafSchemaContext("redbull", FOODNS, "food", FOODNS, (YangLeaf) leaf1);
    rId.setName("kingfisher");
    leaf1 = child.getChildSchema(rId).getSchemaNode();
    checkLeafSchemaContext("kingfisher", FOODNS, "food", FOODNS, (YangLeaf) leaf1);
    id = new SchemaId("bool", FOODNS);
    YangLeaf leaf = (YangLeaf) registry.getChildContext(id);
    checkLeafSchemaContext("bool", FOODNS, "/", null, leaf);
    id = new SchemaId("boolean", FOODNS);
    YangLeafList leafList = (YangLeafList) registry.getChildContext(id);
    checkLeafListSchemaContext("boolean", FOODNS, "/", null, leafList);
}
#method_after
@Test
public void leafSchemaContTest() throws DataModelException {
    schemaProvider.processSchemaRegistry();
    DefaultYangModelRegistry registry = schemaProvider.registry();
    SchemaId id = new SchemaId("food", FOODNS);
    YangNode child = (YangNode) registry.getChildContext(id);
    checkSchemaContext("food", FOODNS, "/", null, DataNode.Type.SINGLE_INSTANCE_NODE, child);
    YangSchemaNodeIdentifier rId = new YangSchemaNodeIdentifier();
    rId.setName("pretzel");
    rId.setNameSpace(new DefaultYangNamespace(FOODNS));
    YangSchemaNode leaf1 = child.getChildSchema(rId).getSchemaNode();
    checkLeafSchemaContext("pretzel", FOODNS, "food", FOODNS, (YangLeaf) leaf1);
    rId.setName("redbull");
    leaf1 = child.getChildSchema(rId).getSchemaNode();
    checkLeafSchemaContext("redbull", FOODNS, "food", FOODNS, (YangLeaf) leaf1);
    rId.setName("kingfisher");
    leaf1 = child.getChildSchema(rId).getSchemaNode();
    checkLeafSchemaContext("kingfisher", FOODNS, "food", FOODNS, (YangLeaf) leaf1);
    id = new SchemaId("bool", FOODNS);
    YangLeaf leaf = (YangLeaf) registry.getChildContext(id);
    checkLeafSchemaContext("bool", FOODNS, "/", null, leaf);
    id = new SchemaId("boolean", FOODNS);
    YangLeafList leafList = (YangLeafList) registry.getChildContext(id);
    checkLeafListSchemaContext("boolean", FOODNS, "/", null, leafList);
}
#end_block

#method_before
@Override
public void setLeafParentContext() {
    // Add parent context for all leafs.
    for (YangLeaf yangLeaf : getListOfLeaf()) {
        yangLeaf.setParentContext(getParentSchemaContext(this));
    }
    // Add parent context for all leaf list.
    for (YangLeafList yangLeafList : getListOfLeafList()) {
        yangLeafList.setParentContext(getParentSchemaContext(this));
    }
}
#method_after
@Override
public void setLeafParentContext() {
    throw new IllegalArgumentException(E_NONDATA);
}
#end_block

#method_before
@Before
public void setup() {
    SignatureBuilder builder1 = new DefaultSignatureBuilder();
    signature1 = builder1.withRecordTtl(100).withSigExpiration(100).withSigInception(100).withKeyTag((short) 100).withSigLength((short) 100).withSigAlgorithm((byte) 1).withSignature(100).build();
    SignatureBuilder builder2 = new DefaultSignatureBuilder();
    sameAsSignature1 = builder2.withRecordTtl(100).withSigExpiration(100).withSigInception(100).withKeyTag((short) 100).withSigLength((short) 100).withSigAlgorithm((byte) 1).withSignature(100).build();
    SignatureBuilder builder3 = new DefaultSignatureBuilder();
    signature2 = builder3.withRecordTtl(200).withSigExpiration(200).withSigInception(200).withKeyTag((short) 200).withSigLength((short) 200).withSigAlgorithm((byte) 2).withSignature(200).build();
}
#method_after
@Before
public void setup() {
    SignatureBuilder builder1 = new DefaultSignatureBuilder();
    signature1 = builder1.withRecordTtl(SIG_UNIQUE_VALUE_1).withSigExpiration(SIG_UNIQUE_VALUE_1).withSigInception(SIG_UNIQUE_VALUE_1).withKeyTag((short) SIG_UNIQUE_VALUE_1).withSigLength((short) SIG_UNIQUE_VALUE_1).withSigAlgorithm((byte) 1).withSignature(SIG_UNIQUE_VALUE_1).build();
    SignatureBuilder builder2 = new DefaultSignatureBuilder();
    sameAsSignature1 = builder2.withRecordTtl(SIG_UNIQUE_VALUE_1).withSigExpiration(SIG_UNIQUE_VALUE_1).withSigInception(SIG_UNIQUE_VALUE_1).withKeyTag((short) SIG_UNIQUE_VALUE_1).withSigLength((short) SIG_UNIQUE_VALUE_1).withSigAlgorithm((byte) 1).withSignature(SIG_UNIQUE_VALUE_1).build();
    SignatureBuilder builder3 = new DefaultSignatureBuilder();
    signature2 = builder3.withRecordTtl(SIG_UNIQUE_VALUE_2).withSigExpiration(SIG_UNIQUE_VALUE_2).withSigInception(SIG_UNIQUE_VALUE_2).withKeyTag((short) SIG_UNIQUE_VALUE_2).withSigLength((short) SIG_UNIQUE_VALUE_2).withSigAlgorithm((byte) 2).withSignature(SIG_UNIQUE_VALUE_2).build();
}
#end_block

#method_before
@Test
public void testConstruction() {
    LispSignature signature = signature1;
    assertThat(signature.getRecordTtl(), is(100));
    assertThat(signature.getSigExpiration(), is(100));
    assertThat(signature.getSigInception(), is(100));
    assertThat(signature.getKeyTag(), is((short) 100));
    assertThat(signature.getSigLength(), is((short) 100));
    assertThat(signature.getSigAlgorithm(), is((byte) 1));
    assertThat(signature.getSignature(), is(100));
}
#method_after
@Test
public void testConstruction() {
    LispSignature signature = signature1;
    assertThat(signature.getRecordTtl(), is(SIG_UNIQUE_VALUE_1));
    assertThat(signature.getSigExpiration(), is(SIG_UNIQUE_VALUE_1));
    assertThat(signature.getSigInception(), is(SIG_UNIQUE_VALUE_1));
    assertThat(signature.getKeyTag(), is((short) SIG_UNIQUE_VALUE_1));
    assertThat(signature.getSigLength(), is((short) SIG_UNIQUE_VALUE_1));
    assertThat(signature.getSigAlgorithm(), is((byte) 1));
    assertThat(signature.getSignature(), is(SIG_UNIQUE_VALUE_1));
}
#end_block

#method_before
@Before
public void setup() {
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    record1 = builder1.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
    MapRecordBuilder builder2 = new DefaultMapRecordBuilder();
    sameAsRecord1 = builder2.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
    MapRecordBuilder builder3 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator2 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    record2 = builder3.withRecordTtl(200).withIsAuthoritative(false).withMapVersionNumber((short) 2).withMaskLength((byte) 0x02).withAction(LispMapReplyAction.Drop).withEidPrefixAfi(ipv4Locator2).build();
}
#method_after
@Before
public void setup() {
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_1));
    record1 = builder1.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
    MapRecordBuilder builder2 = new DefaultMapRecordBuilder();
    sameAsRecord1 = builder2.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
    MapRecordBuilder builder3 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator2 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_2));
    record2 = builder3.withRecordTtl(200).withIsAuthoritative(false).withMapVersionNumber((short) 2).withMaskLength((byte) 0x02).withAction(LispMapReplyAction.Drop).withEidPrefixAfi(ipv4Locator2).build();
}
#end_block

#method_before
@Test
public void testConstruction() {
    DefaultLispMapRecord record = (DefaultLispMapRecord) record1;
    LispIpv4Address ipv4Locator = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    assertThat(record.getRecordTtl(), is(100));
    assertThat(record.isAuthoritative(), is(true));
    assertThat(record.getMapVersionNumber(), is((short) 1));
    assertThat(record.getMaskLength(), is((byte) 0x01));
    assertThat(record.getAction(), is(LispMapReplyAction.NativelyForward));
    assertThat(record.getEidPrefixAfi(), is(ipv4Locator));
}
#method_after
@Test
public void testConstruction() {
    DefaultLispMapRecord record = (DefaultLispMapRecord) record1;
    LispIpv4Address ipv4Locator = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_1));
    assertThat(record.getRecordTtl(), is(100));
    assertThat(record.isAuthoritative(), is(true));
    assertThat(record.getMapVersionNumber(), is((short) 1));
    assertThat(record.getMaskLength(), is((byte) 0x01));
    assertThat(record.getAction(), is(LispMapReplyAction.NativelyForward));
    assertThat(record.getEidPrefixAfi(), is(ipv4Locator));
}
#end_block

#method_before
@Before
public void setup() {
    LispLocator.LocatorBuilder builder1 = new DefaultLocatorBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    record1 = builder1.withPriority((byte) 0x01).withWeight((byte) 0x01).withMulticastPriority((byte) 0x01).withMulticastWeight((byte) 0x01).withLocalLocator(true).withRlocProbed(false).withRouted(true).withLocatorAfi(ipv4Locator1).build();
    LocatorBuilder builder2 = new DefaultLocatorBuilder();
    sameAsRecord1 = builder2.withPriority((byte) 0x01).withWeight((byte) 0x01).withMulticastPriority((byte) 0x01).withMulticastWeight((byte) 0x01).withLocalLocator(true).withRlocProbed(false).withRouted(true).withLocatorAfi(ipv4Locator1).build();
    LispLocator.LocatorBuilder builder3 = new DefaultLocatorBuilder();
    LispIpv4Address ipv4Locator2 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    record2 = builder3.withPriority((byte) 0x02).withWeight((byte) 0x02).withMulticastPriority((byte) 0x02).withMulticastWeight((byte) 0x02).withLocalLocator(false).withRlocProbed(true).withRouted(false).withLocatorAfi(ipv4Locator2).build();
}
#method_after
@Before
public void setup() {
    LispLocator.LocatorBuilder builder1 = new DefaultLocatorBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_1));
    record1 = builder1.withPriority((byte) 0x01).withWeight((byte) 0x01).withMulticastPriority((byte) 0x01).withMulticastWeight((byte) 0x01).withLocalLocator(true).withRlocProbed(false).withRouted(true).withLocatorAfi(ipv4Locator1).build();
    LocatorBuilder builder2 = new DefaultLocatorBuilder();
    sameAsRecord1 = builder2.withPriority((byte) 0x01).withWeight((byte) 0x01).withMulticastPriority((byte) 0x01).withMulticastWeight((byte) 0x01).withLocalLocator(true).withRlocProbed(false).withRouted(true).withLocatorAfi(ipv4Locator1).build();
    LispLocator.LocatorBuilder builder3 = new DefaultLocatorBuilder();
    LispIpv4Address ipv4Locator2 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_2));
    record2 = builder3.withPriority((byte) 0x02).withWeight((byte) 0x02).withMulticastPriority((byte) 0x02).withMulticastWeight((byte) 0x02).withLocalLocator(false).withRlocProbed(true).withRouted(false).withLocatorAfi(ipv4Locator2).build();
}
#end_block

#method_before
@Test
public void testConstruction() {
    DefaultLispLocator record = (DefaultLispLocator) record1;
    LispIpv4Address ipv4Locator = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    assertThat(record.getPriority(), is((byte) 0x01));
    assertThat(record.getWeight(), is((byte) 0x01));
    assertThat(record.getMulticastPriority(), is((byte) 0x01));
    assertThat(record.getMulticastWeight(), is((byte) 0x01));
    assertThat(record.isLocalLocator(), is(true));
    assertThat(record.isRlocProbed(), is(false));
    assertThat(record.isRouted(), is(true));
    assertThat(record.getLocatorAfi(), is(ipv4Locator));
}
#method_after
@Test
public void testConstruction() {
    DefaultLispLocator record = (DefaultLispLocator) record1;
    LispIpv4Address ipv4Locator = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_1));
    assertThat(record.getPriority(), is((byte) 0x01));
    assertThat(record.getWeight(), is((byte) 0x01));
    assertThat(record.getMulticastPriority(), is((byte) 0x01));
    assertThat(record.getMulticastWeight(), is((byte) 0x01));
    assertThat(record.isLocalLocator(), is(true));
    assertThat(record.isRlocProbed(), is(false));
    assertThat(record.isRouted(), is(true));
    assertThat(record.getLocatorAfi(), is(ipv4Locator));
}
#end_block

#method_before
private LispMapRecord getMapRecord() {
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    return builder1.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
}
#method_after
private LispMapRecord getMapRecord() {
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS));
    return builder1.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
}
#end_block

#method_before
private LispMapRecord getMapRecord() {
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    return builder1.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
}
#method_after
private LispMapRecord getMapRecord() {
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS));
    return builder1.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
}
#end_block

#method_before
@Before
public void setup() {
    byte cidr1 = (byte) 32;
    LispIpv4Address eid1 = new LispIpv4Address(IpAddress.valueOf("10.1.1.1"));
    LispEidRecord eidRecord1 = new LispEidRecord(cidr1, eid1);
    LispIpv4Address locator11 = new LispIpv4Address(IpAddress.valueOf("123.1.1.1"));
    LispIpv4Address locator12 = new LispIpv4Address(IpAddress.valueOf("123.1.1.2"));
    LispIpv4Address locator13 = new LispIpv4Address(IpAddress.valueOf("123.1.1.3"));
    LispLocator locatorRecord11 = new DefaultLocatorBuilder().withLocatorAfi(locator11).build();
    LispLocator locatorRecord12 = new DefaultLocatorBuilder().withLocatorAfi(locator12).build();
    LispLocator locatorRecord13 = new DefaultLocatorBuilder().withLocatorAfi(locator13).build();
    List<LispLocator> locatorRecords1 = ImmutableList.of(locatorRecord11, locatorRecord12, locatorRecord13);
    byte cidr2 = (byte) 24;
    LispIpv4Address eid2 = new LispIpv4Address(IpAddress.valueOf("10.1.2.0"));
    LispEidRecord eidRecord2 = new LispEidRecord(cidr2, eid2);
    LispIpv4Address locator21 = new LispIpv4Address(IpAddress.valueOf("123.2.1.1"));
    LispIpv4Address locator22 = new LispIpv4Address(IpAddress.valueOf("123.2.1.2"));
    LispLocator locatorRecord21 = new DefaultLocatorBuilder().withLocatorAfi(locator21).build();
    LispLocator locatorRecord22 = new DefaultLocatorBuilder().withLocatorAfi(locator22).build();
    List<LispLocator> locatorRecords2 = ImmutableList.of(locatorRecord21, locatorRecord22);
    byte cidr3 = (byte) 16;
    LispIpv4Address eid3 = new LispIpv4Address(IpAddress.valueOf("10.2.0.0"));
    LispEidRecord eidRecord3 = new LispEidRecord(cidr3, eid3);
    LispIpv4Address locator31 = new LispIpv4Address(IpAddress.valueOf("123.3.1.1"));
    LispLocator locatorRecord31 = new DefaultLocatorBuilder().withLocatorAfi(locator31).build();
    List<LispLocator> locatorRecords3 = ImmutableList.of(locatorRecord31);
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    builder1.withMaskLength(cidr1);
    builder1.withEidPrefixAfi(eid1);
    builder1.withLocators(locatorRecords1);
    builder1.withRecordTtl(60);
    LispMapRecord mapRecord1 = builder1.build();
    MapRecordBuilder builder2 = new DefaultMapRecordBuilder();
    builder2.withMaskLength(cidr2);
    builder2.withEidPrefixAfi(eid2);
    builder2.withLocators(locatorRecords2);
    builder2.withRecordTtl(60);
    LispMapRecord mapRecord2 = builder2.build();
    MapRecordBuilder builder3 = new DefaultMapRecordBuilder();
    builder3.withMaskLength(cidr3);
    builder3.withEidPrefixAfi(eid3);
    builder3.withLocators(locatorRecords3);
    builder3.withRecordTtl(60);
    LispMapRecord mapRecord3 = builder3.build();
    mapDb.putMapRecord(eidRecord1, mapRecord1, true);
    mapDb.putMapRecord(eidRecord2, mapRecord2, true);
    mapDb.putMapRecord(eidRecord3, mapRecord3, true);
}
#method_after
@Before
public void setup() {
    byte cidr1 = (byte) 32;
    LispIpv4Address eid1 = new LispIpv4Address(IpAddress.valueOf(EID_IP_1));
    LispEidRecord eidRecord1 = new LispEidRecord(cidr1, eid1);
    LispIpv4Address locator11 = new LispIpv4Address(IpAddress.valueOf(LOCATOR_IP_1_1));
    LispIpv4Address locator12 = new LispIpv4Address(IpAddress.valueOf(LOCATOR_IP_1_2));
    LispIpv4Address locator13 = new LispIpv4Address(IpAddress.valueOf(LOCATOR_IP_1_3));
    LispLocator locatorRecord11 = new DefaultLocatorBuilder().withLocatorAfi(locator11).build();
    LispLocator locatorRecord12 = new DefaultLocatorBuilder().withLocatorAfi(locator12).build();
    LispLocator locatorRecord13 = new DefaultLocatorBuilder().withLocatorAfi(locator13).build();
    List<LispLocator> locatorRecords1 = ImmutableList.of(locatorRecord11, locatorRecord12, locatorRecord13);
    byte cidr2 = (byte) 24;
    LispIpv4Address eid2 = new LispIpv4Address(IpAddress.valueOf(EID_IP_2));
    LispEidRecord eidRecord2 = new LispEidRecord(cidr2, eid2);
    LispIpv4Address locator21 = new LispIpv4Address(IpAddress.valueOf(LOCATOR_IP_2_1));
    LispIpv4Address locator22 = new LispIpv4Address(IpAddress.valueOf(LOCATOR_IP_2_2));
    LispLocator locatorRecord21 = new DefaultLocatorBuilder().withLocatorAfi(locator21).build();
    LispLocator locatorRecord22 = new DefaultLocatorBuilder().withLocatorAfi(locator22).build();
    List<LispLocator> locatorRecords2 = ImmutableList.of(locatorRecord21, locatorRecord22);
    byte cidr3 = (byte) 16;
    LispIpv4Address eid3 = new LispIpv4Address(IpAddress.valueOf(EID_IP_3));
    LispEidRecord eidRecord3 = new LispEidRecord(cidr3, eid3);
    LispIpv4Address locator31 = new LispIpv4Address(IpAddress.valueOf(LOCATOR_IP_3_1));
    LispLocator locatorRecord31 = new DefaultLocatorBuilder().withLocatorAfi(locator31).build();
    List<LispLocator> locatorRecords3 = ImmutableList.of(locatorRecord31);
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    builder1.withMaskLength(cidr1);
    builder1.withEidPrefixAfi(eid1);
    builder1.withLocators(locatorRecords1);
    builder1.withRecordTtl(60);
    LispMapRecord mapRecord1 = builder1.build();
    MapRecordBuilder builder2 = new DefaultMapRecordBuilder();
    builder2.withMaskLength(cidr2);
    builder2.withEidPrefixAfi(eid2);
    builder2.withLocators(locatorRecords2);
    builder2.withRecordTtl(60);
    LispMapRecord mapRecord2 = builder2.build();
    MapRecordBuilder builder3 = new DefaultMapRecordBuilder();
    builder3.withMaskLength(cidr3);
    builder3.withEidPrefixAfi(eid3);
    builder3.withLocators(locatorRecords3);
    builder3.withRecordTtl(60);
    LispMapRecord mapRecord3 = builder3.build();
    mapDb.putMapRecord(eidRecord1, mapRecord1, true);
    mapDb.putMapRecord(eidRecord2, mapRecord2, true);
    mapDb.putMapRecord(eidRecord3, mapRecord3, true);
}
#end_block

#method_before
@Test
public void test32MaskRange() {
    byte cidr32 = (byte) 32;
    LispIpv4Address eid = new LispIpv4Address(IpAddress.valueOf("10.1.1.1"));
    LispEidRecord record = new LispEidRecord(cidr32, eid);
    LispMapRecord mapRecord = mapDb.getMapRecordByEidRecord(record, true);
    assertThat("Failed to fetch the RLOCs with /32 EID record", mapRecord.getLocatorCount(), is(3));
}
#method_after
@Test
public void test32MaskRange() {
    byte cidr32 = (byte) 32;
    LispIpv4Address eid = new LispIpv4Address(IpAddress.valueOf(EID_IP_1));
    LispEidRecord record = new LispEidRecord(cidr32, eid);
    LispMapRecord mapRecord = mapDb.getMapRecordByEidRecord(record, true);
    assertThat("Failed to fetch the RLOCs with /32 EID record", mapRecord.getLocatorCount(), is(3));
}
#end_block

#method_before
@Test
public void test24MaskRange() {
    byte cidr32 = (byte) 32;
    LispIpv4Address eid = new LispIpv4Address(IpAddress.valueOf("10.1.2.1"));
    LispEidRecord record32 = new LispEidRecord(cidr32, eid);
    LispMapRecord mapRecord32 = mapDb.getMapRecordByEidRecord(record32, true);
    byte cidr24 = (byte) 24;
    LispIpv4Address eid24 = new LispIpv4Address(IpAddress.valueOf("10.1.2.0"));
    LispEidRecord record24 = new LispEidRecord(cidr24, eid24);
    LispMapRecord mapRecord24 = mapDb.getMapRecordByEidRecord(record24, true);
    assertThat("Failed to fetch the RLOCs with /32 EID record", mapRecord32.getLocatorCount(), is(2));
    assertThat("Failed to fetch the RLOCs with /24 EID record", mapRecord24.getLocatorCount(), is(2));
}
#method_after
@Test
public void test24MaskRange() {
    byte cidr32 = (byte) 32;
    LispIpv4Address eid = new LispIpv4Address(IpAddress.valueOf(EID_IP_PREFIX_2_32));
    LispEidRecord record32 = new LispEidRecord(cidr32, eid);
    LispMapRecord mapRecord32 = mapDb.getMapRecordByEidRecord(record32, true);
    byte cidr24 = (byte) 24;
    LispIpv4Address eid24 = new LispIpv4Address(IpAddress.valueOf(EID_IP_PREFIX_2_24));
    LispEidRecord record24 = new LispEidRecord(cidr24, eid24);
    LispMapRecord mapRecord24 = mapDb.getMapRecordByEidRecord(record24, true);
    assertThat("Failed to fetch the RLOCs with /32 EID record", mapRecord32.getLocatorCount(), is(2));
    assertThat("Failed to fetch the RLOCs with /24 EID record", mapRecord24.getLocatorCount(), is(2));
}
#end_block

#method_before
@Test
public void test16MaskRange() {
    byte cidr32 = (byte) 32;
    LispIpv4Address eid = new LispIpv4Address(IpAddress.valueOf("10.2.1.1"));
    LispEidRecord record32 = new LispEidRecord(cidr32, eid);
    LispMapRecord mapRecord32 = mapDb.getMapRecordByEidRecord(record32, true);
    byte cidr24 = (byte) 24;
    LispIpv4Address eid24 = new LispIpv4Address(IpAddress.valueOf("10.2.1.0"));
    LispEidRecord record24 = new LispEidRecord(cidr24, eid24);
    LispMapRecord mapRecord24 = mapDb.getMapRecordByEidRecord(record24, true);
    byte cidr16 = (byte) 16;
    LispIpv4Address eid16 = new LispIpv4Address(IpAddress.valueOf("10.2.0.0"));
    LispEidRecord record16 = new LispEidRecord(cidr16, eid16);
    LispMapRecord mapRecord16 = mapDb.getMapRecordByEidRecord(record16, true);
    assertThat("Failed to fetch the RLOCs with /32 EID record", mapRecord32.getLocatorCount(), is(1));
    assertThat("Failed to fetch the RLOCs with /24 EID record", mapRecord24.getLocatorCount(), is(1));
    assertThat("Failed to fetch the RLOCs with /16 EID record", mapRecord16.getLocatorCount(), is(1));
}
#method_after
@Test
public void test16MaskRange() {
    byte cidr32 = (byte) 32;
    LispIpv4Address eid = new LispIpv4Address(IpAddress.valueOf(EID_IP_PREFIX_1_32));
    LispEidRecord record32 = new LispEidRecord(cidr32, eid);
    LispMapRecord mapRecord32 = mapDb.getMapRecordByEidRecord(record32, true);
    byte cidr24 = (byte) 24;
    LispIpv4Address eid24 = new LispIpv4Address(IpAddress.valueOf(EID_IP_PREFIX_1_24));
    LispEidRecord record24 = new LispEidRecord(cidr24, eid24);
    LispMapRecord mapRecord24 = mapDb.getMapRecordByEidRecord(record24, true);
    byte cidr16 = (byte) 16;
    LispIpv4Address eid16 = new LispIpv4Address(IpAddress.valueOf(EID_IP_PREFIX_1_16));
    LispEidRecord record16 = new LispEidRecord(cidr16, eid16);
    LispMapRecord mapRecord16 = mapDb.getMapRecordByEidRecord(record16, true);
    assertThat("Failed to fetch the RLOCs with /32 EID record", mapRecord32.getLocatorCount(), is(1));
    assertThat("Failed to fetch the RLOCs with /24 EID record", mapRecord24.getLocatorCount(), is(1));
    assertThat("Failed to fetch the RLOCs with /16 EID record", mapRecord16.getLocatorCount(), is(1));
}
#end_block

#method_before
private LispMapRecord getMapRecord() {
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    return builder1.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
}
#method_after
private LispMapRecord getMapRecord() {
    MapRecordBuilder builder1 = new DefaultMapRecordBuilder();
    LispIpv4Address ipv4Locator1 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS));
    return builder1.withRecordTtl(100).withIsAuthoritative(true).withMapVersionNumber((short) 1).withMaskLength((byte) 0x01).withAction(LispMapReplyAction.NativelyForward).withEidPrefixAfi(ipv4Locator1).build();
}
#end_block

#method_before
public Long getValue() {
    return value;
}
#method_after
public long getValue() {
    return value;
}
#end_block

#method_before
public Long getOrder() {
    return order;
}
#method_after
public long getOrder() {
    return order;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = Objects.hashCode(value);
    result = prime * result + Objects.hashCode(order);
    return result;
}
#method_after
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(value);
    return prime * result + Objects.hashCode(order);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    IntValueKey other = (IntValueKey) obj;
    if (!Objects.equals(value, other.value)) {
        return false;
    }
    if (!Objects.equals(order, other.order)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    IntValueKey other = (IntValueKey) obj;
    return Objects.equals(value, other.value) && Objects.equals(order, other.order);
}
#end_block

#method_before
public RangeValueBuilder addAugmentation(Class<? extends RangeValue> augmentationType, RangeValue augmentation) {
    if (augmentation == null) {
        return removeAugmentation(augmentationType);
    }
    if (!(this.augmentation instanceof HashMap)) {
        this.augmentation = new HashMap<>();
    }
    this.augmentation.put(augmentationType, augmentation);
    return this;
}
#method_after
public RangeValueBuilder addAugmentation(Class<? extends RangeValue> augmentationType, RangeValue augmentation) {
    if (augmentation == null) {
        return removeAugmentation(augmentationType);
    }
    this.augmentation.put(augmentationType, augmentation);
    return this;
}
#end_block

#method_before
public RangeValueBuilder removeAugmentation(Class<? extends RangeValue> augmentationType) {
    if (this.augmentation instanceof HashMap) {
        this.augmentation.remove(augmentationType);
    }
    return this;
}
#method_after
public RangeValueBuilder removeAugmentation(Class<? extends RangeValue> augmentationType) {
    augmentation.remove(augmentationType);
    return this;
}
#end_block

#method_before
@Override
public Long getMax() {
    return max;
}
#method_after
@Override
public long getMax() {
    return max;
}
#end_block

#method_before
@Override
public Long getMin() {
    return min;
}
#method_after
@Override
public long getMin() {
    return min;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = Objects.hashCode(max);
    result = prime * result + Objects.hashCode(min);
    result = prime * result + Objects.hashCode(augmentation);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(max, min, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    RangeValue other = (RangeValue) obj;
    if (!Objects.equals(max, other.getMax())) {
        return false;
    }
    if (!Objects.equals(min, other.getMin())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        // Simple case: we are comparing against self
        RangeValueImpl otherImpl = (RangeValueImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        // .. and give the other one the chance to do the same
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    RangeValueImpl o = (RangeValueImpl) obj;
    return max == o.max && min == o.min && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("max", max).add("min", min).add("augmentation", augmentation).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("max", max).add("min", min).add("augmentation", augmentation).toString();
}
#end_block

#method_before
public IntValueBuilder addAugmentation(Class<? extends IntValue> augmentationType, IntValue augmentation) {
    if (augmentation == null) {
        return removeAugmentation(augmentationType);
    }
    if (!(this.augmentation instanceof HashMap)) {
        this.augmentation = new HashMap<>();
    }
    this.augmentation.put(augmentationType, augmentation);
    return this;
}
#method_after
public IntValueBuilder addAugmentation(Class<? extends IntValue> augmentationType, IntValue augmentation) {
    if (augmentation == null) {
        return removeAugmentation(augmentationType);
    }
    this.augmentation.put(augmentationType, augmentation);
    return this;
}
#end_block

#method_before
public IntValueBuilder removeAugmentation(Class<? extends IntValue> augmentationType) {
    if (this.augmentation instanceof HashMap) {
        this.augmentation.remove(augmentationType);
    }
    return this;
}
#method_after
public IntValueBuilder removeAugmentation(Class<? extends IntValue> augmentationType) {
    augmentation.remove(augmentationType);
    return this;
}
#end_block

#method_before
@Override
public Long getOrder() {
    return order;
}
#method_after
@Override
public long getOrder() {
    return order;
}
#end_block

#method_before
@Override
public Long getValue() {
    return value;
}
#method_after
@Override
public long getValue() {
    return value;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = Objects.hashCode(key);
    result = prime * result + Objects.hashCode(order);
    result = prime * result + Objects.hashCode(value);
    result = prime * result + Objects.hashCode(augmentation);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(key, order, value, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    IntValue other = (IntValue) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(order, other.getOrder())) {
        return false;
    }
    if (!Objects.equals(value, other.getValue())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        // Simple case: we are comparing against self
        IntValueImpl otherImpl = (IntValueImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        // .. and give the other one the chance to do the same
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    IntValue other = (IntValue) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(order, other.getOrder())) {
        return false;
    }
    if (!Objects.equals(value, other.getValue())) {
        return false;
    }
    // Simple case: we are comparing against self
    IntValueImpl otherImpl = (IntValueImpl) obj;
    if (!Objects.equals(augmentation, otherImpl.augmentation)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("key", key).add("order", order).add("augmentation", augmentation).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("key", key).add("order", order).add("augmentation", augmentation).toString();
}
#end_block

#method_before
public Long getOrder() {
    return order;
}
#method_after
public long getOrder() {
    return order;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = Objects.hashCode(value);
    result = prime * result + Objects.hashCode(order);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(order, value);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StringValueKey other = (StringValueKey) obj;
    if (!Objects.equals(value, other.value)) {
        return false;
    }
    if (!Objects.equals(order, other.order)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StringValueKey other = (StringValueKey) obj;
    return Objects.equals(value, other.value) && Objects.equals(order, other.order);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("order", order).add("value", value).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("order", order).add("value", value).toString();
}
#end_block

#method_before
public StringValueBuilder addAugmentation(Class<? extends StringValue> augmentationType, StringValue augmentation) {
    if (augmentation == null) {
        return removeAugmentation(augmentationType);
    }
    if (!(this.augmentation instanceof HashMap)) {
        this.augmentation = new HashMap<>();
    }
    this.augmentation.put(augmentationType, augmentation);
    return this;
}
#method_after
public StringValueBuilder addAugmentation(Class<? extends StringValue> augmentationType, StringValue augmentation) {
    if (augmentation == null) {
        return removeAugmentation(augmentationType);
    }
    this.augmentation.put(augmentationType, augmentation);
    return this;
}
#end_block

#method_before
public StringValueBuilder removeAugmentation(Class<? extends StringValue> augmentationType) {
    if (this.augmentation instanceof HashMap) {
        this.augmentation.remove(augmentationType);
    }
    return this;
}
#method_after
public StringValueBuilder removeAugmentation(Class<? extends StringValue> augmentationType) {
    augmentation.remove(augmentationType);
    return this;
}
#end_block

#method_before
@Override
public Long getOrder() {
    return order;
}
#method_after
@Override
public long getOrder() {
    return order;
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(key);
    result = prime * result + Objects.hashCode(order);
    result = prime * result + Objects.hashCode(value);
    result = prime * result + Objects.hashCode(augmentation);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(key, order, value, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    StringValue other = (StringValue) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(order, other.getOrder())) {
        return false;
    }
    if (!Objects.equals(value, other.getValue())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        // Simple case: we are comparing against self
        StringValueImpl otherImpl = (StringValueImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        // .. and give the other one the chance to do the same
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        return false;
    }
    StringValueImpl o = (StringValueImpl) obj;
    return Objects.equals(key, o.key) && Objects.equals(order, o.order) && Objects.equals(value, o.value) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("key", key).add("order", order).add("value", value).add("augmentation", augmentation).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("key", key).add("order", order).add("value", value).add("augmentation", augmentation).toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(userId);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(userId, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    EndTransactionInput other = (EndTransactionInput) obj;
    if (!Objects.equals(userId, other.getUserId())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        EndTransactionInputImpl otherImpl = (EndTransactionInputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    EndTransactionInputImpl other = (EndTransactionInputImpl) obj;
    return Objects.equals(userId, other.getUserId()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(message);
    result = prime * result + Objects.hashCode(resultCode);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(message, resultCode, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    LanguageStyleNemoRequestOutput other = (LanguageStyleNemoRequestOutput) obj;
    if (!Objects.equals(message, other.getMessage())) {
        return false;
    }
    if (!Objects.equals(resultCode, other.getResultCode())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        LanguageStyleNemoRequestOutputImpl otherImpl = (LanguageStyleNemoRequestOutputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    LanguageStyleNemoRequestOutputImpl other = (LanguageStyleNemoRequestOutputImpl) obj;
    return Objects.equals(message, other.getMessage()) && Objects.equals(resultCode, other.getResultCode()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(nemoStatement);
    result = prime * result + Objects.hashCode(userId);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(nemoStatement, userId, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    LanguageStyleNemoRequestInput other = (LanguageStyleNemoRequestInput) obj;
    if (!Objects.equals(nemoStatement, other.getNemoStatement())) {
        return false;
    }
    if (!Objects.equals(userId, other.getUserId())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        LanguageStyleNemoRequestInputImpl otherImpl = (LanguageStyleNemoRequestInputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    LanguageStyleNemoRequestInputImpl other = (LanguageStyleNemoRequestInputImpl) obj;
    return Objects.equals(nemoStatement, other.getNemoStatement()) && Objects.equals(userId, other.getUserId()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(message);
    result = prime * result + Objects.hashCode(resultCode);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(message, resultCode, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    StructureStyleNemoUpdateOutput other = (StructureStyleNemoUpdateOutput) obj;
    if (!Objects.equals(message, other.getMessage())) {
        return false;
    }
    if (!Objects.equals(resultCode, other.getResultCode())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        StructureStyleNemoUpdateOutputImpl otherImpl = (StructureStyleNemoUpdateOutputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StructureStyleNemoUpdateOutputImpl other = (StructureStyleNemoUpdateOutputImpl) obj;
    return Objects.equals(message, other.getMessage()) && Objects.equals(resultCode, other.getResultCode()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(userId);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(userId, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    BeginTransactionInput other = (BeginTransactionInput) obj;
    if (!Objects.equals(userId, other.getUserId())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        BeginTransactionInputImpl otherImpl = (BeginTransactionInputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    BeginTransactionInputImpl other = (BeginTransactionInputImpl) obj;
    return Objects.equals(userId, other.getUserId()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(message);
    result = prime * result + Objects.hashCode(resultCode);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(message, resultCode, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    RegisterUserOutput other = (RegisterUserOutput) obj;
    if (!Objects.equals(message, other.getMessage())) {
        return false;
    }
    if (!Objects.equals(resultCode, other.getResultCode())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        RegisterUserOutputImpl otherImpl = (RegisterUserOutputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    RegisterUserOutputImpl other = (RegisterUserOutputImpl) obj;
    return Objects.equals(message, other.getMessage()) && Objects.equals(resultCode, other.getResultCode()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(message);
    result = prime * result + Objects.hashCode(resultCode);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(message, resultCode, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    BeginTransactionOutput other = (BeginTransactionOutput) obj;
    if (!Objects.equals(message, other.getMessage())) {
        return false;
    }
    if (!Objects.equals(resultCode, other.getResultCode())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        BeginTransactionOutputImpl otherImpl = (BeginTransactionOutputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    BeginTransactionOutputImpl other = (BeginTransactionOutputImpl) obj;
    return Objects.equals(message, other.getMessage()) && Objects.equals(resultCode, other.getResultCode()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(message);
    result = prime * result + Objects.hashCode(message);
    result = prime * result + Objects.hashCode(resultCode);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(message, resultCode, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    StructureStyleNemoDeleteOutput other = (StructureStyleNemoDeleteOutput) obj;
    if (!Objects.equals(message, other.getMessage())) {
        return false;
    }
    if (!Objects.equals(resultCode, other.getResultCode())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        StructureStyleNemoDeleteOutputImpl otherImpl = (StructureStyleNemoDeleteOutputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StructureStyleNemoDeleteOutputImpl other = (StructureStyleNemoDeleteOutputImpl) obj;
    return Objects.equals(message, other.getMessage()) && Objects.equals(resultCode, other.getResultCode()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    int prime = 31;
    int result = Objects.hashCode(message);
    result = prime * result + Objects.hashCode(resultCode);
    return prime * result + Objects.hashCode(augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(message, resultCode, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    EndTransactionOutput other = (EndTransactionOutput) obj;
    if (!Objects.equals(message, other.getMessage())) {
        return false;
    }
    if (!Objects.equals(resultCode, other.getResultCode())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        EndTransactionOutputImpl otherImpl = (EndTransactionOutputImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    EndTransactionOutputImpl other = (EndTransactionOutputImpl) obj;
    return Objects.equals(message, other.getMessage()) && Objects.equals(resultCode, other.getResultCode()) && Objects.equals(augmentation, other.augmentation);
}
#end_block

#method_before
@Override
public int hashCode() {
    return java.util.Objects.hash(connection, flow, node, augmentation);
}
#method_after
@Override
public int hashCode() {
    return java.util.Objects.hash(connectionIds, flowIds, nodeIds, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    ObjectsImpl o = (ObjectsImpl) obj;
    return java.util.Objects.equals(connection, o.getConnection()) && java.util.Objects.equals(flow, o.getFlow()) && java.util.Objects.equals(node, o.getNode()) && java.util.Objects.equals(augmentation, o.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    ObjectsImpl o = (ObjectsImpl) obj;
    return java.util.Objects.equals(connectionIds, o.getConnectionIds()) && java.util.Objects.equals(flowIds, o.getFlowIds()) && java.util.Objects.equals(nodeIds, o.getNodeIds()) && java.util.Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("connection", connection).add("flow", flow).add("node", node).add("augmentation", augmentation).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("connection", connectionIds).add("flow", flowIds).add("node", nodeIds).add("augmentation", augmentation).toString();
}
#end_block

#method_before
@Test
public void buildObjectsWithOperationIDlist() {
    connectionIdList = new ArrayList<>();
    flowIdList = new ArrayList<>();
    nodeIdList = new ArrayList<>();
    objects = new ObjectsBuilder().connection(connectionIdList).flow(flowIdList).node(nodeIdList).build();
    assertEquals(OBJECTS_ERROR_MSG, connectionIdList, objects.getConnection());
    assertEquals(OBJECTS_ERROR_MSG, flowIdList, objects.getFlow());
    assertEquals(OBJECTS_ERROR_MSG, nodeIdList, objects.getNode());
}
#method_after
@Test
public void buildObjectsWithOperationIDlist() {
    connectionIdList = new ArrayList<>();
    flowIdList = new ArrayList<>();
    nodeIdList = new ArrayList<>();
    objects = new ObjectsBuilder().connectionIds(connectionIdList).flowIds(flowIdList).nodeIds(nodeIdList).build();
    assertEquals(OBJECTS_ERROR_MSG, connectionIdList, objects.getConnectionIds());
    assertEquals(OBJECTS_ERROR_MSG, flowIdList, objects.getFlowIds());
    assertEquals(OBJECTS_ERROR_MSG, nodeIdList, objects.getNodeIds());
}
#end_block

#method_before
@Test
public void fromObjects() {
    connectionIdList = new ArrayList<>();
    objects = new ObjectsBuilder().connection(connectionIdList).build();
    copy = new ObjectsBuilder(objects).build();
    assertEquals(OBJECTS_ERROR_MSG, connectionIdList, copy.getConnection());
}
#method_after
@Test
public void fromObjects() {
    connectionIdList = new ArrayList<>();
    flowIdList = new ArrayList<>();
    nodeIdList = new ArrayList<>();
    objects = new ObjectsBuilder().connectionIds(connectionIdList).flowIds(flowIdList).nodeIds(nodeIdList).build();
    copy = new ObjectsBuilder(objects).build();
    assertEquals(OBJECTS_ERROR_MSG, connectionIdList, copy.getConnectionIds());
}
#end_block

#method_before
@Test
public void equality() {
    connectionIdList = new ArrayList<>();
    objects = new ObjectsBuilder().connection(connectionIdList).build();
    otherConnectionIdList = new ArrayList<>();
    otherConnectionIdList.add(null);
    otherFlowIdList = new ArrayList<>();
    otherFlowIdList.add(null);
    otherNodeIdList = new ArrayList<>();
    otherNodeIdList.add(null);
    copy = new ObjectsBuilder().connection(connectionIdList).flow(flowIdList).node(nodeIdList).build();
    diff = new ObjectsBuilder().connection(otherConnectionIdList).flow(otherFlowIdList).node(otherNodeIdList).build();
    new EqualsTester().addEqualityGroup(objects, copy).addEqualityGroup(diff).testEquals();
}
#method_after
@Test
public void equality() {
    connectionIdList = new ArrayList<>();
    flowIdList = new ArrayList<>();
    nodeIdList = new ArrayList<>();
    objects = new ObjectsBuilder().connectionIds(connectionIdList).flowIds(flowIdList).nodeIds(nodeIdList).build();
    otherConnectionIdList = new ArrayList<>();
    otherConnectionIdList.add(null);
    otherFlowIdList = new ArrayList<>();
    otherFlowIdList.add(null);
    otherNodeIdList = new ArrayList<>();
    otherNodeIdList.add(null);
    copy = new ObjectsBuilder().connectionIds(connectionIdList).flowIds(flowIdList).nodeIds(nodeIdList).build();
    diff = new ObjectsBuilder().connectionIds(otherConnectionIdList).flowIds(otherFlowIdList).nodeIds(otherNodeIdList).build();
    new EqualsTester().addEqualityGroup(objects, copy).addEqualityGroup(diff).testEquals();
}
#end_block

#method_before
@Test
public void equalityTwo() {
    connectionID = new ConnectionId(ID);
    otherconnectionID = new ConnectionId(OTHER_ID);
    connectionIdList = new ArrayList<>();
    connectionIdList.add(connectionID);
    objects = new ObjectsBuilder().connection(connectionIdList).build();
    otherConnectionIdList = new ArrayList<>();
    otherConnectionIdList.add(otherconnectionID);
    copy = new ObjectsBuilder().connection(connectionIdList).build();
    diff = new ObjectsBuilder().connection(otherConnectionIdList).build();
    new EqualsTester().addEqualityGroup(objects, copy).addEqualityGroup(diff).testEquals();
}
#method_after
@Test
public void equalityTwo() {
    connectionID = new ConnectionId(ID);
    otherconnectionID = new ConnectionId(OTHER_ID);
    connectionIdList = new ArrayList<>();
    connectionIdList.add(connectionID);
    flowIdList = new ArrayList<>();
    nodeIdList = new ArrayList<>();
    objects = new ObjectsBuilder().connectionIds(connectionIdList).flowIds(flowIdList).nodeIds(nodeIdList).build();
    otherConnectionIdList = new ArrayList<>();
    otherConnectionIdList.add(otherconnectionID);
    copy = new ObjectsBuilder().connectionIds(connectionIdList).flowIds(flowIdList).nodeIds(nodeIdList).build();
    diff = new ObjectsBuilder().connectionIds(otherConnectionIdList).flowIds(flowIdList).nodeIds(nodeIdList).build();
    new EqualsTester().addEqualityGroup(objects, copy).addEqualityGroup(diff).testEquals();
}
#end_block

#method_before
@Test
public void buildOperationsWithOperationIDlist() {
    operationIdList = new ArrayList<>();
    operations = new OperationsBuilder().operation(operationIdList).build();
    assertEquals(OPERATIONS_ERROR_MSG, operationIdList, operations.getOperation());
}
#method_after
@Test
public void buildOperationsWithOperationIDlist() {
    operationIdList = new ArrayList<>();
    operations = new OperationsBuilder().operationIds(operationIdList).build();
    assertEquals(OPERATIONS_ERROR_MSG, operationIdList, operations.getOperationIds());
}
#end_block

#method_before
@Test
public void fromOperations() {
    operationIdList = new ArrayList<>();
    operations = new OperationsBuilder().operation(operationIdList).build();
    copy = new OperationsBuilder(operations).build();
    assertEquals(OPERATIONS_ERROR_MSG, operationIdList, copy.getOperation());
}
#method_after
@Test
public void fromOperations() {
    operationIdList = new ArrayList<>();
    operations = new OperationsBuilder().operationIds(operationIdList).build();
    copy = new OperationsBuilder(operations).build();
    assertEquals(OPERATIONS_ERROR_MSG, operationIdList, copy.getOperationIds());
}
#end_block

#method_before
@Test
public void equality() {
    operationIdList = new ArrayList<>();
    operations = new OperationsBuilder().operation(operationIdList).build();
    otherList = new ArrayList<>();
    otherList.add(null);
    copy = new OperationsBuilder().operation(operationIdList).build();
    diff = new OperationsBuilder().operation(otherList).build();
    new EqualsTester().addEqualityGroup(operations, copy).addEqualityGroup(diff).testEquals();
}
#method_after
@Test
public void equality() {
    operationIdList = new ArrayList<>();
    operations = new OperationsBuilder().operationIds(operationIdList).build();
    otherList = new ArrayList<>();
    otherList.add(null);
    copy = new OperationsBuilder().operationIds(operationIdList).build();
    diff = new OperationsBuilder().operationIds(otherList).build();
    new EqualsTester().addEqualityGroup(operations, copy).addEqualityGroup(diff).testEquals();
}
#end_block

#method_before
@Test
public void equalityTwo() {
    operationID = new OperationId(ID);
    otheroperationID = new OperationId(OTHER_ID);
    operationIdList = new ArrayList<>();
    operationIdList.add(operationID);
    operations = new OperationsBuilder().operation(operationIdList).build();
    otherList = new ArrayList<>();
    otherList.add(otheroperationID);
    copy = new OperationsBuilder().operation(operationIdList).build();
    diff = new OperationsBuilder().operation(otherList).build();
    new EqualsTester().addEqualityGroup(operations, copy).addEqualityGroup(diff).testEquals();
}
#method_after
@Test
public void equalityTwo() {
    operationID = new OperationId(ID);
    otheroperationID = new OperationId(OTHER_ID);
    operationIdList = new ArrayList<>();
    operationIdList.add(operationID);
    operations = new OperationsBuilder().operationIds(operationIdList).build();
    otherList = new ArrayList<>();
    otherList.add(otheroperationID);
    copy = new OperationsBuilder().operationIds(operationIdList).build();
    diff = new OperationsBuilder().operationIds(otherList).build();
    new EqualsTester().addEqualityGroup(operations, copy).addEqualityGroup(diff).testEquals();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(operation, augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(operationIds, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    OperationsImpl o = (OperationsImpl) obj;
    return Objects.equals(operation, o.getOperation()) && Objects.equals(augmentation, o.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    OperationsImpl o = (OperationsImpl) obj;
    return Objects.equals(operationIds, o.getOperationIds()) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("operation", operation).add("augmentation", augmentation).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("operation", operationIds).add("augmentation", augmentation).toString();
}
#end_block

#method_before
@Test
public void testGetBit() {
    byte one = 1;
    assertThat(ByteOperator.getBit(one, 0), is(true));
    assertThat(ByteOperator.getBit(one, 1), is(false));
    assertThat(ByteOperator.getBit(one, 2), is(false));
    assertThat(ByteOperator.getBit(one, 3), is(false));
    assertThat(ByteOperator.getBit(one, 4), is(false));
    assertThat(ByteOperator.getBit(one, 5), is(false));
    assertThat(ByteOperator.getBit(one, 6), is(false));
    assertThat(ByteOperator.getBit(one, 7), is(false));
    byte two = 2;
    assertThat(ByteOperator.getBit(two, 0), is(false));
    assertThat(ByteOperator.getBit(two, 1), is(true));
    assertThat(ByteOperator.getBit(two, 2), is(false));
    assertThat(ByteOperator.getBit(two, 3), is(false));
    assertThat(ByteOperator.getBit(two, 4), is(false));
    assertThat(ByteOperator.getBit(two, 5), is(false));
    assertThat(ByteOperator.getBit(two, 6), is(false));
    assertThat(ByteOperator.getBit(two, 7), is(false));
    byte four = 4;
    assertThat(ByteOperator.getBit(four, 0), is(false));
    assertThat(ByteOperator.getBit(four, 1), is(false));
    assertThat(ByteOperator.getBit(four, 2), is(true));
    assertThat(ByteOperator.getBit(four, 3), is(false));
    assertThat(ByteOperator.getBit(four, 4), is(false));
    assertThat(ByteOperator.getBit(four, 5), is(false));
    assertThat(ByteOperator.getBit(four, 6), is(false));
    assertThat(ByteOperator.getBit(four, 7), is(false));
    byte eight = 8;
    assertThat(ByteOperator.getBit(eight, 0), is(false));
    assertThat(ByteOperator.getBit(eight, 1), is(false));
    assertThat(ByteOperator.getBit(eight, 2), is(false));
    assertThat(ByteOperator.getBit(eight, 3), is(true));
    assertThat(ByteOperator.getBit(eight, 4), is(false));
    assertThat(ByteOperator.getBit(eight, 5), is(false));
    assertThat(ByteOperator.getBit(eight, 6), is(false));
    assertThat(ByteOperator.getBit(eight, 7), is(false));
    byte sixteen = 16;
    assertThat(ByteOperator.getBit(sixteen, 0), is(false));
    assertThat(ByteOperator.getBit(sixteen, 1), is(false));
    assertThat(ByteOperator.getBit(sixteen, 2), is(false));
    assertThat(ByteOperator.getBit(sixteen, 3), is(false));
    assertThat(ByteOperator.getBit(sixteen, 4), is(true));
    assertThat(ByteOperator.getBit(sixteen, 5), is(false));
    assertThat(ByteOperator.getBit(sixteen, 6), is(false));
    assertThat(ByteOperator.getBit(sixteen, 7), is(false));
    byte thirtytwo = 32;
    assertThat(ByteOperator.getBit(thirtytwo, 0), is(false));
    assertThat(ByteOperator.getBit(thirtytwo, 1), is(false));
    assertThat(ByteOperator.getBit(thirtytwo, 2), is(false));
    assertThat(ByteOperator.getBit(thirtytwo, 3), is(false));
    assertThat(ByteOperator.getBit(thirtytwo, 4), is(false));
    assertThat(ByteOperator.getBit(thirtytwo, 5), is(true));
    assertThat(ByteOperator.getBit(thirtytwo, 6), is(false));
    assertThat(ByteOperator.getBit(thirtytwo, 7), is(false));
    byte sixtyfour = 64;
    assertThat(ByteOperator.getBit(sixtyfour, 0), is(false));
    assertThat(ByteOperator.getBit(sixtyfour, 1), is(false));
    assertThat(ByteOperator.getBit(sixtyfour, 2), is(false));
    assertThat(ByteOperator.getBit(sixtyfour, 3), is(false));
    assertThat(ByteOperator.getBit(sixtyfour, 4), is(false));
    assertThat(ByteOperator.getBit(sixtyfour, 5), is(false));
    assertThat(ByteOperator.getBit(sixtyfour, 6), is(true));
    assertThat(ByteOperator.getBit(sixtyfour, 7), is(false));
    byte minus = -128;
    assertThat(ByteOperator.getBit(minus, 0), is(false));
    assertThat(ByteOperator.getBit(minus, 1), is(false));
    assertThat(ByteOperator.getBit(minus, 2), is(false));
    assertThat(ByteOperator.getBit(minus, 3), is(false));
    assertThat(ByteOperator.getBit(minus, 4), is(false));
    assertThat(ByteOperator.getBit(minus, 5), is(false));
    assertThat(ByteOperator.getBit(minus, 6), is(false));
    assertThat(ByteOperator.getBit(minus, 7), is(true));
}
#method_after
@Test
public void testGetBit() {
    final byte[] number = new byte[] { 1, 2, 4, 8, 16, 32, 64, -128 };
    for (int i = 0; i < number.length; i++) {
        for (int j = 0; j < 8; j++) {
            assertThat(ByteOperator.getBit(number[i], j), is(i == j));
        }
    }
}
#end_block

#method_before
public static boolean getBit(byte value, int index) {
    // the length of byte should always be positive whiles less than 8
    if (index > 7 || index < 0) {
        return false;
    }
    final BitSet set = BitSet.valueOf(new byte[] { value });
    return set.get(index);
}
#method_after
public static boolean getBit(byte value, int index) {
    // the length of byte should always be positive whiles less than 8
    if (index > 7 || index < 0) {
        return false;
    }
    return (value & (0x1 << index)) != 0;
}
#end_block

#method_before
private List<GroupInfo> prepareL2InterfaceGroup(NextObjective nextObj, VlanId assignedVlan) {
    ImmutableList.Builder<GroupInfo> groupInfoBuilder = ImmutableList.builder();
    // break up broadcast next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    // each treatment is converted to an L2 interface group
    for (TrafficTreatment treatment : buckets) {
        TrafficTreatment.Builder newTreatment = DefaultTrafficTreatment.builder();
        PortNumber portNum = null;
        VlanId egressVlan = null;
        // ensure that the only allowed treatments are pop-vlan and output
        for (Instruction ins : treatment.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                switch(l2ins.subtype()) {
                    case VLAN_POP:
                        newTreatment.add(l2ins);
                        break;
                    case VLAN_ID:
                        egressVlan = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                        break;
                    default:
                        log.debug("action {} not permitted for broadcast nextObj", l2ins.subtype());
                        break;
                }
            } else if (ins.type() == Instruction.Type.OUTPUT) {
                portNum = ((Instructions.OutputInstruction) ins).port();
                newTreatment.add(ins);
            } else {
                log.debug("TrafficTreatment of type {} not permitted in " + " broadcast nextObjective", ins.type());
            }
        }
        // assemble info for l2 interface group
        VlanId l2InterfaceGroupVlan = (egressVlan != null && !assignedVlan.equals(egressVlan)) ? egressVlan : assignedVlan;
        int l2gk = l2InterfaceGroupKey(deviceId, l2InterfaceGroupVlan, portNum.toLong());
        final GroupKey l2InterfaceGroupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l2gk));
        int l2InterfaceGroupId = L2_INTERFACE_TYPE | ((l2InterfaceGroupVlan.toShort() & THREE_BIT_MASK) << 16) | ((int) portNum.toLong() & FOUR_BIT_MASK);
        GroupBucket l2InterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(newTreatment.build());
        GroupDescription l2InterfaceGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2InterfaceGroupBucket)), l2InterfaceGroupKey, l2InterfaceGroupId, nextObj.appId());
        log.debug("Trying L2-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2InterfaceGroupId), l2InterfaceGroupKey, nextObj.id());
        groupInfoBuilder.add(new GroupInfo(l2InterfaceGroupDescription, l2InterfaceGroupDescription));
    }
    return groupInfoBuilder.build();
}
#method_after
private List<GroupInfo> prepareL2InterfaceGroup(NextObjective nextObj, VlanId assignedVlan) {
    ImmutableList.Builder<GroupInfo> groupInfoBuilder = ImmutableList.builder();
    // break up broadcast next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    // each treatment is converted to an L2 interface group
    for (TrafficTreatment treatment : buckets) {
        TrafficTreatment.Builder newTreatment = DefaultTrafficTreatment.builder();
        PortNumber portNum = null;
        VlanId egressVlan = null;
        // ensure that the only allowed treatments are pop-vlan and output
        for (Instruction ins : treatment.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                switch(l2ins.subtype()) {
                    case VLAN_POP:
                        newTreatment.add(l2ins);
                        break;
                    case VLAN_ID:
                        egressVlan = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                        break;
                    default:
                        log.debug("action {} not permitted for broadcast nextObj", l2ins.subtype());
                        break;
                }
            } else if (ins.type() == Instruction.Type.OUTPUT) {
                portNum = ((Instructions.OutputInstruction) ins).port();
                newTreatment.add(ins);
            } else {
                log.debug("TrafficTreatment of type {} not permitted in " + " broadcast nextObjective", ins.type());
            }
        }
        // assemble info for l2 interface group
        VlanId l2InterfaceGroupVlan = (egressVlan != null && !assignedVlan.equals(egressVlan)) ? egressVlan : assignedVlan;
        int l2gk = l2InterfaceGroupKey(deviceId, l2InterfaceGroupVlan, portNum.toLong());
        final GroupKey l2InterfaceGroupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l2gk));
        int l2InterfaceGroupId = L2_INTERFACE_TYPE | ((l2InterfaceGroupVlan.toShort() & THREE_BIT_MASK) << PORT_LEN) | ((int) portNum.toLong() & FOUR_BIT_MASK);
        GroupBucket l2InterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(newTreatment.build());
        GroupDescription l2InterfaceGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2InterfaceGroupBucket)), l2InterfaceGroupKey, l2InterfaceGroupId, nextObj.appId());
        log.debug("Trying L2-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2InterfaceGroupId), l2InterfaceGroupKey, nextObj.id());
        groupInfoBuilder.add(new GroupInfo(l2InterfaceGroupDescription, l2InterfaceGroupDescription));
    }
    return groupInfoBuilder.build();
}
#end_block

#method_before
@Before
public void setup() {
    NonceAddressBuilder builder1 = new NonceAddressBuilder();
    LispIpv4Address ipv4Address1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    address1 = builder1.withNonce(1048576).withAddress(ipv4Address1).build();
    NonceAddressBuilder builder2 = new NonceAddressBuilder();
    sameAsAddress1 = builder2.withNonce(1048576).withAddress(ipv4Address1).build();
    NonceAddressBuilder builder3 = new NonceAddressBuilder();
    LispIpv4Address ipv4Address2 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    address2 = builder3.withNonce(1).withAddress(ipv4Address2).build();
}
#method_after
@Before
public void setup() {
    NonceAddressBuilder builder1 = new NonceAddressBuilder();
    LispIpv4Address ipv4Address1 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_1));
    address1 = builder1.withNonce(NONCE_1).withAddress(ipv4Address1).build();
    NonceAddressBuilder builder2 = new NonceAddressBuilder();
    sameAsAddress1 = builder2.withNonce(NONCE_1).withAddress(ipv4Address1).build();
    NonceAddressBuilder builder3 = new NonceAddressBuilder();
    LispIpv4Address ipv4Address2 = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_2));
    address2 = builder3.withNonce(NONCE_2).withAddress(ipv4Address2).build();
}
#end_block

#method_before
@Test
public void testConstruction() {
    LispNonceLcafAddress nonceLcafAddress = address1;
    LispIpv4Address ipv4Address = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    assertThat(nonceLcafAddress.getNonce(), is(1048576));
    assertThat(nonceLcafAddress.getAddress(), is(ipv4Address));
}
#method_after
@Test
public void testConstruction() {
    LispNonceLcafAddress nonceLcafAddress = address1;
    LispIpv4Address ipv4Address = new LispIpv4Address(IpAddress.valueOf(IP_ADDRESS_1));
    assertThat(nonceLcafAddress.getNonce(), is(NONCE_1));
    assertThat(nonceLcafAddress.getAddress(), is(ipv4Address));
}
#end_block

#method_before
protected void sendForward(ForwardingObjective fwd, Collection<FlowRule> rules) {
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::add);
            log.debug("Applying a add fwd-obj {} to sw:{}", fwd.id(), deviceId);
            break;
        case REMOVE:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::remove);
            log.info("Deleting a flow rule to sw:{}", deviceId);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
protected void sendForward(ForwardingObjective fwd, Collection<FlowRule> rules) {
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::add);
            log.debug("Applying a add fwd-obj {} to sw:{}", fwd.id(), deviceId);
            break;
        case REMOVE:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::remove);
            log.debug("Deleting a flow rule to sw:{}", deviceId);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
protected List<FlowRule> processVlanIdFilterInternal(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId, boolean useSetVlanExtension) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (useSetVlanExtension) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        } else {
            treatment.setVlanId(assignedVlan);
        }
        preSelector = DefaultTrafficSelector.builder();
        OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
        preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processVlanIdFilterInternal(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId, boolean useSetVlanExtension) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (useSetVlanExtension) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        } else {
            treatment.setVlanId(assignedVlan);
        }
        preSelector = DefaultTrafficSelector.builder();
        OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
        preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            if (useSetVlanExtension) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
                treatment.extension(ofdpaSetVlanVid, deviceId);
            } else {
                treatment.setVlanId(assignedVlan);
            }
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        if (buildIpv4Selector(filteredSelector, complementarySelector, fwd, allowDefaultRoute) < 0) {
            return Collections.emptyList();
        }
        // We need to set properly the next table
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            forTableId = MULTICAST_ROUTING_TABLE;
        } else {
            forTableId = UNICAST_ROUTING_TABLE;
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                    // setting the MPLS_TYPE so pop can happen down the pipeline
                    if (mplsNextTable == MPLS_TYPE_TABLE && bos != null && !bos.mplsBos()) {
                        tb.immediate().popMpls();
                    }
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a MPLS interface,
            // or a MPLS SWAP (with-same) but that would have to be handled in the next-objective.
            // Also the pop-mpls logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
            if (bos != null && !bos.mplsBos() && group.type().equals(HASHED)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (!allowDefaultRoute) {
        flowRuleCollection.add(defaultRoute(fwd, complementarySelector, forTableId, tb));
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#method_after
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        if (buildIpv4Selector(filteredSelector, complementarySelector, fwd, allowDefaultRoute) < 0) {
            return Collections.emptyList();
        }
        // We need to set properly the next table
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            forTableId = MULTICAST_ROUTING_TABLE;
        } else {
            forTableId = UNICAST_ROUTING_TABLE;
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                    // setting the MPLS_TYPE so pop can happen down the pipeline
                    if (mplsNextTable == MPLS_TYPE_TABLE && bos != null && !bos.mplsBos()) {
                        tb.immediate().popMpls();
                    }
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a MPLS interface,
            // or a MPLS SWAP (with-same) but that would have to be handled in the next-objective.
            // Also the pop-mpls logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (isNotMplsBos(selector) && group.type().equals(HASHED)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (!allowDefaultRoute) {
        flowRuleCollection.add(defaultRoute(fwd, complementarySelector, forTableId, tb));
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    MplsBosCriterion bosCriterion = (MplsBosCriterion) fwd.selector().getCriterion(MPLS_BOS);
    if (bosCriterion != null && !bosCriterion.mplsBos()) {
        return processEthTypeSpecificInternal(fwd, true, MPLS_TYPE_TABLE);
    }
    return processEthTypeSpecificInternal(fwd, true, MPLS_L3_TYPE_TABLE);
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    if (isNotMplsBos(fwd.selector())) {
        return processEthTypeSpecificInternal(fwd, true, MPLS_TYPE_TABLE);
    }
    return processEthTypeSpecificInternal(fwd, true, MPLS_L3_TYPE_TABLE);
}
#end_block

#method_before
private Collection<FlowRule> processTermPwVersatile(ForwardingObjective forwardingObjective, ModTunnelIdInstruction modTunnelIdInstruction, OutputInstruction outputInstruction) {
    TrafficTreatment.Builder flowTreatment;
    TrafficSelector.Builder flowSelector;
    // We divide the mpls actions from the tunnel actions. We need
    // this to order the actions in the final treatment.
    TrafficTreatment.Builder mplsTreatment = DefaultTrafficTreatment.builder();
    createMplsTreatment(forwardingObjective.treatment(), mplsTreatment);
    // The match of the forwarding objective is ready to go.
    flowSelector = DefaultTrafficSelector.builder(forwardingObjective.selector());
    // We verify the tunnel id and mpls port are correct.
    long tunnelId = MPLS_TUNNEL_ID_BASE | modTunnelIdInstruction.tunnelId();
    if (tunnelId > MPLS_TUNNEL_ID_MAX) {
        log.error("Pw Versatile Forwarding Objective must include tunnel id < {}", MPLS_TUNNEL_ID_MAX);
        fail(forwardingObjective, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    // 0x0002XXXX is NNI interface.
    int mplsLogicalPort = ((int) outputInstruction.port().toLong()) | MPLS_NNI_PORT_BASE;
    if (mplsLogicalPort > MPLS_NNI_PORT_MAX) {
        log.error("Pw Versatile Forwarding Objective invalid logical port {}", mplsLogicalPort);
        fail(forwardingObjective, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    // Next id cannot be null.
    if (forwardingObjective.nextId() == null) {
        log.error("Pw Versatile Forwarding Objective must contain nextId ", forwardingObjective.nextId());
        fail(forwardingObjective, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    // We retrieve the l2 interface group and point the mpls
    // flow to this.
    NextGroup next = getGroupForNextObjective(forwardingObjective.nextId());
    if (next == null) {
        log.warn("next-id:{} not found in dev:{}", forwardingObjective.nextId(), deviceId);
        fail(forwardingObjective, ObjectiveError.GROUPMISSING);
        return Collections.emptySet();
    }
    List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
    Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
    if (group == null) {
        log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), forwardingObjective.nextId(), deviceId);
        fail(forwardingObjective, ObjectiveError.GROUPMISSING);
        return Collections.emptySet();
    }
    // We prepare the treatment for the mpls flow table.
    // The order of the actions has to be strictly this
    // according to the OFDPA 2.0 specification.
    flowTreatment = DefaultTrafficTreatment.builder(mplsTreatment.build());
    flowTreatment.extension(new Ofdpa3PopCw(), deviceId);
    // Even though the specification and the xml/json files
    // specify is allowed, the switch rejects the flow. In the
    // previous version was necessary
    // flowTreatment.popVlan();
    flowTreatment.extension(new Ofdpa3PopL2Header(), deviceId);
    flowTreatment.setTunnelId(tunnelId);
    flowTreatment.extension(new Ofdpa3SetMplsL2Port(mplsLogicalPort), deviceId);
    flowTreatment.extension(new Ofdpa3SetMplsType(VPWS), deviceId);
    flowTreatment.transition(MPLS_TYPE_TABLE);
    flowTreatment.deferred().group(group.id());
    // We prepare the flow rule for the mpls table.
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(forwardingObjective.appId()).withPriority(forwardingObjective.priority()).forDevice(deviceId).withSelector(flowSelector.build()).withTreatment(flowTreatment.build()).makePermanent().forTable(MPLS_TABLE_1);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
private Collection<FlowRule> processTermPwVersatile(ForwardingObjective forwardingObjective, ModTunnelIdInstruction modTunnelIdInstruction, OutputInstruction outputInstruction) {
    TrafficTreatment.Builder flowTreatment;
    TrafficSelector.Builder flowSelector;
    // We divide the mpls actions from the tunnel actions. We need
    // this to order the actions in the final treatment.
    TrafficTreatment.Builder mplsTreatment = DefaultTrafficTreatment.builder();
    createMplsTreatment(forwardingObjective.treatment(), mplsTreatment);
    // The match of the forwarding objective is ready to go.
    flowSelector = DefaultTrafficSelector.builder(forwardingObjective.selector());
    // We verify the tunnel id and mpls port are correct.
    long tunnelId = MPLS_TUNNEL_ID_BASE | modTunnelIdInstruction.tunnelId();
    if (tunnelId > MPLS_TUNNEL_ID_MAX) {
        log.error("Pw Versatile Forwarding Objective must include tunnel id < {}", MPLS_TUNNEL_ID_MAX);
        fail(forwardingObjective, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    // 0x0002XXXX is NNI interface.
    int mplsLogicalPort = ((int) outputInstruction.port().toLong()) | MPLS_NNI_PORT_BASE;
    if (mplsLogicalPort > MPLS_NNI_PORT_MAX) {
        log.error("Pw Versatile Forwarding Objective invalid logical port {}", mplsLogicalPort);
        fail(forwardingObjective, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    // Next id cannot be null.
    if (forwardingObjective.nextId() == null) {
        log.error("Pw Versatile Forwarding Objective must contain nextId ", forwardingObjective.nextId());
        fail(forwardingObjective, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    // We retrieve the l2 interface group and point the mpls
    // flow to this.
    NextGroup next = getGroupForNextObjective(forwardingObjective.nextId());
    if (next == null) {
        log.warn("next-id:{} not found in dev:{}", forwardingObjective.nextId(), deviceId);
        fail(forwardingObjective, ObjectiveError.GROUPMISSING);
        return Collections.emptySet();
    }
    List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
    Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
    if (group == null) {
        log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), forwardingObjective.nextId(), deviceId);
        fail(forwardingObjective, ObjectiveError.GROUPMISSING);
        return Collections.emptySet();
    }
    // We prepare the treatment for the mpls flow table.
    // The order of the actions has to be strictly this
    // according to the OFDPA 2.0 specification.
    flowTreatment = DefaultTrafficTreatment.builder(mplsTreatment.build());
    flowTreatment.extension(new Ofdpa3PopCw(), deviceId);
    // Even though the specification and the xml/json files
    // specify is allowed, the switch rejects the flow. In the
    // version 2.0 the pop vlan was necessary and not accepted.
    // flowTreatment.popVlan();
    flowTreatment.extension(new Ofdpa3PopL2Header(), deviceId);
    flowTreatment.setTunnelId(tunnelId);
    flowTreatment.extension(new Ofdpa3SetMplsL2Port(mplsLogicalPort), deviceId);
    flowTreatment.extension(new Ofdpa3SetMplsType(VPWS), deviceId);
    flowTreatment.transition(MPLS_TYPE_TABLE);
    flowTreatment.deferred().group(group.id());
    // We prepare the flow rule for the mpls table.
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(forwardingObjective.appId()).withPriority(forwardingObjective.priority()).forDevice(deviceId).withSelector(flowSelector.build()).withTreatment(flowTreatment.build()).makePermanent().forTable(MPLS_TABLE_1);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    MplsBosCriterion bosCriterion = (MplsBosCriterion) fwd.selector().getCriterion(MPLS_BOS);
    if (bosCriterion != null && !bosCriterion.mplsBos()) {
        return processEthTypeSpecificInternal(fwd, true, MPLS_TYPE_TABLE);
    }
    return processEthTypeSpecificInternal(fwd, true, MPLS_L3_TYPE_TABLE);
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    if (isNotMplsBos(fwd.selector())) {
        return processEthTypeSpecificInternal(fwd, true, MPLS_TYPE_TABLE);
    }
    return processEthTypeSpecificInternal(fwd, true, MPLS_L3_TYPE_TABLE);
}
#end_block

#method_before
protected void sendForward(ForwardingObjective fwd, Collection<FlowRule> rules) {
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::add);
            log.debug("Applying a add fwd-obj {} to sw:{}", fwd.id(), deviceId);
            break;
        case REMOVE:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::remove);
            log.info("Deleting a flow rule to sw:{}", deviceId);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
protected void sendForward(ForwardingObjective fwd, Collection<FlowRule> rules) {
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::add);
            log.debug("Applying a add fwd-obj {} to sw:{}", fwd.id(), deviceId);
            break;
        case REMOVE:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::remove);
            log.debug("Deleting a flow rule to sw:{}", deviceId);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
protected List<FlowRule> processVlanIdFilterInternal(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId, boolean useSetVlanExtension) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (useSetVlanExtension) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        } else {
            treatment.setVlanId(assignedVlan);
        }
        preSelector = DefaultTrafficSelector.builder();
        OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
        preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processVlanIdFilterInternal(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId, boolean useSetVlanExtension) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (useSetVlanExtension) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        } else {
            treatment.setVlanId(assignedVlan);
        }
        preSelector = DefaultTrafficSelector.builder();
        OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
        preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            if (useSetVlanExtension) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
                treatment.extension(ofdpaSetVlanVid, deviceId);
            } else {
                treatment.setVlanId(assignedVlan);
            }
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            filteredSelector.extension(ofdpaMatchVlanVid, deviceId);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    /*
                         * NOTE: The switch does not support matching 0.0.0.0/0
                         * Split it into 0.0.0.0/1 and 128.0.0.0/1
                         */
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                // OF-DPA does not pop in MPLS table. Instead it requires
                // setting the MPLS_TYPE so pop can happen down the pipeline
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
            if (bos != null && !bos.mplsBos() && group.type().equals(HASHED)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#method_after
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            filteredSelector.extension(ofdpaMatchVlanVid, deviceId);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    /*
                         * NOTE: The switch does not support matching 0.0.0.0/0
                         * Split it into 0.0.0.0/1 and 128.0.0.0/1
                         */
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                // OF-DPA does not pop in MPLS table. Instead it requires
                // setting the MPLS_TYPE so pop can happen down the pipeline
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (isNotMplsBos(selector) && group.type().equals(HASHED)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#end_block

#method_before
protected void sendForward(ForwardingObjective fwd, Collection<FlowRule> rules) {
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::add);
            log.debug("Applying a add fwd-obj {} to sw:{}", fwd.id(), deviceId);
            break;
        case REMOVE:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::remove);
            log.info("Deleting a flow rule to sw:{}", deviceId);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
protected void sendForward(ForwardingObjective fwd, Collection<FlowRule> rules) {
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::add);
            log.debug("Applying a add fwd-obj {} to sw:{}", fwd.id(), deviceId);
            break;
        case REMOVE:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::remove);
            log.debug("Deleting a flow rule to sw:{}", deviceId);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
protected List<FlowRule> processVlanIdFilterInternal(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId, boolean useSetVlanExtension) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (useSetVlanExtension) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        } else {
            treatment.setVlanId(assignedVlan);
        }
        preSelector = DefaultTrafficSelector.builder();
        OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
        preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processVlanIdFilterInternal(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId, boolean useSetVlanExtension) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (useSetVlanExtension) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        } else {
            treatment.setVlanId(assignedVlan);
        }
        preSelector = DefaultTrafficSelector.builder();
        OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
        preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            if (useSetVlanExtension) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
                treatment.extension(ofdpaSetVlanVid, deviceId);
            } else {
                treatment.setVlanId(assignedVlan);
            }
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            filteredSelector.extension(ofdpaMatchVlanVid, deviceId);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    /*
                         * NOTE: The switch does not support matching 0.0.0.0/0
                         * Split it into 0.0.0.0/1 and 128.0.0.0/1
                         */
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                // OF-DPA does not pop in MPLS table. Instead it requires
                // setting the MPLS_TYPE so pop can happen down the pipeline
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
            if (bos != null && !bos.mplsBos() && group.type().equals(HASHED)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#method_after
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            filteredSelector.extension(ofdpaMatchVlanVid, deviceId);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    /*
                         * NOTE: The switch does not support matching 0.0.0.0/0
                         * Split it into 0.0.0.0/1 and 128.0.0.0/1
                         */
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                // OF-DPA does not pop in MPLS table. Instead it requires
                // setting the MPLS_TYPE so pop can happen down the pipeline
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (isNotMplsBos(selector) && group.type().equals(HASHED)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(vpwsConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    // Request ARP packet-in
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.requestPackets(selector.build(), PacketPriority.CONTROL, appId, Optional.empty());
    cfgListener.configureNetwork();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    // Request ARP packet-in
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.requestPackets(selector.build(), PacketPriority.CONTROL, appId, Optional.empty());
    cfgListener.configureNetwork();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(vpwsConfigFactory);
    // Withdraw ARP packet-in
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId, Optional.empty());
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    cordConfigService.removeListener(cordConfigListener);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    nsNextObjStore.destroy();
    subnetNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    subnetVidStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(pwaasConfigFactory);
    // Withdraw ARP packet-in
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId, Optional.empty());
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    cordConfigService.removeListener(cordConfigListener);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    nsNextObjStore.destroy();
    subnetNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    subnetVidStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(VpwsConfig.class)) {
        checkState(l2TunnelHandler != null, "L2TunnelHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                l2TunnelHandler.processPWaaSConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                l2TunnelHandler.processPWaaSConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                l2TunnelHandler.processPWaaSConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(PwaasConfig.class)) {
        checkState(l2TunnelHandler != null, "L2TunnelHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                l2TunnelHandler.processPwaasConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                l2TunnelHandler.processPwaasConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                l2TunnelHandler.processPwaasConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void processPwNextObjective(NextObjective nextObjective) {
    TrafficTreatment treatment = nextObjective.next().iterator().next();
    Deque<GroupKey> gkeyChain = new ArrayDeque<>();
    GroupChainElem groupChainElem;
    GroupKey groupKey;
    GroupDescription groupDescription;
    // Now we separate the mpls actions from the l2/l3 actions
    TrafficTreatment.Builder l2L3Treatment = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder mplsTreatment = DefaultTrafficTreatment.builder();
    createL2L3AndMplsTreatments(treatment, l2L3Treatment, mplsTreatment);
    // We create the chain from mpls intf group to
    // l2 intf group.
    GroupInfo groupInfo = createL2L3ChainInternal(l2L3Treatment.build(), nextObjective.id(), nextObjective.appId(), true, nextObjective.meta(), false);
    if (groupInfo == null) {
        log.error("Could not process nextObj={} in dev:{}", nextObjective.id(), deviceId);
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.GROUPINSTALLATIONFAILED);
        return;
    }
    // We update the chain with the last two groups;
    gkeyChain.addFirst(groupInfo.getInnerMostGroupDesc().appCookie());
    gkeyChain.addFirst(groupInfo.getNextGroupDesc().appCookie());
    // We retrieve also all mpls instructions.
    List<List<Instruction>> mplsInstructionSets = Lists.newArrayList();
    List<Instruction> mplsInstructionSet = Lists.newArrayList();
    L3ModificationInstruction l3Ins;
    for (Instruction ins : treatment.allInstructions()) {
        // Each mpls instruction set is delimited by a
        // copy ttl outward action.
        mplsInstructionSet.add(ins);
        if (ins.type() == Instruction.Type.L3MODIFICATION) {
            l3Ins = (L3ModificationInstruction) ins;
            if (l3Ins.subtype() == TTL_OUT) {
                mplsInstructionSets.add(mplsInstructionSet);
                mplsInstructionSet = Lists.newArrayList();
            }
        }
    }
    if (mplsInstructionSets.size() > 3) {
        log.error("Next Objective for pseudo wire should have at " + "most {} mpls instruction sets. Next Objective Id:{}", mplsInstructionSets.size(), nextObjective.id());
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    int nextGid = groupInfo.getNextGroupDesc().givenGroupId();
    int index;
    // tunnel label group 2;
    if (mplsInstructionSets.size() == 3) {
        // We deal with the label 2 group.
        index = getNextAvailableIndex();
        groupDescription = createMplsTunnelLabelGroup(nextGid, MPLS_TUNNEL_LABEL_2, index, mplsInstructionSets.get(2), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        // We update the chain.
        groupChainElem = new GroupChainElem(groupDescription, 1, false);
        updatePendingGroups(groupInfo.getNextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        // We have to create tunnel label group and
        // l2 vpn group before to send the inner most
        // group. We update the nextGid.
        nextGid = groupDescription.givenGroupId();
        groupInfo = new GroupInfo(groupInfo.getInnerMostGroupDesc(), groupDescription);
        log.debug("Trying Label 2 Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
    }
    // We deal with the label 1 group.
    index = getNextAvailableIndex();
    groupDescription = createMplsTunnelLabelGroup(nextGid, MPLS_TUNNEL_LABEL_1, index, mplsInstructionSets.get(1), nextObjective.appId());
    groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
    groupChainElem = new GroupChainElem(groupDescription, 1, false);
    updatePendingGroups(groupInfo.getNextGroupDesc().appCookie(), groupChainElem);
    gkeyChain.addFirst(groupKey);
    // We have to create the l2 vpn group before
    // to send the inner most group.
    nextGid = groupDescription.givenGroupId();
    groupInfo = new GroupInfo(groupInfo.getInnerMostGroupDesc(), groupDescription);
    log.debug("Trying Label 1 Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
    // Finally we create the l2 vpn group.
    index = getNextAvailableIndex();
    groupDescription = createMplsL2VpnGroup(nextGid, index, mplsInstructionSets.get(0), nextObjective.appId());
    groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
    groupChainElem = new GroupChainElem(groupDescription, 1, false);
    updatePendingGroups(groupInfo.getNextGroupDesc().appCookie(), groupChainElem);
    gkeyChain.addFirst(groupKey);
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObjective);
    updatePendingNextObjective(groupKey, ofdpaGrp);
    log.debug("Trying L2 Vpn Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
    // Finally we send the innermost group.
    log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.getInnerMostGroupDesc().givenGroupId()), deviceId);
    groupService.addGroup(groupInfo.getInnerMostGroupDesc());
}
#method_after
@Override
protected void processPwNextObjective(NextObjective nextObjective) {
    TrafficTreatment treatment = nextObjective.next().iterator().next();
    Deque<GroupKey> gkeyChain = new ArrayDeque<>();
    GroupChainElem groupChainElem;
    GroupKey groupKey;
    GroupDescription groupDescription;
    // Now we separate the mpls actions from the l2/l3 actions
    TrafficTreatment.Builder l2L3Treatment = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder mplsTreatment = DefaultTrafficTreatment.builder();
    createL2L3AndMplsTreatments(treatment, l2L3Treatment, mplsTreatment);
    // We create the chain from mpls intf group to
    // l2 intf group.
    GroupInfo groupInfo = createL2L3ChainInternal(l2L3Treatment.build(), nextObjective.id(), nextObjective.appId(), true, nextObjective.meta(), false);
    if (groupInfo == null) {
        log.error("Could not process nextObj={} in dev:{}", nextObjective.id(), deviceId);
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.GROUPINSTALLATIONFAILED);
        return;
    }
    // We update the chain with the last two groups;
    gkeyChain.addFirst(groupInfo.getInnerMostGroupDesc().appCookie());
    gkeyChain.addFirst(groupInfo.getNextGroupDesc().appCookie());
    // We retrieve also all mpls instructions.
    List<List<Instruction>> mplsInstructionSets = Lists.newArrayList();
    List<Instruction> mplsInstructionSet = Lists.newArrayList();
    L3ModificationInstruction l3Ins;
    for (Instruction ins : treatment.allInstructions()) {
        // Each mpls instruction set is delimited by a
        // copy ttl outward action.
        mplsInstructionSet.add(ins);
        if (ins.type() == Instruction.Type.L3MODIFICATION) {
            l3Ins = (L3ModificationInstruction) ins;
            if (l3Ins.subtype() == TTL_OUT) {
                mplsInstructionSets.add(mplsInstructionSet);
                mplsInstructionSet = Lists.newArrayList();
            }
        }
    }
    if (mplsInstructionSets.size() > MAX_DEPTH_UNPROTECTED_PW) {
        log.error("Next Objective for pseudo wire should have at " + "most {} mpls instruction sets. Next Objective Id:{}", MAX_DEPTH_UNPROTECTED_PW, nextObjective.id());
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    int nextGid = groupInfo.getNextGroupDesc().givenGroupId();
    int index;
    // tunnel label group 2;
    if (mplsInstructionSets.size() == MAX_DEPTH_UNPROTECTED_PW) {
        // We deal with the label 2 group.
        index = getNextAvailableIndex();
        groupDescription = createMplsTunnelLabelGroup(nextGid, MPLS_TUNNEL_LABEL_2, index, mplsInstructionSets.get(2), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        // We update the chain.
        groupChainElem = new GroupChainElem(groupDescription, 1, false);
        updatePendingGroups(groupInfo.getNextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        // We have to create tunnel label group and
        // l2 vpn group before to send the inner most
        // group. We update the nextGid.
        nextGid = groupDescription.givenGroupId();
        groupInfo = new GroupInfo(groupInfo.getInnerMostGroupDesc(), groupDescription);
        log.debug("Trying Label 2 Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
    }
    // We deal with the label 1 group.
    index = getNextAvailableIndex();
    groupDescription = createMplsTunnelLabelGroup(nextGid, MPLS_TUNNEL_LABEL_1, index, mplsInstructionSets.get(1), nextObjective.appId());
    groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
    groupChainElem = new GroupChainElem(groupDescription, 1, false);
    updatePendingGroups(groupInfo.getNextGroupDesc().appCookie(), groupChainElem);
    gkeyChain.addFirst(groupKey);
    // We have to create the l2 vpn group before
    // to send the inner most group.
    nextGid = groupDescription.givenGroupId();
    groupInfo = new GroupInfo(groupInfo.getInnerMostGroupDesc(), groupDescription);
    log.debug("Trying Label 1 Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
    // Finally we create the l2 vpn group.
    index = getNextAvailableIndex();
    groupDescription = createMplsL2VpnGroup(nextGid, index, mplsInstructionSets.get(0), nextObjective.appId());
    groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
    groupChainElem = new GroupChainElem(groupDescription, 1, false);
    updatePendingGroups(groupInfo.getNextGroupDesc().appCookie(), groupChainElem);
    gkeyChain.addFirst(groupKey);
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObjective);
    updatePendingNextObjective(groupKey, ofdpaGrp);
    log.debug("Trying L2 Vpn Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
    // Finally we send the innermost group.
    log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.getInnerMostGroupDesc().givenGroupId()), deviceId);
    groupService.addGroup(groupInfo.getInnerMostGroupDesc());
}
#end_block

#method_before
private void createL2L3AndMplsTreatments(TrafficTreatment treatment, TrafficTreatment.Builder l2L3Treatment, TrafficTreatment.Builder mplsTreatment) {
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                // treatment.
                case ETH_DST:
                case ETH_SRC:
                case VLAN_ID:
                case VLAN_POP:
                    l2L3Treatment.add(ins);
                    break;
                // treatment.
                case MPLS_BOS:
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_PUSH:
                    mplsTreatment.add(ins);
                    break;
                default:
                    log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives: {} - {}", ins.type(), ins);
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            // The output goes in the l2/l3 treatment.
            l2L3Treatment.add(ins);
        } else if (ins.type() == Instruction.Type.L3MODIFICATION) {
            // We support partially the l3 instructions.
            L3ModificationInstruction l3ins = (L3ModificationInstruction) ins;
            switch(l3ins.subtype()) {
                case TTL_OUT:
                    mplsTreatment.add(ins);
                    break;
                default:
                    log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives: {} - {}", ins.type(), ins);
            }
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives: {} - {}", ins.type(), ins);
        }
    }
    // We add in a transparent way the set vlan to 4094.
    l2L3Treatment.setVlanId(VlanId.vlanId((short) ASSIGNED_VLAN_NO_SUBNET));
}
#method_after
private void createL2L3AndMplsTreatments(TrafficTreatment treatment, TrafficTreatment.Builder l2L3Treatment, TrafficTreatment.Builder mplsTreatment) {
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                // These instructions have to go in the l2/l3 treatment.
                case ETH_DST:
                case ETH_SRC:
                case VLAN_ID:
                case VLAN_POP:
                    l2L3Treatment.add(ins);
                    break;
                // These instructions have to go in the mpls treatment.
                case MPLS_BOS:
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_PUSH:
                    mplsTreatment.add(ins);
                    break;
                default:
                    log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives: {} - {}", ins.type(), ins);
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            // The output goes in the l2/l3 treatment.
            l2L3Treatment.add(ins);
        } else if (ins.type() == Instruction.Type.L3MODIFICATION) {
            // We support partially the l3 instructions.
            L3ModificationInstruction l3ins = (L3ModificationInstruction) ins;
            switch(l3ins.subtype()) {
                case TTL_OUT:
                    mplsTreatment.add(ins);
                    break;
                default:
                    log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives: {} - {}", ins.type(), ins);
            }
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives: {} - {}", ins.type(), ins);
        }
    }
    // We add in a transparent way the set vlan to 4094.
    l2L3Treatment.setVlanId(VlanId.vlanId((short) PW_INTERNAL_VLAN));
}
#end_block

#method_before
public boolean verifyHashedNextObjective(NextObjective nextObjective) {
    // if it is not hashed, there is something wrong;
    if (nextObjective.type() != HASHED) {
        return false;
    }
    // The case non supported is the MPLS-ECMP. For now, we try
    // to create a MPLS-ECMP for the transport of a VPWS. The
    // necessary info are contained in the meta selector. In particular
    // we are looking for the case of BoS==False;
    TrafficSelector metaSelector = nextObjective.meta();
    if (metaSelector != null) {
        MplsBosCriterion bosCriterion = (MplsBosCriterion) metaSelector.getCriterion(MPLS_BOS);
        if (bosCriterion != null && !bosCriterion.mplsBos()) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean verifyHashedNextObjective(NextObjective nextObjective) {
    // if it is not hashed, there is something wrong;
    if (nextObjective.type() != HASHED) {
        return false;
    }
    // The case non supported is the MPLS-ECMP. For now, we try
    // to create a MPLS-ECMP for the transport of a VPWS. The
    // necessary info are contained in the meta selector. In particular
    // we are looking for the case of BoS==False;
    TrafficSelector metaSelector = nextObjective.meta();
    if (metaSelector != null && isNotMplsBos(metaSelector)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void processSimpleNextObjective(NextObjective nextObj) {
    TrafficTreatment treatment = nextObj.next().iterator().next();
    // determine if plain L2 or L3->L2
    boolean plainL2 = true;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            if (l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_DST || l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_SRC) {
                plainL2 = false;
                break;
            }
        }
    }
    if (plainL2) {
        createL2InterfaceGroup(nextObj);
        return;
    }
    boolean isMpls = false;
    // In order to understand if it is a pseudo wire related
    // next objective we look for the tunnel id in the meta.
    boolean isPw = false;
    if (nextObj.meta() != null) {
        MplsBosCriterion bosCriterion = (MplsBosCriterion) nextObj.meta().getCriterion(MPLS_BOS);
        if (bosCriterion != null) {
            isMpls = !bosCriterion.mplsBos();
        }
        TunnelIdCriterion tunnelIdCriterion = (TunnelIdCriterion) nextObj.meta().getCriterion(TUNNEL_ID);
        if (tunnelIdCriterion != null) {
            isPw = true;
        }
    }
    if (!isPw) {
        // break up simple next objective to GroupChain objects
        GroupInfo groupInfo = createL2L3Chain(treatment, nextObj.id(), nextObj.appId(), isMpls, nextObj.meta());
        if (groupInfo == null) {
            log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
            return;
        }
        // create object for local and distributed storage
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(groupInfo.innerMostGroupDesc.appCookie());
        gkeyChain.addFirst(groupInfo.nextGroupDesc.appCookie());
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObj);
        // store l3groupkey with the ofdpaNextGroup for the nextObjective that depends on it
        updatePendingNextObjective(groupInfo.nextGroupDesc.appCookie(), ofdpaGrp);
        // now we are ready to send the l2 groupDescription (inner), as all the stores
        // that will get async replies have been updated. By waiting to update
        // the stores, we prevent nasty race conditions.
        groupService.addGroup(groupInfo.innerMostGroupDesc);
    } else {
        // We handle the pseudo wire with a different a procedure.
        // This procedure is meant to handle both initiation and
        // termination of the pseudo wire.
        processPwNextObjective(nextObj);
    }
}
#method_after
private void processSimpleNextObjective(NextObjective nextObj) {
    TrafficTreatment treatment = nextObj.next().iterator().next();
    // determine if plain L2 or L3->L2
    boolean plainL2 = true;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            if (l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_DST || l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_SRC) {
                plainL2 = false;
                break;
            }
        }
    }
    if (plainL2) {
        createL2InterfaceGroup(nextObj);
        return;
    }
    boolean isMpls = false;
    // In order to understand if it is a pseudo wire related
    // next objective we look for the tunnel id in the meta.
    boolean isPw = false;
    if (nextObj.meta() != null) {
        isMpls = isNotMplsBos(nextObj.meta());
        TunnelIdCriterion tunnelIdCriterion = (TunnelIdCriterion) nextObj.meta().getCriterion(TUNNEL_ID);
        if (tunnelIdCriterion != null) {
            isPw = true;
        }
    }
    if (!isPw) {
        // break up simple next objective to GroupChain objects
        GroupInfo groupInfo = createL2L3Chain(treatment, nextObj.id(), nextObj.appId(), isMpls, nextObj.meta());
        if (groupInfo == null) {
            log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
            return;
        }
        // create object for local and distributed storage
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(groupInfo.innerMostGroupDesc.appCookie());
        gkeyChain.addFirst(groupInfo.nextGroupDesc.appCookie());
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObj);
        // store l3groupkey with the ofdpaNextGroup for the nextObjective that depends on it
        updatePendingNextObjective(groupInfo.nextGroupDesc.appCookie(), ofdpaGrp);
        // now we are ready to send the l2 groupDescription (inner), as all the stores
        // that will get async replies have been updated. By waiting to update
        // the stores, we prevent nasty race conditions.
        groupService.addGroup(groupInfo.innerMostGroupDesc);
    } else {
        // We handle the pseudo wire with a different a procedure.
        // This procedure is meant to handle both initiation and
        // termination of the pseudo wire.
        processPwNextObjective(nextObj);
    }
}
#end_block

#method_before
protected void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo = null;
            TrafficSelector metaSelector = nextObj.meta();
            if (metaSelector != null) {
                MplsBosCriterion bosCriterion = (MplsBosCriterion) metaSelector.getCriterion(MPLS_BOS);
                if (bosCriterion != null && !bosCriterion.mplsBos()) {
                    nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
                } else {
                    nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
                }
            } else {
                nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            }
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.nextGroupDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.nextGroupDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpnIndex = getNextAvailableIndex();
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | (SUBTYPE_MASK & l3vpnIndex);
            GroupKey l3vpngroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3vpnIndex));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.nextGroupDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.nextGroupDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.nextGroupDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#method_after
protected void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo;
            TrafficSelector metaSelector = nextObj.meta();
            if (metaSelector != null) {
                if (isNotMplsBos(metaSelector)) {
                    nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
                } else {
                    nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
                }
            } else {
                nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            }
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.nextGroupDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.nextGroupDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpnIndex = getNextAvailableIndex();
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | (SUBTYPE_MASK & l3vpnIndex);
            GroupKey l3vpngroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3vpnIndex));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.nextGroupDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.nextGroupDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.nextGroupDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    MplsBosCriterion bosCriterion = (MplsBosCriterion) fwd.selector().getCriterion(MPLS_BOS);
    if (bosCriterion != null && !bosCriterion.mplsBos()) {
        return processEthTypeSpecificInternal(fwd, true, MPLS_TYPE_TABLE);
    }
    return processEthTypeSpecificInternal(fwd, true, MPLS_L3_TYPE_TABLE);
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    if (isNotMplsBos(fwd.selector())) {
        return processEthTypeSpecificInternal(fwd, true, MPLS_TYPE_TABLE);
    }
    return processEthTypeSpecificInternal(fwd, true, MPLS_L3_TYPE_TABLE);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(vpwsConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    // Request ARP packet-in
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.requestPackets(selector.build(), PacketPriority.CONTROL, appId, Optional.empty());
    cfgListener.configureNetwork();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    // Request ARP packet-in
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.requestPackets(selector.build(), PacketPriority.CONTROL, appId, Optional.empty());
    cfgListener.configureNetwork();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(vpwsConfigFactory);
    // Withdraw ARP packet-in
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId, Optional.empty());
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    cordConfigService.removeListener(cordConfigListener);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    nsNextObjStore.destroy();
    subnetNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    subnetVidStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(pwaasConfigFactory);
    // Withdraw ARP packet-in
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_ARP);
    packetService.cancelPackets(selector.build(), PacketPriority.CONTROL, appId, Optional.empty());
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    cordConfigService.removeListener(cordConfigListener);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    nsNextObjStore.destroy();
    subnetNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    subnetVidStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(VpwsConfig.class)) {
        checkState(l2TunnelHandler != null, "L2TunnelHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                l2TunnelHandler.processPWaaSConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                l2TunnelHandler.processPWaaSConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                l2TunnelHandler.processPWaaSConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(PwaasConfig.class)) {
        checkState(l2TunnelHandler != null, "L2TunnelHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                l2TunnelHandler.processPWaasConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                l2TunnelHandler.processPWaasConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                l2TunnelHandler.processPWaasConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public boolean verifyHashedNextObjective(NextObjective nextObjective) {
    // if it is not hashed, there is something wrong;
    if (nextObjective.type() != HASHED) {
        return false;
    }
    // The case non supported is the MPLS-ECMP. For now, we try
    // to create a MPLS-ECMP for the transport of a VPWS. The
    // necessary info are contained in the meta selector. In particular
    // we are looking for the case of BoS==False;
    TrafficSelector metaSelector = nextObjective.meta();
    if (metaSelector != null) {
        MplsBosCriterion bosCriterion = (MplsBosCriterion) metaSelector.getCriterion(MPLS_BOS);
        if (bosCriterion != null && !bosCriterion.mplsBos()) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean verifyHashedNextObjective(NextObjective nextObjective) {
    // if it is not hashed, there is something wrong;
    if (nextObjective.type() != HASHED) {
        return false;
    }
    // The case non supported is the MPLS-ECMP. For now, we try
    // to create a MPLS-ECMP for the transport of a VPWS. The
    // necessary info are contained in the meta selector. In particular
    // we are looking for the case of BoS==False;
    TrafficSelector metaSelector = nextObjective.meta();
    if (metaSelector != null && isNotMplsBos(metaSelector)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void processSimpleNextObjective(NextObjective nextObj) {
    TrafficTreatment treatment = nextObj.next().iterator().next();
    // determine if plain L2 or L3->L2
    boolean plainL2 = true;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            if (l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_DST || l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_SRC) {
                plainL2 = false;
                break;
            }
        }
    }
    if (plainL2) {
        createL2InterfaceGroup(nextObj);
        return;
    }
    boolean isMpls = false;
    if (nextObj.meta() != null) {
        MplsBosCriterion bosCriterion = (MplsBosCriterion) nextObj.meta().getCriterion(MPLS_BOS);
        if (bosCriterion != null) {
            isMpls = !bosCriterion.mplsBos();
        }
    }
    // break up simple next objective to GroupChain objects
    GroupInfo groupInfo = createL2L3Chain(treatment, nextObj.id(), nextObj.appId(), isMpls, nextObj.meta());
    if (groupInfo == null) {
        log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
        return;
    }
    // create object for local and distributed storage
    Deque<GroupKey> gkeyChain = new ArrayDeque<>();
    gkeyChain.addFirst(groupInfo.innerMostGroupDesc.appCookie());
    gkeyChain.addFirst(groupInfo.nextGroupDesc.appCookie());
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObj);
    // store l3groupkey with the ofdpaNextGroup for the nextObjective that depends on it
    updatePendingNextObjective(groupInfo.nextGroupDesc.appCookie(), ofdpaGrp);
    // now we are ready to send the l2 groupDescription (inner), as all the stores
    // that will get async replies have been updated. By waiting to update
    // the stores, we prevent nasty race conditions.
    groupService.addGroup(groupInfo.innerMostGroupDesc);
}
#method_after
private void processSimpleNextObjective(NextObjective nextObj) {
    TrafficTreatment treatment = nextObj.next().iterator().next();
    // determine if plain L2 or L3->L2
    boolean plainL2 = true;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            if (l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_DST || l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_SRC) {
                plainL2 = false;
                break;
            }
        }
    }
    if (plainL2) {
        createL2InterfaceGroup(nextObj);
        return;
    }
    boolean isMpls = false;
    if (nextObj.meta() != null) {
        isMpls = isNotMplsBos(nextObj.meta());
    }
    // break up simple next objective to GroupChain objects
    GroupInfo groupInfo = createL2L3Chain(treatment, nextObj.id(), nextObj.appId(), isMpls, nextObj.meta());
    if (groupInfo == null) {
        log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
        return;
    }
    // create object for local and distributed storage
    Deque<GroupKey> gkeyChain = new ArrayDeque<>();
    gkeyChain.addFirst(groupInfo.innerMostGroupDesc.appCookie());
    gkeyChain.addFirst(groupInfo.nextGroupDesc.appCookie());
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObj);
    // store l3groupkey with the ofdpaNextGroup for the nextObjective that depends on it
    updatePendingNextObjective(groupInfo.nextGroupDesc.appCookie(), ofdpaGrp);
    // now we are ready to send the l2 groupDescription (inner), as all the stores
    // that will get async replies have been updated. By waiting to update
    // the stores, we prevent nasty race conditions.
    groupService.addGroup(groupInfo.innerMostGroupDesc);
}
#end_block

#method_before
protected void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo = null;
            TrafficSelector metaSelector = nextObj.meta();
            if (metaSelector != null) {
                MplsBosCriterion bosCriterion = (MplsBosCriterion) metaSelector.getCriterion(MPLS_BOS);
                if (bosCriterion != null && !bosCriterion.mplsBos()) {
                    nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
                } else {
                    nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
                }
            } else {
                nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            }
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.nextGroupDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.nextGroupDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpnIndex = getNextAvailableIndex();
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | (SUBTYPE_MASK & l3vpnIndex);
            GroupKey l3vpngroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3vpnIndex));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.nextGroupDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.nextGroupDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.nextGroupDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#method_after
protected void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo;
            TrafficSelector metaSelector = nextObj.meta();
            if (metaSelector != null) {
                if (isNotMplsBos(metaSelector)) {
                    nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
                } else {
                    nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
                }
            } else {
                nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            }
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.nextGroupDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.nextGroupDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpnIndex = getNextAvailableIndex();
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | (SUBTYPE_MASK & l3vpnIndex);
            GroupKey l3vpngroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3vpnIndex));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.nextGroupDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.nextGroupDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.nextGroupDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    MplsBosCriterion bosCriterion = (MplsBosCriterion) fwd.selector().getCriterion(MPLS_BOS);
    if (bosCriterion != null && !bosCriterion.mplsBos()) {
        return processEthTypeSpecificInternal(fwd, true, MPLS_TYPE_TABLE);
    }
    return processEthTypeSpecificInternal(fwd, true, MPLS_L3_TYPE_TABLE);
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    if (isNotMplsBos(fwd.selector())) {
        return processEthTypeSpecificInternal(fwd, true, MPLS_TYPE_TABLE);
    }
    return processEthTypeSpecificInternal(fwd, true, MPLS_L3_TYPE_TABLE);
}
#end_block

#method_before
protected List<FlowRule> processVlanIdFilterInternal(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId, boolean useSetVlanExtension) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (useSetVlanExtension) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        } else {
            treatment.setVlanId(assignedVlan);
        }
        preSelector = DefaultTrafficSelector.builder();
        OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
        preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processVlanIdFilterInternal(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId, boolean useSetVlanExtension) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (useSetVlanExtension) {
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
        } else {
            treatment.setVlanId(assignedVlan);
        }
        preSelector = DefaultTrafficSelector.builder();
        OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
        preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        selector.extension(ofdpaMatchVlanVid, deviceId);
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            if (useSetVlanExtension) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
                treatment.extension(ofdpaSetVlanVid, deviceId);
            } else {
                treatment.setVlanId(assignedVlan);
            }
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            filteredSelector.extension(ofdpaMatchVlanVid, deviceId);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    /*
                         * NOTE: The switch does not support matching 0.0.0.0/0
                         * Split it into 0.0.0.0/1 and 128.0.0.0/1
                         */
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                // OF-DPA does not pop in MPLS table. Instead it requires
                // setting the MPLS_TYPE so pop can happen down the pipeline
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
            if (bos != null && !bos.mplsBos() && group.type().equals(HASHED)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#method_after
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            filteredSelector.extension(ofdpaMatchVlanVid, deviceId);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    /*
                         * NOTE: The switch does not support matching 0.0.0.0/0
                         * Split it into 0.0.0.0/1 and 128.0.0.0/1
                         */
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                // OF-DPA does not pop in MPLS table. Instead it requires
                // setting the MPLS_TYPE so pop can happen down the pipeline
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (isNotMplsBos(selector) && group.type().equals(HASHED)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#end_block

#method_before
@Override
protected void processHashedNextObjective(NextObjective nextObjective) {
    // The case for MPLS-ECMP. For now, we try to create a MPLS-ECMP for
    // the transport of a VPWS. The necessary info are contained in the
    // meta selector. In particular we are looking for the case of BoS==False;
    TrafficSelector metaSelector = nextObjective.meta();
    if (metaSelector != null) {
        MplsBosCriterion bosCriterion = (MplsBosCriterion) metaSelector.getCriterion(MPLS_BOS);
        if (bosCriterion != null && !bosCriterion.mplsBos()) {
            // storage for all group keys in the chain of groups created
            List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
            List<GroupInfo> unsentGroups = new ArrayList<>();
            createHashBucketChains(nextObjective, allGroupKeys, unsentGroups);
            // now we can create the outermost MPLS ECMP group
            List<GroupBucket> mplsEcmpGroupBuckets = new ArrayList<>();
            for (GroupInfo gi : unsentGroups) {
                // create ECMP bucket to point to the outer group
                TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
                ttb.group(new DefaultGroupId(gi.getNextGroupDesc().givenGroupId()));
                GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
                mplsEcmpGroupBuckets.add(sbucket);
            }
            int mplsEcmpIndex = getNextAvailableIndex();
            int mplsEcmpGroupId = makeMplsForwardingGroupId(MPLS_ECMP, mplsEcmpIndex);
            GroupKey mplsEmpGroupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(mplsEcmpIndex));
            GroupDescription mplsEcmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(mplsEcmpGroupBuckets), mplsEmpGroupKey, mplsEcmpGroupId, nextObjective.appId());
            GroupChainElem mplsEcmpGce = new GroupChainElem(mplsEcmpGroupDesc, mplsEcmpGroupBuckets.size(), false);
            // create objects for local and distributed storage
            allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(mplsEmpGroupKey));
            OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObjective);
            // store mplsEcmpGroupKey with the ofdpaGroupChain for the nextObjective
            // that depends on it
            updatePendingNextObjective(mplsEmpGroupKey, ofdpaGrp);
            log.debug("Trying MPLS-ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(mplsEcmpGroupId), mplsEmpGroupKey, nextObjective.id());
            // finally we are ready to send the innermost groups
            for (GroupInfo gi : unsentGroups) {
                log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.getInnerMostGroupDesc().givenGroupId()), deviceId);
                updatePendingGroups(gi.getNextGroupDesc().appCookie(), mplsEcmpGce);
                groupService.addGroup(gi.getInnerMostGroupDesc());
            }
            return;
        }
    }
    super.processHashedNextObjective(nextObjective);
}
#method_after
@Override
protected void processHashedNextObjective(NextObjective nextObjective) {
    // The case for MPLS-ECMP. For now, we try to create a MPLS-ECMP for
    // the transport of a VPWS. The necessary info are contained in the
    // meta selector. In particular we are looking for the case of BoS==False;
    TrafficSelector metaSelector = nextObjective.meta();
    if (metaSelector != null && isNotMplsBos(metaSelector)) {
        // storage for all group keys in the chain of groups created
        List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
        List<GroupInfo> unsentGroups = new ArrayList<>();
        createHashBucketChains(nextObjective, allGroupKeys, unsentGroups);
        // now we can create the outermost MPLS ECMP group
        List<GroupBucket> mplsEcmpGroupBuckets = new ArrayList<>();
        for (GroupInfo gi : unsentGroups) {
            // create ECMP bucket to point to the outer group
            TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
            ttb.group(new DefaultGroupId(gi.getNextGroupDesc().givenGroupId()));
            GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
            mplsEcmpGroupBuckets.add(sbucket);
        }
        int mplsEcmpIndex = getNextAvailableIndex();
        int mplsEcmpGroupId = makeMplsForwardingGroupId(MPLS_ECMP, mplsEcmpIndex);
        GroupKey mplsEmpGroupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(mplsEcmpIndex));
        GroupDescription mplsEcmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(mplsEcmpGroupBuckets), mplsEmpGroupKey, mplsEcmpGroupId, nextObjective.appId());
        GroupChainElem mplsEcmpGce = new GroupChainElem(mplsEcmpGroupDesc, mplsEcmpGroupBuckets.size(), false);
        // create objects for local and distributed storage
        allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(mplsEmpGroupKey));
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObjective);
        // store mplsEcmpGroupKey with the ofdpaGroupChain for the nextObjective
        // that depends on it
        updatePendingNextObjective(mplsEmpGroupKey, ofdpaGrp);
        log.debug("Trying MPLS-ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(mplsEcmpGroupId), mplsEmpGroupKey, nextObjective.id());
        // finally we are ready to send the innermost groups
        for (GroupInfo gi : unsentGroups) {
            log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.getInnerMostGroupDesc().givenGroupId()), deviceId);
            updatePendingGroups(gi.getNextGroupDesc().appCookie(), mplsEcmpGce);
            groupService.addGroup(gi.getInnerMostGroupDesc());
        }
        return;
    }
    super.processHashedNextObjective(nextObjective);
}
#end_block

#method_before
private Collection<ForwardingObjective> handleMpls(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops, int segmentId) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = Lists.newArrayList();
    // For the transport of VPWS we can use two or three MPLS label
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchMplsBos(false);
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        // If the next hop is the destination router for the segment, do pop
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop", segmentId, targetSwId);
        // Not-bos pop case (php for the current label). If MPLS-ECMP
        // has been configured, the application we will request the
        // installation for an MPLS-ECMP group.
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, true, false, metabuilder.build());
        // Error case, we cannot handle, exit.
        if (fwdObjNoBosBuilder == null) {
            return Collections.emptyList();
        }
        fwdObjBuilders.add(fwdObjNoBosBuilder);
    } else {
        // next hop is not destination, SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop", segmentId, targetSwId);
        // Not-bos pop case. If MPLS-ECMP has been configured, the
        // application we will request the installation for an MPLS-ECMP
        // group.
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, false, false, metabuilder.build());
        // Error case, we cannot handle, exit.
        if (fwdObjNoBosBuilder == null) {
            return Collections.emptyList();
        }
        fwdObjBuilders.add(fwdObjNoBosBuilder);
    }
    List<ForwardingObjective> fwdObjs = Lists.newArrayList();
    // We add the final property to the fwdObjs.
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(SegmentRoutingService.DEFAULT_PRIORITY)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("MPLS rule {} for SID {} populated in dev:{} ", objective.id(), segmentId, targetSwId), (objective, error) -> log.warn("Failed to populate MPLS rule {} for SID {}: {} in dev:{}", objective.id(), segmentId, error, targetSwId));
        ForwardingObjective fob = fwdObjBuilder.add(context);
        fwdObjs.add(fob);
    }
    return fwdObjs;
}
#method_after
private Collection<ForwardingObjective> handleMpls(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops, int segmentId, boolean isMplsBos) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = Lists.newArrayList();
    // For the transport of VPWS we can use two or three MPLS label
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchMplsBos(isMplsBos);
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        // If the next hop is the destination router for the segment, do pop
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop", segmentId, targetSwId);
        // if Not-bos pop case (php for the current label). If MPLS-ECMP
        // has been configured, the application we will request the
        // installation for an MPLS-ECMP group.
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, true, isMplsBos, metabuilder.build());
        // Error case, we cannot handle, exit.
        if (fwdObjNoBosBuilder == null) {
            return Collections.emptyList();
        }
        fwdObjBuilders.add(fwdObjNoBosBuilder);
    } else {
        // next hop is not destination, SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop", segmentId, targetSwId);
        // If Not-bos pop case. If MPLS-ECMP has been configured, the
        // application we will request the installation for an MPLS-ECMP
        // group. Driver can handle depending on availability
        // of MPLS ECMP or not
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, false, isMplsBos, metabuilder.build());
        // Error case, we cannot handle, exit.
        if (fwdObjNoBosBuilder == null) {
            return Collections.emptyList();
        }
        fwdObjBuilders.add(fwdObjNoBosBuilder);
    }
    List<ForwardingObjective> fwdObjs = Lists.newArrayList();
    // We add the final property to the fwdObjs.
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(SegmentRoutingService.DEFAULT_PRIORITY)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("MPLS rule {} for SID {} populated in dev:{} ", objective.id(), segmentId, targetSwId), (objective, error) -> log.warn("Failed to populate MPLS rule {} for SID {}: {} in dev:{}", objective.id(), segmentId, error, targetSwId));
        ForwardingObjective fob = fwdObjBuilder.add(context);
        fwdObjs.add(fob);
    }
    return fwdObjs;
}
#end_block

#method_before
public boolean populateMplsRule(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSwId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    List<ForwardingObjective> fwdObjs = new ArrayList<>();
    Collection<ForwardingObjective> fwdObjsMpls;
    // Generates the transit rules used by the standard "routing".
    fwdObjsMpls = handleMplsBos(targetSwId, destSwId, nextHops, segmentId);
    if (fwdObjsMpls.isEmpty()) {
        return false;
    }
    fwdObjs.addAll(fwdObjsMpls);
    // Generates the transit rules used by the MPLS VPWS and by other tunnels.
    fwdObjsMpls = handleMpls(targetSwId, destSwId, nextHops, segmentId);
    if (fwdObjsMpls.isEmpty()) {
        return false;
    }
    fwdObjs.addAll(fwdObjsMpls);
    for (ForwardingObjective fwdObj : fwdObjs) {
        log.debug("Sending MPLS fwd obj {} for SID {}-> next {} in sw: {}", fwdObj.id(), segmentId, fwdObj.nextId(), targetSwId);
        srManager.flowObjectiveService.forward(targetSwId, fwdObj);
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#method_after
public boolean populateMplsRule(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        segmentId = config.getSegmentId(destSwId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    List<ForwardingObjective> fwdObjs = new ArrayList<>();
    Collection<ForwardingObjective> fwdObjsMpls;
    // Generates the transit rules used by the standard "routing".
    fwdObjsMpls = handleMpls(targetSwId, destSwId, nextHops, segmentId, true);
    if (fwdObjsMpls.isEmpty()) {
        return false;
    }
    fwdObjs.addAll(fwdObjsMpls);
    // Generates the transit rules used by the MPLS VPWS and by other tunnels.
    fwdObjsMpls = handleMpls(targetSwId, destSwId, nextHops, segmentId, false);
    if (fwdObjsMpls.isEmpty()) {
        return false;
    }
    fwdObjs.addAll(fwdObjsMpls);
    for (ForwardingObjective fwdObj : fwdObjs) {
        log.debug("Sending MPLS fwd obj {} for SID {}-> next {} in sw: {}", fwdObj.id(), segmentId, fwdObj.nextId(), targetSwId);
        srManager.flowObjectiveService.forward(targetSwId, fwdObj);
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    int combinedHash = 0;
    for (DeviceId d : neighbors) {
        combinedHash = combinedHash + Objects.hash(d);
    }
    result = 31 * result + combinedHash + Objects.hash(edgeLabel) + Objects.hash(mplsSet);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(neighbors, edgeLabel, mplsSet);
}
#end_block

#method_before
@Override
public String toString() {
    return " Neighborset Sw: " + neighbors + " label: " + edgeLabel + " mplsSet: " + mplsSet;
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("Neighborset Sw", neighbors).add("Label", edgeLabel).add("MplsSet", mplsSet).toString();
}
#end_block

#method_before
@Override
public void write(IntentData newData) {
    checkNotNull(newData);
    IntentData currentData = currentMap.get(newData.key());
    if (IntentData.isUpdateAcceptable(currentData, newData)) {
        // this always succeeds
        if (newData.state() == PURGE_REQ) {
            if (currentData != null) {
                currentMap.remove(newData.key(), currentData);
            } else {
                log.info("Gratuitous purge request for intent: {}", newData.key());
            }
        } else {
            currentMap.put(newData.key(), new IntentData(newData));
        }
        /*
             * Remove the intent data from the pending map if the newData is more
             * recent or equal to the existing entry.
             */
        pendingMap.compute(newData.key(), (key, existingValue) -> {
            if (existingValue == null || !existingValue.version().isNewerThan(newData.version())) {
                return null;
            } else {
                return existingValue;
            }
        });
    }
}
#method_after
@Override
public void write(IntentData newData) {
    checkNotNull(newData);
    IntentData currentData = currentMap.get(newData.key());
    if (IntentData.isUpdateAcceptable(currentData, newData)) {
        // this always succeeds
        if (newData.state() == PURGE_REQ) {
            if (currentData != null) {
                currentMap.remove(newData.key(), currentData);
            } else {
                log.info("Gratuitous purge request for intent: {}", newData.key());
            }
        } else {
            currentMap.put(newData.key(), new IntentData(newData));
        }
    }
    // Remove the intent data from the pending map if the newData is more
    // recent or equal to the existing entry. No matter if it is an acceptable
    // update or not
    pendingMap.compute(newData.key(), (key, existingValue) -> {
        if (existingValue == null || !existingValue.version().isNewerThan(newData.version())) {
            return null;
        } else {
            return existingValue;
        }
    });
}
#end_block

#method_before
@Activate
public void activate() {
    configService.registerProperties(getClass());
    intentInstaller.init(store, trackerService, flowRuleService, flowObjectiveService, networkConfigService);
    if (skipReleaseResourcesOnWithdrawal) {
        store.setDelegate(testOnlyDelegate);
    } else {
        store.setDelegate(delegate);
    }
    trackerService.setDelegate(topoDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    batchExecutor = newSingleThreadExecutor(groupedThreads("onos/intent", "batch", log));
    workerExecutor = newFixedThreadPool(numThreads, groupedThreads("onos/intent", "worker-%d", log));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    configService.registerProperties(getClass());
    intentInstaller.init(store, trackerService, flowRuleService, flowObjectiveService, networkConfigService);
    if (skipReleaseResourcesOnWithdrawal) {
        store.setDelegate(testOnlyDelegate);
    } else {
        store.setDelegate(delegate);
    }
    trackerService.setDelegate(topoDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    batchExecutor = newSingleThreadExecutor(groupedThreads("onos/intent", "batch", log));
    workerExecutor = newFixedThreadPool(numThreads, groupedThreads("onos/intent", "worker-%d", log));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.unbindIdGenerator(idGenerator);
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#end_block

#method_before
@Override
public void execute(Collection<IntentData> operations) {
    log.debug("Execute {} operation(s).", operations.size());
    log.trace("Execute operations: {}", operations);
    // batchExecutor is single-threaded, so only one batch is in flight at a time
    CompletableFuture.runAsync(() -> {
        // process intent until the phase reaches one of the final phases
        List<CompletableFuture<IntentData>> futures = operations.stream().map(x -> CompletableFuture.completedFuture(x).thenApply(IntentManager.this::createInitialPhase).thenApplyAsync(IntentProcessPhase::process, workerExecutor).thenApply(FinalIntentProcessPhase::data).exceptionally(e -> {
            /*
                                     * When the future fails, we update the Intent to simulate the failure of
                                     * the installation/withdrawal phase and we save in the current map. In
                                     * the next round the CleanUp Thread will pick this Intent again.
                                     */
            log.warn("Future failed: {}", e);
            log.warn("Intent {} - state {} - request {}", x.key(), x.state(), x.request());
            switch(x.state()) {
                case INSTALL_REQ:
                case INSTALLING:
                    x.setState(CORRUPT);
                    return new IntentData(x);
                case WITHDRAW_REQ:
                case WITHDRAWING:
                    x.setState(CORRUPT);
                    IntentData current = store.getIntentData(x.key());
                    return new IntentData(x, current.installables());
                default:
                    return null;
            }
        })).collect(Collectors.toList());
        // write multiple data to store in order
        store.batchWrite(Tools.allOf(futures).join().stream().filter(Objects::nonNull).collect(Collectors.toList()));
    }, batchExecutor).exceptionally(e -> {
        log.error("Error submitting batches:", e);
        // FIXME incomplete Intents should be cleaned up
        // (transition to FAILED, etc.)
        // the batch has failed
        // TODO: maybe we should do more?
        log.error("Walk the plank, matey...");
        return null;
    }).thenRun(accumulator::ready);
}
#method_after
@Override
public void execute(Collection<IntentData> operations) {
    log.debug("Execute {} operation(s).", operations.size());
    log.trace("Execute operations: {}", operations);
    // batchExecutor is single-threaded, so only one batch is in flight at a time
    CompletableFuture.runAsync(() -> {
        // process intent until the phase reaches one of the final phases
        List<CompletableFuture<IntentData>> futures = operations.stream().map(x -> CompletableFuture.completedFuture(x).thenApply(IntentManager.this::createInitialPhase).thenApplyAsync(IntentProcessPhase::process, workerExecutor).thenApply(FinalIntentProcessPhase::data).exceptionally(e -> {
            // When the future fails, we update the Intent to simulate the failure of
            // the installation/withdrawal phase and we save in the current map. In
            // the next round the CleanUp Thread will pick this Intent again.
            log.warn("Future failed", e);
            log.warn("Intent {} - state {} - request {}", x.key(), x.state(), x.request());
            switch(x.state()) {
                case INSTALL_REQ:
                case INSTALLING:
                case WITHDRAW_REQ:
                case WITHDRAWING:
                    x.setState(FAILED);
                    IntentData current = store.getIntentData(x.key());
                    return new IntentData(x, current.installables());
                default:
                    return null;
            }
        })).collect(Collectors.toList());
        // write multiple data to store in order
        store.batchWrite(Tools.allOf(futures).join().stream().filter(Objects::nonNull).collect(Collectors.toList()));
    }, batchExecutor).exceptionally(e -> {
        log.error("Error submitting batches:", e);
        // FIXME incomplete Intents should be cleaned up
        // (transition to FAILED, etc.)
        // the batch has failed
        // TODO: maybe we should do more?
        log.error("Walk the plank, matey...");
        return null;
    }).thenRun(accumulator::ready);
}
#end_block

#method_before
public static Builder builder(LeafNode node) {
    return new Builder(node);
}
#method_after
public static Builder builder(String name, String nameSpace) {
    return new Builder(name, nameSpace);
}
#end_block

#method_before
public LeafNode build() {
    return new LeafNode(this);
}
#method_after
@Override
public LeafNode build() {
    if (type == null) {
        throw new IllegalStateException("node should have a type.");
    }
    if (key == null) {
        key = keyBuilder.build();
    }
    return new LeafNode(this);
}
#end_block

#method_before
public static Builder builder(InnerNode node) {
    return new Builder(node);
}
#method_after
public static Builder builder(String name, String nameSpace) {
    return new Builder(name, nameSpace);
}
#end_block

#method_before
public Builder addNode(NodeKey key, DataNode node) {
    childNodes.put(key, node);
    return this;
}
#method_after
public Builder addNode(DataNode node) {
    childNodes.put(node.key(), node);
    return this;
}
#end_block

#method_before
public InnerNode build() {
    return new InnerNode(this);
}
#method_after
@Override
public InnerNode build() {
    if (type == null) {
        throw new IllegalStateException("node should have a type.");
    }
    if (key == null) {
        key = keyBuilder.build();
    }
    return new InnerNode(this);
}
#end_block

#method_before
private static TeLink yangLinkEvent2TeLinkAttributes(TeLinkEvent yangLinkEvent, TeLink oldTeLink, TeStatus opStatus, TeTopologyService teTopologyService) {
    TeLinkAttributes yangTeLinkAttrs = yangLinkEvent.teLinkAttributes();
    TeLinkTpKey teLinkKey = oldTeLink.teLinkKey();
    // long teNodeIdDest = oldTeLink.peerTeLinkKey().teNodeId();
    // long teNodeIdSrc = oldTeLink.teLinkKey().teNodeId();
    long teNodeIdDest = 0;
    long teNodeIdSrc = 0;
    TeLinkTpGlobalKey supportTeLinkId = oldTeLink.supportingTeLinkId();
    TeLinkTpKey peerTeLinkKey = oldTeLink.peerTeLinkKey();
    TeTopologyKey underlayTopologyId = null;
    // TODO: add code to retrieve underlayTopologyId
    TeLink updatedTeLink = yangLinkAttr2TeLinkAttributes(yangTeLinkAttrs, opStatus, teNodeIdSrc, teNodeIdDest, teLinkKey, peerTeLinkKey, supportTeLinkId, underlayTopologyId);
    return updatedTeLink;
}
#method_after
private static TeLink yangLinkEvent2TeLinkAttributes(TeLinkEvent yangLinkEvent, TeLink oldTeLink, TeStatus opStatus, TeTopologyService teTopologyService) {
    TeLinkAttributes yangTeLinkAttrs = yangLinkEvent.teLinkAttributes();
    TeLinkTpKey teLinkKey = oldTeLink.teLinkKey();
    long teNodeIdDest = 0;
    long teNodeIdSrc = 0;
    TeLinkTpGlobalKey supportTeLinkId = oldTeLink.supportingTeLinkId();
    TeLinkTpKey peerTeLinkKey = oldTeLink.peerTeLinkKey();
    TeTopologyKey underlayTopologyId = null;
    // TODO: add code to retrieve underlayTopologyId
    TeLink updatedTeLink = yangLinkAttr2TeLinkAttributes(yangTeLinkAttrs, opStatus, teNodeIdSrc, teNodeIdDest, teLinkKey, peerTeLinkKey, supportTeLinkId, underlayTopologyId);
    return updatedTeLink;
}
#end_block

#method_before
private void handleRestconfLinkNotification(String linkString) {
    IetfTeTopologyEvent event = convertJson2IetfTeTopologyEvent("ietf-te-topology:te-link-event", linkString);
    if (event == null) {
        log.error("ERROR: json to YO conversion failure");
        return;
    }
    if (event.type() != IetfTeTopologyEvent.Type.TE_LINK_EVENT) {
        log.error("ERROR: wrong YO event type: {}", event.type());
        return;
    }
    TeLinkEvent teLinkEvent = event.subject().teLinkEvent();
    log.debug("TeLinkEvent: {}", teLinkEvent);
    NetworkLinkKey linkKey = LinkConverter.yangLinkEvent2NetworkLinkKey(teLinkEvent);
    NetworkLink networkLink = LinkConverter.yangLinkEvent2NetworkLink(teLinkEvent, teTopologyService);
    if (networkLink == null) {
        log.error("ERROR: yangLinkEvent2NetworkLink returns null");
        return;
    }
    log.debug("networkLink: {}", networkLink);
    topologyProviderService.linkUpdated(linkKey, networkLink);
}
#method_after
private void handleRestconfLinkNotification(String linkString) {
    IetfTeTopologyEvent event = convertJson2IetfTeTopologyEvent("ietf-te-topology:te-link-event", linkString);
    if (event == null) {
        log.error("ERROR: json to YO conversion failure");
        return;
    }
    if (event.type() != IetfTeTopologyEvent.Type.TE_LINK_EVENT) {
        log.error("ERROR: wrong YO event type: {}", event.type());
        return;
    }
    TeLinkEvent teLinkEvent = event.subject().teLinkEvent();
    log.debug("TeLinkEvent: {}", teLinkEvent);
    NetworkLinkKey linkKey = LinkConverter.yangLinkEvent2NetworkLinkKey(teLinkEvent);
    TeTopologyEventTypeEnum teLinkEventType = teLinkEvent.eventType().enumeration();
    if (teLinkEventType == TeTopologyEventTypeEnum.REMOVE) {
        topologyProviderService.linkRemoved(linkKey);
        return;
    }
    NetworkLink networkLink = LinkConverter.yangLinkEvent2NetworkLink(teLinkEvent, teTopologyService);
    if (networkLink == null) {
        log.error("ERROR: yangLinkEvent2NetworkLink returns null");
        return;
    }
    log.debug("networkLink: {}", networkLink);
    topologyProviderService.linkUpdated(linkKey, networkLink);
}
#end_block

#method_before
private void handleRestconfNodeNotification(String nodeString) {
    IetfTeTopologyEvent event = convertJson2IetfTeTopologyEvent("ietf-te-topology:te-node-event", nodeString);
    if (event == null) {
        log.error("ERROR: json to YO conversion failure");
        return;
    }
    if (event.type() != IetfTeTopologyEvent.Type.TE_NODE_EVENT) {
        log.error("ERROR: wrong YO event type: {}", event.type());
        return;
    }
    TeNodeEvent teNodeEvent = event.subject().teNodeEvent();
    log.debug("TeNodeEvent: {}", teNodeEvent);
    NetworkNodeKey nodeKey = NodeConverter.yangNodeEvent2NetworkNodeKey(teNodeEvent);
    NetworkNode networkNode = NodeConverter.yangNodeEvent2NetworkNode(teNodeEvent, teTopologyService);
    if (networkNode == null) {
        log.error("ERROR: yangNodeEvent2NetworkNode returns null");
        return;
    }
    topologyProviderService.nodeUpdated(nodeKey, networkNode);
}
#method_after
private void handleRestconfNodeNotification(String nodeString) {
    IetfTeTopologyEvent event = convertJson2IetfTeTopologyEvent("ietf-te-topology:te-node-event", nodeString);
    if (event == null) {
        log.error("ERROR: json to YO conversion failure");
        return;
    }
    if (event.type() != IetfTeTopologyEvent.Type.TE_NODE_EVENT) {
        log.error("ERROR: wrong YO event type: {}", event.type());
        return;
    }
    TeNodeEvent teNodeEvent = event.subject().teNodeEvent();
    log.debug("TeNodeEvent: {}", teNodeEvent);
    NetworkNodeKey nodeKey = NodeConverter.yangNodeEvent2NetworkNodeKey(teNodeEvent);
    TeTopologyEventTypeEnum teNodeEventType = teNodeEvent.eventType().enumeration();
    if (teNodeEventType == TeTopologyEventTypeEnum.REMOVE) {
        topologyProviderService.nodeRemoved(nodeKey);
        return;
    }
    NetworkNode networkNode = NodeConverter.yangNodeEvent2NetworkNode(teNodeEvent, teTopologyService);
    if (networkNode == null) {
        log.error("ERROR: yangNodeEvent2NetworkNode returns null");
        return;
    }
    topologyProviderService.nodeUpdated(nodeKey, networkNode);
}
#end_block

#method_before
private void handleRestconfNodeNotification(String nodeString) {
    IetfTeTopologyEvent event = convertJson2IetfTeTopologyEvent("ietf-te-topology:te-node-event", nodeString);
    if (event == null) {
        log.error("ERROR: json to YO conversion failure");
        return;
    }
    if (event.type() != IetfTeTopologyEvent.Type.TE_NODE_EVENT) {
        log.error("ERROR: wrong YO event type: {}", event.type());
        return;
    }
    TeNodeEvent teNodeEvent = event.subject().teNodeEvent();
    log.debug("TeNodeEvent: {}", teNodeEvent);
    NetworkNodeKey nodeKey = NodeConverter.yangNodeEvent2NetworkNodeKey(teNodeEvent);
    TeTopologyEventTypeEnum teLinkEventType = teNodeEvent.eventType().enumeration();
    if (teLinkEventType == TeTopologyEventTypeEnum.REMOVE) {
        topologyProviderService.nodeRemoved(nodeKey);
        return;
    }
    NetworkNode networkNode = NodeConverter.yangNodeEvent2NetworkNode(teNodeEvent, teTopologyService);
    if (networkNode == null) {
        log.error("ERROR: yangNodeEvent2NetworkNode returns null");
        return;
    }
    topologyProviderService.nodeUpdated(nodeKey, networkNode);
}
#method_after
private void handleRestconfNodeNotification(String nodeString) {
    IetfTeTopologyEvent event = convertJson2IetfTeTopologyEvent("ietf-te-topology:te-node-event", nodeString);
    if (event == null) {
        log.error("ERROR: json to YO conversion failure");
        return;
    }
    if (event.type() != IetfTeTopologyEvent.Type.TE_NODE_EVENT) {
        log.error("ERROR: wrong YO event type: {}", event.type());
        return;
    }
    TeNodeEvent teNodeEvent = event.subject().teNodeEvent();
    log.debug("TeNodeEvent: {}", teNodeEvent);
    NetworkNodeKey nodeKey = NodeConverter.yangNodeEvent2NetworkNodeKey(teNodeEvent);
    TeTopologyEventTypeEnum teNodeEventType = teNodeEvent.eventType().enumeration();
    if (teNodeEventType == TeTopologyEventTypeEnum.REMOVE) {
        topologyProviderService.nodeRemoved(nodeKey);
        return;
    }
    NetworkNode networkNode = NodeConverter.yangNodeEvent2NetworkNode(teNodeEvent, teTopologyService);
    if (networkNode == null) {
        log.error("ERROR: yangNodeEvent2NetworkNode returns null");
        return;
    }
    topologyProviderService.nodeUpdated(nodeKey, networkNode);
}
#end_block

#method_before
@Override
public void handleOutgoingMessage(LispRouterId routerId, LispMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(routerId.toString());
    switch(msg.getType()) {
        case LISP_MAP_REPLY:
            LispMapReply reply = (LispMapReply) msg;
            MappingEntry replyMe = new MappingEntryBuilder(deviceId, reply).build();
            providerService.mappingAdded(replyMe, false);
            break;
        case LISP_MAP_NOTIFY:
            LispMapNotify notify = (LispMapNotify) msg;
            MappingEntry notifyMe = new MappingEntryBuilder(deviceId, notify).build();
            providerService.mappingAdded(notifyMe, true);
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleOutgoingMessage(LispRouterId routerId, LispMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(routerId.toString());
    switch(msg.getType()) {
        case LISP_MAP_REPLY:
            LispMapReply reply = (LispMapReply) msg;
            MappingEntry replyMe = new MappingEntryBuilder(deviceId, reply).build();
            providerService.mappingAdded(replyMe, false);
            break;
        case LISP_MAP_NOTIFY:
            LispMapNotify notify = (LispMapNotify) msg;
            MappingEntry notifyMe = new MappingEntryBuilder(deviceId, notify).build();
            providerService.mappingAdded(notifyMe, true);
            break;
        default:
            log.warn("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
protected Path getPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<Path> paths = pathService.getPaths(one, two, weigher(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<Path> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        return null;
    }
    // TODO: let's be more intelligent about this eventually
    return filtered.get(intent.hashCode() % filtered.size());
}
#method_after
protected Path getPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<Path> paths = pathService.getPaths(one, two, weigher(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<Path> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        return null;
    }
    if (constraints.stream().anyMatch(c -> c instanceof HashedPathSelectionConstraint)) {
        return filtered.get(intent.hashCode() % filtered.size());
    }
    return filtered.iterator().next();
}
#end_block

#method_before
protected DisjointPath getDisjointPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<DisjointPath> paths = pathService.getDisjointPaths(one, two, weigher(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<DisjointPath> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        throw new PathNotFoundException(one, two);
    }
    // TODO: let's be more intelligent about this eventually
    return filtered.get(intent.hashCode() % filtered.size());
}
#method_after
protected DisjointPath getDisjointPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<DisjointPath> paths = pathService.getDisjointPaths(one, two, weigher(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<DisjointPath> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        throw new PathNotFoundException(one, two);
    }
    if (constraints.stream().anyMatch(c -> c instanceof HashedPathSelectionConstraint)) {
        return filtered.get(intent.hashCode() % filtered.size());
    }
    return filtered.iterator().next();
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet == null) {
        return;
    }
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("{} - we are still receiving ARP packets from {}", context.inPacket().receivedFrom());
        log.debug("{}", ethernet);
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) ethernet.getPayload();
        // ipHandler.addToPacketBuffer(ipv4Packet);
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processIcmp(ethernet, pkt.receivedFrom());
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCP packets.
        // ipHandler.processPacketIn(ipv4Packet, pkt.receivedFrom());
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
        // We deal with the packet only if the packet is a ICMP6 ECHO/REPLY
        if (ipv6Packet.getNextHeader() == IPv6.PROTOCOL_ICMP6) {
            ICMP6 icmp6Packet = (ICMP6) ipv6Packet.getPayload();
            if (icmp6Packet.getIcmpType() == ICMP6.ECHO_REQUEST || icmp6Packet.getIcmpType() == ICMP6.ECHO_REPLY) {
                icmpHandler.processIcmpv6(ethernet, pkt.receivedFrom());
            } else {
                // not under our control
                if (handleUPstreamPackets(context)) {
                    log.debug("Rcvd pktin from UpStream: {}", ipv6Packet);
                } else {
                    log.debug("Received ICMPv6 0x{} - not handled", Integer.toHexString(icmp6Packet.getIcmpType() & 0xff));
                }
            }
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCPv6 packets.
        // ipHandler.processPacketIn(ipv6Packet, pkt.receivedFrom());
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet == null) {
        return;
    }
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("{} - we are still receiving ARP packets from {}", context.inPacket().receivedFrom());
        log.debug("{}", ethernet);
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) ethernet.getPayload();
        // ipHandler.addToPacketBuffer(ipv4Packet);
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processIcmp(ethernet, pkt.receivedFrom());
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCP packets.
        // ipHandler.processPacketIn(ipv4Packet, pkt.receivedFrom());
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
        // We deal with the packet only if the packet is a ICMP6 ECHO/REPLY
        if (ipv6Packet.getNextHeader() == IPv6.PROTOCOL_ICMP6) {
            ICMP6 icmp6Packet = (ICMP6) ipv6Packet.getPayload();
            if (icmp6Packet.getIcmpType() == ICMP6.ECHO_REQUEST || icmp6Packet.getIcmpType() == ICMP6.ECHO_REPLY) {
                icmpHandler.processIcmpv6(ethernet, pkt.receivedFrom());
            } else {
                // not under our control
                if (icmpHandler.handleUPstreamPackets(context)) {
                    log.debug("Rcvd pktin from UpStream: {}", ipv6Packet);
                } else {
                    log.debug("Received ICMPv6 0x{} - not handled", Integer.toHexString(icmp6Packet.getIcmpType() & 0xff));
                }
            }
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCPv6 packets.
        // ipHandler.processPacketIn(ipv6Packet, pkt.receivedFrom());
        }
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
        configureNetwork();
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    // XXX Neighbour hacking. This method is looking for
    // the Internet-Router interface. In order to retrieve
    // the upstream port.
    } else if (event.configClass().equals(InterfaceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
            case CONFIG_UPDATED:
                updateUPstreamCP(event);
            case CONFIG_REGISTERED:
            case CONFIG_UNREGISTERED:
            case CONFIG_REMOVED:
                break;
            default:
                break;
        }
    // XXX Neighbour hacking. This method is looking for
    // the vrouter port.
    } else if (event.configClass().equals(RouterConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
            case CONFIG_UPDATED:
                updateVRouterCP(event);
            case CONFIG_REGISTERED:
            case CONFIG_UNREGISTERED:
            case CONFIG_REMOVED:
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
        configureNetwork();
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    // XXX Neighbour hacking. This method is looking for
    // the Internet-Router interface. In order to retrieve
    // the upstream port.
    } else if (event.configClass().equals(InterfaceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
            case CONFIG_UPDATED:
                icmpHandler.updateUPstreamCP(event);
            case CONFIG_REGISTERED:
            case CONFIG_UNREGISTERED:
            case CONFIG_REMOVED:
                break;
            default:
                break;
        }
    // XXX Neighbour hacking. This method is looking for
    // the vrouter port.
    } else if (event.configClass().equals(RouterConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
            case CONFIG_UPDATED:
                icmpHandler.updateVRouterCP(event);
            case CONFIG_REGISTERED:
            case CONFIG_UNREGISTERED:
            case CONFIG_REMOVED:
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void sendNdpRequest(DeviceId deviceId, IpAddress targetAddress, ConnectPoint inPort) {
    byte[] senderMacAddress = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] senderIpAddress = new byte[Ip6Address.BYTE_LENGTH];
    /*
         * Retrieves device info.
         */
    if (getSenderInfo(senderMacAddress, senderIpAddress, deviceId, targetAddress) < 0) {
        log.warn("Aborting sendNdpRequest, we cannot get all the information needed");
        return;
    }
    /*
         * We have to compute the dst mac address and dst
         * ip address.
         */
    byte[] dstIp = IPv6.getSolicitNodeAddress(targetAddress.toOctets());
    byte[] dstMac = IPv6.getMCastMacAddress(dstIp);
    /*
         * Creates the request.
         */
    Ethernet ndpRequest = NeighborSolicitation.buildNdpSolicit(targetAddress.toOctets(), senderIpAddress, dstIp, senderMacAddress, dstMac, VlanId.NONE);
    flood(ndpRequest, inPort, targetAddress);
}
#method_after
public void sendNdpRequest(DeviceId deviceId, IpAddress targetAddress, ConnectPoint inPort) {
    byte[] senderMacAddress = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] senderIpAddress = new byte[Ip6Address.BYTE_LENGTH];
    /*
         * Retrieves device info.
         */
    if (!getSenderInfo(senderMacAddress, senderIpAddress, deviceId, targetAddress)) {
        log.warn("Aborting sendNdpRequest, we cannot get all the information needed");
        return;
    }
    /*
         * We have to compute the dst mac address and dst
         * ip address.
         */
    byte[] dstIp = IPv6.getSolicitNodeAddress(targetAddress.toOctets());
    byte[] dstMac = IPv6.getMCastMacAddress(dstIp);
    /*
         * Creates the request.
         */
    Ethernet ndpRequest = NeighborSolicitation.buildNdpSolicit(targetAddress.toOctets(), senderIpAddress, dstIp, senderMacAddress, dstMac, VlanId.NONE);
    flood(ndpRequest, inPort, targetAddress);
}
#end_block

#method_before
public void sendArpRequest(DeviceId deviceId, IpAddress targetAddress, ConnectPoint inPort) {
    byte[] senderMacAddress = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] senderIpAddress = new byte[Ip4Address.BYTE_LENGTH];
    /*
         * Retrieves device info.
         */
    if (getSenderInfo(senderMacAddress, senderIpAddress, deviceId, targetAddress) < 0) {
        log.warn("Aborting sendArpRequest, we cannot get all the information needed");
        return;
    }
    /*
         * Creates the request.
         */
    Ethernet arpRequest = ARP.buildArpRequest(senderMacAddress, senderIpAddress, targetAddress.toOctets(), VlanId.NO_VID);
    flood(arpRequest, inPort, targetAddress);
}
#method_after
public void sendArpRequest(DeviceId deviceId, IpAddress targetAddress, ConnectPoint inPort) {
    byte[] senderMacAddress = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] senderIpAddress = new byte[Ip4Address.BYTE_LENGTH];
    /*
         * Retrieves device info.
         */
    if (!getSenderInfo(senderMacAddress, senderIpAddress, deviceId, targetAddress)) {
        log.warn("Aborting sendArpRequest, we cannot get all the information needed");
        return;
    }
    /*
         * Creates the request.
         */
    Ethernet arpRequest = ARP.buildArpRequest(senderMacAddress, senderIpAddress, targetAddress.toOctets(), VlanId.NO_VID);
    flood(arpRequest, inPort, targetAddress);
}
#end_block

#method_before
protected int getSenderInfo(byte[] mac, byte[] ip, DeviceId deviceId, IpAddress targetAddress) {
    byte[] senderMacAddress;
    byte[] senderIpAddress;
    IpAddress sender;
    try {
        senderMacAddress = config.getDeviceMac(deviceId).toBytes();
        if (targetAddress.isIp4()) {
            sender = config.getRouterIpAddressForASubnetHost(targetAddress.getIp4Address());
        } else {
            sender = config.getRouterIpAddressForASubnetHost(targetAddress.getIp6Address());
        }
        // If sender is null we abort.
        if (sender == null) {
            return -1;
        }
        senderIpAddress = sender.toOctets();
    } catch (DeviceConfigNotFoundException e) {
        return -1;
    }
    System.arraycopy(senderMacAddress, 0, mac, 0, senderMacAddress.length);
    System.arraycopy(senderIpAddress, 0, ip, 0, senderIpAddress.length);
    return 0;
}
#method_after
protected boolean getSenderInfo(byte[] mac, byte[] ip, DeviceId deviceId, IpAddress targetAddress) {
    byte[] senderMacAddress;
    byte[] senderIpAddress;
    IpAddress sender;
    try {
        senderMacAddress = config.getDeviceMac(deviceId).toBytes();
        if (targetAddress.isIp4()) {
            sender = config.getRouterIpAddressForASubnetHost(targetAddress.getIp4Address());
        } else {
            sender = config.getRouterIpAddressForASubnetHost(targetAddress.getIp6Address());
        }
        // If sender is null we abort.
        if (sender == null) {
            log.warn("Sender ip is null. Aborting getSenderInfo");
            return false;
        }
        senderIpAddress = sender.toOctets();
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting getSenderInfo");
        return false;
    }
    System.arraycopy(senderMacAddress, 0, mac, 0, senderMacAddress.length);
    System.arraycopy(senderIpAddress, 0, ip, 0, senderIpAddress.length);
    return true;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    componentConfigService.registerProperties(getClass());
    componentConfigService.preSetProperty("org.onosproject.incubator.store.routing.impl.RouteStoreImpl", "distributed", "true");
    baseComponents.forEach(name -> componentService.activate(appId, name));
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    componentConfigService.preSetProperty("org.onosproject.incubator.store.routing.impl.RouteStoreImpl", "distributed", "true");
    baseComponents.forEach(name -> componentService.activate(appId, name));
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
}
#method_after
@Deactivate
public void deactivate() {
    providerRegistryService.unregisterProvider(this);
}
#end_block

#method_before
@Override
public void event(AlarmEvent event) {
    if (isMonitoring) {
        updateAlarms();
    }
}
#method_after
@Override
public void event(AlarmEvent event) {
    if (isMonitoring) {
        messageHandler.sendAlarmHighlights();
    }
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    log.debug("Start Display");
    Highlights highlights = new Highlights();
    createBadges(highlights);
    highlights.delay(DELAY_MS);
    sendHighlights(highlights);
    alarmMonitor.startMonitorig();
}
#method_after
@Override
public void process(ObjectNode payload) {
    log.debug("Start Display");
    sendDelayedAlarmHighlights();
    alarmMonitor.startMonitorig();
}
#end_block

#method_before
protected void sendHighlights(Highlights highlights) {
    sendMessage(TopoJson.highlightsMessage(highlights));
}
#method_after
private void sendHighlights(Highlights highlights) {
    sendMessage(TopoJson.highlightsMessage(highlights));
}
#end_block

#method_before
protected void createBadges(Highlights highlights) {
    deviceService.getAvailableDevices().forEach(d -> {
        Set<Alarm> alarmsOnDevice = alarmService.getAlarms(d.id());
        log.debug("{} Alarms on device {}", alarmsOnDevice.size(), d.id());
        if (alarmsOnDevice.size() > 0) {
            addDeviceBadge(highlights, d.id(), alarmsOnDevice.size());
        }
    });
}
#method_after
private void createBadges(Highlights highlights) {
    deviceService.getAvailableDevices().forEach(d -> {
        Set<Alarm> alarmsOnDevice = alarmService.getAlarms(d.id());
        int alarmSize = alarmsOnDevice.size();
        log.debug("{} Alarms on device {}", alarmSize, d.id());
        if (alarmSize > 0) {
            addDeviceBadge(highlights, d.id(), alarmSize);
        }
    });
}
#end_block

#method_before
@Override
public boolean isValid() {
    for (JsonNode node : array) {
        if (!hasOnlyFields((ObjectNode) node, NAME, IPS, MAC, VLAN, VLAN_UNTAGGED, VLAN_TAGGED, VLAN_NATIVE)) {
            return false;
        }
        ObjectNode obj = (ObjectNode) node;
        if (!(isString(obj, NAME, FieldPresence.OPTIONAL) && isMacAddress(obj, MAC, FieldPresence.OPTIONAL) && isIntegralNumber(obj, VLAN, FieldPresence.OPTIONAL, 0, VlanId.MAX_VLAN) && isIntegralNumber(obj, VLAN_UNTAGGED, FieldPresence.OPTIONAL, 0, VlanId.MAX_VLAN) && isIntegralNumber(obj, VLAN_NATIVE, FieldPresence.OPTIONAL, 0, VlanId.MAX_VLAN))) {
            return false;
        }
        for (JsonNode ipNode : node.path(IPS)) {
            if (!ipNode.isTextual() || IpPrefix.valueOf(ipNode.asText()) == null) {
                return false;
            }
        }
        if (hasField(obj, VLAN_TAGGED) && !node.path(VLAN_TAGGED).isArray()) {
            log.warn("{} should be an array", VLAN_TAGGED);
            return false;
        }
        for (JsonNode vlanNode : node.path(VLAN_TAGGED)) {
            if (!vlanNode.isInt() || vlanNode.intValue() < 0 || vlanNode.intValue() > VlanId.MAX_VLAN) {
                log.warn("Invalid VLAN ID {} in {}", vlanNode.intValue(), VLAN_TAGGED);
                return false;
            }
        }
        if (hasField(obj, VLAN_UNTAGGED) && (hasField(obj, VLAN_TAGGED) || hasField(obj, VLAN_NATIVE))) {
            log.warn("{} and {} should not be used when {} is set", VLAN_TAGGED, VLAN_NATIVE, VLAN_UNTAGGED);
            return false;
        }
        if (hasField(obj, VLAN_TAGGED) && hasField(obj, VLAN_UNTAGGED)) {
            log.warn("{} should not be used when {} is set", VLAN_UNTAGGED, VLAN_TAGGED);
            return false;
        }
        if (hasField(obj, VLAN_NATIVE) && !hasField(obj, VLAN_TAGGED)) {
            log.warn("{} should not be used alone without {}", VLAN_NATIVE, VLAN_TAGGED);
            return false;
        }
        if (hasField(obj, VLAN_NATIVE) && hasField(obj, VLAN_TAGGED) && getVlans(obj, VLAN_TAGGED).contains(getVlan(obj, VLAN_NATIVE))) {
            log.warn("{} cannot be one of the VLANs configured in {}", VLAN_NATIVE, VLAN_TAGGED);
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean isValid() {
    for (JsonNode node : array) {
        if (!hasOnlyFields((ObjectNode) node, NAME, IPS, MAC, VLAN, VLAN_UNTAGGED, VLAN_TAGGED, VLAN_NATIVE)) {
            return false;
        }
        ObjectNode obj = (ObjectNode) node;
        if (!(isString(obj, NAME, FieldPresence.OPTIONAL) && isMacAddress(obj, MAC, FieldPresence.OPTIONAL) && isIntegralNumber(obj, VLAN, FieldPresence.OPTIONAL, 0, VlanId.MAX_VLAN) && isIntegralNumber(obj, VLAN_UNTAGGED, FieldPresence.OPTIONAL, 0, VlanId.MAX_VLAN) && isIntegralNumber(obj, VLAN_NATIVE, FieldPresence.OPTIONAL, 0, VlanId.MAX_VLAN))) {
            return false;
        }
        for (JsonNode ipNode : node.path(IPS)) {
            if (!ipNode.isTextual() || IpPrefix.valueOf(ipNode.asText()) == null) {
                return false;
            }
        }
        checkArgument(!hasField(obj, VLAN_TAGGED) || (node.path(VLAN_TAGGED).isArray() && node.path(VLAN_TAGGED).size() >= 1), "%s must be an array with at least one element", VLAN_TAGGED);
        for (JsonNode vlanNode : node.path(VLAN_TAGGED)) {
            checkArgument(vlanNode.isInt() && vlanNode.intValue() >= 0 && vlanNode.intValue() <= VlanId.MAX_VLAN, "Invalid VLAN ID %s in %s", vlanNode.intValue(), VLAN_TAGGED);
        }
        checkArgument(!hasField(obj, VLAN_UNTAGGED) || !(hasField(obj, VLAN_TAGGED) || hasField(obj, VLAN_NATIVE)), "%s and %s should not be used when %s is set", VLAN_TAGGED, VLAN_NATIVE, VLAN_UNTAGGED);
        checkArgument(!hasField(obj, VLAN_TAGGED) || !hasField(obj, VLAN_UNTAGGED), "%s should not be used when %s is set", VLAN_UNTAGGED, VLAN_TAGGED);
        checkArgument(!hasField(obj, VLAN_NATIVE) || hasField(obj, VLAN_TAGGED), "%s should not be used alone without %s", VLAN_NATIVE, VLAN_TAGGED);
        checkArgument(!hasField(obj, VLAN_NATIVE) || !hasField(obj, VLAN_TAGGED) || !getVlans(obj, VLAN_TAGGED).contains(getVlan(obj, VLAN_NATIVE)), "%s cannot be one of the VLANs configured in %s", VLAN_NATIVE, VLAN_TAGGED);
    }
    return true;
}
#end_block

#method_before
private void subscribeRestconfNotification(DeviceId deviceId) {
    if (!restconfClient.isNotificationListenerEnabled(deviceId)) {
        restconfClient.enableNotifications(deviceId, IETF_NOTIFICATION_URI, "application/json", new DefaultRestconfNotificationEventListener());
    }
    restconfClient.getNotificationEventListener(deviceId).registerEventCallbackFunction(TE_TOPOLOGY_LINK_NOTIFICATION, new InternalLinkEventProcessor());
    restconfClient.getNotificationEventListener(deviceId).registerEventCallbackFunction(TE_TOPOLOGY_NODE_NOTIFICATION, new InternalNodeEventProcessor());
}
#method_after
private void subscribeRestconfNotification(DeviceId deviceId) {
    TeTopologyRestconfEventListener listener = new TeTopologyRestconfEventListener();
    listener.addCallbackFunction(TE_TOPOLOGY_LINK_NOTIFICATION, new InternalLinkEventProcessor());
    listener.addCallbackFunction(TE_TOPOLOGY_NODE_NOTIFICATION, new InternalNodeEventProcessor());
    if (!restconfClient.isNotificationEnabled(deviceId)) {
        restconfClient.enableNotifications(deviceId, IETF_NOTIFICATION_URI, "application/json", listener);
    } else {
        restconfClient.addNotificationListener(deviceId, listener);
    }
}
#end_block

#method_before
@Override
public void enableNotifications(DeviceId device, String request, String mediaType, RestconfNotificationEventListener listener) {
    request = discoverRootResource(device) + NOTIFICATION_PATH_PREFIX + request;
    addNotificationListener(device, listener);
    GetChunksRunnable runnable = new GetChunksRunnable(request, mediaType, device);
    runnableTable.put(device, runnable);
    executor.execute(runnable);
}
#method_after
@Override
public void enableNotifications(DeviceId device, String request, String mediaType, RestconfNotificationEventListener listener) {
    if (isNotificationEnabled(device)) {
        log.warn("enableNotifications: already enabled on device: {}", device);
        return;
    }
    request = discoverRootResource(device) + NOTIFICATION_PATH_PREFIX + request;
    addNotificationListener(device, listener);
    GetChunksRunnable runnable = new GetChunksRunnable(request, mediaType, device);
    runnableTable.put(device, runnable);
    executor.execute(runnable);
}
#end_block

#method_before
public void stopNotifications(DeviceId device) {
    runnableTable.get(device).terminate();
    runnableTable.remove(device);
    removeNotificationListener(device);
    log.debug("Stop sending notifications for device URI: " + device.uri().toString());
}
#method_after
public void stopNotifications(DeviceId device) {
    runnableTable.get(device).terminate();
    runnableTable.remove(device);
    restconfNotificationListenerMap.remove(device);
    log.debug("Stop sending notifications for device URI: " + device.uri().toString());
}
#end_block

#method_before
@Override
public void run() {
    WebTarget wt = getWebTarget(device, request);
    Response clientResp = wt.request(mediaType).get();
    RestconfNotificationEventListener listener = restconfNotificationListenerMap.get(device);
    final ChunkedInput<String> chunkedInput = (ChunkedInput<String>) clientResp.readEntity(new GenericType<ChunkedInput<String>>() {
    });
    String chunk;
    // interrupts.
    while (running) {
        chunk = chunkedInput.read();
        if (chunk != null) {
            if (running) {
                listener.handleNotificationEvent(device, chunk);
            } else {
                log.trace("the requesting client is no more interested " + "to receive such notifications.");
            }
        } else {
            log.trace("The received notification chunk is null. do not continue any more.");
            break;
        }
    }
    log.trace("out of while loop -- end of run");
}
#method_after
@Override
public void run() {
    WebTarget wt = getWebTarget(device, request);
    Response clientResp = wt.request(mediaType).get();
    Set<RestconfNotificationEventListener> listeners = restconfNotificationListenerMap.get(device);
    final ChunkedInput<String> chunkedInput = (ChunkedInput<String>) clientResp.readEntity(new GenericType<ChunkedInput<String>>() {
    });
    String chunk;
    // interrupts.
    while (running) {
        chunk = chunkedInput.read();
        if (chunk != null) {
            if (running) {
                for (RestconfNotificationEventListener listener : listeners) {
                    listener.handleNotificationEvent(device, chunk);
                }
            } else {
                log.trace("the requesting client is no more interested " + "to receive such notifications.");
            }
        } else {
            log.trace("The received notification chunk is null. do not continue any more.");
            break;
        }
    }
    log.trace("out of while loop -- end of run");
}
#end_block

#method_before
@Override
public void addNotificationListener(DeviceId deviceId, RestconfNotificationEventListener listener) {
    if (!restconfNotificationListenerMap.containsKey(deviceId)) {
        this.restconfNotificationListenerMap.put(deviceId, listener);
    }
}
#method_after
@Override
public void addNotificationListener(DeviceId deviceId, RestconfNotificationEventListener listener) {
    Set<RestconfNotificationEventListener> listeners = restconfNotificationListenerMap.get(deviceId);
    if (listeners == null) {
        listeners = new HashSet<>();
    }
    listeners.add(listener);
    this.restconfNotificationListenerMap.put(deviceId, listeners);
}
#end_block

#method_before
@Override
public void removeNotificationListener(DeviceId deviceId) {
    this.restconfNotificationListenerMap.remove(deviceId);
}
#method_after
@Override
public void removeNotificationListener(DeviceId deviceId, RestconfNotificationEventListener listener) {
    Set<RestconfNotificationEventListener> listeners = restconfNotificationListenerMap.get(deviceId);
    if (listeners != null) {
        listeners.remove(listener);
    }
}
#end_block

#method_before
private void subscribe() {
    for (DeviceId deviceId : controller.getDevices().keySet()) {
        try {
            if (!controller.isNotificationListenerEnabled(deviceId)) {
                controller.enableNotifications(deviceId, IETF_NOTIFICATION_URI, "application/json", new DefaultRestconfNotificationEventListener());
            }
            controller.getNotificationEventListener(deviceId).registerEventCallbackFunction(TE_TUNNEL_NOTIFICATION, new InternalTunnelEventProcessor());
        } catch (Exception e) {
            log.error("Failed to subscribe for {} : {}", deviceId, e.getMessage());
        }
    }
}
#method_after
private void subscribe() {
    for (DeviceId deviceId : controller.getDevices().keySet()) {
        try {
            if (!controller.isNotificationEnabled(deviceId)) {
                controller.enableNotifications(deviceId, IETF_NOTIFICATION_URI, "application/json", new InternalTunnelNotificationListener());
            } else {
                controller.addNotificationListener(deviceId, new InternalTunnelNotificationListener());
            }
        } catch (Exception e) {
            log.error("Failed to subscribe for {} : {}", deviceId, e.getMessage());
        }
    }
}
#end_block

#method_before
private void unsubscribe() {
    controller.getDevices().keySet().forEach(deviceId -> controller.removeNotificationListener(deviceId));
}
#method_after
private void unsubscribe() {
    controller.getDevices().keySet().forEach(deviceId -> controller.removeNotificationListener(deviceId, new InternalTunnelNotificationListener()));
}
#end_block

#method_before
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    TeTunnel teTunnel = tunnelService.getTeTunnel(tunnel.tunnelId());
    IetfTe ietfTe = buildIetfTe(teTunnel);
    YangCompositeEncoding encoding = codecHandler.encodeCompositeOperation(RESTCONF_ROOT, null, ietfTe, JSON, EDIT_CONFIG_REQUEST);
    String identifier = encoding.getResourceIdentifier();
    String resourceInformation = encoding.getResourceInformation();
    if (srcElement == null) {
        log.error("Can't find remote device for tunnel : {}", tunnel);
        return;
    }
    controller.post((DeviceId) srcElement, identifier, new ByteArrayInputStream(resourceInformation.getBytes()), MediaType.APPLICATION_JSON, ObjectNode.class);
}
#method_after
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (!tunnel.annotations().keys().contains(TE_TUNNEL_KEY)) {
        log.warn("No tunnel key info in tunnel {}", tunnel);
        return;
    }
    String teTunnelKey = tunnel.annotations().value(TE_TUNNEL_KEY);
    Optional<TeTunnel> optTunnel = tunnelService.getTeTunnels().stream().filter(t -> t.teTunnelKey().toString().equals(teTunnelKey)).findFirst();
    if (!optTunnel.isPresent()) {
        log.warn("No te tunnel map to tunnel {}", tunnel);
        return;
    }
    IetfTe ietfTe = buildIetfTe(optTunnel.get());
    YangCompositeEncoding encoding = codecHandler.encodeCompositeOperation(RESTCONF_ROOT, null, ietfTe, JSON, EDIT_CONFIG_REQUEST);
    String identifier = encoding.getResourceIdentifier();
    String resourceInformation = encoding.getResourceInformation();
    if (srcElement == null) {
        log.error("Can't find remote device for tunnel : {}", tunnel);
        return;
    }
    controller.post((DeviceId) srcElement, identifier, new ByteArrayInputStream(resourceInformation.getBytes()), MEDIA_TYPE_JSON, ObjectNode.class);
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.provider.virtual-packet-provider");
    providerRegistry.register(this);
    processor = new InternalPacketProcessor(this);
    packetService.addProcessor(processor, PACKET_PROCESSOR_PRIORITY);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.provider.virtual-packet-provider");
    processor = new InternalPacketProcessor();
    packetService.addProcessor(processor, PACKET_PROCESSOR_PRIORITY);
    contextMap = Maps.newConcurrentMap();
    log.info("Started");
}
#end_block

#method_before
private String summary() {
    StringBuilder builder = new StringBuilder();
    builder.append(SUMMARY_TITLES);
    builder.append("\n" + SEPARATOR + SEPARATOR + SEPARATOR);
    builder.append(summaryAll.summary("%29d"));
    builder.append(summaryPointToPoint.summary("%20d"));
    builder.append(summarySinglePointToMultiPoint.summary("%9d"));
    builder.append(summaryMultiPointToSinglePoint.summary("%9d"));
    builder.append(summaryHostToHost.summary("%22d"));
    builder.append(summaryLinkCollection.summary("%18d"));
    builder.append(summaryConnectivity.summary("%20d"));
    builder.append(summaryPath.summary("%28d"));
    builder.append(summaryOpticalCircuit.summary("%18d"));
    builder.append(summaryOpticalConnectivity.summary("%13d"));
    builder.append(summaryOpticalOdu.summary("%22d"));
    builder.append(summaryUnknownType.summary("%21d"));
    return builder.toString();
}
#method_after
private String summary() {
    StringBuilder builder = new StringBuilder();
    builder.append(SUMMARY_TITLES);
    builder.append("\n" + SEPARATOR);
    builder.append(summaryAll.summary());
    builder.append(summaryPointToPoint.summary());
    builder.append(summarySinglePointToMultiPoint.summary());
    builder.append(summaryMultiPointToSinglePoint.summary());
    builder.append(summaryHostToHost.summary());
    builder.append(summaryLinkCollection.summary());
    builder.append(summaryConnectivity.summary());
    builder.append(summaryPath.summary());
    builder.append(summaryOpticalCircuit.summary());
    builder.append(summaryOpticalConnectivity.summary());
    builder.append(summaryOpticalOdu.summary());
    builder.append(summaryUnknownType.summary());
    return builder.toString();
}
#end_block

#method_before
String summary(String firstSpace) {
    StringBuilder builder = new StringBuilder();
    builder.append(String.format("\n%1s" + firstSpace + "%14d%14d%14d%14d%14d%14d%14d%14d%14d%14d", BOLD + intentType + RESET, total, installed, withdrawn, failed, installReq, compiling, installing, recompiling, withdrawReq, withdrawing, unknownState));
    builder.append("\n" + SEPARATOR + SEPARATOR + SEPARATOR);
    return builder.toString();
}
#method_after
String summary() {
    StringBuilder builder = new StringBuilder();
    builder.append(String.format("\n%1s%s%14d%14d%14d%14d%14d%14d%14d%14d%14d%14d", BOLD + intentType + RESET, Strings.padStart(String.valueOf(total), (32 - intentType.length()), ' '), installed, withdrawn, failed, installReq, compiling, installing, recompiling, withdrawReq, withdrawing, unknownState));
    builder.append("\n" + SEPARATOR);
    return builder.toString();
}
#end_block

#method_before
private String detailsFormat(IntentService service, Intent intent) {
    StringBuilder builder = new StringBuilder();
    if (!intent.resources().isEmpty()) {
        builder.append("\n" + String.format(RESOURCES, intent.resources()));
    }
    if (intent instanceof ConnectivityIntent) {
        ConnectivityIntent ci = (ConnectivityIntent) intent;
        if (!ci.selector().criteria().isEmpty()) {
            builder.append("\n" + String.format(COMMON_SELECTOR, formatSelector(ci.selector())));
        }
        if (!ci.treatment().allInstructions().isEmpty()) {
            builder.append("\n" + String.format(TREATMENT, ci.treatment().allInstructions()));
        }
        if (ci.constraints() != null && !ci.constraints().isEmpty()) {
            builder.append("\n" + String.format(CONSTRAINTS, ci.constraints()));
        }
    }
    if (intent instanceof HostToHostIntent) {
        HostToHostIntent pi = (HostToHostIntent) intent;
        builder.append("\n" + String.format(SRC + HOST, pi.one()));
        builder.append("\n" + String.format(DST + HOST, pi.two()));
    } else if (intent instanceof PointToPointIntent) {
        PointToPointIntent pi = (PointToPointIntent) intent;
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredIngressPoint()), INGRESS));
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredEgressPoint()), EGRESS));
    } else if (intent instanceof MultiPointToSinglePointIntent) {
        MultiPointToSinglePointIntent pi = (MultiPointToSinglePointIntent) intent;
        builder.append("\n" + formatFilteredCps(pi.filteredIngressPoints(), INGRESS));
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredEgressPoint()), EGRESS));
    } else if (intent instanceof SinglePointToMultiPointIntent) {
        SinglePointToMultiPointIntent pi = (SinglePointToMultiPointIntent) intent;
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredIngressPoint()), INGRESS));
        builder.append("\n" + formatFilteredCps(pi.filteredEgressPoints(), EGRESS));
    } else if (intent instanceof PathIntent) {
        PathIntent pi = (PathIntent) intent;
        builder.append(String.format("path=%s, cost=%d", pi.path().links(), pi.path().cost()));
    } else if (intent instanceof LinkCollectionIntent) {
        LinkCollectionIntent li = (LinkCollectionIntent) intent;
        builder.append("\n" + String.format("links=%s", li.links()));
        builder.append("\n" + String.format(CP, li.egressPoints()));
    } else if (intent instanceof OpticalCircuitIntent) {
        OpticalCircuitIntent ci = (OpticalCircuitIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    } else if (intent instanceof OpticalConnectivityIntent) {
        OpticalConnectivityIntent ci = (OpticalConnectivityIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    } else if (intent instanceof OpticalOduIntent) {
        OpticalOduIntent ci = (OpticalOduIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    }
    List<Intent> installable = service.getInstallableIntents(intent.key());
    installable.stream().filter(i -> contentFilter.filter(i));
    if (showInstallable && installable != null && !installable.isEmpty()) {
        builder.append("\n" + String.format(INSTALLABLE, installable));
    }
    return builder.toString();
}
#method_after
private String detailsFormat(IntentService service, Intent intent) {
    StringBuilder builder = new StringBuilder();
    if (!intent.resources().isEmpty()) {
        builder.append("\n" + String.format(RESOURCES, intent.resources()));
    }
    if (intent instanceof ConnectivityIntent) {
        ConnectivityIntent ci = (ConnectivityIntent) intent;
        if (!ci.selector().criteria().isEmpty()) {
            builder.append("\n" + String.format(COMMON_SELECTOR, formatSelector(ci.selector())));
        }
        if (!ci.treatment().allInstructions().isEmpty()) {
            builder.append("\n" + String.format(TREATMENT, ci.treatment().allInstructions()));
        }
        if (ci.constraints() != null && !ci.constraints().isEmpty()) {
            builder.append("\n" + String.format(CONSTRAINTS, ci.constraints()));
        }
    }
    if (intent instanceof HostToHostIntent) {
        HostToHostIntent pi = (HostToHostIntent) intent;
        builder.append("\n" + String.format(SRC + HOST, pi.one()));
        builder.append("\n" + String.format(DST + HOST, pi.two()));
    } else if (intent instanceof PointToPointIntent) {
        PointToPointIntent pi = (PointToPointIntent) intent;
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredIngressPoint()), INGRESS));
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredEgressPoint()), EGRESS));
    } else if (intent instanceof MultiPointToSinglePointIntent) {
        MultiPointToSinglePointIntent pi = (MultiPointToSinglePointIntent) intent;
        builder.append("\n" + formatFilteredCps(pi.filteredIngressPoints(), INGRESS));
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredEgressPoint()), EGRESS));
    } else if (intent instanceof SinglePointToMultiPointIntent) {
        SinglePointToMultiPointIntent pi = (SinglePointToMultiPointIntent) intent;
        builder.append("\n" + formatFilteredCps(Sets.newHashSet(pi.filteredIngressPoint()), INGRESS));
        builder.append("\n" + formatFilteredCps(pi.filteredEgressPoints(), EGRESS));
    } else if (intent instanceof PathIntent) {
        PathIntent pi = (PathIntent) intent;
        builder.append(String.format("path=%s, cost=%f", pi.path().links(), pi.path().cost()));
    } else if (intent instanceof LinkCollectionIntent) {
        LinkCollectionIntent li = (LinkCollectionIntent) intent;
        builder.append("\n" + String.format("links=%s", li.links()));
        builder.append("\n" + String.format(CP, li.egressPoints()));
    } else if (intent instanceof OpticalCircuitIntent) {
        OpticalCircuitIntent ci = (OpticalCircuitIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    } else if (intent instanceof OpticalConnectivityIntent) {
        OpticalConnectivityIntent ci = (OpticalConnectivityIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    } else if (intent instanceof OpticalOduIntent) {
        OpticalOduIntent ci = (OpticalOduIntent) intent;
        builder.append("\n" + String.format("src=%s, dst=%s", ci.getSrc(), ci.getDst()));
    }
    List<Intent> installable = service.getInstallableIntents(intent.key());
    installable.stream().filter(i -> contentFilter.filter(i));
    if (showInstallable && installable != null && !installable.isEmpty()) {
        builder.append("\n" + String.format(INSTALLABLE, installable));
    }
    return builder.toString();
}
#end_block

#method_before
private void printIntents(IntentService service) {
    for (Intent intent : service.getIntents()) {
        IntentState state = service.getIntentState(intent.key());
        String intentFormat = fullFormat(intent, state.toString());
        String detailsIntentFormat = detailsFormat(service, intent);
        if (state != null && (contentFilter.filter(intentFormat + detailsIntentFormat))) {
            StringBuilder builder = new StringBuilder();
            builder.append(intentFormat).append(detailsIntentFormat).append("\n" + SEPARATOR);
            print(builder.toString());
        }
    }
}
#method_after
private void printIntents(IntentService service) {
    for (Intent intent : service.getIntents()) {
        IntentState state = service.getIntentState(intent.key());
        String intentFormat = fullFormat(intent, state.toString());
        String detailsIntentFormat = detailsFormat(service, intent);
        if (state != null && (contentFilter.filter(intentFormat + detailsIntentFormat))) {
            StringBuilder builder = new StringBuilder();
            builder.append(intentFormat).append(detailsIntentFormat).append("\n");
            print(builder.toString());
        }
    }
}
#end_block

#method_before
public static IntentId valueOf(String id) {
    checkArgument(id.startsWith("0x"), "Invalid id: %s", id);
    return valueOf(Long.parseUnsignedLong(id.substring(2), 16));
}
#method_after
public static IntentId valueOf(String id) {
    checkArgument(id.startsWith(HEX_PREFIX), "Invalid id: %s", id);
    return valueOf(Long.parseUnsignedLong(id.substring(2), 16));
}
#end_block

#method_before
@Override
public String toString() {
    return "0x" + Long.toHexString(identifier);
}
#method_after
@Override
public String toString() {
    return HEX_PREFIX + Long.toHexString(identifier);
}
#end_block

#method_before
@Override
protected void execute() {
    if (idsStr != null) {
        ids = idsStr.stream().map(IntentId::valueOf).collect(Collectors.toSet());
    }
    IntentService service = get(IntentService.class);
    StreamSupport.stream(service.getIntentData().spliterator(), false).filter(this::filter).forEach(this::printIntentData);
}
#method_after
@Override
protected void execute() {
    if (idsStr != null) {
        ids = idsStr.stream().map(IntentId::valueOf).collect(Collectors.toSet());
    }
    IntentService service = get(IntentService.class);
    Tools.stream(service.getIntentData()).filter(this::filter).forEach(this::printIntentData);
}
#end_block

#method_before
private void printIntentData(IntentData data) {
    print("Key: %s ID: %s", data.key(), data.intent().id());
    print(" Request: %s Current: %s", data.request(), data.state());
    print(" intent: %s", s(data.intent()));
    data.installables().stream().forEach(this::printeInstallable);
    // empty line
    print("");
}
#method_after
private void printIntentData(IntentData data) {
    print("Key: %s ID: %s", data.key(), data.intent().id());
    print(" Request: %s Current: %s", data.request(), data.state());
    print(" intent: %s", s(data.intent()));
    data.installables().stream().forEach(this::printInstallable);
    // empty line
    print("");
}
#end_block

#method_before
private void addProtection(DeviceId did, ProtectionConfig added) {
    ProtectedTransportEndpointDescription description = added.asDescription();
    log.info("adding protection {}", description);
    ProtectionConfigBehaviour behaviour = getBehaviour(did);
    CompletableFuture<ConnectPoint> result;
    result = behaviour.createProtectionEndpoint(description);
    result.handle((vPort, e) -> {
        if (vPort != null) {
            log.info("Virtual Port {} created for {}", vPort, description);
            log.debug("{}", deviceService.getPort(vPort));
        } else {
            log.error("Protection {} exceptionally failed.", added, e);
        }
        return vPort;
    });
}
#method_after
private void addProtection(DeviceId did, ProtectionConfig added) {
    ProtectedTransportEndpointDescription description = added.asDescription();
    log.info("adding protection {}-{}", did, description);
    ProtectionConfigBehaviour behaviour = getBehaviour(did);
    CompletableFuture<ConnectPoint> result;
    result = behaviour.createProtectionEndpoint(description);
    result.handle((vPort, e) -> {
        if (vPort != null) {
            log.info("Virtual Port {} created for {}", vPort, description);
            log.debug("{}", deviceService.getPort(vPort));
        } else {
            log.error("Protection {} exceptionally failed.", added, e);
        }
        return vPort;
    });
}
#end_block

#method_before
private void updateProtection(DeviceId did, ProtectionConfig before, ProtectionConfig after) {
    ProtectedTransportEndpointDescription description = after.asDescription();
    log.info("updating protection {}", description);
    ProtectionConfigBehaviour behaviour = getBehaviour(did);
    Optional<ConnectPoint> existing = findFirstVirtualPort(behaviour, after.fingerprint());
    if (!existing.isPresent()) {
        log.warn("Update requested, but not found, falling back as add");
        addProtection(did, after);
        return;
    }
    ConnectPoint vPort = existing.get();
    log.info("updating protection virtual Port {} : {}", vPort, description);
    behaviour.updateProtectionEndpoint(vPort, description).handle((vPortNew, e) -> {
        if (vPort != null) {
            log.info("Virtual Port {} updated for {}", vPort, description);
            log.debug("{}", deviceService.getPort(vPort));
        } else {
            log.error("Protection {} -> {} exceptionally failed.", before, after, e);
        }
        return vPort;
    });
}
#method_after
private void updateProtection(DeviceId did, ProtectionConfig before, ProtectionConfig after) {
    ProtectedTransportEndpointDescription description = after.asDescription();
    log.info("updating protection {}-{}", did, description);
    ProtectionConfigBehaviour behaviour = getBehaviour(did);
    Optional<ConnectPoint> existing = findFirstVirtualPort(behaviour, after.fingerprint());
    if (!existing.isPresent()) {
        log.warn("Update requested, but not found, falling back as add");
        addProtection(did, after);
        return;
    }
    ConnectPoint vPort = existing.get();
    log.info("updating protection virtual Port {} : {}", vPort, description);
    behaviour.updateProtectionEndpoint(vPort, description).handle((vPortNew, e) -> {
        if (vPort != null) {
            log.info("Virtual Port {} updated for {}", vPort, description);
            log.debug("{}", deviceService.getPort(vPort));
        } else {
            log.error("Protection {} -> {} exceptionally failed.", before, after, e);
        }
        return vPort;
    });
}
#end_block

#method_before
private void removeProtection(DeviceId did, ProtectionConfig removed) {
    ProtectedTransportEndpointDescription description = removed.asDescription();
    log.info("removing protection {}", description);
    ProtectionConfigBehaviour behaviour = getBehaviour(did);
    final String fingerprint = removed.fingerprint();
    Optional<ConnectPoint> existing = findFirstVirtualPort(behaviour, removed.fingerprint());
    if (!existing.isPresent()) {
        log.warn("Remove requested, but not found, ignoring");
        return;
    }
    ConnectPoint vPort = existing.get();
    log.info("removing protection virtual port {} : {}", vPort, description);
    behaviour.deleteProtectionEndpoint(vPort).handle((result, ex) -> {
        if (ex != null) {
            log.info("removed protection {} : {}", vPort, result);
        } else {
            log.warn("removed protection {} failed.", vPort, ex);
        }
        return result;
    });
}
#method_after
private void removeProtection(DeviceId did, ProtectionConfig removed) {
    ProtectedTransportEndpointDescription description = removed.asDescription();
    log.info("removing protection {}-{}", did, description);
    ProtectionConfigBehaviour behaviour = getBehaviour(did);
    Optional<ConnectPoint> existing = findFirstVirtualPort(behaviour, removed.fingerprint());
    if (!existing.isPresent()) {
        log.warn("Remove requested, but not found, ignoring");
        return;
    }
    ConnectPoint vPort = existing.get();
    log.info("removing protection virtual port {} : {}", vPort, description);
    behaviour.deleteProtectionEndpoint(vPort).handle((result, ex) -> {
        if (ex != null) {
            log.info("removed protection {} : {}", vPort, result);
        } else {
            log.warn("removed protection {} failed.", vPort, ex);
        }
        return result;
    });
}
#end_block

#method_before
protected void processEvent(NetworkConfigEvent event) {
    final DeviceId did = (DeviceId) event.subject();
    log.info("DEBUG: {} to {}: {}", event.type(), did, event);
    if (deviceService.getRole(did) != MastershipRole.MASTER) {
        log.trace("Not my problem. {}", event);
        return;
    }
    switch(event.type()) {
        case CONFIG_ADDED:
            addProtection(did, (ProtectionConfig) event.config().get());
            break;
        case CONFIG_UPDATED:
            updateProtection(did, (ProtectionConfig) event.prevConfig().get(), (ProtectionConfig) event.config().get());
            break;
        case CONFIG_REMOVED:
            removeProtection(did, (ProtectionConfig) event.prevConfig().get());
            break;
        case CONFIG_REGISTERED:
        case CONFIG_UNREGISTERED:
        default:
            log.warn("Ignoring unexpected event: {}", event);
            break;
    }
}
#method_after
protected void processEvent(NetworkConfigEvent event) {
    final DeviceId did = (DeviceId) event.subject();
    log.debug("{} to {}: {}", event.type(), did, event);
    if (deviceService.getRole(did) != MastershipRole.MASTER) {
        log.debug("Not the master, ignoring. {}", event);
        return;
    }
    switch(event.type()) {
        case CONFIG_ADDED:
            addProtection(did, (ProtectionConfig) event.config().get());
            break;
        case CONFIG_UPDATED:
            updateProtection(did, (ProtectionConfig) event.prevConfig().get(), (ProtectionConfig) event.config().get());
            break;
        case CONFIG_REMOVED:
            removeProtection(did, (ProtectionConfig) event.prevConfig().get());
            break;
        case CONFIG_REGISTERED:
        case CONFIG_UNREGISTERED:
        default:
            log.warn("Ignoring unexpected event: {}", event);
            break;
    }
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("type", type).add("data", Arrays.toString(data)).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("type", type).add("data", data).toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    for (Option option : this.options) {
        result = prime * result + option.type();
        result = prime * result + Arrays.hashCode(option.data());
    }
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(this.options.toArray());
}
#end_block

#method_before
protected <T> List<T> getList(String name, Function<String, T> function) {
    List<T> list = Lists.newArrayList();
    ArrayNode arrayNode = (ArrayNode) object.path(name);
    arrayNode.forEach(i -> list.add(function.apply(i.asText())));
    return list;
}
#method_after
protected <T> List<T> getList(String name, Function<String, T> function) {
    List<T> list = Lists.newArrayList();
    ArrayNode arrayNode = (ArrayNode) object.path(name);
    arrayNode.forEach(i -> list.add(function.apply(asString(i))));
    return list;
}
#end_block

#method_before
protected <T> List<T> getList(String name, Function<String, T> function, List<T> defaultValue) {
    List<T> list = Lists.newArrayList();
    JsonNode jsonNode = object.path(name);
    if (jsonNode.isMissingNode()) {
        return defaultValue;
    }
    ArrayNode arrayNode = (ArrayNode) jsonNode;
    arrayNode.forEach(i -> list.add(function.apply(i.asText())));
    return list;
}
#method_after
protected <T> List<T> getList(String name, Function<String, T> function, List<T> defaultValue) {
    List<T> list = Lists.newArrayList();
    JsonNode jsonNode = object.path(name);
    if (jsonNode.isMissingNode()) {
        return defaultValue;
    }
    ArrayNode arrayNode = (ArrayNode) jsonNode;
    arrayNode.forEach(i -> list.add(function.apply(asString(i))));
    return list;
}
#end_block

#method_before
Element updateNameAndNamespace(YdtContext ydtContext, Element xmlElement) {
    String nameSpace = null;
    if (ydtContext.getNamespace() != null) {
        nameSpace = ydtContext.getNamespace();
    }
    String parentNameSpace = null;
    if (ydtContext.getParent() != null) {
        parentNameSpace = ydtContext.getParent().getNamespace();
    }
    Element newElement;
    if (nameSpace != null) {
        newElement = xmlElement.addElement(ydtContext.getName(), nameSpace);
    } else {
        if (parentNameSpace != null) {
            newElement = xmlElement.addElement(ydtContext.getName(), parentNameSpace);
        } else {
            newElement = xmlElement.addElement(ydtContext.getName());
        }
    }
    YdtContextOperationType opType = ((YdtExtendedContext) ydtContext).getYdtContextOperationType();
    if (opType != null && opType != NONE) {
        newElement.addAttribute("nc:" + OPERATION, opType.toString().toLowerCase());
        addNsToRootElement(newElement);
    }
    return newElement;
}
#method_after
Element updateNameAndNamespace(YdtContext ydtContext, Element xmlElement) {
    String nameSpace = null;
    if (ydtContext.getNamespace() != null) {
        nameSpace = ydtContext.getNamespace();
    }
    String parentNameSpace = null;
    if (ydtContext.getParent() != null) {
        parentNameSpace = ydtContext.getParent().getNamespace();
    }
    Element newElement;
    if (nameSpace != null) {
        newElement = xmlElement.addElement(ydtContext.getName(), nameSpace);
    } else {
        if (parentNameSpace != null) {
            newElement = xmlElement.addElement(ydtContext.getName(), parentNameSpace);
        } else {
            newElement = xmlElement.addElement(ydtContext.getName());
        }
    }
    YdtContextOperationType opType = ((YdtExtendedContext) ydtContext).getYdtContextOperationType();
    if (opType != null && opType != NONE) {
        newElement.addAttribute("nc:" + OPERATION, opType.toString().toLowerCase());
    }
    return newElement;
}
#end_block

#method_before
private static String merchandXml() {
    return "<config xmlns=\"ydt.root\">" + "<supervisor xmlns=\"ydt.Merchandiser-supervisor\">" + "Merchandisersupervisor</supervisor>" + "</config>";
}
#method_after
private static String merchandXml() {
    return "<config xmlns=\"ydt.root\" " + "xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">" + "<supervisor xmlns=\"ydt.Merchandiser-supervisor\">" + "Merchandisersupervisor</supervisor>" + "</config>";
}
#end_block

#method_before
private static String tradingXml() {
    return "<config xmlns=\"ydt.root\">" + "<supervisor xmlns=\"ydt.trading-supervisor\">" + "Tradingsupervisor</supervisor>" + "</config>";
}
#method_after
private static String tradingXml() {
    return "<config xmlns=\"ydt.root\" " + "xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">" + "<supervisor xmlns=\"ydt.trading-supervisor\">" + "Tradingsupervisor</supervisor>" + "</config>";
}
#end_block

#method_before
private static String purchaseXml() {
    return "<config xmlns=\"ydt.root\">" + "<ych-purchasing-supervisor xmlns=\"ych.purchasing-supervisor\" " + "xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\" " + "nc:operation=\"create\">" + "<ych-purchasing-specialist>purchasingSpecialist" + "</ych-purchasing-specialist>" + "<ych-purchasing-support>support</ych-purchasing-support>" + "</ych-purchasing-supervisor>" + "</config>";
}
#method_after
private static String purchaseXml() {
    return "<config xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" " + "xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">" + "<ych-purchasing-supervisor xmlns=\"ych.purchasing-supervisor\" " + "nc:operation=\"create\">" + "<ych-purchasing-specialist>purchasingSpecialist" + "</ych-purchasing-specialist>" + "<ych-purchasing-support>support</ych-purchasing-support>" + "</ych-purchasing-supervisor>" + "</config>";
}
#end_block

#method_before
// TODO negative scenario will be handled later
@Test
public void proceessCodecHandlerForContainer() {
    testYangSchemaNodeProvider.processSchemaRegistry(null);
    DefaultYangSchemaRegistry schemaRegistry = testYangSchemaNodeProvider.getDefaultYangSchemaRegistry();
    List<Object> yangModuleList = new ArrayList<>();
    // Creating the object
    YchPurchasingSupervisor supervisor = new DefaultYchPurchasingSupervisor.YchPurchasingSupervisorBuilder().ychPurchasingSpecialist("purchasingSpecialist").ychPurchasingSupport("support").yangYchPurchasingSupervisorOpType(OnosYangOpType.CREATE).build();
    Object object = YchPurchasingsupervisorOpParam.builder().ychPurchasingSupervisor(supervisor).build();
    yangModuleList.add(object);
    YangCodecRegistry.initializeDefaultCodec();
    DefaultYangCodecHandler codecHandler = new DefaultYangCodecHandler(schemaRegistry);
    String xml = codecHandler.encodeOperation("config", "ydt.root", null, yangModuleList, XML, null);
    assertEquals(AM_XML + "puchas-super: container info", purchaseXml(), xml);
}
#method_after
// TODO negative scenario will be handled later
@Test
public void proceessCodecHandlerForContainer() {
    testYangSchemaNodeProvider.processSchemaRegistry(null);
    DefaultYangSchemaRegistry schemaRegistry = testYangSchemaNodeProvider.getDefaultYangSchemaRegistry();
    List<Object> yangModuleList = new ArrayList<>();
    // Creating the object
    YchPurchasingSupervisor supervisor = new DefaultYchPurchasingSupervisor.YchPurchasingSupervisorBuilder().ychPurchasingSpecialist("purchasingSpecialist").ychPurchasingSupport("support").yangYchPurchasingSupervisorOpType(OnosYangOpType.CREATE).build();
    Object object = YchPurchasingsupervisorOpParam.builder().ychPurchasingSupervisor(supervisor).build();
    yangModuleList.add(object);
    YangCodecRegistry.initializeDefaultCodec();
    DefaultYangCodecHandler codecHandler = new DefaultYangCodecHandler(schemaRegistry);
    String xml = codecHandler.encodeOperation("config", "urn:ietf:params:xml:ns:netconf:base:1.0", null, yangModuleList, XML, null);
    assertEquals(AM_XML + "puchas-super: container info", purchaseXml(), xml);
}
#end_block

#method_before
private boolean testDeviceConnection(RestSBDevice device) {
    try {
        String testUrl = "";
        if (device.testUrl().isPresent()) {
            testUrl = device.testUrl().get();
        }
        return controller.get(device.deviceId(), testUrl, "json") != null;
    } catch (ProcessingException e) {
        log.warn("Cannot connect to device {}", device, e);
    }
    return false;
}
#method_after
private boolean testDeviceConnection(RestSBDevice dev) {
    try {
        if (dev.testUrl().isPresent()) {
            return controller.get(dev.deviceId(), dev.testUrl().get(), JSON) != null;
        }
        return controller.get(dev.deviceId(), "", JSON) != null;
    } catch (ProcessingException e) {
        log.warn("Cannot connect to device {}", dev, e);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("url", url).add("testUrl", testUrl).add("protocol", protocol).add("username", username).add("port", port).add("ip", ip).add("manufacturer", manufacturer).add("hwVersion", hwVersion).add("swVersion", swVersion).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).omitNullValues().add("url", url).add("testUrl", testUrl).add("protocol", protocol).add("username", username).add("port", port).add("ip", ip).add("manufacturer", manufacturer.orElse(null)).add("hwVersion", hwVersion.orElse(null)).add("swVersion", swVersion.orElse(null)).toString();
}
#end_block

#method_before
protected SinglePointToMultiPointIntent buildBrcIntent(Key key, FilteredConnectPoint src, Set<FilteredConnectPoint> dsts, EncapsulationType encap) {
    log.debug("Building broadcast intent {} for source {}", SP2MP, src);
    SinglePointToMultiPointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
    intentBuilder = SinglePointToMultiPointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoint(src).filteredEgressPoints(dsts).constraints(PARTIAL_FAILURE_CONSTAINT).priority(PRIORITY_OFFSET);
    setEncap(intentBuilder, PARTIAL_FAILURE_CONSTAINT, encap);
    return intentBuilder.build();
}
#method_after
protected SinglePointToMultiPointIntent buildBrcIntent(Key key, FilteredConnectPoint src, Set<FilteredConnectPoint> dsts, EncapsulationType encap) {
    log.debug("Building broadcast intent {} for source {}", SP2MP, src);
    SinglePointToMultiPointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
    intentBuilder = SinglePointToMultiPointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoint(src).filteredEgressPoints(dsts).constraints(PARTIAL_FAILURE_CONSTRAINT).priority(PRIORITY_OFFSET);
    setEncap(intentBuilder, PARTIAL_FAILURE_CONSTRAINT, encap);
    return intentBuilder.build();
}
#end_block

#method_before
protected MultiPointToSinglePointIntent buildUniIntent(Key key, Set<FilteredConnectPoint> srcs, FilteredConnectPoint dst, Host host, EncapsulationType encap) {
    log.debug("Building unicast intent {} for destination {}", MP2SP, dst);
    MultiPointToSinglePointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
    intentBuilder = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoints(srcs).filteredEgressPoint(dst).constraints(PARTIAL_FAILURE_CONSTAINT).priority(PRIORITY_OFFSET);
    setEncap(intentBuilder, PARTIAL_FAILURE_CONSTAINT, encap);
    return intentBuilder.build();
}
#method_after
protected MultiPointToSinglePointIntent buildUniIntent(Key key, Set<FilteredConnectPoint> srcs, FilteredConnectPoint dst, Host host, EncapsulationType encap) {
    log.debug("Building unicast intent {} for destination {}", MP2SP, dst);
    MultiPointToSinglePointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
    intentBuilder = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoints(srcs).filteredEgressPoint(dst).constraints(PARTIAL_FAILURE_CONSTRAINT).priority(PRIORITY_OFFSET);
    setEncap(intentBuilder, PARTIAL_FAILURE_CONSTRAINT, encap);
    return intentBuilder.build();
}
#end_block

#method_before
private static void setEncap(ConnectivityIntent.Builder builder, List<Constraint> constraints, EncapsulationType encap) {
    // Constraints might be an immutable list, so a new modifiable list
    // is created
    List<Constraint> newConstraints = new ArrayList<>(constraints);
    // Remove any encapsulation constraint if already in the list
    constraints.stream().filter(c -> c instanceof EncapsulationConstraint).forEach(c -> newConstraints.remove(c));
    // constraint should be added to the list
    if (!encap.equals(NONE)) {
        newConstraints.add(new EncapsulationConstraint(encap));
    }
    // Submit new constraint list as immutable list
    builder.constraints(ImmutableList.copyOf(newConstraints));
}
#method_after
public static void setEncap(ConnectivityIntent.Builder builder, List<Constraint> constraints, EncapsulationType encap) {
    // Constraints might be an immutable list, so a new modifiable list
    // is created
    List<Constraint> newConstraints = new ArrayList<>(constraints);
    // Remove any encapsulation constraint if already in the list
    constraints.stream().filter(c -> c instanceof EncapsulationConstraint).forEach(newConstraints::remove);
    // constraint should be added to the list
    if (!encap.equals(NONE)) {
        newConstraints.add(new EncapsulationConstraint(encap));
    }
    // Submit new constraint list as immutable list
    builder.constraints(ImmutableList.copyOf(newConstraints));
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    configService.removeListener(configListener);
    intentSynchronizer.removeIntentsByAppId(appId);
    log.info("Deactivated");
}
#method_after
@Deactivate
public void deactivate() {
    hostService.removeListener(hostListener);
    interfaceService.removeListener(interfaceListener);
    configService.removeListener(configListener);
    intentSynchronizer.removeIntentsByAppId(appId);
    log.info("Deactivated");
}
#end_block

#method_before
private SinglePointToMultiPointIntent buildBrcIntent(Key key, FilteredConnectPoint src, Set<FilteredConnectPoint> dsts, EncapsulationType encap) {
    SinglePointToMultiPointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
    intentBuilder = SinglePointToMultiPointIntent.builder().appId(APPID).key(key).selector(selector).filteredIngressPoint(src).filteredEgressPoints(dsts).constraints(PARTIAL_FAILURE_CONSTAINT).priority(PRIORITY_OFFSET);
    setEncap(intentBuilder, PARTIAL_FAILURE_CONSTAINT, encap);
    return intentBuilder.build();
}
#method_after
private SinglePointToMultiPointIntent buildBrcIntent(Key key, FilteredConnectPoint src, Set<FilteredConnectPoint> dsts, EncapsulationType encap) {
    SinglePointToMultiPointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
    intentBuilder = SinglePointToMultiPointIntent.builder().appId(APPID).key(key).selector(selector).filteredIngressPoint(src).filteredEgressPoints(dsts).constraints(PARTIAL_FAILURE_CONSTRAINT).priority(PRIORITY_OFFSET);
    setEncap(intentBuilder, PARTIAL_FAILURE_CONSTRAINT, encap);
    return intentBuilder.build();
}
#end_block

#method_before
private MultiPointToSinglePointIntent buildUniIntent(Key key, Set<FilteredConnectPoint> srcs, FilteredConnectPoint dst, Host host, EncapsulationType encap) {
    MultiPointToSinglePointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
    intentBuilder = MultiPointToSinglePointIntent.builder().appId(APPID).key(key).selector(selector).filteredIngressPoints(srcs).filteredEgressPoint(dst).constraints(PARTIAL_FAILURE_CONSTAINT).priority(PRIORITY_OFFSET);
    setEncap(intentBuilder, PARTIAL_FAILURE_CONSTAINT, encap);
    return intentBuilder.build();
}
#method_after
private MultiPointToSinglePointIntent buildUniIntent(Key key, Set<FilteredConnectPoint> srcs, FilteredConnectPoint dst, Host host, EncapsulationType encap) {
    MultiPointToSinglePointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
    intentBuilder = MultiPointToSinglePointIntent.builder().appId(APPID).key(key).selector(selector).filteredIngressPoints(srcs).filteredEgressPoint(dst).constraints(PARTIAL_FAILURE_CONSTRAINT).priority(PRIORITY_OFFSET);
    setEncap(intentBuilder, PARTIAL_FAILURE_CONSTRAINT, encap);
    return intentBuilder.build();
}
#end_block

#method_before
void value(Object val) {
    this.val = val;
}
#method_after
LeafListKeyBuilder value(Object val) {
    this.val = val;
    return this;
}
#end_block

#method_before
public Builder addBranchPointSchema(String name, String nameSpace) {
    if (curKeyBuilder != null) {
        if (curKeyBuilder instanceof LeafListKey.LeafListKeyBuilder) {
            throw new ModelException(LEAF_IS_TERMINAL);
        }
        curKey = curKeyBuilder.build();
        nodeKeyList.add(curKey);
    }
    curKeyBuilder = new NodeKey.NodeKeyBuilder();
    curKeyBuilder.schemaId(name, nameSpace);
    return this;
}
#method_after
public Builder addBranchPointSchema(String name, String nameSpace) {
    if (curKeyBuilder != null) {
        if (curKeyBuilder instanceof LeafListKey.LeafListKeyBuilder) {
            throw new ModelException(LEAF_IS_TERMINAL);
        }
        nodeKeyList.add(curKeyBuilder.build());
    }
    curKeyBuilder = new NodeKey.NodeKeyBuilder();
    curKeyBuilder.schemaId(name, nameSpace);
    return this;
}
#end_block

#method_before
public ResourceId build() {
    if (curKeyBuilder == null) {
        throw new ModelException(NO_KEY_SET);
    }
    curKey = curKeyBuilder.build();
    nodeKeyList.add(curKey);
    return new ResourceId(this);
}
#method_after
public ResourceId build() {
    if (curKeyBuilder == null) {
        throw new ModelException(NO_KEY_SET);
    }
    nodeKeyList.add(curKeyBuilder.build());
    return new ResourceId(this);
}
#end_block

#method_before
public NodeKey build() {
    if (schemaId.name() == null || schemaId.namespace() == null) {
        throw new ModelException(INCOMPLETE_SCHEMA_INFO);
    }
    return new NodeKey(this);
}
#method_after
public NodeKey build() {
    checkNotNull(schemaId.name(), INCOMPLETE_SCHEMA_INFO);
    checkNotNull(schemaId.namespace(), INCOMPLETE_SCHEMA_INFO);
    return new NodeKey(this);
}
#end_block

#method_before
private String insertConfig(String childTableName, String childColumnName, String parentTableName, String parentColumnName, String parentUuid, Row row) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema tableSchema = dbSchema.getTableSchema(childTableName);
    Insert insert = new Insert(tableSchema, childTableName, row);
    ArrayList<Operation> operations = Lists.newArrayList();
    operations.add(insert);
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.insert(parentColumnSchema.name(), Uuid.uuid(childTableName));
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(parentUuid));
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    if (childTableName.equalsIgnoreCase(PORT)) {
        log.debug("Handle port insert");
        Insert intfInsert = handlePortInsertTable(row);
        if (intfInsert != null) {
            operations.add(intfInsert);
        }
        Insert ins = (Insert) operations.get(0);
        ins.getRow().put("interfaces", Uuid.uuid(INTERFACE));
    }
    List<OperationResult> results;
    try {
        results = transactConfig(DATABASENAME, operations).get(3, TimeUnit.SECONDS);
        return results.get(0).getUuid().value();
    } catch (TimeoutException e) {
        log.warn("TimeoutException thrown while to get result");
    } catch (InterruptedException e) {
        log.warn("Interrupted while waiting to get result");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
        log.error("Exception thrown while to get result");
    }
    return null;
}
#method_after
private String insertConfig(String childTableName, String childColumnName, String parentTableName, String parentColumnName, String parentUuid, Row row) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema tableSchema = dbSchema.getTableSchema(childTableName);
    Insert insert = new Insert(tableSchema, childTableName, row);
    ArrayList<Operation> operations = Lists.newArrayList();
    operations.add(insert);
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.insert(parentColumnSchema.name(), Uuid.uuid(childTableName));
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(parentUuid));
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    if (childTableName.equalsIgnoreCase(PORT)) {
        log.debug("Handle port insert");
        Insert intfInsert = handlePortInsertTable(row);
        if (intfInsert != null) {
            operations.add(intfInsert);
        }
        Insert ins = (Insert) operations.get(0);
        ins.getRow().put("interfaces", Uuid.uuid(INTERFACE));
    }
    List<OperationResult> results;
    try {
        results = transactConfig(DATABASENAME, operations).get(TRANSACTCONFIG_TIMEOUT, TimeUnit.SECONDS);
        return results.get(0).getUuid().value();
    } catch (TimeoutException e) {
        log.warn("TimeoutException thrown while to get result");
    } catch (InterruptedException e) {
        log.warn("Interrupted while waiting to get result");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
        log.error("Exception thrown while to get result");
    }
    return null;
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder hostSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API);
    hostsConsistentMap = storageService.<HostId, DefaultHost>consistentMapBuilder().withName("onos-hosts").withRelaxedReadConsistency().withSerializer(Serializer.using(hostSerializer.build())).build();
    hosts = hostsConsistentMap.asJavaMap();
    hostsTimestamp = storageService.<HostId, Timestamp>eventuallyConsistentMapBuilder().withName("onos-hosts-timestamp").withTimestampProvider((k, v) -> new WallClockTimestamp()).withSerializer(hostSerializer).build();
    hostsConsistentMap.addListener(hostLocationTracker);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    configService.registerProperties(getClass());
    KryoNamespace.Builder hostSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API);
    hostsConsistentMap = storageService.<HostId, DefaultHost>consistentMapBuilder().withName("onos-hosts").withRelaxedReadConsistency().withSerializer(Serializer.using(hostSerializer.build())).build();
    hosts = hostsConsistentMap.asJavaMap();
    hostsTimestamp = storageService.<HostId, Timestamp>eventuallyConsistentMapBuilder().withName("onos-hosts-timestamp").withTimestampProvider((k, v) -> new WallClockTimestamp()).withSerializer(hostSerializer).build();
    hostsConsistentMap.addListener(hostLocationTracker);
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    hostsConsistentMap.removeListener(hostLocationTracker);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    configService.unregisterProperties(getClass(), false);
    hostsConsistentMap.removeListener(hostLocationTracker);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public HostEvent createOrUpdateHost(ProviderId providerId, HostId hostId, HostDescription hostDescription, boolean replaceIPs) {
    if (!hostDescription.ipAddress().isEmpty()) {
        hostsTimestamp.put(hostId, new WallClockTimestamp());
    }
    hostsConsistentMap.computeIf(hostId, existingHost -> shouldUpdate(existingHost, providerId, hostId, hostDescription, replaceIPs), (id, existingHost) -> {
        HostLocation location = hostDescription.location();
        final Set<IpAddress> addresses;
        if (existingHost == null || replaceIPs) {
            addresses = ImmutableSet.copyOf(hostDescription.ipAddress());
        } else {
            addresses = Sets.newHashSet(existingHost.ipAddresses());
            addresses.addAll(hostDescription.ipAddress());
        }
        final Annotations annotations;
        final boolean configured;
        if (existingHost != null) {
            annotations = merge((DefaultAnnotations) existingHost.annotations(), hostDescription.annotations());
            configured = existingHost.configured();
        } else {
            annotations = hostDescription.annotations();
            configured = hostDescription.configured();
        }
        return new DefaultHost(providerId, hostId, hostDescription.hwAddress(), hostDescription.vlan(), location, addresses, configured, annotations);
    });
    return null;
}
#method_after
@Override
public HostEvent createOrUpdateHost(ProviderId providerId, HostId hostId, HostDescription hostDescription, boolean replaceIPs) {
    if (recordHostTimestamp && !hostDescription.ipAddress().isEmpty()) {
        hostsTimestamp.put(hostId, new WallClockTimestamp());
    }
    hostsConsistentMap.computeIf(hostId, existingHost -> shouldUpdate(existingHost, providerId, hostId, hostDescription, replaceIPs), (id, existingHost) -> {
        HostLocation location = hostDescription.location();
        final Set<IpAddress> addresses;
        if (existingHost == null || replaceIPs) {
            addresses = ImmutableSet.copyOf(hostDescription.ipAddress());
        } else {
            addresses = Sets.newHashSet(existingHost.ipAddresses());
            addresses.addAll(hostDescription.ipAddress());
        }
        final Annotations annotations;
        final boolean configured;
        if (existingHost != null) {
            annotations = merge((DefaultAnnotations) existingHost.annotations(), hostDescription.annotations());
            configured = existingHost.configured();
        } else {
            annotations = hostDescription.annotations();
            configured = hostDescription.configured();
        }
        return new DefaultHost(providerId, hostId, hostDescription.hwAddress(), hostDescription.vlan(), location, addresses, configured, annotations);
    });
    return null;
}
#end_block

#method_before
@Override
public Timestamp getHostLastseenTime(HostId hostId) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public Timestamp getHostLastseenTime(HostId hostId) {
    return null;
}
#end_block

#method_before
@Override
public Timestamp getHostLastseenTime(HostId hostId) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public Timestamp getHostLastseenTime(HostId hostId) {
    return null;
}
#end_block

#method_before
@Activate
public void activate() {
    embeddingAlgorithm = new DefaultEmbeddingAlgorithm();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.virtual.vnet-flow");
    providerRegistryService.registerProvider(this);
    flowRuleListener = new InternalFlowRuleListener();
    flowRuleService.addListener(flowRuleListener);
    internalRoutingAlgorithm = new DefaultInternalRoutingAlgorithm();
    frm = new InternalVirtualFlowRuleManager();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
}
#method_after
@Deactivate
public void deactivate() {
    flowRuleService.removeListener(flowRuleListener);
    providerRegistryService.unregisterProvider(this);
}
#end_block

#method_before
@Override
public void applyFlowRule(NetworkId networkId, FlowRule... flowRules) {
    for (FlowRule flowRule : flowRules) {
        devirtualize(networkId, flowRule).forEach(r -> flowRuleService.applyFlowRules(r));
    }
}
#method_after
@Override
public void applyFlowRule(NetworkId networkId, FlowRule... flowRules) {
    for (FlowRule flowRule : flowRules) {
        devirtualize(networkId, flowRule).forEach(r -> {
            flowRuleService.applyFlowRules(r);
        });
    }
}
#end_block

#method_before
@Override
public void removeFlowRule(NetworkId networkId, FlowRule... flowRules) {
    for (FlowRule flowRule : flowRules) {
        devirtualize(networkId, flowRule).forEach(r -> flowRuleService.removeFlowRules(r));
    }
}
#method_after
@Override
public void removeFlowRule(NetworkId networkId, FlowRule... flowRules) {
    for (FlowRule flowRule : flowRules) {
        devirtualize(networkId, flowRule).forEach(r -> {
            flowRuleService.removeFlowRules(r);
        });
    }
}
#end_block

#method_before
public void setEmbeddingAlgorithm(EmbeddingAlgorithm embeddingAlgorithm) {
    this.embeddingAlgorithm = embeddingAlgorithm;
}
#method_after
public void setEmbeddingAlgorithm(InternalRoutingAlgorithm internalRoutingAlgorithm) {
    this.internalRoutingAlgorithm = internalRoutingAlgorithm;
}
#end_block

#method_before
private ImmutablePair<NetworkId, FlowRule> virtualize(FlowRule flowRule) {
    return null;
}
#method_after
private FlowRule virtualize(FlowRule flowRule) {
    return frm.getVirtualRule(flowRule);
}
#end_block

#method_before
private ImmutablePair<NetworkId, FlowRule> virtualize(FlowRule flowRule) {
    return null;
}
#method_after
private FlowEntry virtualize(FlowEntry flowEntry) {
    FlowRule vRule = virtualize(flowEntry);
    FlowEntry vEntry = new DefaultFlowEntry(vRule, flowEntry.state(), flowEntry.life(), flowEntry.packets(), flowEntry.bytes());
    return vEntry;
}
#end_block

#method_before
private Set<FlowRule> devirtualize(NetworkId networkId, FlowRule flowRule) {
    Set<VirtualPort> vPorts = virtualNetworkService.getVirtualPorts(networkId, flowRule.deviceId());
    PortNumber vInPortNum = ((PortCriterion) flowRule.selector().getCriterion(Criterion.Type.IN_PORT)).port();
    PortNumber vOutPortNum = flowRule.treatment().allInstructions().stream().filter(i -> i.type() == Instruction.Type.OUTPUT).map(i -> ((Instructions.OutputInstruction) i).port()).findFirst().get();
    // TODO support when a flow rule contains multiple in_port matching
    ConnectPoint ingressPoint = vPorts.stream().filter(v -> v.number() == vInPortNum).map(v -> v.realizedBy()).findFirst().get();
    ConnectPoint egressPoint = vPorts.stream().filter(v -> v.number() == vOutPortNum).map(v -> v.realizedBy()).findFirst().get();
    Set<FlowRule> outRules = new HashSet<>();
    TrafficSelector.Builder commonSelectorBuilder = DefaultTrafficSelector.builder();
    flowRule.selector().criteria().stream().filter(c -> c.type() != Criterion.Type.IN_PORT).forEach(c -> commonSelectorBuilder.add(c));
    TrafficSelector commonSelector = commonSelectorBuilder.build();
    TrafficTreatment.Builder commonTreatmentBuilder = DefaultTrafficTreatment.builder();
    flowRule.treatment().allInstructions().stream().filter(i -> i.type() != Instruction.Type.OUTPUT).forEach(i -> commonTreatmentBuilder.add(i));
    TrafficTreatment commonTreatement = commonTreatmentBuilder.build();
    if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
        // Traffic is handled inside a single physical switch
        // No tunnel is needed.
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder(commonSelector);
        selectorBuilder.matchInPort(ingressPoint.port());
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatement);
        treatmentBuilder.setOutput(egressPoint.port());
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder();
        ruleBuilder.forDevice(ingressPoint.deviceId());
        ruleBuilder.withSelector(selectorBuilder.build());
        ruleBuilder.withTreatment(treatmentBuilder.build());
        outRules.add(ruleBuilder.build());
    } else {
        // Traffic is handled by multiple physical switches
        // A tunnel is needed.
        Path internalPath = embeddingAlgorithm.findPath(ingressPoint, egressPoint);
        ConnectPoint inCp = ingressPoint;
        ConnectPoint outCp = internalPath.links().get(0).src();
        // ingress point of tunnel
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder(commonSelector);
        selectorBuilder.matchInPort(ingressPoint.port());
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatement);
        treatmentBuilder.pushVlan().setVlanId(VlanId.vlanId(networkId.id().shortValue()));
        treatmentBuilder.setOutput(outCp.port());
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder();
        ruleBuilder.forDevice(ingressPoint.deviceId());
        ruleBuilder.withSelector(selectorBuilder.build());
        ruleBuilder.withTreatment(treatmentBuilder.build());
        outRules.add(ruleBuilder.build());
        // routing inside tunnel
        inCp = internalPath.links().get(0).dst();
        for (Link l : internalPath.links().subList(1, internalPath.links().size() - 1)) {
            outCp = l.src();
            selectorBuilder = DefaultTrafficSelector.builder(commonSelector);
            selectorBuilder.matchVlanId(VlanId.vlanId(networkId.id().shortValue()));
            selectorBuilder.matchInPort(inCp.port());
            treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatement);
            treatmentBuilder.setOutput(outCp.port());
            ruleBuilder = DefaultFlowRule.builder();
            ruleBuilder.forDevice(inCp.deviceId());
            ruleBuilder.withSelector(selectorBuilder.build());
            ruleBuilder.withTreatment(treatmentBuilder.build());
            outRules.add(ruleBuilder.build());
            inCp = l.dst();
        }
        // egress point of tunnel
        selectorBuilder = DefaultTrafficSelector.builder(commonSelector);
        selectorBuilder.matchVlanId(VlanId.vlanId(networkId.id().shortValue()));
        selectorBuilder.matchInPort(ingressPoint.port());
        treatmentBuilder = DefaultTrafficTreatment.builder(commonTreatement);
        treatmentBuilder.popVlan();
        treatmentBuilder.setOutput(egressPoint.port());
        ruleBuilder = DefaultFlowRule.builder();
        ruleBuilder.forDevice(egressPoint.deviceId());
        ruleBuilder.withSelector(selectorBuilder.build());
        ruleBuilder.withTreatment(treatmentBuilder.build());
        outRules.add(ruleBuilder.build());
    }
    return outRules;
}
#method_after
private Set<FlowRule> devirtualize(NetworkId networkId, FlowRule flowRule) {
    Set<FlowRule> outRules = new HashSet<>();
    Set<VirtualPort> vPorts = virtualNetworkAdminService.getVirtualPorts(networkId, flowRule.deviceId());
    PortCriterion portCriterion = ((PortCriterion) flowRule.selector().getCriterion(Criterion.Type.IN_PORT));
    Set<ConnectPoint> ingressPoints = new HashSet<>();
    if (portCriterion != null) {
        PortNumber vInPortNum = portCriterion.port();
        Optional<ConnectPoint> optionalCp = vPorts.stream().filter(v -> v.number().equals(vInPortNum)).map(v -> v.realizedBy()).findFirst();
        if (!optionalCp.isPresent()) {
            log.info("Port {} is not realized yet, in Network {}, Device {}", vInPortNum, networkId, flowRule.deviceId());
            return outRules;
        }
        ingressPoints.add(optionalCp.get());
    } else {
        for (VirtualPort vPort : vPorts) {
            if (vPort.realizedBy() != null) {
                ingressPoints.add(vPort.realizedBy());
            } else {
                log.info("Port {} is not realized yet, in Network {}, " + "Device {}", vPort, networkId, flowRule.deviceId());
                return outRules;
            }
        }
    }
    PortNumber vOutPortNum = flowRule.treatment().allInstructions().stream().filter(i -> i.type() == Instruction.Type.OUTPUT).map(i -> ((Instructions.OutputInstruction) i).port()).findFirst().get();
    Optional<ConnectPoint> optionalCpOut = vPorts.stream().filter(v -> v.number().equals(vOutPortNum)).map(v -> v.realizedBy()).findFirst();
    if (!optionalCpOut.isPresent()) {
        log.info("Port {} is not realized yet, in Network {}, Device {}", vOutPortNum, networkId, flowRule.deviceId());
        return outRules;
    }
    ConnectPoint egressPoint = optionalCpOut.get();
    TrafficSelector.Builder commonSelectorBuilder = DefaultTrafficSelector.builder();
    flowRule.selector().criteria().stream().filter(c -> c.type() != Criterion.Type.IN_PORT).forEach(c -> commonSelectorBuilder.add(c));
    TrafficSelector commonSelector = commonSelectorBuilder.build();
    TrafficTreatment.Builder commonTreatmentBuilder = DefaultTrafficTreatment.builder();
    flowRule.treatment().allInstructions().stream().filter(i -> i.type() != Instruction.Type.OUTPUT).forEach(i -> commonTreatmentBuilder.add(i));
    TrafficTreatment commonTreatment = commonTreatmentBuilder.build();
    for (ConnectPoint ingressPoint : ingressPoints) {
        outRules.addAll(generateRules(networkId, ingressPoint, egressPoint, commonSelector, commonTreatment, flowRule));
    }
    return outRules;
}
#end_block

#method_before
protected Set<TestEdge> edges() {
    return of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(A, C, new TestWeight(3)), new TestEdge(B, D, new TestWeight(2)), new TestEdge(B, C, new TestWeight(1)), new TestEdge(B, E, new TestWeight(4)), new TestEdge(C, E, new TestWeight(1)), new TestEdge(D, H, new TestWeight(5)), new TestEdge(D, E, new TestWeight(1)), new TestEdge(E, F, new TestWeight(1)), new TestEdge(F, D, new TestWeight(1)), new TestEdge(F, G, new TestWeight(1)), new TestEdge(F, H, new TestWeight(1)));
}
#method_after
protected Set<TestEdge> edges() {
    return of(new TestEdge(A, B, W1), new TestEdge(A, C, W3), new TestEdge(B, D, W2), new TestEdge(B, C, W1), new TestEdge(B, E, W4), new TestEdge(C, E, W1), new TestEdge(D, H, W5), new TestEdge(D, E, W1), new TestEdge(E, F, W1), new TestEdge(F, D, W1), new TestEdge(F, G, W1), new TestEdge(F, H, W1));
}
#end_block

#method_before
@Override
public double cost() {
    if (usingPath1) {
        return path1.cost();
    }
    return path2.cost();
}
#method_after
@Override
public double cost() {
    return usingPath1 ? path1.cost() : path2.cost();
}
#end_block

#method_before
@Override
public double cost() {
    if (cost instanceof DefaultWeight) {
        return ((DefaultWeight) cost).getValue();
    } else {
        return 0;
    }
}
#method_after
@Override
public double cost() {
    if (cost instanceof ScalarWeight) {
        return ((ScalarWeight) cost).value();
    }
    return 0;
}
#end_block

#method_before
private Result<V, E> findShortestPathFromSubset(boolean[] subset) {
    Graph<V, E> graph = orig;
    EdgeWeigher<V, E> modified = new EdgeWeigher<V, E>() {

        final boolean[] subsetF = subset;

        @Override
        public Weight weight(E edge) {
            if (subsetF[riskGrouping.get(edge)]) {
                return weigher.weight(edge);
            }
            return weigher.getNonViableWeight();
        }

        @Override
        public Weight getNullPathWeight() {
            return weigher.getNullPathWeight();
        }

        @Override
        public Weight getNonViableWeight() {
            return weigher.getNonViableWeight();
        }
    };
    Result<V, E> res = new DijkstraGraphSearch<V, E>().search(graph, src, dst, modified, 1);
    return res;
}
#method_after
private Result<V, E> findShortestPathFromSubset(boolean[] subset) {
    Graph<V, E> graph = orig;
    EdgeWeigher<V, E> modified = new EdgeWeigher<V, E>() {

        final boolean[] subsetF = subset;

        @Override
        public Weight weight(E edge) {
            if (subsetF[riskGrouping.get(edge)]) {
                return weigher.weight(edge);
            }
            return weigher.getNonViableWeight();
        }

        @Override
        public Weight getInitialWeight() {
            return weigher.getInitialWeight();
        }

        @Override
        public Weight getNonViableWeight() {
            return weigher.getNonViableWeight();
        }
    };
    Result<V, E> res = new DijkstraGraphSearch<V, E>().search(graph, src, dst, modified, 1);
    return res;
}
#end_block

#method_before
@Override
public Comparable fitness() {
    Set<Path<V, E>> paths1 = findShortestPathFromSubset(subset).paths();
    Set<Path<V, E>> paths2 = findShortestPathFromSubset(not).paths();
    if (paths1.size() == 0 || paths2.size() == 0) {
        return weigher.getNonViableWeight();
    }
    return paths1.iterator().next().cost().concat(paths2.iterator().next().cost());
}
#method_after
@Override
public Comparable fitness() {
    Set<Path<V, E>> paths1 = findShortestPathFromSubset(subset).paths();
    Set<Path<V, E>> paths2 = findShortestPathFromSubset(not).paths();
    if (paths1.isEmpty() || paths2.isEmpty()) {
        return weigher.getNonViableWeight();
    }
    return paths1.iterator().next().cost().merge(paths2.iterator().next().cost());
}
#end_block

#method_before
@Override
public Set<Path> getPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight));
}
#method_after
@Override
public Set<Path> getPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getPaths(topology, src, dst, adapt(weight));
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getDisjointPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight));
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getDisjointPaths(topology, src, dst, adapt(weight));
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight, Map<Link, Object> riskProfile) {
    return getDisjointPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight), riskProfile);
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight, Map<Link, Object> riskProfile) {
    return getDisjointPaths(topology, src, dst, adapt(weight), riskProfile);
}
#end_block

#method_before
@Override
public void setDefaultLinkWeight(LinkWeight linkWeight) {
    DefaultTopology.setDefaultLinkWeigher(AdapterLinkWeigher.adapt(linkWeight));
}
#method_after
@Override
public void setDefaultLinkWeight(LinkWeight linkWeight) {
    DefaultTopology.setDefaultLinkWeigher(adapt(linkWeight));
}
#end_block

#method_before
@Test
public void twoClustersConnectedWithIgnoredEdges() {
    graph = new AdjacencyListsGraph<>(vertexes(), of(new TestEdge(A, B), new TestEdge(B, C), new TestEdge(C, D), new TestEdge(D, A), new TestEdge(E, F), new TestEdge(F, G), new TestEdge(G, H), new TestEdge(H, E), new TestEdge(B, E, new TestWeight(-1)), new TestEdge(E, B, new TestWeight(-1))));
    TarjanGraphSearch<TestVertex, TestEdge> gs = new TarjanGraphSearch<>();
    SccResult<TestVertex, TestEdge> result = gs.search(graph, weigher);
    validate(result, 2);
    validate(result, 0, 4, 4);
    validate(result, 1, 4, 4);
}
#method_after
@Test
public void twoClustersConnectedWithIgnoredEdges() {
    graph = new AdjacencyListsGraph<>(vertexes(), of(new TestEdge(A, B), new TestEdge(B, C), new TestEdge(C, D), new TestEdge(D, A), new TestEdge(E, F), new TestEdge(F, G), new TestEdge(G, H), new TestEdge(H, E), new TestEdge(B, E, weigher.getNonViableWeight()), new TestEdge(E, B, weigher.getNonViableWeight())));
    TarjanGraphSearch<TestVertex, TestEdge> gs = new TarjanGraphSearch<>();
    SccResult<TestVertex, TestEdge> result = gs.search(graph, weigher);
    validate(result, 2);
    validate(result, 0, 4, 4);
    validate(result, 1, 4, 4);
}
#end_block

#method_before
private VertexData<V> connect(Graph<V, E> graph, V vertex, EdgeWeigher<V, E> weigher, SccResult<V, E> result) {
    VertexData<V> data = result.addData(vertex);
    // Scan through all egress edges of the current vertex.
    for (E edge : graph.getEdgesFrom(vertex)) {
        V nextVertex = edge.dst();
        // If edge weight is negative, skip it.
        if (weigher != null && weigher.weight(edge).isNegative()) {
            continue;
        }
        // Attempt to get the augmentation vertexData for the next vertex.
        VertexData<V> nextData = result.data(nextVertex);
        if (nextData == null) {
            // Next vertex has not been visited yet, so do this now.
            nextData = connect(graph, nextVertex, weigher, result);
            data.lowLink = Math.min(data.lowLink, nextData.lowLink);
        } else if (result.visited(nextData)) {
            // Next vertex has been visited, which means it is in the
            // same cluster as the current vertex.
            data.lowLink = Math.min(data.lowLink, nextData.index);
        }
    }
    if (data.lowLink == data.index) {
        result.addCluster(data);
    }
    return data;
}
#method_after
private VertexData<V> connect(Graph<V, E> graph, V vertex, EdgeWeigher<V, E> weigher, SccResult<V, E> result) {
    VertexData<V> data = result.addData(vertex);
    // Scan through all egress edges of the current vertex.
    for (E edge : graph.getEdgesFrom(vertex)) {
        V nextVertex = edge.dst();
        // If edge is not viable, skip it.
        if (weigher != null && !weigher.weight(edge).isViable()) {
            continue;
        }
        // Attempt to get the augmentation vertexData for the next vertex.
        VertexData<V> nextData = result.data(nextVertex);
        if (nextData == null) {
            // Next vertex has not been visited yet, so do this now.
            nextData = connect(graph, nextVertex, weigher, result);
            data.lowLink = Math.min(data.lowLink, nextData.lowLink);
        } else if (result.visited(nextData)) {
            // Next vertex has been visited, which means it is in the
            // same cluster as the current vertex.
            data.lowLink = Math.min(data.lowLink, nextData.index);
        }
    }
    if (data.lowLink == data.index) {
        result.addCluster(data);
    }
    return data;
}
#end_block

#method_before
@Test
public void equality() {
    DefaultPath<TestVertex, TestEdge> p1 = new DefaultPath<>(of(new TestEdge(A, B), new TestEdge(B, C)), new TestWeight(2.0));
    DefaultPath<TestVertex, TestEdge> p2 = new DefaultPath<>(of(new TestEdge(A, B), new TestEdge(B, D)), new TestWeight(2.0));
    new EqualsTester().addEqualityGroup(new DefaultMutablePath<>(p1), new DefaultMutablePath<>(p1)).addEqualityGroup(new DefaultMutablePath<>(p2)).testEquals();
}
#method_after
@Test
public void equality() {
    DefaultPath<TestVertex, TestEdge> p1 = new DefaultPath<>(of(new TestEdge(A, B), new TestEdge(B, C)), new TestDoubleWeight(2.0));
    DefaultPath<TestVertex, TestEdge> p2 = new DefaultPath<>(of(new TestEdge(A, B), new TestEdge(B, D)), new TestDoubleWeight(2.0));
    new EqualsTester().addEqualityGroup(new DefaultMutablePath<>(p1), new DefaultMutablePath<>(p1)).addEqualityGroup(new DefaultMutablePath<>(p2)).testEquals();
}
#end_block

#method_before
@Test
public void pathCost() {
    MutablePath<TestVertex, TestEdge> p = new DefaultMutablePath<>();
    Weight weight = new TestWeight(4);
    p.setCost(weight);
    assertEquals("incorrect path cost", weight, p.cost());
}
#method_after
@Test
public void pathCost() {
    MutablePath<TestVertex, TestEdge> p = new DefaultMutablePath<>();
    Weight weight = new TestDoubleWeight(4);
    p.setCost(weight);
    assertEquals("incorrect path cost", weight, p.cost());
}
#end_block

#method_before
@Test
public void basicGraphTest() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B), new TestEdge(B, C), new TestEdge(A, D), new TestEdge(D, C)));
    executeSearch(graphSearch(), graph, A, C, null, 1, new DefaultWeight(4.0));
}
#method_after
@Test
public void basicGraphTest() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B), new TestEdge(B, C), new TestEdge(A, D), new TestEdge(D, C)));
    executeSearch(graphSearch(), graph, A, C, null, 1, new ScalarWeight(4.0));
}
#end_block

#method_before
@Test
public void multiplePathOnePairGraphTest() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D, E), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(B, C, new TestWeight(1)), new TestEdge(A, D, new TestWeight(1)), new TestEdge(D, C, new TestWeight(1)), new TestEdge(B, E, new TestWeight(2)), new TestEdge(C, E, new TestWeight(1))));
    executeSearch(graphSearch(), graph, A, E, weigher, 1, new TestWeight(6.0));
}
#method_after
@Test
public void multiplePathOnePairGraphTest() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D, E), of(new TestEdge(A, B, W1), new TestEdge(B, C, W1), new TestEdge(A, D, W1), new TestEdge(D, C, W1), new TestEdge(B, E, W2), new TestEdge(C, E, W1)));
    executeSearch(graphSearch(), graph, A, E, weigher, 1, new TestDoubleWeight(6.0));
}
#end_block

#method_before
@Test
public void multiplePathsMultiplePairs() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D, E), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(B, E, new TestWeight(1)), new TestEdge(A, C, new TestWeight(1)), new TestEdge(C, E, new TestWeight(1)), new TestEdge(A, D, new TestWeight(1)), new TestEdge(D, E, new TestWeight(1)), new TestEdge(A, E, new TestWeight(2))));
    GraphPathSearch.Result<TestVertex, TestEdge> result = graphSearch().search(graph, A, E, weigher, GraphPathSearch.ALL_PATHS);
    Set<Path<TestVertex, TestEdge>> paths = result.paths();
    System.out.println("\n\n" + paths + "\n\n\ndone\n");
    assertEquals("incorrect paths count", 3, paths.size());
    DisjointPathPair<TestVertex, TestEdge> dpp = (DisjointPathPair<TestVertex, TestEdge>) paths.iterator().next();
    assertEquals("incorrect disjoint paths per path", 2, dpp.size());
}
#method_after
@Test
public void multiplePathsMultiplePairs() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D, E), of(new TestEdge(A, B, W1), new TestEdge(B, E, W1), new TestEdge(A, C, W1), new TestEdge(C, E, W1), new TestEdge(A, D, W1), new TestEdge(D, E, W1), new TestEdge(A, E, W2)));
    GraphPathSearch.Result<TestVertex, TestEdge> result = graphSearch().search(graph, A, E, weigher, GraphPathSearch.ALL_PATHS);
    Set<Path<TestVertex, TestEdge>> paths = result.paths();
    System.out.println("\n\n" + paths + "\n\n\ndone\n");
    assertEquals("incorrect paths count", 3, paths.size());
    DisjointPathPair<TestVertex, TestEdge> dpp = (DisjointPathPair<TestVertex, TestEdge>) paths.iterator().next();
    assertEquals("incorrect disjoint paths per path", 2, dpp.size());
}
#end_block

#method_before
@Test
public void differingPrimaryAndBackupPathLengths() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D, E), of(new TestEdge(A, B), new TestEdge(B, C), new TestEdge(A, D), new TestEdge(D, C), new TestEdge(B, E), new TestEdge(C, E)));
    executeSearch(graphSearch(), graph, A, E, weigher, 1, new TestWeight(5.0));
}
#method_after
@Test
public void differingPrimaryAndBackupPathLengths() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D, E), of(new TestEdge(A, B), new TestEdge(B, C), new TestEdge(A, D), new TestEdge(D, C), new TestEdge(B, E), new TestEdge(C, E)));
    executeSearch(graphSearch(), graph, A, E, weigher, 1, new TestDoubleWeight(5.0));
}
#end_block

#method_before
@Test
public void onePath() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(B, C, new TestWeight(1)), new TestEdge(A, C, new TestWeight(4)), new TestEdge(C, D, new TestWeight(1))));
    GraphPathSearch.Result<TestVertex, TestEdge> result = graphSearch().search(graph, A, D, weigher, GraphPathSearch.ALL_PATHS);
    Set<Path<TestVertex, TestEdge>> paths = result.paths();
    assertEquals("incorrect paths count", 1, paths.size());
    DisjointPathPair<TestVertex, TestEdge> dpp = (DisjointPathPair<TestVertex, TestEdge>) paths.iterator().next();
    assertEquals("incorrect disjoint paths count", 1, dpp.size());
}
#method_after
@Test
public void onePath() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B, W1), new TestEdge(B, C, W1), new TestEdge(A, C, W4), new TestEdge(C, D, W1)));
    GraphPathSearch.Result<TestVertex, TestEdge> result = graphSearch().search(graph, A, D, weigher, GraphPathSearch.ALL_PATHS);
    Set<Path<TestVertex, TestEdge>> paths = result.paths();
    assertEquals("incorrect paths count", 1, paths.size());
    DisjointPathPair<TestVertex, TestEdge> dpp = (DisjointPathPair<TestVertex, TestEdge>) paths.iterator().next();
    assertEquals("incorrect disjoint paths count", 1, dpp.size());
}
#end_block

#method_before
@Test
public void noPath() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(B, C, new TestWeight(1)), new TestEdge(A, C, new TestWeight(4))));
    GraphPathSearch.Result<TestVertex, TestEdge> result = graphSearch().search(graph, A, D, weigher, GraphPathSearch.ALL_PATHS);
    Set<Path<TestVertex, TestEdge>> paths = result.paths();
    assertEquals("incorrect paths count", paths.size(), 0);
}
#method_after
@Test
public void noPath() {
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B, W1), new TestEdge(B, C, W1), new TestEdge(A, C, W4)));
    GraphPathSearch.Result<TestVertex, TestEdge> result = graphSearch().search(graph, A, D, weigher, GraphPathSearch.ALL_PATHS);
    Set<Path<TestVertex, TestEdge>> paths = result.paths();
    assertEquals("incorrect paths count", paths.size(), 0);
}
#end_block

#method_before
public Set<Path> getPaths(DeviceId src, DeviceId dst) {
    return getPaths(src, dst, linkWeight());
}
#method_after
public Set<Path> getPaths(DeviceId src, DeviceId dst) {
    return getPaths(src, dst, linkWeight(), ALL_PATHS);
}
#end_block

#method_before
public Set<Path> getPaths(DeviceId src, DeviceId dst, LinkWeigher weigher) {
    DefaultTopologyVertex srcV = new DefaultTopologyVertex(src);
    DefaultTopologyVertex dstV = new DefaultTopologyVertex(dst);
    Set<TopologyVertex> vertices = graph.getVertexes();
    if (!vertices.contains(srcV) || !vertices.contains(dstV)) {
        // src or dst not part of the current graph
        return ImmutableSet.of();
    }
    GraphPathSearch.Result<TopologyVertex, TopologyEdge> result = graphPathSearch().search(graph, srcV, dstV, weigher, ALL_PATHS);
    ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
    for (org.onlab.graph.Path<TopologyVertex, TopologyEdge> path : result.paths()) {
        builder.add(networkPath(path));
    }
    return builder.build();
}
#method_after
public Set<Path> getPaths(DeviceId src, DeviceId dst, LinkWeigher weigher) {
    return getPaths(src, dst, weigher, ALL_PATHS);
}
#end_block

#method_before
public Set<Path> getPaths(DeviceId src, DeviceId dst, LinkWeigher weigher) {
    DefaultTopologyVertex srcV = new DefaultTopologyVertex(src);
    DefaultTopologyVertex dstV = new DefaultTopologyVertex(dst);
    Set<TopologyVertex> vertices = graph.getVertexes();
    if (!vertices.contains(srcV) || !vertices.contains(dstV)) {
        // src or dst not part of the current graph
        return ImmutableSet.of();
    }
    GraphPathSearch.Result<TopologyVertex, TopologyEdge> result = graphPathSearch().search(graph, srcV, dstV, weigher, ALL_PATHS);
    ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
    for (org.onlab.graph.Path<TopologyVertex, TopologyEdge> path : result.paths()) {
        builder.add(networkPath(path));
    }
    return builder.build();
}
#method_after
public Set<Path> getPaths(DeviceId src, DeviceId dst, LinkWeigher weigher, int maxPaths) {
    DefaultTopologyVertex srcV = new DefaultTopologyVertex(src);
    DefaultTopologyVertex dstV = new DefaultTopologyVertex(dst);
    Set<TopologyVertex> vertices = graph.getVertexes();
    if (!vertices.contains(srcV) || !vertices.contains(dstV)) {
        // src or dst not part of the current graph
        return ImmutableSet.of();
    }
    GraphPathSearch.Result<TopologyVertex, TopologyEdge> result = graphPathSearch().search(graph, srcV, dstV, weigher, maxPaths);
    ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
    for (org.onlab.graph.Path<TopologyVertex, TopologyEdge> path : result.paths()) {
        builder.add(networkPath(path));
    }
    return builder.build();
}
#end_block

#method_before
public Set<DisjointPath> getDisjointPaths(DeviceId src, DeviceId dst, LinkWeigher weigher) {
    DefaultTopologyVertex srcV = new DefaultTopologyVertex(src);
    DefaultTopologyVertex dstV = new DefaultTopologyVertex(dst);
    Set<TopologyVertex> vertices = graph.getVertexes();
    if (!vertices.contains(srcV) || !vertices.contains(dstV)) {
        // src or dst not part of the current graph
        return ImmutableSet.of();
    }
    GraphPathSearch.Result<TopologyVertex, TopologyEdge> result = SUURBALLE.search(graph, srcV, dstV, weigher, ALL_PATHS);
    ImmutableSet.Builder<DisjointPath> builder = ImmutableSet.builder();
    for (org.onlab.graph.Path<TopologyVertex, TopologyEdge> path : result.paths()) {
        DisjointPath disjointPath = networkDisjointPath((org.onlab.graph.DisjointPathPair<TopologyVertex, TopologyEdge>) path);
        if (disjointPath.backup() != null) {
            builder.add(disjointPath);
        }
    }
    return builder.build();
}
#method_after
public Set<DisjointPath> getDisjointPaths(DeviceId src, DeviceId dst, LinkWeigher weigher) {
    DefaultTopologyVertex srcV = new DefaultTopologyVertex(src);
    DefaultTopologyVertex dstV = new DefaultTopologyVertex(dst);
    Set<TopologyVertex> vertices = graph.getVertexes();
    if (!vertices.contains(srcV) || !vertices.contains(dstV)) {
        // src or dst not part of the current graph
        return ImmutableSet.of();
    }
    GraphPathSearch.Result<TopologyVertex, TopologyEdge> result = SUURBALLE.search(graph, srcV, dstV, weigher, ALL_PATHS);
    ImmutableSet.Builder<DisjointPath> builder = ImmutableSet.builder();
    for (org.onlab.graph.Path<TopologyVertex, TopologyEdge> path : result.paths()) {
        DisjointPath disjointPath = networkDisjointPath((DisjointPathPair<TopologyVertex, TopologyEdge>) path);
        if (disjointPath.backup() != null) {
            builder.add(disjointPath);
        }
    }
    return builder.build();
}
#end_block

#method_before
private Set<DisjointPath> disjointPaths(DeviceId src, DeviceId dst, LinkWeigher weigher, Map<TopologyEdge, Object> riskProfile) {
    DefaultTopologyVertex srcV = new DefaultTopologyVertex(src);
    DefaultTopologyVertex dstV = new DefaultTopologyVertex(dst);
    Set<TopologyVertex> vertices = graph.getVertexes();
    if (!vertices.contains(srcV) || !vertices.contains(dstV)) {
        // src or dst not part of the current graph
        return ImmutableSet.of();
    }
    SrlgGraphSearch<TopologyVertex, TopologyEdge> srlg = new SrlgGraphSearch<>(riskProfile);
    GraphPathSearch.Result<TopologyVertex, TopologyEdge> result = srlg.search(graph, srcV, dstV, weigher, ALL_PATHS);
    ImmutableSet.Builder<DisjointPath> builder = ImmutableSet.builder();
    for (org.onlab.graph.Path<TopologyVertex, TopologyEdge> path : result.paths()) {
        DisjointPath disjointPath = networkDisjointPath((org.onlab.graph.DisjointPathPair<TopologyVertex, TopologyEdge>) path);
        if (disjointPath.backup() != null) {
            builder.add(disjointPath);
        }
    }
    return builder.build();
}
#method_after
private Set<DisjointPath> disjointPaths(DeviceId src, DeviceId dst, LinkWeigher weigher, Map<TopologyEdge, Object> riskProfile) {
    DefaultTopologyVertex srcV = new DefaultTopologyVertex(src);
    DefaultTopologyVertex dstV = new DefaultTopologyVertex(dst);
    Set<TopologyVertex> vertices = graph.getVertexes();
    if (!vertices.contains(srcV) || !vertices.contains(dstV)) {
        // src or dst not part of the current graph
        return ImmutableSet.of();
    }
    SrlgGraphSearch<TopologyVertex, TopologyEdge> srlg = new SrlgGraphSearch<>(riskProfile);
    GraphPathSearch.Result<TopologyVertex, TopologyEdge> result = srlg.search(graph, srcV, dstV, weigher, ALL_PATHS);
    ImmutableSet.Builder<DisjointPath> builder = ImmutableSet.builder();
    for (org.onlab.graph.Path<TopologyVertex, TopologyEdge> path : result.paths()) {
        DisjointPath disjointPath = networkDisjointPath((DisjointPathPair<TopologyVertex, TopologyEdge>) path);
        if (disjointPath.backup() != null) {
            builder.add(disjointPath);
        }
    }
    return builder.build();
}
#end_block

#method_before
@Override
public Weight weight(TopologyEdge edge) {
    double value = (edge.link().state() == INACTIVE) || (edge.link().type() == INDIRECT) ? -1 : HOP_WEIGHT_VALUE;
    return new DefaultWeight(value);
}
#method_after
@Override
public Weight weight(TopologyEdge edge) {
    return (edge.link().state() == INACTIVE) || (edge.link().type() == INDIRECT) ? getNonViableWeight() : new ScalarWeight(HOP_WEIGHT_VALUE);
}
#end_block

#method_before
@Override
public Weight weight(E edge) {
    return new DefaultWeight(HOP_WEIGHT_VALUE);
}
#method_after
@Override
public Weight weight(E edge) {
    return new ScalarWeight(HOP_WEIGHT_VALUE);
}
#end_block

#method_before
@Override
public Weight getNonViableWeight() {
    return DefaultWeight.NON_VIABLE_WEIGHT;
}
#method_after
@Override
public Weight getNonViableWeight() {
    return ScalarWeight.NON_VIABLE_WEIGHT;
}
#end_block

#method_before
@Override
public Set<Path> getPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight));
}
#method_after
@Override
public Set<Path> getPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getPaths(topology, src, dst, adapt(weight));
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getDisjointPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight));
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getDisjointPaths(topology, src, dst, adapt(weight));
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight, Map<Link, Object> riskProfile) {
    return getDisjointPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight), riskProfile);
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight, Map<Link, Object> riskProfile) {
    return getDisjointPaths(topology, src, dst, adapt(weight), riskProfile);
}
#end_block

#method_before
private Weight calculatePathCost(EdgeWeigher<V, E> weighter, List<E> edges) {
    Weight totalCost = weighter.getNullPathWeight();
    for (E edge : edges) {
        totalCost = totalCost.concat(weighter.weight(edge));
    }
    return totalCost;
}
#method_after
private Weight calculatePathCost(EdgeWeigher<V, E> weighter, List<E> edges) {
    Weight totalCost = weighter.getInitialWeight();
    for (E edge : edges) {
        totalCost = totalCost.merge(weighter.weight(edge));
    }
    return totalCost;
}
#end_block

#method_before
@Test
public void equality() {
    List<TestEdge> edges = of(new TestEdge(A, B), new TestEdge(B, C));
    new EqualsTester().addEqualityGroup(new DefaultPath<>(edges, new TestWeight(2.0)), new DefaultPath<>(edges, new TestWeight(2.0))).addEqualityGroup(new DefaultPath<>(edges, new TestWeight(3.0))).testEquals();
}
#method_after
@Test
public void equality() {
    List<TestEdge> edges = of(new TestEdge(A, B), new TestEdge(B, C));
    new EqualsTester().addEqualityGroup(new DefaultPath<>(edges, new TestDoubleWeight(2.0)), new DefaultPath<>(edges, new TestDoubleWeight(2.0))).addEqualityGroup(new DefaultPath<>(edges, new TestDoubleWeight(3.0))).testEquals();
}
#end_block

#method_before
@Test
public void basics() {
    Path<TestVertex, TestEdge> p = new DefaultPath<>(of(new TestEdge(A, B), new TestEdge(B, C)), new TestWeight(2.0));
    validatePath(p, A, C, 2, new TestWeight(2.0));
}
#method_after
@Test
public void basics() {
    Path<TestVertex, TestEdge> p = new DefaultPath<>(of(new TestEdge(A, B), new TestEdge(B, C)), new TestDoubleWeight(2.0));
    validatePath(p, A, C, 2, new TestDoubleWeight(2.0));
}
#end_block

#method_before
@Override
public Set<Path> getPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight));
}
#method_after
@Override
public Set<Path> getPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getPaths(topology, src, dst, adapt(weight));
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getDisjointPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight));
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight) {
    return getDisjointPaths(topology, src, dst, adapt(weight));
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight, Map<Link, Object> riskProfile) {
    return getDisjointPaths(topology, src, dst, AdapterLinkWeigher.adapt(weight), riskProfile);
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(Topology topology, DeviceId src, DeviceId dst, LinkWeight weight, Map<Link, Object> riskProfile) {
    return getDisjointPaths(topology, src, dst, adapt(weight), riskProfile);
}
#end_block

#method_before
@Test
public void defaultGraphTest() {
    executeDefaultTest(3, 6, new TestWeight(5.0), new TestWeight(12.0));
    executeBroadSearch();
}
#method_after
@Test
public void defaultGraphTest() {
    executeDefaultTest(3, 6, new TestDoubleWeight(5.0), new TestDoubleWeight(12.0));
    executeBroadSearch();
}
#end_block

#method_before
@Test
public void defaultHopCountWeight() {
    weigher = null;
    executeDefaultTest(3, 6, new DefaultWeight(3.0), new DefaultWeight(6.0));
    executeBroadSearch();
}
#method_after
@Test
public void defaultHopCountWeight() {
    weigher = null;
    executeDefaultTest(3, 6, new ScalarWeight(3.0), new ScalarWeight(6.0));
    executeBroadSearch();
}
#end_block

#method_before
protected void executeDefaultTest(int minLength, int maxLength, Weight minCost, Weight maxCost) {
    graph = new AdjacencyListsGraph<>(vertexes(), edges());
    DepthFirstSearch<TestVertex, TestEdge> search = graphSearch();
    DepthFirstSearch<TestVertex, TestEdge>.SpanningTreeResult result = search.search(graph, A, H, weigher, 1);
    Set<Path<TestVertex, TestEdge>> paths = result.paths();
    assertEquals("incorrect path count", 1, paths.size());
    Path path = paths.iterator().next();
    System.out.println(path);
    assertEquals("incorrect src", A, path.src());
    assertEquals("incorrect dst", H, path.dst());
    int l = path.edges().size();
    assertTrue("incorrect path length " + l, minLength <= l && l <= maxLength);
    assertTrue("incorrect path cost " + path.cost(), path.cost().compareTo(minCost) >= 0 && path.cost().compareTo(maxCost) <= 0);
    System.out.println(result.edges());
    printPaths(paths);
}
#method_after
protected void executeDefaultTest(int minLength, int maxLength, Weight minCost, Weight maxCost) {
    graph = new AdjacencyListsGraph<>(vertexes(), edges());
    DepthFirstSearch<TestVertex, TestEdge> search = graphSearch();
    DepthFirstSearch<TestVertex, TestEdge>.SpanningTreeResult result = (DepthFirstSearch<TestVertex, TestEdge>.SpanningTreeResult) search.search(graph, A, H, weigher, 1);
    Set<Path<TestVertex, TestEdge>> paths = result.paths();
    assertEquals("incorrect path count", 1, paths.size());
    Path path = paths.iterator().next();
    System.out.println(path);
    assertEquals("incorrect src", A, path.src());
    assertEquals("incorrect dst", H, path.dst());
    int l = path.edges().size();
    assertTrue("incorrect path length " + l, minLength <= l && l <= maxLength);
    assertTrue("incorrect path cost " + path.cost(), path.cost().compareTo(minCost) >= 0 && path.cost().compareTo(maxCost) <= 0);
    System.out.println(result.edges());
    printPaths(paths);
}
#end_block

#method_before
public void executeBroadSearch() {
    graph = new AdjacencyListsGraph<>(vertexes(), edges());
    DepthFirstSearch<TestVertex, TestEdge> search = graphSearch();
    // Perform narrow path search to a specific destination.
    DepthFirstSearch<TestVertex, TestEdge>.SpanningTreeResult result = search.search(graph, A, null, weigher, ALL_PATHS);
    assertEquals("incorrect paths count", 7, result.paths().size());
    int[] types = new int[] { 0, 0, 0, 0 };
    for (EdgeType t : result.edges().values()) {
        types[t.ordinal()] += 1;
    }
    assertEquals("incorrect tree-edge count", 7, types[EdgeType.TREE_EDGE.ordinal()]);
    assertEquals("incorrect back-edge count", 1, types[EdgeType.BACK_EDGE.ordinal()]);
    assertEquals("incorrect cross-edge & forward-edge count", 4, types[EdgeType.FORWARD_EDGE.ordinal()] + types[EdgeType.CROSS_EDGE.ordinal()]);
}
#method_after
public void executeBroadSearch() {
    graph = new AdjacencyListsGraph<>(vertexes(), edges());
    DepthFirstSearch<TestVertex, TestEdge> search = graphSearch();
    // Perform narrow path search to a specific destination.
    DepthFirstSearch<TestVertex, TestEdge>.SpanningTreeResult result = (DepthFirstSearch<TestVertex, TestEdge>.SpanningTreeResult) search.search(graph, A, null, weigher, ALL_PATHS);
    assertEquals("incorrect paths count", 7, result.paths().size());
    int[] types = new int[] { 0, 0, 0, 0 };
    for (EdgeType t : result.edges().values()) {
        types[t.ordinal()] += 1;
    }
    assertEquals("incorrect tree-edge count", 7, types[EdgeType.TREE_EDGE.ordinal()]);
    assertEquals("incorrect back-edge count", 1, types[EdgeType.BACK_EDGE.ordinal()]);
    assertEquals("incorrect cross-edge & forward-edge count", 4, types[EdgeType.FORWARD_EDGE.ordinal()] + types[EdgeType.CROSS_EDGE.ordinal()]);
}
#end_block

#method_before
public TestWeight weight() {
    return weight;
}
#method_after
public Weight weight() {
    return weight;
}
#end_block

#method_before
@Test
public void testSinglePath() {
    // Tests that there is only a single path possible between A and B
    graph = new AdjacencyListsGraph<>(vertexes(), edges());
    this.result = kShortestPathsSearch.search(graph, A, B, weigher, 2);
    Iterator<Path<TestVertex, TestEdge>> itr = result.paths().iterator();
    assertEquals("incorrect paths count", 1, result.paths().size());
    List<TestEdge> correctEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, B, new TestWeight(1)));
    assertTrue("That wrong path was returned.", edgeListsAreEqual(correctEdgeList, result.paths().iterator().next().edges()));
}
#method_after
@Test
public void testSinglePath() {
    // Tests that there is only a single path possible between A and B
    graph = new AdjacencyListsGraph<>(vertexes(), edges());
    this.result = kShortestPathsSearch.search(graph, A, B, weigher, 2);
    Iterator<Path<TestVertex, TestEdge>> itr = result.paths().iterator();
    assertEquals("incorrect paths count", 1, result.paths().size());
    List<TestEdge> correctEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, B, W1));
    assertTrue("That wrong path was returned.", edgeListsAreEqual(correctEdgeList, result.paths().iterator().next().edges()));
}
#end_block

#method_before
@Test
public void testTwoPath() {
    // Tests that there are only two paths between A and C and that they are returned in the correct order
    result = kShortestPathsSearch.search(graph, A, C, weigher, 3);
    assertTrue("There are an unexpected number of paths.", result.paths().size() == 2);
    Iterator<Path<TestVertex, TestEdge>> edgeListIterator = result.paths().iterator();
    List<TestEdge> correctEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, B, new TestWeight(1)));
    correctEdgeList.add(new TestEdge(B, C, new TestWeight(1)));
    assertTrue("The first path from A to C was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
    correctEdgeList.clear();
    correctEdgeList.add(new TestEdge(A, C, new TestWeight(3)));
    assertTrue("The second path from A to C was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
}
#method_after
@Test
public void testTwoPath() {
    // Tests that there are only two paths between A and C and that they are returned in the correct order
    result = kShortestPathsSearch.search(graph, A, C, weigher, 3);
    assertTrue("There are an unexpected number of paths.", result.paths().size() == 2);
    Iterator<Path<TestVertex, TestEdge>> edgeListIterator = result.paths().iterator();
    List<TestEdge> correctEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, B, W1));
    correctEdgeList.add(new TestEdge(B, C, W1));
    assertTrue("The first path from A to C was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
    correctEdgeList.clear();
    correctEdgeList.add(new TestEdge(A, C, W3));
    assertTrue("The second path from A to C was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
}
#end_block

#method_before
@Test
public void testFourPath() {
    // Tests that there are only four paths between A and E and that they are returned in the correct order
    // Also tests the special case where some correct solutions are equal
    result = kShortestPathsSearch.search(graph, A, E, weigher, 5);
    assertTrue("There are an unexpected number of paths.", result.paths().size() == 4);
    Iterator<Path<TestVertex, TestEdge>> edgeListIterator = result.paths().iterator();
    List<TestEdge> correctEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, B, new TestWeight(1)));
    correctEdgeList.add(new TestEdge(B, C, new TestWeight(1)));
    correctEdgeList.add(new TestEdge(C, E, new TestWeight(1)));
    assertTrue("The first path from A to E was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
    correctEdgeList.clear();
    // There are two paths of equal length that should hold positions two and three
    List<TestEdge> alternateCorrectEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, C, new TestWeight(3)));
    correctEdgeList.add(new TestEdge(C, E, new TestWeight(1)));
    alternateCorrectEdgeList.add(new TestEdge(A, B, new TestWeight(1)));
    alternateCorrectEdgeList.add(new TestEdge(B, D, new TestWeight(2)));
    alternateCorrectEdgeList.add(new TestEdge(D, E, new TestWeight(1)));
    List<TestEdge> candidateOne = edgeListIterator.next().edges();
    List<TestEdge> candidateTwo = edgeListIterator.next().edges();
    if (candidateOne.size() == 2) {
        assertTrue("The second path from A to E was incorrect.", edgeListsAreEqual(candidateOne, correctEdgeList));
        assertTrue("The third path from A to E was incorrect.", edgeListsAreEqual(candidateTwo, alternateCorrectEdgeList));
    } else {
        assertTrue("The second path from A to E was incorrect.", edgeListsAreEqual(candidateOne, alternateCorrectEdgeList));
        assertTrue("The third path from A to E was incorrect.", edgeListsAreEqual(candidateTwo, correctEdgeList));
    }
    correctEdgeList.clear();
    correctEdgeList.add(new TestEdge(A, B, new TestWeight(1)));
    correctEdgeList.add(new TestEdge(B, E, new TestWeight(4)));
    assertTrue("The fourth path rom A to E was incorrect", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
}
#method_after
@Test
public void testFourPath() {
    // Tests that there are only four paths between A and E and that they are returned in the correct order
    // Also tests the special case where some correct solutions are equal
    result = kShortestPathsSearch.search(graph, A, E, weigher, 5);
    assertTrue("There are an unexpected number of paths.", result.paths().size() == 4);
    Iterator<Path<TestVertex, TestEdge>> edgeListIterator = result.paths().iterator();
    List<TestEdge> correctEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, B, W1));
    correctEdgeList.add(new TestEdge(B, C, W1));
    correctEdgeList.add(new TestEdge(C, E, W1));
    assertTrue("The first path from A to E was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
    correctEdgeList.clear();
    // There are two paths of equal length that should hold positions two and three
    List<TestEdge> alternateCorrectEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, C, W3));
    correctEdgeList.add(new TestEdge(C, E, W1));
    alternateCorrectEdgeList.add(new TestEdge(A, B, W1));
    alternateCorrectEdgeList.add(new TestEdge(B, D, W2));
    alternateCorrectEdgeList.add(new TestEdge(D, E, W1));
    List<TestEdge> candidateOne = edgeListIterator.next().edges();
    List<TestEdge> candidateTwo = edgeListIterator.next().edges();
    if (candidateOne.size() == 2) {
        assertTrue("The second path from A to E was incorrect.", edgeListsAreEqual(candidateOne, correctEdgeList));
        assertTrue("The third path from A to E was incorrect.", edgeListsAreEqual(candidateTwo, alternateCorrectEdgeList));
    } else {
        assertTrue("The second path from A to E was incorrect.", edgeListsAreEqual(candidateOne, alternateCorrectEdgeList));
        assertTrue("The third path from A to E was incorrect.", edgeListsAreEqual(candidateTwo, correctEdgeList));
    }
    correctEdgeList.clear();
    correctEdgeList.add(new TestEdge(A, B, W1));
    correctEdgeList.add(new TestEdge(B, E, W4));
    assertTrue("The fourth path rom A to E was incorrect", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
}
#end_block

#method_before
@Test
@Override
public void defaultGraphTest() {
    executeDefaultTest(7, 5, new TestWeight(5.0));
}
#method_after
@Test
@Override
public void defaultGraphTest() {
    executeDefaultTest(7, 5, new TestDoubleWeight(5.0));
}
#end_block

#method_before
@Test
public void defaultHopCountWeight() {
    weigher = null;
    executeDefaultTest(10, 3, new DefaultWeight(3.0));
}
#method_after
@Test
public void defaultHopCountWeight() {
    weigher = null;
    executeDefaultTest(10, 3, new ScalarWeight(3.0));
}
#end_block

#method_before
@Test
public void searchGraphWithNegativeCycles() {
    Set<TestVertex> vertexes = new HashSet<>(vertexes());
    vertexes.add(Z);
    Set<TestEdge> edges = new HashSet<>(edges());
    edges.add(new TestEdge(G, Z, new TestWeight(1.0)));
    edges.add(new TestEdge(Z, G, new TestWeight(-2.0)));
    graph = new AdjacencyListsGraph<>(vertexes, edges);
    GraphPathSearch<TestVertex, TestEdge> search = graphSearch();
    Set<Path<TestVertex, TestEdge>> paths = search.search(graph, A, H, weigher, ALL_PATHS).paths();
    assertEquals("incorrect paths count", 1, paths.size());
    Path p = paths.iterator().next();
    assertEquals("incorrect src", A, p.src());
    assertEquals("incorrect dst", H, p.dst());
    assertEquals("incorrect path length", 5, p.edges().size());
    assertEquals("incorrect path cost", new TestWeight(5), p.cost());
    paths = search.search(graph, A, G, weigher, ALL_PATHS).paths();
    assertEquals("incorrect paths count", 0, paths.size());
    paths = search.search(graph, A, null, weigher, ALL_PATHS).paths();
    printPaths(paths);
    assertEquals("incorrect paths count", 6, paths.size());
}
#method_after
@Test
public void searchGraphWithNegativeCycles() {
    Set<TestVertex> vertexes = new HashSet<>(vertexes());
    vertexes.add(Z);
    Set<TestEdge> edges = new HashSet<>(edges());
    edges.add(new TestEdge(G, Z, new TestDoubleWeight(1.0)));
    edges.add(new TestEdge(Z, G, new TestDoubleWeight(-2.0)));
    graph = new AdjacencyListsGraph<>(vertexes, edges);
    GraphPathSearch<TestVertex, TestEdge> search = graphSearch();
    Set<Path<TestVertex, TestEdge>> paths = search.search(graph, A, H, weigher, ALL_PATHS).paths();
    assertEquals("incorrect paths count", 1, paths.size());
    Path p = paths.iterator().next();
    assertEquals("incorrect src", A, p.src());
    assertEquals("incorrect dst", H, p.dst());
    assertEquals("incorrect path length", 5, p.edges().size());
    assertEquals("incorrect path cost", new TestDoubleWeight(5), p.cost());
    paths = search.search(graph, A, G, weigher, ALL_PATHS).paths();
    assertEquals("incorrect paths count", 0, paths.size());
    paths = search.search(graph, A, null, weigher, ALL_PATHS).paths();
    printPaths(paths);
    assertEquals("incorrect paths count", 6, paths.size());
}
#end_block

#method_before
@Override
public Weight weight(TopologyEdge edge) {
    return new DefaultWeight(doubleWeigher.weight(edge));
}
#method_after
@Override
public Weight weight(TopologyEdge edge) {
    return new ScalarWeight(doubleWeigher.weight(edge));
}
#end_block

#method_before
public static LinkWeigher adapt(LinkWeight doubleWeigher) {
    if (doubleWeigher == null) {
        return null;
    }
    return new AdapterLinkWeigher(doubleWeigher);
}
#method_after
public static LinkWeigher adapt(LinkWeight lw) {
    return lw == null ? null : new AdapterLinkWeigher(lw);
}
#end_block

#method_before
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeight weight) {
    return getPaths(src, dst, AdapterLinkWeigher.adapt(weight));
}
#method_after
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeight weight) {
    return getPaths(src, dst, adapt(weight));
}
#end_block

#method_before
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    checkNotNull(src, ELEMENT_ID_NULL);
    checkNotNull(dst, ELEMENT_ID_NULL);
    if (weigher == null) {
        weigher = DEFAULT_WEIGHER;
    }
    // Get the source and destination edge locations
    EdgeLink srcEdge = getEdgeLink(src, true);
    EdgeLink dstEdge = getEdgeLink(dst, false);
    // If either edge is null, bail with no paths.
    if (srcEdge == null || dstEdge == null) {
        return ImmutableSet.of();
    }
    DeviceId srcDevice = srcEdge != NOT_HOST ? srcEdge.dst().deviceId() : (DeviceId) src;
    DeviceId dstDevice = dstEdge != NOT_HOST ? dstEdge.src().deviceId() : (DeviceId) dst;
    // is just one path, so build it and return it.
    if (srcDevice.equals(dstDevice)) {
        return edgeToEdgePaths(srcEdge, dstEdge, weigher);
    }
    // Otherwise get all paths between the source and destination edge
    // devices.
    Topology topology = topologyService.currentTopology();
    Set<Path> paths = weigher == null ? topologyService.getPaths(topology, srcDevice, dstDevice) : topologyService.getPaths(topology, srcDevice, dstDevice, weigher);
    return edgeToEdgePaths(srcEdge, dstEdge, paths, weigher);
}
#method_after
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    checkNotNull(src, ELEMENT_ID_NULL);
    checkNotNull(dst, ELEMENT_ID_NULL);
    LinkWeigher internalWeigher = weigher != null ? weigher : DEFAULT_WEIGHER;
    // Get the source and destination edge locations
    EdgeLink srcEdge = getEdgeLink(src, true);
    EdgeLink dstEdge = getEdgeLink(dst, false);
    // If either edge is null, bail with no paths.
    if (srcEdge == null || dstEdge == null) {
        return ImmutableSet.of();
    }
    DeviceId srcDevice = srcEdge != NOT_HOST ? srcEdge.dst().deviceId() : (DeviceId) src;
    DeviceId dstDevice = dstEdge != NOT_HOST ? dstEdge.src().deviceId() : (DeviceId) dst;
    // is just one path, so build it and return it.
    if (srcDevice.equals(dstDevice)) {
        return edgeToEdgePaths(srcEdge, dstEdge, internalWeigher);
    }
    // Otherwise get all paths between the source and destination edge
    // devices.
    Topology topology = topologyService.currentTopology();
    Set<Path> paths = topologyService.getPaths(topology, srcDevice, dstDevice, internalWeigher);
    return edgeToEdgePaths(srcEdge, dstEdge, paths, internalWeigher);
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(ElementId src, ElementId dst, LinkWeight weight) {
    return getDisjointPaths(src, dst, AdapterLinkWeigher.adapt(weight));
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(ElementId src, ElementId dst, LinkWeight weight) {
    return getDisjointPaths(src, dst, adapt(weight));
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    checkNotNull(src, ELEMENT_ID_NULL);
    checkNotNull(dst, ELEMENT_ID_NULL);
    if (weigher == null) {
        weigher = DEFAULT_WEIGHER;
    }
    // Get the source and destination edge locations
    EdgeLink srcEdge = getEdgeLink(src, true);
    EdgeLink dstEdge = getEdgeLink(dst, false);
    // If either edge is null, bail with no paths.
    if (srcEdge == null || dstEdge == null) {
        return ImmutableSet.of();
    }
    DeviceId srcDevice = srcEdge != NOT_HOST ? srcEdge.dst().deviceId() : (DeviceId) src;
    DeviceId dstDevice = dstEdge != NOT_HOST ? dstEdge.src().deviceId() : (DeviceId) dst;
    // is just one path, so build it and return it.
    if (srcDevice.equals(dstDevice)) {
        return edgeToEdgePathsDisjoint(srcEdge, dstEdge, weigher);
    }
    // Otherwise get all paths between the source and destination edge
    // devices.
    Topology topology = topologyService.currentTopology();
    Set<DisjointPath> paths = weigher == null ? topologyService.getDisjointPaths(topology, srcDevice, dstDevice) : topologyService.getDisjointPaths(topology, srcDevice, dstDevice, weigher);
    return edgeToEdgePathsDisjoint(srcEdge, dstEdge, paths, weigher);
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    checkNotNull(src, ELEMENT_ID_NULL);
    checkNotNull(dst, ELEMENT_ID_NULL);
    LinkWeigher internalWeigher = weigher != null ? weigher : DEFAULT_WEIGHER;
    // Get the source and destination edge locations
    EdgeLink srcEdge = getEdgeLink(src, true);
    EdgeLink dstEdge = getEdgeLink(dst, false);
    // If either edge is null, bail with no paths.
    if (srcEdge == null || dstEdge == null) {
        return ImmutableSet.of();
    }
    DeviceId srcDevice = srcEdge != NOT_HOST ? srcEdge.dst().deviceId() : (DeviceId) src;
    DeviceId dstDevice = dstEdge != NOT_HOST ? dstEdge.src().deviceId() : (DeviceId) dst;
    // is just one path, so build it and return it.
    if (srcDevice.equals(dstDevice)) {
        return edgeToEdgePathsDisjoint(srcEdge, dstEdge, internalWeigher);
    }
    // Otherwise get all paths between the source and destination edge
    // devices.
    Topology topology = topologyService.currentTopology();
    Set<DisjointPath> paths = topologyService.getDisjointPaths(topology, srcDevice, dstDevice, internalWeigher);
    return edgeToEdgePathsDisjoint(srcEdge, dstEdge, paths, internalWeigher);
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(ElementId src, ElementId dst, LinkWeight weight, Map<Link, Object> riskProfile) {
    return getDisjointPaths(src, dst, AdapterLinkWeigher.adapt(weight), riskProfile);
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(ElementId src, ElementId dst, LinkWeight weight, Map<Link, Object> riskProfile) {
    return getDisjointPaths(src, dst, adapt(weight), riskProfile);
}
#end_block

#method_before
@Override
public Set<DisjointPath> getDisjointPaths(ElementId src, ElementId dst, LinkWeigher weigher, Map<Link, Object> riskProfile) {
    checkNotNull(src, ELEMENT_ID_NULL);
    checkNotNull(dst, ELEMENT_ID_NULL);
    if (weigher == null) {
        weigher = DEFAULT_WEIGHER;
    }
    // Get the source and destination edge locations
    EdgeLink srcEdge = getEdgeLink(src, true);
    EdgeLink dstEdge = getEdgeLink(dst, false);
    // If either edge is null, bail with no paths.
    if (srcEdge == null || dstEdge == null) {
        return ImmutableSet.of();
    }
    DeviceId srcDevice = srcEdge != NOT_HOST ? srcEdge.dst().deviceId() : (DeviceId) src;
    DeviceId dstDevice = dstEdge != NOT_HOST ? dstEdge.src().deviceId() : (DeviceId) dst;
    // is just one path, so build it and return it.
    if (srcDevice.equals(dstDevice)) {
        return edgeToEdgePathsDisjoint(srcEdge, dstEdge, weigher);
    }
    // Otherwise get all paths between the source and destination edge
    // devices.
    Topology topology = topologyService.currentTopology();
    Set<DisjointPath> paths = weigher == null ? topologyService.getDisjointPaths(topology, srcDevice, dstDevice, riskProfile) : topologyService.getDisjointPaths(topology, srcDevice, dstDevice, weigher, riskProfile);
    return edgeToEdgePathsDisjoint(srcEdge, dstEdge, paths, weigher);
}
#method_after
@Override
public Set<DisjointPath> getDisjointPaths(ElementId src, ElementId dst, LinkWeigher weigher, Map<Link, Object> riskProfile) {
    checkNotNull(src, ELEMENT_ID_NULL);
    checkNotNull(dst, ELEMENT_ID_NULL);
    LinkWeigher internalWeigher = weigher != null ? weigher : DEFAULT_WEIGHER;
    // Get the source and destination edge locations
    EdgeLink srcEdge = getEdgeLink(src, true);
    EdgeLink dstEdge = getEdgeLink(dst, false);
    // If either edge is null, bail with no paths.
    if (srcEdge == null || dstEdge == null) {
        return ImmutableSet.of();
    }
    DeviceId srcDevice = srcEdge != NOT_HOST ? srcEdge.dst().deviceId() : (DeviceId) src;
    DeviceId dstDevice = dstEdge != NOT_HOST ? dstEdge.src().deviceId() : (DeviceId) dst;
    // is just one path, so build it and return it.
    if (srcDevice.equals(dstDevice)) {
        return edgeToEdgePathsDisjoint(srcEdge, dstEdge, internalWeigher);
    }
    // Otherwise get all paths between the source and destination edge
    // devices.
    Topology topology = topologyService.currentTopology();
    Set<DisjointPath> paths = topologyService.getDisjointPaths(topology, srcDevice, dstDevice, internalWeigher, riskProfile);
    return edgeToEdgePathsDisjoint(srcEdge, dstEdge, paths, internalWeigher);
}
#end_block

#method_before
private Path edgeToEdgePath(EdgeLink srcLink, EdgeLink dstLink, Path path, LinkWeigher weigher) {
    List<Link> links = Lists.newArrayListWithCapacity(2);
    Weight cost = weigher.getNullPathWeight();
    // add the infrastructure path only if it is not null.
    if (srcLink != NOT_HOST) {
        links.add(srcLink);
        cost = cost.concat(weigher.weight(new DefaultTopologyEdge(null, null, srcLink)));
    }
    if (path != null) {
        links.addAll(path.links());
        cost = cost.concat(path.costObj());
    }
    if (dstLink != NOT_HOST) {
        links.add(dstLink);
        cost = cost.concat(weigher.weight(new DefaultTopologyEdge(null, null, srcLink)));
    }
    return new DefaultPath(PID, links, cost);
}
#method_after
private Path edgeToEdgePath(EdgeLink srcLink, EdgeLink dstLink, Path path, LinkWeigher weigher) {
    List<Link> links = Lists.newArrayListWithCapacity(2);
    Weight cost = weigher.getInitialWeight();
    // add the infrastructure path only if it is not null.
    if (srcLink != NOT_HOST) {
        links.add(srcLink);
        cost = cost.merge(weigher.weight(new DefaultTopologyEdge(null, null, srcLink)));
    }
    if (path != null) {
        links.addAll(path.links());
        cost = cost.merge(path.weight());
    }
    if (dstLink != NOT_HOST) {
        links.add(dstLink);
        cost = cost.merge(weigher.weight(new DefaultTopologyEdge(null, null, srcLink)));
    }
    return new DefaultPath(PID, links, cost);
}
#end_block

#method_before
@Override
public Weight weight(TopologyEdge edge) {
    double value = edge.src().deviceId().equals(D4) || edge.dst().deviceId().equals(D4) ? 2.0 : HOP_WEIGHT_VALUE;
    return new DefaultWeight(value);
}
#method_after
@Override
public Weight weight(TopologyEdge edge) {
    double value = edge.src().deviceId().equals(D4) || edge.dst().deviceId().equals(D4) ? 2.0 : HOP_WEIGHT_VALUE;
    return new ScalarWeight(value);
}
#end_block

#method_before
@Test
@Override
public void defaultGraphTest() {
    executeDefaultTest(7, 5, new TestWeight(5.0));
}
#method_after
@Test
@Override
public void defaultGraphTest() {
    executeDefaultTest(7, 5, new TestDoubleWeight(5.0));
}
#end_block

#method_before
@Test
@Override
public void defaultHopCountWeight() {
    weigher = null;
    executeDefaultTest(10, 3, new DefaultWeight(3.0));
}
#method_after
@Test
@Override
public void defaultHopCountWeight() {
    weigher = null;
    executeDefaultTest(10, 3, new ScalarWeight(3.0));
}
#end_block

#method_before
@Test
public void noPath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(B, A, new TestWeight(1)), new TestEdge(C, D, new TestWeight(1)), new TestEdge(D, C, new TestWeight(1))));
    GraphPathSearch<TestVertex, TestEdge> gs = graphSearch();
    Set<Path<TestVertex, TestEdge>> paths = gs.search(graph, A, B, weigher, 1).paths();
    printPaths(paths);
    assertEquals("incorrect paths count", 1, paths.size());
    assertEquals("incorrect path cost", new TestWeight(1.0), paths.iterator().next().cost());
    paths = gs.search(graph, A, D, weigher, 1).paths();
    printPaths(paths);
    assertEquals("incorrect paths count", 0, paths.size());
    paths = gs.search(graph, A, null, weigher, 1).paths();
    printPaths(paths);
    assertEquals("incorrect paths count", 1, paths.size());
    assertEquals("incorrect path cost", new TestWeight(1.0), paths.iterator().next().cost());
}
#method_after
@Test
public void noPath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B, W1), new TestEdge(B, A, W1), new TestEdge(C, D, W1), new TestEdge(D, C, W1)));
    GraphPathSearch<TestVertex, TestEdge> gs = graphSearch();
    Set<Path<TestVertex, TestEdge>> paths = gs.search(graph, A, B, weigher, 1).paths();
    printPaths(paths);
    assertEquals("incorrect paths count", 1, paths.size());
    assertEquals("incorrect path cost", new TestDoubleWeight(1.0), paths.iterator().next().cost());
    paths = gs.search(graph, A, D, weigher, 1).paths();
    printPaths(paths);
    assertEquals("incorrect paths count", 0, paths.size());
    paths = gs.search(graph, A, null, weigher, 1).paths();
    printPaths(paths);
    assertEquals("incorrect paths count", 1, paths.size());
    assertEquals("incorrect path cost", new TestDoubleWeight(1.0), paths.iterator().next().cost());
}
#end_block

#method_before
@Test
public void simpleMultiplePath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(A, C, new TestWeight(1)), new TestEdge(B, D, new TestWeight(1)), new TestEdge(C, D, new TestWeight(1))));
    executeSearch(graphSearch(), graph, A, D, weigher, 2, new TestWeight(2.0));
    executeSinglePathSearch(graphSearch(), graph, A, D, weigher, 1, new TestWeight(2.0));
}
#method_after
@Test
public void simpleMultiplePath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(new TestEdge(A, B, W1), new TestEdge(A, C, W1), new TestEdge(B, D, W1), new TestEdge(C, D, W1)));
    executeSearch(graphSearch(), graph, A, D, weigher, 2, W2);
    executeSinglePathSearch(graphSearch(), graph, A, D, weigher, 1, W2);
}
#end_block

#method_before
@Test
public void denseMultiplePath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(A, C, new TestWeight(1)), new TestEdge(B, D, new TestWeight(1)), new TestEdge(C, D, new TestWeight(1)), new TestEdge(D, E, new TestWeight(1)), new TestEdge(D, F, new TestWeight(1)), new TestEdge(E, G, new TestWeight(1)), new TestEdge(F, G, new TestWeight(1)), new TestEdge(A, G, new TestWeight(4))));
    executeSearch(graphSearch(), graph, A, G, weigher, 5, new TestWeight(4.0));
    executeSinglePathSearch(graphSearch(), graph, A, G, weigher, 1, new TestWeight(4.0));
}
#method_after
@Test
public void denseMultiplePath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G), of(new TestEdge(A, B, W1), new TestEdge(A, C, W1), new TestEdge(B, D, W1), new TestEdge(C, D, W1), new TestEdge(D, E, W1), new TestEdge(D, F, W1), new TestEdge(E, G, W1), new TestEdge(F, G, W1), new TestEdge(A, G, W4)));
    executeSearch(graphSearch(), graph, A, G, weigher, 5, W4);
    executeSinglePathSearch(graphSearch(), graph, A, G, weigher, 1, W4);
}
#end_block

#method_before
@Test
public void dualEdgeMultiplePath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G, H), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(A, C, new TestWeight(3)), new TestEdge(B, D, new TestWeight(2)), new TestEdge(B, C, new TestWeight(1)), new TestEdge(B, E, new TestWeight(4)), new TestEdge(C, E, new TestWeight(1)), new TestEdge(D, H, new TestWeight(5)), new TestEdge(D, E, new TestWeight(1)), new TestEdge(E, F, new TestWeight(1)), new TestEdge(F, D, new TestWeight(1)), new TestEdge(F, G, new TestWeight(1)), new TestEdge(F, H, new TestWeight(1)), new TestEdge(A, E, new TestWeight(3)), new TestEdge(B, D, new TestWeight(1))));
    executeSearch(graphSearch(), graph, A, E, weigher, 3, new TestWeight(3.0));
    executeSinglePathSearch(graphSearch(), graph, A, E, weigher, 1, new TestWeight(3.0));
}
#method_after
@Test
public void dualEdgeMultiplePath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G, H), of(new TestEdge(A, B, W1), new TestEdge(A, C, W3), new TestEdge(B, D, W2), new TestEdge(B, C, W1), new TestEdge(B, E, W4), new TestEdge(C, E, W1), new TestEdge(D, H, W5), new TestEdge(D, E, W1), new TestEdge(E, F, W1), new TestEdge(F, D, W1), new TestEdge(F, G, W1), new TestEdge(F, H, W1), new TestEdge(A, E, W3), new TestEdge(B, D, W1)));
    executeSearch(graphSearch(), graph, A, E, weigher, 3, W3);
    executeSinglePathSearch(graphSearch(), graph, A, E, weigher, 1, W3);
}
#end_block

#method_before
@Test
public void negativeWeights() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G), of(new TestEdge(A, B, new TestWeight(1)), new TestEdge(A, C, new TestWeight(-1)), new TestEdge(B, D, new TestWeight(1)), new TestEdge(D, A, new TestWeight(-2)), new TestEdge(C, D, new TestWeight(1)), new TestEdge(D, E, new TestWeight(1)), new TestEdge(D, F, new TestWeight(1)), new TestEdge(E, G, new TestWeight(1)), new TestEdge(F, G, new TestWeight(1)), new TestEdge(G, A, new TestWeight(-5)), new TestEdge(A, G, new TestWeight(4))));
    executeSearch(graphSearch(), graph, A, G, weigher, 3, new TestWeight(4.0));
    executeSinglePathSearch(graphSearch(), graph, A, G, weigher, 1, new TestWeight(4.0));
}
#method_after
@Test
public void negativeWeights() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G), of(new TestEdge(A, B, W1), new TestEdge(A, C, NW1), new TestEdge(B, D, W1), new TestEdge(D, A, NW2), new TestEdge(C, D, W1), new TestEdge(D, E, W1), new TestEdge(D, F, W1), new TestEdge(E, G, W1), new TestEdge(F, G, W1), new TestEdge(G, A, NW5), new TestEdge(A, G, W4)));
    executeSearch(graphSearch(), graph, A, G, weigher, 3, new TestDoubleWeight(4.0));
    executeSinglePathSearch(graphSearch(), graph, A, G, weigher, 1, new TestDoubleWeight(4.0));
}
#end_block

#method_before
@Test
public void disconnectedPerf() {
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
}
#method_after
public void disconnectedPerf() {
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
    disconnected();
}
#end_block

#method_before
@Test
public void disconnected() {
    Set<TestVertex> vertexes = new HashSet<>();
    for (int i = 0; i < 200; i++) {
        vertexes.add(new TestVertex("v" + i));
    }
    graph = new AdjacencyListsGraph<>(vertexes, of());
    long start = System.nanoTime();
    for (TestVertex src : vertexes) {
        executeSearch(graphSearch(), graph, src, null, null, 0, new TestWeight(0));
    }
    long end = System.nanoTime();
    DecimalFormat fmt = new DecimalFormat("#,###");
    System.out.println("Compute cost is " + fmt.format(end - start) + " nanos");
}
#method_after
public void disconnected() {
    Set<TestVertex> vertexes = new HashSet<>();
    for (int i = 0; i < 200; i++) {
        vertexes.add(new TestVertex("v" + i));
    }
    graph = new AdjacencyListsGraph<>(vertexes, of());
    long start = System.nanoTime();
    for (TestVertex src : vertexes) {
        executeSearch(graphSearch(), graph, src, null, null, 0, new TestDoubleWeight(0));
    }
    long end = System.nanoTime();
    DecimalFormat fmt = new DecimalFormat("#,###");
    System.out.println("Compute cost is " + fmt.format(end - start) + " nanos");
}
#end_block

#method_before
@Override
public Weight cost() {
    return hasBackup() ? primary.cost().concat(secondary.cost()) : primary.cost();
}
#method_after
@Override
public Weight cost() {
    return hasBackup() ? primary.cost().merge(secondary.cost()) : primary.cost();
}
#end_block

#method_before
@Test
public void defaultGraphTest() {
    executeDefaultTest(7, 3, new TestWeight(8.0));
}
#method_after
@Test
public void defaultGraphTest() {
    executeDefaultTest(7, 3, new TestDoubleWeight(8.0));
}
#end_block

#method_before
@Test
public void defaultHopCountWeight() {
    weigher = null;
    executeDefaultTest(7, 3, new DefaultWeight(3.0));
}
#method_after
@Test
public void defaultHopCountWeight() {
    weigher = null;
    executeDefaultTest(7, 3, new ScalarWeight(3.0));
}
#end_block

#method_before
boolean relaxEdge(E edge, Weight cost, EdgeWeigher<V, E> ew, boolean... forbidNegatives) {
    V v = edge.dst();
    Weight hopCost = ew.weight(edge);
    if ((!hopCost.isViable()) || (hopCost.isNegative() && forbidNegatives.length == 1 && forbidNegatives[0])) {
        return false;
    }
    Weight newCost = cost.concat(hopCost);
    int compareResult = -1;
    if (hasCost(v)) {
        Weight oldCost = cost(v);
        compareResult = newCost.compareTo(oldCost);
    }
    if (compareResult <= 0) {
        updateVertex(v, edge, newCost, compareResult < 0);
    }
    return compareResult < 0;
}
#method_after
boolean relaxEdge(E edge, Weight cost, EdgeWeigher<V, E> ew, boolean... forbidNegatives) {
    V v = edge.dst();
    Weight hopCost = ew.weight(edge);
    if ((!hopCost.isViable()) || (hopCost.isNegative() && forbidNegatives.length == 1 && forbidNegatives[0])) {
        return false;
    }
    Weight newCost = cost.merge(hopCost);
    int compareResult = -1;
    if (hasCost(v)) {
        Weight oldCost = cost(v);
        compareResult = newCost.compareTo(oldCost);
    }
    if (compareResult <= 0) {
        updateVertex(v, edge, newCost, compareResult < 0);
    }
    return compareResult < 0;
}
#end_block

#method_before
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    final Set<Path> paths = getPaths(src, dst);
    for (Path path : paths) {
        final DeviceId srcDevice = path.src().elementId() instanceof DeviceId ? path.src().deviceId() : null;
        final DeviceId dstDevice = path.dst().elementId() instanceof DeviceId ? path.dst().deviceId() : null;
        if (srcDevice != null && dstDevice != null) {
            final TopologyVertex srcVertex = new DefaultTopologyVertex(srcDevice);
            final TopologyVertex dstVertex = new DefaultTopologyVertex(dstDevice);
            final Link link = link(src.toString(), 1, dst.toString(), 1);
            final Weight weightValue = weigher.weight(new DefaultTopologyEdge(srcVertex, dstVertex, link));
            if (weightValue.isNegative()) {
                return new HashSet<>();
            }
        }
    }
    return paths;
}
#method_after
@Override
public Set<Path> getPaths(ElementId src, ElementId dst, LinkWeigher weigher) {
    Set<Path> paths = getPaths(src, dst);
    for (Path path : paths) {
        DeviceId srcDevice = path.src().elementId() instanceof DeviceId ? path.src().deviceId() : null;
        DeviceId dstDevice = path.dst().elementId() instanceof DeviceId ? path.dst().deviceId() : null;
        if (srcDevice != null && dstDevice != null) {
            TopologyVertex srcVertex = new DefaultTopologyVertex(srcDevice);
            TopologyVertex dstVertex = new DefaultTopologyVertex(dstDevice);
            Link link = link(src.toString(), 1, dst.toString(), 1);
            Weight weightValue = weigher.weight(new DefaultTopologyEdge(srcVertex, dstVertex, link));
            if (weightValue.isNegative()) {
                return new HashSet<>();
            }
        }
    }
    return paths;
}
#end_block

#method_before
protected Path getPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<Path> paths = pathService.getPaths(one, two, weigher(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<Path> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        throw new PathNotFoundException(one, two);
    }
    // TODO: let's be more intelligent about this eventually
    return filtered.iterator().next();
}
#method_after
protected Path getPath(ConnectivityIntent intent, ElementId one, ElementId two) {
    Set<Path> paths = pathService.getPaths(one, two, weigher(intent.constraints()));
    final List<Constraint> constraints = intent.constraints();
    ImmutableList<Path> filtered = FluentIterable.from(paths).filter(path -> checkPath(path, constraints)).toList();
    if (filtered.isEmpty()) {
        return null;
    }
    // TODO: let's be more intelligent about this eventually
    return filtered.iterator().next();
}
#end_block

#method_before
@Override
public Weight weight(TopologyEdge edge) {
    // iterate over all constraints in order and return the weight of
    // the first one with fast fail over the first failure
    Iterator<Constraint> it = constraints.iterator();
    if (!it.hasNext()) {
        return new DefaultWeight(HOP_WEIGHT_VALUE);
    }
    double cost = it.next().cost(edge.link(), resourceService::isAvailable);
    while (it.hasNext() && cost > 0) {
        if (it.next().cost(edge.link(), resourceService::isAvailable) < 0) {
            cost = -1;
        }
    }
    return new DefaultWeight(cost);
}
#method_after
@Override
public Weight weight(TopologyEdge edge) {
    // iterate over all constraints in order and return the weight of
    // the first one with fast fail over the first failure
    Iterator<Constraint> it = constraints.iterator();
    if (!it.hasNext()) {
        return new ScalarWeight(HOP_WEIGHT_VALUE);
    }
    double cost = it.next().cost(edge.link(), resourceService::isAvailable);
    while (it.hasNext() && cost > 0) {
        if (it.next().cost(edge.link(), resourceService::isAvailable) < 0) {
            cost = -1;
        }
    }
    return new ScalarWeight(cost);
}
#end_block

#method_before
private void findTunnelAndHighlights() {
    Collection<Tunnel> tunnelSet = null;
    Highlights highlights = new Highlights();
    paths.clear();
    tunnelSet = tunnelService.queryTunnel(MPLS);
    if (tunnelSet.size() == 0) {
        log.warn("Tunnel does not exist");
        sendMessage(highlightsMessage(highlights));
        return;
    }
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.path() == null) {
            log.error("path does not exist");
            sendMessage(highlightsMessage(highlights));
            return;
        }
        if (!tunnel.state().equals(ACTIVE)) {
            log.debug("Tunnel state is not active");
            sendMessage(highlightsMessage(highlights));
            return;
        }
        Link firstLink = tunnel.path().links().get(0);
        if (firstLink != null) {
            if (firstLink.src() != null) {
                highlights = addBadge(highlights, firstLink.src().deviceId().toString(), SRC);
            }
        }
        Link lastLink = tunnel.path().links().get(tunnel.path().links().size() - 1);
        if (lastLink != null) {
            if (lastLink.dst() != null) {
                highlights = addBadge(highlights, lastLink.dst().deviceId().toString(), DST);
            }
        }
        paths.add(tunnel.path());
    }
    ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
    allPathLinks = buildPaths(builder).build();
    hilightAndSendPaths(highlights);
}
#method_after
private void findTunnelAndHighlights() {
    Collection<Tunnel> tunnelSet = null;
    Highlights highlights = new Highlights();
    paths.clear();
    tunnelSet = tunnelService.queryTunnel(MPLS);
    if (tunnelSet.isEmpty()) {
        log.warn("Tunnel does not exist");
        sendMessage(highlightsMessage(highlights));
        return;
    }
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.path() == null) {
            log.error("path does not exist");
            sendMessage(highlightsMessage(highlights));
            return;
        }
        if (!tunnel.state().equals(ACTIVE)) {
            log.debug("Tunnel state is not active");
            sendMessage(highlightsMessage(highlights));
            return;
        }
        Link firstLink = tunnel.path().links().get(0);
        if (firstLink != null) {
            if (firstLink.src() != null) {
                highlights = addBadge(highlights, firstLink.src().deviceId().toString(), SRC);
            }
        }
        Link lastLink = tunnel.path().links().get(tunnel.path().links().size() - 1);
        if (lastLink != null) {
            if (lastLink.dst() != null) {
                highlights = addBadge(highlights, lastLink.dst().deviceId().toString(), DST);
            }
        }
        paths.add(tunnel.path());
    }
    ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
    allPathLinks = buildPaths(builder).build();
    hilightAndSendPaths(highlights);
}
#end_block

#method_before
private void sendPacketOut(ConnectPoint outport, Ethernet payload, int sid, IpAddress destIpAddress, byte allowedHops) {
    if (sid == -1 || config.getSegmentId(payload.getDestinationMAC()) == sid || config.inSameSubnet(outport.deviceId(), destIpAddress)) {
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(outport.port()).build();
        OutboundPacket packet = new DefaultOutboundPacket(outport.deviceId(), treatment, ByteBuffer.wrap(payload.serialize()));
        srManager.packetService.emit(packet);
    } else {
        log.debug("Send a MPLS packet as a ICMP response");
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(outport.port()).build();
        payload.setEtherType(Ethernet.MPLS_UNICAST);
        MPLS mplsPkt = new MPLS();
        mplsPkt.setLabel(sid);
        mplsPkt.setTtl(allowedHops);
        mplsPkt.setPayload(payload.getPayload());
        payload.setPayload(mplsPkt);
        OutboundPacket packet = new DefaultOutboundPacket(outport.deviceId(), treatment, ByteBuffer.wrap(payload.serialize()));
        srManager.packetService.emit(packet);
    }
}
#method_after
private void sendPacketOut(ConnectPoint outport, Ethernet payload, int sid, IpAddress destIpAddress, byte allowedHops) {
    int destSid;
    if (destIpAddress.isIp4()) {
        destSid = config.getIPv4SegmentId(payload.getDestinationMAC());
    } else {
        destSid = config.getIPv6SegmentId(payload.getDestinationMAC());
    }
    if (sid == -1 || destSid == sid || config.inSameSubnet(outport.deviceId(), destIpAddress)) {
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(outport.port()).build();
        OutboundPacket packet = new DefaultOutboundPacket(outport.deviceId(), treatment, ByteBuffer.wrap(payload.serialize()));
        srManager.packetService.emit(packet);
    } else {
        log.debug("Send a MPLS packet as a ICMP response");
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(outport.port()).build();
        payload.setEtherType(Ethernet.MPLS_UNICAST);
        MPLS mplsPkt = new MPLS();
        mplsPkt.setLabel(sid);
        mplsPkt.setTtl(allowedHops);
        mplsPkt.setPayload(payload.getPayload());
        payload.setPayload(mplsPkt);
        OutboundPacket packet = new DefaultOutboundPacket(outport.deviceId(), treatment, ByteBuffer.wrap(payload.serialize()));
        srManager.packetService.emit(packet);
    }
}
#end_block

#method_before
// ////////////////////////////////////
// ICMP Echo/Reply Protocol     //
// ////////////////////////////////////
public void processIcmp(Ethernet eth, ConnectPoint inPort) {
    DeviceId deviceId = inPort.deviceId();
    IPv4 ipv4Packet = (IPv4) eth.getPayload();
    Ip4Address destinationAddress = Ip4Address.valueOf(ipv4Packet.getDestinationAddress());
    Set<IpAddress> gatewayIpAddresses = config.getPortIPs(deviceId);
    IpAddress routerIp;
    try {
        routerIp = config.getRouterIp(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting processPacketIn.");
        return;
    }
    // ICMP to the router IP or gateway IP
    if (((ICMP) ipv4Packet.getPayload()).getIcmpType() == ICMP.TYPE_ECHO_REQUEST && (destinationAddress.equals(routerIp.getIp4Address()) || gatewayIpAddresses.contains(destinationAddress))) {
        sendIcmpResponse(eth, inPort);
    // ICMP for any known host
    } else if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        // TODO: known host packet should not be coming to controller - resend flows?
        srManager.ipHandler.forwardPackets(deviceId, destinationAddress);
    // ICMP for an unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.arpHandler.sendArpRequest(deviceId, destinationAddress, inPort);
    // ICMP for an unknown host
    } else {
        log.debug("ICMP request for unknown host {} ", destinationAddress);
    // Do nothing
    }
}
#method_after
// ////////////////////////////////////
// ICMP Echo/Reply Protocol     //
// ////////////////////////////////////
public void processIcmp(Ethernet eth, ConnectPoint inPort) {
    DeviceId deviceId = inPort.deviceId();
    IPv4 ipv4Packet = (IPv4) eth.getPayload();
    Ip4Address destinationAddress = Ip4Address.valueOf(ipv4Packet.getDestinationAddress());
    Set<IpAddress> gatewayIpAddresses = config.getPortIPs(deviceId);
    IpAddress routerIp;
    try {
        routerIp = config.getRouterIpv4(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting processPacketIn.");
        return;
    }
    // ICMP to the router IP or gateway IP
    if (((ICMP) ipv4Packet.getPayload()).getIcmpType() == ICMP.TYPE_ECHO_REQUEST && (destinationAddress.equals(routerIp.getIp4Address()) || gatewayIpAddresses.contains(destinationAddress))) {
        sendIcmpResponse(eth, inPort);
        // We remove the packet from the queue
        srManager.ipHandler.dequeuePacket(ipv4Packet, destinationAddress);
    // ICMP for any known host
    } else if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        // TODO: known host packet should not be coming to controller - resend flows?
        srManager.ipHandler.forwardPackets(deviceId, destinationAddress);
    // ICMP for an unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.arpHandler.sendArpRequest(deviceId, destinationAddress, inPort);
    // ICMP for an unknown host
    } else {
        log.debug("ICMP request for unknown host {} ", destinationAddress);
        // We remove the packet from the queue
        srManager.ipHandler.dequeuePacket(ipv4Packet, destinationAddress);
    }
}
#end_block

#method_before
private void sendIcmpResponse(Ethernet icmpRequest, ConnectPoint outport) {
    // Note: We assume that packets arrive at the edge switches have
    // untagged VLAN.
    Ethernet icmpReplyEth = ICMP.buildIcmpReply(icmpRequest);
    IPv4 icmpRequestIpv4 = (IPv4) icmpRequest.getPayload();
    IPv4 icmpReplyIpv4 = (IPv4) icmpReplyEth.getPayload();
    Ip4Address destIpAddress = Ip4Address.valueOf(icmpRequestIpv4.getSourceAddress());
    IpAddress destRouterAddress = config.getRouterIpAddressForASubnetHost(destIpAddress);
    int sid = config.getSegmentId(destRouterAddress);
    if (sid < 0) {
        log.warn("Cannot find the Segment ID for {}", destIpAddress);
        return;
    }
    sendPacketOut(outport, icmpReplyEth, sid, destIpAddress, icmpReplyIpv4.getTtl());
}
#method_after
private void sendIcmpResponse(Ethernet icmpRequest, ConnectPoint outport) {
    // Note: We assume that packets arrive at the edge switches have
    // untagged VLAN.
    Ethernet icmpReplyEth = ICMP.buildIcmpReply(icmpRequest);
    IPv4 icmpRequestIpv4 = (IPv4) icmpRequest.getPayload();
    IPv4 icmpReplyIpv4 = (IPv4) icmpReplyEth.getPayload();
    Ip4Address destIpAddress = Ip4Address.valueOf(icmpRequestIpv4.getSourceAddress());
    Ip4Address destRouterAddress = config.getRouterIpAddressForASubnetHost(destIpAddress);
    int destSid = config.getIPv4SegmentId(destRouterAddress);
    if (destSid < 0) {
        log.warn("Cannot find the Segment ID for {}", destIpAddress);
        return;
    }
    sendPacketOut(outport, icmpReplyEth, destSid, destIpAddress, icmpReplyIpv4.getTtl());
}
#end_block

#method_before
// /////////////////////////////////////////
// ICMPv6 Echo/Reply Protocol       //
// /////////////////////////////////////////
public void processIcmpv6(Ethernet eth, ConnectPoint inPort) {
    DeviceId deviceId = inPort.deviceId();
    IPv6 ipv6Packet = (IPv6) eth.getPayload();
    Ip6Address destinationAddress = Ip6Address.valueOf(ipv6Packet.getDestinationAddress());
    Set<IpAddress> gatewayIpAddresses = config.getPortIPs(deviceId);
    IpAddress routerIp;
    try {
        routerIp = config.getRouterIp(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting processPacketIn.");
        return;
    }
    ICMP6 icmp6 = (ICMP6) ipv6Packet.getPayload();
    // ICMP to the router IP or gateway IP
    if (icmp6.getIcmpType() == ICMP6.ECHO_REQUEST && (destinationAddress.equals(routerIp.getIp6Address()) || gatewayIpAddresses.contains(destinationAddress))) {
        sendIcmpv6Response(eth, inPort);
    // ICMP for any known host
    } else if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        // TODO: known host packet should not be coming to controller - resend flows?
        srManager.ipHandler.forwardPackets(deviceId, destinationAddress);
    // ICMP for an unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        sendNdpRequest(deviceId, destinationAddress, inPort);
    // ICMP for an unknown host
    } else {
        log.debug("ICMPv6 request for unknown host {} ", destinationAddress);
    // Do nothing
    }
}
#method_after
// /////////////////////////////////////////
// ICMPv6 Echo/Reply Protocol       //
// /////////////////////////////////////////
public void processIcmpv6(Ethernet eth, ConnectPoint inPort) {
    DeviceId deviceId = inPort.deviceId();
    IPv6 ipv6Packet = (IPv6) eth.getPayload();
    Ip6Address destinationAddress = Ip6Address.valueOf(ipv6Packet.getDestinationAddress());
    Set<IpAddress> gatewayIpAddresses = config.getPortIPs(deviceId);
    IpAddress routerIp;
    try {
        routerIp = config.getRouterIpv6(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting processPacketIn.");
        return;
    }
    ICMP6 icmp6 = (ICMP6) ipv6Packet.getPayload();
    // ICMP to the router IP or gateway IP
    if (icmp6.getIcmpType() == ICMP6.ECHO_REQUEST && (destinationAddress.equals(routerIp.getIp6Address()) || gatewayIpAddresses.contains(destinationAddress))) {
        sendIcmpv6Response(eth, inPort);
        // We remove the packet from the queue
        srManager.ipHandler.dequeuePacket(ipv6Packet, destinationAddress);
    // ICMP for any known host
    } else if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        // TODO: known host packet should not be coming to controller - resend flows?
        srManager.ipHandler.forwardPackets(deviceId, destinationAddress);
    // ICMP for an unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        sendNdpRequest(deviceId, destinationAddress, inPort);
    // ICMP for an unknown host or not configured host
    } else {
        log.debug("ICMPv6 request for unknown host or not configured host {} ", destinationAddress);
        // We remove the packet from the queue
        srManager.ipHandler.dequeuePacket(ipv6Packet, destinationAddress);
    }
}
#end_block

#method_before
private void sendIcmpv6Response(Ethernet ethRequest, ConnectPoint outport) {
    // Note: We assume that packets arrive at the edge switches have
    // untagged VLAN.
    Ethernet ethReply = ICMP6.buildIcmp6Reply(ethRequest);
    IPv6 icmpRequestIpv6 = (IPv6) ethRequest.getPayload();
    IPv6 icmpReplyIpv6 = (IPv6) ethRequest.getPayload();
    Ip6Address destIpAddress = Ip6Address.valueOf(icmpRequestIpv6.getSourceAddress());
    IpAddress destRouterAddress = config.getRouterIpAddressForASubnetHost(destIpAddress);
    int sid = config.getSegmentId(destRouterAddress);
    if (sid < 0) {
        log.warn("Cannot find the Segment ID for {}", destIpAddress);
        return;
    }
    sendPacketOut(outport, ethReply, sid, destIpAddress, icmpReplyIpv6.getHopLimit());
}
#method_after
private void sendIcmpv6Response(Ethernet ethRequest, ConnectPoint outport) {
    // Note: We assume that packets arrive at the edge switches have
    // untagged VLAN.
    Ethernet ethReply = ICMP6.buildIcmp6Reply(ethRequest);
    IPv6 icmpRequestIpv6 = (IPv6) ethRequest.getPayload();
    IPv6 icmpReplyIpv6 = (IPv6) ethRequest.getPayload();
    Ip6Address destIpAddress = Ip6Address.valueOf(icmpRequestIpv6.getSourceAddress());
    Ip6Address destRouterAddress = config.getRouterIpAddressForASubnetHost(destIpAddress);
    int sid = config.getIPv6SegmentId(destRouterAddress);
    if (sid < 0) {
        log.warn("Cannot find the Segment ID for {}", destIpAddress);
        return;
    }
    sendPacketOut(outport, ethReply, sid, destIpAddress, icmpReplyIpv6.getHopLimit());
}
#end_block

#method_before
// /////////////////////////////////////////
// ICMPv6 Neighbour Discovery Protocol  //
// /////////////////////////////////////////
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    /*
         * First we validate the ndp packet
         */
    if (!validateSrcIp(pkt)) {
        log.debug("Ignore NDP packet discovered on {} with unexpected src ip address {}.", pkt.inPort(), pkt.sender());
        pkt.drop();
        return;
    }
    if (pkt.type() == NeighbourMessageType.REQUEST) {
        handleNdpRequest(pkt, hostService);
    } else {
        handleNdpReply(pkt, hostService);
    }
}
#method_after
// /////////////////////////////////////////
// ICMPv6 Neighbour Discovery Protocol  //
// /////////////////////////////////////////
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    /*
         * First we validate the ndp packet
         */
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(pkt.inPort())) {
        // Ignore NDP packets come from suppressed ports
        pkt.drop();
        return;
    }
    if (!validateSrcIp(pkt)) {
        log.debug("Ignore NDP packet discovered on {} with unexpected src ip address {}.", pkt.inPort(), pkt.sender());
        pkt.drop();
        return;
    }
    if (pkt.type() == NeighbourMessageType.REQUEST) {
        handleNdpRequest(pkt, hostService);
    } else {
        handleNdpReply(pkt, hostService);
    }
}
#end_block

#method_before
private boolean validateSrcIp(NeighbourMessageContext pkt) {
    ConnectPoint connectPoint = pkt.inPort();
    IpPrefix subnet = config.getPortSubnet(connectPoint.deviceId(), connectPoint.port()).getIp6Prefix();
    return subnet != null && subnet.contains(pkt.sender());
}
#method_after
private boolean validateSrcIp(NeighbourMessageContext pkt) {
    ConnectPoint connectPoint = pkt.inPort();
    IpPrefix subnet = config.getPortIPv6Subnet(connectPoint.deviceId(), connectPoint.port()).getIp6Prefix();
    return subnet != null && subnet.contains(pkt.sender());
}
#end_block

#method_before
private boolean isNdpForGateway(NeighbourMessageContext pkt) {
    DeviceId deviceId = pkt.inPort().deviceId();
    Set<IpAddress> gatewayIpAddresses = null;
    try {
        if (pkt.target().equals(config.getRouterIp(deviceId))) {
            return true;
        }
        gatewayIpAddresses = config.getPortIPs(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting check for router IP in processing ndp");
    }
    if (gatewayIpAddresses != null && gatewayIpAddresses.contains(pkt.target())) {
        return true;
    }
    return false;
}
#method_after
private boolean isNdpForGateway(NeighbourMessageContext pkt) {
    DeviceId deviceId = pkt.inPort().deviceId();
    Set<IpAddress> gatewayIpAddresses = null;
    try {
        if (pkt.target().equals(config.getRouterIpv6(deviceId))) {
            return true;
        }
        gatewayIpAddresses = config.getPortIPs(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting check for router IP in processing ndp");
    }
    if (gatewayIpAddresses != null && gatewayIpAddresses.contains(pkt.target())) {
        return true;
    }
    return false;
}
#end_block

#method_before
public void sendNdpRequest(DeviceId deviceId, IpAddress targetAddress, ConnectPoint inPort) {
    byte[] senderMacAddress = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] senderIpAddress = new byte[Ip6Address.BYTE_LENGTH];
    /*
         * Retrieves device info.
         */
    getSenderInfo(senderMacAddress, senderIpAddress, deviceId, targetAddress);
    /*
         * We have to compute the dst mac address and dst
         * ip address.
         */
    byte[] dstIp = IPv6.solicitationNodeAddress(targetAddress.toOctets());
    byte[] dstMac = IPv6.multicastMacAddress(dstIp);
    /*
         * Creates the request.
         */
    Ethernet ndpRequest = NeighborSolicitation.buildNdpSolicit(targetAddress.toOctets(), senderIpAddress, dstIp, senderMacAddress, dstMac, VlanId.NONE);
    flood(ndpRequest, inPort, targetAddress);
}
#method_after
public void sendNdpRequest(DeviceId deviceId, IpAddress targetAddress, ConnectPoint inPort) {
    byte[] senderMacAddress = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] senderIpAddress = new byte[Ip6Address.BYTE_LENGTH];
    /*
         * Retrieves device info.
         */
    getSenderInfo(senderMacAddress, senderIpAddress, deviceId, targetAddress);
    /*
         * We have to compute the dst mac address and dst
         * ip address.
         */
    byte[] dstIp = IPv6.getSolicitNodeAddress(targetAddress.toOctets());
    byte[] dstMac = IPv6.getMCastMacAddress(dstIp);
    /*
         * Creates the request.
         */
    Ethernet ndpRequest = NeighborSolicitation.buildNdpSolicit(targetAddress.toOctets(), senderIpAddress, dstIp, senderMacAddress, dstMac, VlanId.NONE);
    flood(ndpRequest, inPort, targetAddress);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    /*
         * This option is necessary to activate the support for NeighborDiscovery
         * protocol in the NRM.
         */
    compCfgService.preSetProperty("org.onosproject.incubator.net.neighbour.impl." + "NeighbourResolutionManager", "ndpEnabled", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.vrouter.Vrouter", "fibInstallerEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.incubator.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelay", "arpEnabled", "false");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    cfgListener.configureNetwork();
    routeService.addListener(routeListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    cordConfigService.removeListener(cordConfigListener);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    nsNextObjStore.destroy();
    subnetNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    subnetVidStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    cordConfigService.removeListener(cordConfigListener);
    routeService.removeListener(routeListener);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    nsNextObjStore.destroy();
    subnetNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    subnetVidStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
/**
 * Returns the vlan-id assigned to the subnet configured for a device.
 * If no vlan-id has been assigned, a new one is assigned out of a pool of ids,
 * if and only if this controller instance is the master for the device.
 * <p>
 * USAGE: The assigned vlans are meant to be applied to untagged packets on those
 * switches/pipelines that need this functionality. These vids are meant
 * to be used internally within a switch, and thus need to be unique only
 * on a switch level. Note that packets never go out on the wire with these
 * vlans. Currently, vlan ids are assigned from value 4093 down.
 * Vlan id 4094 expected to be used for all ports that are not assigned subnets.
 * Vlan id 4095 is reserved and unused. Only a single vlan id is assigned
 * per subnet.
 *
 * @param deviceId switch dpid
 * @param subnet IP prefix for which assigned vlan is desired
 * @return VlanId assigned for the subnet on the device, or
 *         null if no vlan assignment was found and this instance is not
 *         the master for the device.
 */
public VlanId getSubnetAssignedVlanId(DeviceId deviceId, IpPrefix subnet) {
    VlanId assignedVid = subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, subnet));
    if (assignedVid != null) {
        log.debug("Query for subnet:{} on device:{} returned assigned-vlan " + "{}", subnet, deviceId, assignedVid);
        return assignedVid;
    }
    // check mastership for the right to assign a vlan
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("This controller instance is not the master for device {}. " + "Cannot assign vlan-id for subnet {}", deviceId, subnet);
        return null;
    }
    // vlan assignment is expensive but done only once
    Set<IpPrefix> configuredSubnets = deviceConfiguration.getSubnets(deviceId);
    Set<Short> assignedVlans = new HashSet<>();
    Set<IpPrefix> unassignedSubnets = new HashSet<>();
    for (IpPrefix sub : configuredSubnets) {
        VlanId v = subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, sub));
        if (v != null) {
            assignedVlans.add(v.toShort());
        } else {
            unassignedSubnets.add(sub);
        }
    }
    short nextAssignedVlan = ASSIGNED_VLAN_START;
    if (!assignedVlans.isEmpty()) {
        nextAssignedVlan = (short) (Collections.min(assignedVlans) - 1);
    }
    for (IpPrefix unsub : unassignedSubnets) {
        // Special case for default route. Assign default VLAN ID to /32, /0 and 128/ subnets
        if (unsub.prefixLength() == IpPrefix.MAX_INET_MASK_LENGTH || unsub.prefixLength() == IpPrefix.MAX_INET6_MASK_LENGTH || unsub.prefixLength() == 0) {
            subnetVidStore.put(new SubnetAssignedVidStoreKey(deviceId, unsub), VlanId.vlanId(ASSIGNED_VLAN_NO_SUBNET));
        } else {
            subnetVidStore.put(new SubnetAssignedVidStoreKey(deviceId, unsub), VlanId.vlanId(nextAssignedVlan--));
            log.info("Assigned vlan: {} to subnet: {} on device: {}", nextAssignedVlan + 1, unsub, deviceId);
        }
    }
    return subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, subnet));
}
#method_after
/**
 * Returns the vlan-id assigned to the subnet configured for a device.
 * If no vlan-id has been assigned, a new one is assigned out of a pool of ids,
 * if and only if this controller instance is the master for the device.
 * <p>
 * USAGE: The assigned vlans are meant to be applied to untagged packets on those
 * switches/pipelines that need this functionality. These vids are meant
 * to be used internally within a switch, and thus need to be unique only
 * on a switch level. Note that packets never go out on the wire with these
 * vlans. Currently, vlan ids are assigned from value 4093 down.
 * Vlan id 4094 expected to be used for all ports that are not assigned subnets.
 * Vlan id 4095 is reserved and unused. Only a single vlan id is assigned
 * per subnet.
 *
 * @param deviceId switch dpid
 * @param subnet IP prefix for which assigned vlan is desired
 * @return VlanId assigned for the subnet on the device, or
 *         null if no vlan assignment was found and this instance is not
 *         the master for the device.
 */
public VlanId getSubnetAssignedVlanId(DeviceId deviceId, IpPrefix subnet) {
    VlanId assignedVid = subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, subnet));
    if (assignedVid != null) {
        log.debug("Query for subnet:{} on device:{} returned assigned-vlan " + "{}", subnet, deviceId, assignedVid);
        return assignedVid;
    }
    // check mastership for the right to assign a vlan
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("This controller instance is not the master for device {}. " + "Cannot assign vlan-id for subnet {}", deviceId, subnet);
        return null;
    }
    // vlan assignment is expensive but done only once
    // FIXME for now we will do assignment considering only the ipv4 subnet.
    Set<Ip4Prefix> configuredSubnets = deviceConfiguration.getSubnets(deviceId).stream().filter(IpPrefix::isIp4).map(IpPrefix::getIp4Prefix).collect(Collectors.toSet());
    Set<Short> assignedVlans = new HashSet<>();
    Set<Ip4Prefix> unassignedSubnets = new HashSet<>();
    for (Ip4Prefix sub : configuredSubnets) {
        VlanId v = subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, sub));
        if (v != null) {
            assignedVlans.add(v.toShort());
        } else {
            unassignedSubnets.add(sub);
        }
    }
    short nextAssignedVlan = ASSIGNED_VLAN_START;
    if (!assignedVlans.isEmpty()) {
        nextAssignedVlan = (short) (Collections.min(assignedVlans) - 1);
    }
    for (Ip4Prefix unsub : unassignedSubnets) {
        subnetVidStore.put(new SubnetAssignedVidStoreKey(deviceId, unsub), VlanId.vlanId(nextAssignedVlan--));
        log.info("Assigned vlan: {} to subnet: {} on device: {}", nextAssignedVlan + 1, unsub, deviceId);
    }
    return subnetVidStore.get(new SubnetAssignedVidStoreKey(deviceId, subnet));
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("{} - we are still receiving ARP packets", ethernet);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) ethernet.getPayload();
        ipHandler.addToPacketBuffer(ipv4Packet);
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processIcmp(ethernet, pkt.receivedFrom());
        } else {
            ipHandler.processPacketIn(ipv4Packet, pkt.receivedFrom());
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        log.info("Received an IPv6 packet");
        /*
                 * We buffer the packet.
                 */
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
        ipHandler.addToPacketBuffer(ipv6Packet);
        /*
                 * We deal with the packet only if the packet is a ICMP6 ECHO/REPLY
                 */
        if (ipv6Packet.getNextHeader() == IPv6.PROTOCOL_ICMP6) {
            ICMP6 icmp6Packet = (ICMP6) ipv6Packet.getPayload();
            if (icmp6Packet.getIcmpType() == ICMP6.ECHO_REQUEST || icmp6Packet.getIcmpType() == ICMP6.ECHO_REPLY) {
                icmpHandler.processIcmpv6(ethernet, pkt.receivedFrom());
            } else {
                log.warn("Received ICMPv6 0x{} - not handled", Integer.toHexString(icmp6Packet.getIcmpType() & 0xff));
            }
        } else {
            ipHandler.processPacketIn(ipv6Packet, pkt.receivedFrom());
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("{} - we are still receiving ARP packets from {}", context.inPacket().receivedFrom());
        log.debug("{}", ethernet);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) ethernet.getPayload();
        // ipHandler.addToPacketBuffer(ipv4Packet);
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processIcmp(ethernet, pkt.receivedFrom());
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCP packets.
        // ipHandler.processPacketIn(pkt);
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
        /*
                 * We deal with the packet only if the packet is a ICMP6 ECHO/REPLY
                 */
        if (ipv6Packet.getNextHeader() == IPv6.PROTOCOL_ICMP6) {
            ICMP6 icmp6Packet = (ICMP6) ipv6Packet.getPayload();
            if (icmp6Packet.getIcmpType() == ICMP6.ECHO_REQUEST || icmp6Packet.getIcmpType() == ICMP6.ECHO_REPLY) {
                icmpHandler.processIcmpv6(ethernet, pkt.receivedFrom());
            } else {
                log.warn("Received ICMPv6 0x{} - not handled", Integer.toHexString(icmp6Packet.getIcmpType() & 0xff));
            }
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCPv6 packets.
        // ipHandler.processPacketIn(ipv6Packet, pkt.receivedFrom());
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        while (true) {
            @SuppressWarnings("rawtypes")
            Event event = null;
            synchronized (threadSchedulerLock) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED) {
                processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                Link linkRemoved = (Link) event.subject();
                if (linkRemoved.src().elementId() instanceof DeviceId && !deviceService.isAvailable(linkRemoved.src().deviceId())) {
                    continue;
                }
                if (linkRemoved.dst().elementId() instanceof DeviceId && !deviceService.isAvailable(linkRemoved.dst().deviceId())) {
                    continue;
                }
                processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // XXX typically these calls come when device is added
                // so port filtering rules are handled there, and it
                // represents all ports on the device, enabled or not.
                log.debug("** PORT ADDED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#method_after
@Override
public void run() {
    try {
        while (true) {
            @SuppressWarnings("rawtypes")
            Event event = null;
            synchronized (threadSchedulerLock) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED) {
                processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                Link linkRemoved = (Link) event.subject();
                if (linkRemoved.src().elementId() instanceof DeviceId && !deviceService.isAvailable(linkRemoved.src().deviceId())) {
                    continue;
                }
                if (linkRemoved.dst().elementId() instanceof DeviceId && !deviceService.isAvailable(linkRemoved.dst().deviceId())) {
                    continue;
                }
                processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.debug("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#end_block

#method_before
private void processDeviceAddedInternal(DeviceId deviceId) {
    // Irrespective of whether the local is a MASTER or not for this device,
    // we need to create a SR-group-handler instance. This is because in a
    // multi-instance setup, any instance can initiate forwarding/next-objectives
    // for any switch (even if this instance is a SLAVE or not even connected
    // to the switch). To handle this, a default-group-handler instance is necessary
    // per switch.
    log.debug("Current groupHandlerMap devs: {}", groupHandlerMap.keySet());
    if (groupHandlerMap.get(deviceId) == null) {
        DefaultGroupHandler groupHandler;
        try {
            groupHandler = DefaultGroupHandler.createGroupHandler(deviceId, appId, deviceConfiguration, linkService, flowObjectiveService, this);
        } catch (DeviceConfigNotFoundException e) {
            log.warn(e.getMessage() + " Aborting processDeviceAdded.");
            return;
        }
        log.debug("updating groupHandlerMap with new config for device: {}", deviceId);
        groupHandlerMap.put(deviceId, groupHandler);
    }
    // Also, in some cases, drivers may need extra
    // information to process rules (eg. Router IP/MAC); and so, we send
    // port addressing rules to the driver as well irrespective of whether
    // this instance is the master or not.
    defaultRoutingHandler.populatePortAddressingRules(deviceId);
    if (mastershipService.isLocalMaster(deviceId)) {
        hostHandler.readInitialHosts(deviceId);
        xConnectHandler.init(deviceId);
        cordConfigHandler.init(deviceId);
        DefaultGroupHandler groupHandler = groupHandlerMap.get(deviceId);
        groupHandler.createGroupsFromSubnetConfig();
        routingRulePopulator.populateSubnetBroadcastRule(deviceId);
    }
    appCfgHandler.initVRouters(deviceId);
}
#method_after
private void processDeviceAddedInternal(DeviceId deviceId) {
    // Irrespective of whether the local is a MASTER or not for this device,
    // we need to create a SR-group-handler instance. This is because in a
    // multi-instance setup, any instance can initiate forwarding/next-objectives
    // for any switch (even if this instance is a SLAVE or not even connected
    // to the switch). To handle this, a default-group-handler instance is necessary
    // per switch.
    log.debug("Current groupHandlerMap devs: {}", groupHandlerMap.keySet());
    if (groupHandlerMap.get(deviceId) == null) {
        DefaultGroupHandler groupHandler;
        try {
            groupHandler = DefaultGroupHandler.createGroupHandler(deviceId, appId, deviceConfiguration, linkService, flowObjectiveService, this);
        } catch (DeviceConfigNotFoundException e) {
            log.warn(e.getMessage() + " Aborting processDeviceAdded.");
            return;
        }
        log.debug("updating groupHandlerMap with new config for device: {}", deviceId);
        groupHandlerMap.put(deviceId, groupHandler);
    }
    // Also, in some cases, drivers may need extra
    // information to process rules (eg. Router IP/MAC); and so, we send
    // port addressing rules to the driver as well irrespective of whether
    // this instance is the master or not.
    defaultRoutingHandler.populatePortAddressingRules(deviceId);
    if (mastershipService.isLocalMaster(deviceId)) {
        hostHandler.init(deviceId);
        xConnectHandler.init(deviceId);
        cordConfigHandler.init(deviceId);
        DefaultGroupHandler groupHandler = groupHandlerMap.get(deviceId);
        groupHandler.createGroupsFromSubnetConfig();
        routingRulePopulator.populateSubnetBroadcastRule(deviceId);
    }
    appCfgHandler.init(deviceId);
    routeHandler.init(deviceId);
}
#end_block

#method_before
private void processPortUpdated(Device device, Port port) {
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(device.id())) {
        log.warn("Device configuration uploading. Not handling port event for" + "dev: {} port: {}", device.id(), port.number());
        return;
    }
    /* XXX create method for single port filtering rules which are needed
           for both switch-to-switch ports and edge ports
        if (defaultRoutingHandler != null) {
            defaultRoutingHandler.populatePortAddressingRules(
                ((Device) event.subject()).id());
        }*/
    // portUpdated calls are for ports that have gone down or up. For switch
    // to switch ports, link-events should take care of any re-routing or
    // group editing necessary for port up/down. Here we only process edge ports
    // that are already configured.
    Ip4Prefix configuredSubnet = deviceConfiguration.getPortSubnet(device.id(), port.number()).getIp4Prefix();
    if (configuredSubnet == null) {
        log.debug("Not handling port updated event for unconfigured port " + "dev/port: {}/{}", device.id(), port.number());
        return;
    }
    processEdgePort(device, port, configuredSubnet);
}
#method_after
private void processPortUpdated(Device device, Port port) {
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(device.id())) {
        log.warn("Device configuration uploading. Not handling port event for" + "dev: {} port: {}", device.id(), port.number());
        return;
    }
    /* XXX create method for single port filtering rules which are needed
           for both switch-to-switch ports and edge ports
        if (defaultRoutingHandler != null) {
            defaultRoutingHandler.populatePortAddressingRules(
                ((Device) event.subject()).id());
        }*/
    // portUpdated calls are for ports that have gone down or up. For switch
    // to switch ports, link-events should take care of any re-routing or
    // group editing necessary for port up/down. Here we only process edge ports
    // that are already configured.
    Ip4Prefix configuredSubnet = deviceConfiguration.getPortIPv4Subnet(device.id(), port.number());
    if (configuredSubnet == null) {
        log.debug("Not handling port updated event for unconfigured port " + "dev/port: {}/{}", device.id(), port.number());
        return;
    }
    processEdgePort(device, port, configuredSubnet);
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Config added.");
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated.");
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
        configureNetwork();
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    if (!validateArpSpa(pkt)) {
        log.debug("Ignore ARP packet discovered on {} with unexpected src protocol address {}.", pkt.inPort(), pkt.sender().getIp4Address());
        return;
    }
    if (pkt.type() == REQUEST) {
        handleArpRequest(pkt, hostService);
    } else {
        handleArpReply(pkt, hostService);
    }
}
#method_after
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(pkt.inPort())) {
        // Ignore ARP packets come from suppressed ports
        pkt.drop();
        return;
    }
    if (!validateArpSpa(pkt)) {
        log.debug("Ignore ARP packet discovered on {} with unexpected src protocol address {}.", pkt.inPort(), pkt.sender().getIp4Address());
        pkt.drop();
        return;
    }
    if (pkt.type() == REQUEST) {
        handleArpRequest(pkt, hostService);
    } else {
        handleArpReply(pkt, hostService);
    }
}
#end_block

#method_before
private void handleArpRequest(NeighbourMessageContext pkt, HostService hostService) {
    // ARP request for router. Send ARP reply.
    if (isArpForRouter(pkt)) {
        MacAddress targetMac = config.getRouterMacForAGatewayIp(pkt.target().getIp4Address());
        sendResponse(pkt, targetMac, hostService);
    } else {
        Set<Host> hosts = hostService.getHostsByIp(pkt.target());
        if (hosts.size() > 1) {
            log.warn("More than host with the same ip {}", pkt.target());
        }
        Host targetHost = hosts.stream().findFirst().orElse(null);
        // ARP request for known hosts. Send proxy ARP reply on behalf of the target.
        if (targetHost != null) {
            pkt.forward(targetHost.location());
        // ARP request for unknown host in the subnet. Flood in the subnet.
        } else {
            flood(pkt);
        }
    }
}
#method_after
private void handleArpRequest(NeighbourMessageContext pkt, HostService hostService) {
    // ARP request for router. Send ARP reply.
    if (isArpForRouter(pkt)) {
        MacAddress targetMac = config.getRouterMacForAGatewayIp(pkt.target().getIp4Address());
        sendResponse(pkt, targetMac, hostService);
    } else {
        Set<Host> hosts = hostService.getHostsByIp(pkt.target());
        if (hosts.size() > 1) {
            log.warn("More than one host with the same ip {}", pkt.target());
        }
        Host targetHost = hosts.stream().findFirst().orElse(null);
        // ARP request for known hosts. Send proxy ARP reply on behalf of the target.
        if (targetHost != null) {
            pkt.forward(targetHost.location());
        // ARP request for unknown host in the subnet. Flood in the subnet.
        } else {
            flood(pkt);
        }
    }
}
#end_block

#method_before
private boolean validateArpSpa(NeighbourMessageContext pkt) {
    Ip4Address spa = pkt.sender().getIp4Address();
    Ip4Prefix subnet = config.getPortSubnet(pkt.inPort().deviceId(), pkt.inPort().port()).getIp4Prefix();
    return subnet != null && subnet.contains(spa);
}
#method_after
private boolean validateArpSpa(NeighbourMessageContext pkt) {
    Ip4Address spa = pkt.sender().getIp4Address();
    Set<IpPrefix> subnet = config.getPortSubnets(pkt.inPort().deviceId(), pkt.inPort().port()).stream().filter(ipPrefix -> ipPrefix.isIp4() && ipPrefix.contains(spa)).collect(Collectors.toSet());
    return !subnet.isEmpty();
}
#end_block

#method_before
private boolean isArpForRouter(NeighbourMessageContext pkt) {
    Ip4Address targetProtocolAddress = pkt.target().getIp4Address();
    Set<IpAddress> gatewayIpAddresses = null;
    try {
        if (targetProtocolAddress.equals(config.getRouterIp(pkt.inPort().deviceId()))) {
            return true;
        }
        gatewayIpAddresses = config.getPortIPs(pkt.inPort().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting check for router IP in processing arp");
    }
    if (gatewayIpAddresses != null && gatewayIpAddresses.contains(targetProtocolAddress)) {
        return true;
    }
    return false;
}
#method_after
private boolean isArpForRouter(NeighbourMessageContext pkt) {
    Ip4Address targetProtocolAddress = pkt.target().getIp4Address();
    Set<IpAddress> gatewayIpAddresses = null;
    try {
        if (targetProtocolAddress.equals(config.getRouterIpv4(pkt.inPort().deviceId()))) {
            return true;
        }
        gatewayIpAddresses = config.getPortIPs(pkt.inPort().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting check for router IP in processing arp");
    }
    if (gatewayIpAddresses != null && gatewayIpAddresses.contains(targetProtocolAddress)) {
        return true;
    }
    return false;
}
#end_block

#method_before
private void enqueuePacket(IP ipPacket, IpAddress destinationAddress) {
    if (ipPacketQueue.get(destinationAddress) == null) {
        ConcurrentLinkedQueue<IP> queue = new ConcurrentLinkedQueue<>();
        queue.add(ipPacket);
        ipPacketQueue.put(destinationAddress, queue);
    } else {
        ipPacketQueue.get(destinationAddress).add(ipPacket);
    }
}
#method_after
private void enqueuePacket(IP ipPacket, IpAddress destinationAddress) {
    ipPacketQueue.computeIfAbsent(destinationAddress, a -> new ConcurrentLinkedQueue<>()).add(ipPacket);
}
#end_block

#method_before
// ////////////////////
// IPv4 Handling  //
// //////////////////
public void processPacketIn(IPv4 pkt, ConnectPoint connectPoint) {
    DeviceId deviceId = connectPoint.deviceId();
    Ip4Address destinationAddress = Ip4Address.valueOf(pkt.getDestinationAddress());
    // IP packet for know hosts
    if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        forwardPackets(deviceId, destinationAddress);
    // IP packet for unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.arpHandler.sendArpRequest(deviceId, destinationAddress, connectPoint);
    // IP packets for unknown host
    } else {
        log.debug("ICMP request for unknown host {} which is not in the subnet", destinationAddress);
    // Do nothing
    }
}
#method_after
// ////////////////////
// IPv4 Handling  //
// //////////////////
public void processPacketIn(IPv4 pkt, ConnectPoint connectPoint) {
    DeviceId deviceId = connectPoint.deviceId();
    Ip4Address destinationAddress = Ip4Address.valueOf(pkt.getDestinationAddress());
    // IP packet for know hosts
    if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        forwardPackets(deviceId, destinationAddress);
    // IP packet for unknown host in one of the configured subnets of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.arpHandler.sendArpRequest(deviceId, destinationAddress, connectPoint);
    // IP packets for unknown host
    } else {
        log.debug("IPv4 packet for unknown host {} which is not in the subnet", destinationAddress);
    // Do nothing
    }
}
#end_block

#method_before
// ////////////////////
// IPv6 Handling  //
// //////////////////
public void processPacketIn(IPv6 pkt, ConnectPoint connectPoint) {
    DeviceId deviceId = connectPoint.deviceId();
    Ip6Address destinationAddress = Ip6Address.valueOf(pkt.getDestinationAddress());
    // IPv6 packet for know hosts
    if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        forwardPackets(deviceId, destinationAddress);
    // IPv6 packet for unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.icmpHandler.sendNdpRequest(deviceId, destinationAddress, connectPoint);
    // IPv6 packets for unknown host
    } else {
        log.debug("IPv6 pakcet for unknown host {} which is not in the subnet", destinationAddress);
    }
}
#method_after
// ////////////////////
// IPv6 Handling  //
// //////////////////
public void processPacketIn(IPv6 pkt, ConnectPoint connectPoint) {
    DeviceId deviceId = connectPoint.deviceId();
    Ip6Address destinationAddress = Ip6Address.valueOf(pkt.getDestinationAddress());
    // IPv6 packet for know hosts
    if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        forwardPackets(deviceId, destinationAddress);
    // IPv6 packet for unknown host in one of the configured subnets of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.icmpHandler.sendNdpRequest(deviceId, destinationAddress, connectPoint);
    // IPv6 packets for unknown host
    } else {
        log.debug("IPv6 packet for unknown host {} which is not in the subnet", destinationAddress);
    }
}
#end_block

#method_before
public void forwardPackets(DeviceId deviceId, Ip6Address destIpAddress) {
    if (ipPacketQueue.get(destIpAddress) == null) {
        return;
    }
    for (IP ipPacket : ipPacketQueue.get(destIpAddress)) {
        if (ipPacket.getVersion() == ((byte) 6)) {
            IPv6 ipv6Packet = (IPv6) ipPacket;
            Ip6Address destAddress = Ip6Address.valueOf(ipv6Packet.getDestinationAddress());
            if (config.inSameSubnet(deviceId, destAddress)) {
                ipv6Packet.setHopLimit((byte) (ipv6Packet.getHopLimit() - 1));
                for (Host dest : srManager.hostService.getHostsByIp(destIpAddress)) {
                    Ethernet eth = new Ethernet();
                    eth.setDestinationMACAddress(dest.mac());
                    try {
                        eth.setSourceMACAddress(config.getDeviceMac(deviceId));
                    } catch (DeviceConfigNotFoundException e) {
                        log.warn(e.getMessage() + " Skipping forwardPackets for this destination.");
                        continue;
                    }
                    eth.setEtherType(Ethernet.TYPE_IPV6);
                    eth.setPayload(ipv6Packet);
                    forwardToHost(deviceId, eth, dest);
                    ipPacketQueue.get(destIpAddress).remove(ipPacket);
                }
                ipPacketQueue.get(destIpAddress).remove(ipPacket);
            }
        }
    }
}
#method_after
public void forwardPackets(DeviceId deviceId, Ip6Address destIpAddress) {
    if (ipPacketQueue.get(destIpAddress) == null) {
        return;
    }
    for (IP ipPacket : ipPacketQueue.get(destIpAddress)) {
        if (ipPacket.getVersion() == ((byte) 6)) {
            IPv6 ipv6Packet = (IPv6) ipPacket;
            Ip6Address destAddress = Ip6Address.valueOf(ipv6Packet.getDestinationAddress());
            if (config.inSameSubnet(deviceId, destAddress)) {
                ipv6Packet.setHopLimit((byte) (ipv6Packet.getHopLimit() - 1));
                for (Host dest : srManager.hostService.getHostsByIp(destIpAddress)) {
                    Ethernet eth = new Ethernet();
                    eth.setDestinationMACAddress(dest.mac());
                    try {
                        eth.setSourceMACAddress(config.getDeviceMac(deviceId));
                    } catch (DeviceConfigNotFoundException e) {
                        log.warn(e.getMessage() + " Skipping forwardPackets for this destination.");
                        continue;
                    }
                    eth.setEtherType(Ethernet.TYPE_IPV6);
                    eth.setPayload(ipv6Packet);
                    forwardToHost(deviceId, eth, dest);
                    ipPacketQueue.get(destIpAddress).remove(ipPacket);
                }
                ipPacketQueue.get(destIpAddress).remove(ipPacket);
            }
        }
        ipPacketQueue.get(destIpAddress).remove(ipPacket);
    }
}
#end_block

#method_before
// /////////////////////////////////////////
// ICMPv6 Neighbour Discovery Protocol  //
// /////////////////////////////////////////
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    /*
         * First we validate the ndp packet
         */
    if (!validateSrcIp(pkt)) {
        log.debug("Ignore NDP packet discovered on {} with unexpected src ip address {}.", pkt.inPort(), pkt.sender());
        pkt.drop();
        return;
    }
    if (pkt.type() == NeighbourMessageType.REQUEST) {
        handleNdpRequest(pkt, hostService);
    } else {
        handleNdpReply(pkt, hostService);
    }
}
#method_after
// /////////////////////////////////////////
// ICMPv6 Neighbour Discovery Protocol  //
// /////////////////////////////////////////
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    /*
         * First we validate the ndp packet
         */
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(pkt.inPort())) {
        // Ignore NDP packets come from suppressed ports
        pkt.drop();
        return;
    }
    if (!validateSrcIp(pkt)) {
        log.debug("Ignore NDP packet discovered on {} with unexpected src ip address {}.", pkt.inPort(), pkt.sender());
        pkt.drop();
        return;
    }
    if (pkt.type() == NeighbourMessageType.REQUEST) {
        handleNdpRequest(pkt, hostService);
    } else {
        handleNdpReply(pkt, hostService);
    }
}
#end_block

#method_before
private boolean isNdpForGateway(NeighbourMessageContext pkt) {
    DeviceId deviceId = pkt.inPort().deviceId();
    Set<IpAddress> gatewayIpAddresses;
    if (pkt.target().equals(config.getRouterIpv6(deviceId))) {
        return true;
    }
    gatewayIpAddresses = config.getPortIPs(deviceId);
    if (gatewayIpAddresses != null && gatewayIpAddresses.contains(pkt.target())) {
        return true;
    }
    return false;
}
#method_after
private boolean isNdpForGateway(NeighbourMessageContext pkt) {
    DeviceId deviceId = pkt.inPort().deviceId();
    Set<IpAddress> gatewayIpAddresses = null;
    try {
        if (pkt.target().equals(config.getRouterIpv6(deviceId))) {
            return true;
        }
        gatewayIpAddresses = config.getPortIPs(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting check for router IP in processing ndp");
    }
    if (gatewayIpAddresses != null && gatewayIpAddresses.contains(pkt.target())) {
        return true;
    }
    return false;
}
#end_block

#method_before
public void processPacketIn(InboundPacket pkt) {
    Ethernet ethernet = pkt.parsed();
    IPv4 ipv4 = (IPv4) ethernet.getPayload();
    ConnectPoint connectPoint = pkt.receivedFrom();
    DeviceId deviceId = connectPoint.deviceId();
    Ip4Address destinationAddress = Ip4Address.valueOf(ipv4.getDestinationAddress());
    // IP packet for know hosts
    if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        forwardPackets(deviceId, destinationAddress);
    // IP packet for unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.arpHandler.sendArpRequest(deviceId, destinationAddress, connectPoint);
    // IP packets for unknown host
    } else {
        log.debug("ICMP request for unknown host {} which is not in the subnet", destinationAddress);
    // Do nothing
    }
}
#method_after
public void processPacketIn(InboundPacket pkt) {
    Ethernet ethernet = pkt.parsed();
    IPv4 ipv4 = (IPv4) ethernet.getPayload();
    ConnectPoint connectPoint = pkt.receivedFrom();
    DeviceId deviceId = connectPoint.deviceId();
    Ip4Address destinationAddress = Ip4Address.valueOf(ipv4.getDestinationAddress());
    // IP packet for know hosts
    if (!srManager.hostService.getHostsByIp(destinationAddress).isEmpty()) {
        forwardPackets(deviceId, destinationAddress);
    // IP packet for unknown host in the subnet of the router
    } else if (config.inSameSubnet(deviceId, destinationAddress)) {
        srManager.arpHandler.sendArpRequest(deviceId, destinationAddress, connectPoint);
    // IP packets for unknown host
    } else {
        log.debug("IP request for unknown host {} which is not in the subnet", destinationAddress);
    // Do nothing
    }
}
#end_block

#method_before
public void addToPacketBuffer(IPv4 ipPacket) {
    // Better not buffer TCP packets due to out-of-order packet transfer
    if (ipPacket.getProtocol() == IPv4.PROTOCOL_TCP) {
        return;
    }
    Ip4Address destIpAddress = Ip4Address.valueOf(ipPacket.getDestinationAddress());
    if (ipPacketQueue.get(destIpAddress) == null) {
        ConcurrentLinkedQueue<IPv4> queue = new ConcurrentLinkedQueue<>();
        queue.add(ipPacket);
        ipPacketQueue.put(destIpAddress, queue);
    } else {
        ipPacketQueue.get(destIpAddress).add(ipPacket);
    }
}
#method_after
public void addToPacketBuffer(IPv4 ipPacket) {
    // Better not buffer TCP packets due to out-of-order packet transfer
    if (ipPacket.getProtocol() == IPv4.PROTOCOL_TCP) {
        return;
    }
    Ip4Address destIpAddress = Ip4Address.valueOf(ipPacket.getDestinationAddress());
    ipPacketQueue.computeIfAbsent(destIpAddress, a -> new ConcurrentLinkedQueue<>()).add(ipPacket);
}
#end_block

#method_before
@Override
public int getIPv4SegmentId(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getIPv4SegmentId for device{} is {}", deviceId, srinfo.ipv4NodeSid);
        return srinfo.ipv4NodeSid;
    } else {
        String message = "getSegmentId fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#method_after
@Override
public int getIPv4SegmentId(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getIPv4SegmentId for device{} is {}", deviceId, srinfo.ipv4NodeSid);
        return srinfo.ipv4NodeSid;
    } else {
        String message = "getIPv4SegmentId fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
@Override
public int getIPv6SegmentId(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getIPv6SegmentId for device{} is {}", deviceId, srinfo.ipv6NodeSid);
        return srinfo.ipv6NodeSid;
    }
    /*
         * If we don't have an IPv6 configuration, it should be fine.
         */
    return -1;
}
#method_after
@Override
public int getIPv6SegmentId(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getIPv6SegmentId for device{} is {}", deviceId, srinfo.ipv6NodeSid);
        return srinfo.ipv6NodeSid;
    } else {
        String message = "getIPv6SegmentId fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
@Override
public Ip4Address getRouterIpv4(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, srinfo.ipv4Loopback);
        return srinfo.ipv4Loopback;
    } else {
        String message = "getRouterIp fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#method_after
@Override
public Ip4Address getRouterIpv4(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getRouterIpv4 for device{} is {}", deviceId, srinfo.ipv4Loopback);
        return srinfo.ipv4Loopback;
    } else {
        String message = "getRouterIpv4 fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
@Override
public Ip6Address getRouterIpv6(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, srinfo.ipv6Loopback);
        return srinfo.ipv6Loopback;
    }
    return null;
}
#method_after
@Override
public Ip6Address getRouterIpv6(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getRouterIpv6 for device{} is {}", deviceId, srinfo.ipv6Loopback);
        return srinfo.ipv6Loopback;
    } else {
        String message = "getRouterIpv6 fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
public Set<IpPrefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        ImmutableSet.Builder<IpPrefix> builder = ImmutableSet.builder();
        return builder.addAll(srinfo.subnets.values()).build();
    }
    return null;
}
#method_after
public Set<IpPrefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        ImmutableSet.Builder<IpPrefix> builder = ImmutableSet.builder();
        return builder.addAll(srinfo.subnets.values()).build();
    }
    return null;
}
#end_block

#method_before
public Set<IpPrefix> getPortSubnets(DeviceId deviceId, PortNumber port) {
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    if (isSuppressedPort(connectPoint)) {
        return Collections.emptySet();
    }
    Set<IpPrefix> subnets = srManager.interfaceService.getInterfacesByPort(connectPoint).stream().flatMap(intf -> intf.ipAddressesList().stream()).map(InterfaceIpAddress::subnetAddress).map(IpPrefix::getIp4Prefix).collect(Collectors.toSet());
    if (subnets.size() == 0) {
        log.info(NO_SUBNET, connectPoint);
        return Collections.emptySet();
    } else if (subnets.size() > 2) {
        log.warn(TOO_MANY_SUBNET, connectPoint);
        return Collections.emptySet();
    } else if (verifySubnets(subnets)) {
        return subnets;
    }
    log.warn(MISCONFIGURED, connectPoint);
    return Collections.emptySet();
}
#method_after
public Set<IpPrefix> getPortSubnets(DeviceId deviceId, PortNumber port) {
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    if (isSuppressedPort(connectPoint)) {
        return Collections.emptySet();
    }
    Set<IpPrefix> subnets = srManager.interfaceService.getInterfacesByPort(connectPoint).stream().flatMap(intf -> intf.ipAddressesList().stream()).map(InterfaceIpAddress::subnetAddress).map(IpPrefix::getIp4Prefix).collect(Collectors.toSet());
    if (subnets.isEmpty()) {
        log.info(NO_SUBNET, connectPoint);
        return Collections.emptySet();
    } else if (subnets.size() > 2) {
        log.warn(TOO_MANY_SUBNET, connectPoint);
        return Collections.emptySet();
    } else if (verifySubnets(subnets)) {
        return subnets;
    }
    log.warn(MISCONFIGURED, connectPoint);
    return Collections.emptySet();
}
#end_block

#method_before
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(pkt.inPort())) {
        // Ignore ARP packets come from suppressed ports
        return;
    }
    if (!validateArpSpa(pkt)) {
        log.debug("Ignore ARP packet discovered on {} with unexpected src protocol address {}.", pkt.inPort(), pkt.sender().getIp4Address());
        return;
    }
    if (pkt.type() == REQUEST) {
        handleArpRequest(pkt, hostService);
    } else {
        handleArpReply(pkt, hostService);
    }
}
#method_after
public void processPacketIn(NeighbourMessageContext pkt, HostService hostService) {
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(pkt.inPort())) {
        // Ignore ARP packets come from suppressed ports
        pkt.drop();
        return;
    }
    if (!validateArpSpa(pkt)) {
        log.debug("Ignore ARP packet discovered on {} with unexpected src protocol address {}.", pkt.inPort(), pkt.sender().getIp4Address());
        pkt.drop();
        return;
    }
    if (pkt.type() == REQUEST) {
        handleArpRequest(pkt, hostService);
    } else {
        handleArpReply(pkt, hostService);
    }
}
#end_block

#method_before
private void handleArpRequest(NeighbourMessageContext pkt, HostService hostService) {
    // ARP request for router. Send ARP reply.
    if (isArpForRouter(pkt)) {
        MacAddress targetMac = config.getRouterMacForAGatewayIp(pkt.target().getIp4Address());
        sendArpResponse(pkt, targetMac, hostService);
    } else {
        Set<Host> hosts = hostService.getHostsByIp(pkt.target());
        if (hosts.size() > 1) {
            log.warn("More than host with the same ip {}", pkt.target());
        }
        Host targetHost = hosts.stream().findFirst().orElse(null);
        // ARP request for known hosts. Send proxy ARP reply on behalf of the target.
        if (targetHost != null) {
            pkt.forward(targetHost.location());
        // ARP request for unknown host in the subnet. Flood in the subnet.
        } else {
            flood(pkt);
        }
    }
}
#method_after
private void handleArpRequest(NeighbourMessageContext pkt, HostService hostService) {
    // ARP request for router. Send ARP reply.
    if (isArpForRouter(pkt)) {
        MacAddress targetMac = config.getRouterMacForAGatewayIp(pkt.target().getIp4Address());
        sendArpResponse(pkt, targetMac, hostService);
    } else {
        Set<Host> hosts = hostService.getHostsByIp(pkt.target());
        if (hosts.size() > 1) {
            log.warn("More than one host with the same ip {}", pkt.target());
        }
        Host targetHost = hosts.stream().findFirst().orElse(null);
        // ARP request for known hosts. Send proxy ARP reply on behalf of the target.
        if (targetHost != null) {
            pkt.forward(targetHost.location());
        // ARP request for unknown host in the subnet. Flood in the subnet.
        } else {
            flood(pkt);
        }
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    /*
         * This option is necessary to activate the support for NeighborDiscovery
         * protocol in the NRM.
         */
    compCfgService.preSetProperty("org.onosproject.incubator.net.neighbour.impl." + "NeighbourResolutionManager", "ndpEnabled", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    cfgListener.configureNetwork();
    routeService.addListener(routeListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.vrouter.Vrouter", "fibInstallerEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.incubator.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelay", "arpEnabled", "false");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    cfgListener.configureNetwork();
    routeService.addListener(routeListener);
    log.info("Started");
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("{} - we are still receiving ARP packets", ethernet);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipPacket = (IPv4) ethernet.getPayload();
        ipHandler.addToPacketBuffer(ipPacket);
        if (ipPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processPacketIn(pkt);
        } else {
            ipHandler.processPacketIn(pkt);
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
    /*
                 * TODO send to ICMPv6 handler and generalize the interaction with IP Handler
                 */
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("{} - we are still receiving ARP packets from {}", context.inPacket().receivedFrom());
        log.debug("{}", ethernet);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipPacket = (IPv4) ethernet.getPayload();
        // ipHandler.addToPacketBuffer(ipPacket);
        if (ipPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processPacketIn(pkt);
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCP packets.
        // ipHandler.processPacketIn(pkt);
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
    /*
                 * TODO send to ICMPv6 handler and generalize the interaction with IP Handler
                 */
    }
}
#end_block

#method_before
public boolean populateMplsRule(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops, IpAddress routerIp) {
    int segmentId;
    try {
        if (routerIp.isIp4()) {
            segmentId = config.getIPv4SegmentId(destSwId);
        } else {
            segmentId = config.getIPv6SegmentId(destSwId);
            if (segmentId == -1) {
                log.warn("Aborting populateMplsRule.");
                return false;
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = new ArrayList<>();
    // TODO Handle the case of Bos == false
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchMplsBos(true);
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    // If the next hop is the destination router for the segment, do pop
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop", segmentId, targetSwId);
        // bos pop case (php)
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, true, true, metabuilder.build(), routerIp);
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX not-bos pop case,  SR app multi-label not implemented yet
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               true,
                                               false);*/
    } else {
        // next hop is not destination, SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop", segmentId, targetSwId);
        // continue case with bos - this does get triggered in edge routers
        // and in core routers - driver can handle depending on availability
        // of MPLS ECMP or not
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, false, true, metabuilder.build(), routerIp);
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX continue case with not-bos - SR app multi label not implemented yet
    // also requires MPLS ECMP
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               false,
                                               false); */
    }
    // debug messages below
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(SegmentRoutingService.DEFAULT_PRIORITY)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("MPLS rule {} for SID {} populated in dev:{} ", objective.id(), segmentId, targetSwId), (objective, error) -> log.warn("Failed to populate MPLS rule {} for SID {}: {} in dev:{}", objective.id(), segmentId, error, targetSwId));
        ForwardingObjective fob = fwdObjBuilder.add(context);
        log.debug("Sending MPLS fwd obj {} for SID {}-> next {} in sw: {}", fob.id(), segmentId, fob.nextId(), targetSwId);
        srManager.flowObjectiveService.forward(targetSwId, fob);
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#method_after
public boolean populateMplsRule(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops, IpAddress routerIp) {
    int segmentId;
    try {
        if (routerIp.isIp4()) {
            segmentId = config.getIPv4SegmentId(destSwId);
        } else {
            segmentId = config.getIPv6SegmentId(destSwId);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = new ArrayList<>();
    // TODO Handle the case of Bos == false
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchMplsBos(true);
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    // If the next hop is the destination router for the segment, do pop
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop", segmentId, targetSwId);
        // bos pop case (php)
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, true, true, metabuilder.build(), routerIp);
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX not-bos pop case,  SR app multi-label not implemented yet
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               true,
                                               false);*/
    } else {
        // next hop is not destination, SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop", segmentId, targetSwId);
        // continue case with bos - this does get triggered in edge routers
        // and in core routers - driver can handle depending on availability
        // of MPLS ECMP or not
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, false, true, metabuilder.build(), routerIp);
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX continue case with not-bos - SR app multi label not implemented yet
    // also requires MPLS ECMP
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               false,
                                               false); */
    }
    // debug messages below
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(SegmentRoutingService.DEFAULT_PRIORITY)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("MPLS rule {} for SID {} populated in dev:{} ", objective.id(), segmentId, targetSwId), (objective, error) -> log.warn("Failed to populate MPLS rule {} for SID {}: {} in dev:{}", objective.id(), segmentId, error, targetSwId));
        ForwardingObjective fob = fwdObjBuilder.add(context);
        log.debug("Sending MPLS fwd obj {} for SID {}-> next {} in sw: {}", fob.id(), segmentId, fob.nextId(), targetSwId);
        srManager.flowObjectiveService.forward(targetSwId, fob);
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#end_block

#method_before
public PortFilterInfo populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return null;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts != null && devPorts.size() == 0) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return null;
    }
    int disabledPorts = 0, suppressedPorts = 0, filteredPorts = 0;
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        if (!port.isEnabled()) {
            disabledPorts++;
            continue;
        }
        boolean isSuppressed = false;
        SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
        if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
            isSuppressed = true;
            suppressedPorts++;
        }
        Ip4Prefix portSubnet = config.getPortIPv4Subnet(deviceId, port.number());
        VlanId assignedVlan = (portSubnet == null || isSuppressed) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
        // vlan assignment is valid only if this instance is master
        if (srManager.mastershipService.isLocalMaster(deviceId)) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(srManager.appId);
        log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
        filteredPorts++;
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    }
    log.info("Filtering on dev:{}, disabledPorts:{}, suppressedPorts:{}, filteredPorts:{}", deviceId, disabledPorts, suppressedPorts, filteredPorts);
    return srManager.defaultRoutingHandler.new PortFilterInfo(disabledPorts, suppressedPorts, filteredPorts);
}
#method_after
public PortFilterInfo populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return null;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts == null || devPorts.isEmpty()) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return null;
    }
    int disabledPorts = 0, suppressedPorts = 0, filteredPorts = 0;
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        if (!port.isEnabled()) {
            disabledPorts++;
            continue;
        }
        boolean isSuppressed = false;
        SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
        if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
            isSuppressed = true;
            suppressedPorts++;
        }
        Ip4Prefix portSubnet = config.getPortIPv4Subnet(deviceId, port.number());
        VlanId assignedVlan = (portSubnet == null || isSuppressed) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
        // vlan assignment is valid only if this instance is master
        if (srManager.mastershipService.isLocalMaster(deviceId)) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(srManager.appId);
        log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
        filteredPorts++;
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    }
    log.info("Filtering on dev:{}, disabledPorts:{}, suppressedPorts:{}, filteredPorts:{}", deviceId, disabledPorts, suppressedPorts, filteredPorts);
    return srManager.defaultRoutingHandler.new PortFilterInfo(disabledPorts, suppressedPorts, filteredPorts);
}
#end_block

#method_before
public void populateRouterIpPunts(DeviceId deviceId) {
    Ip4Address routerIpv4;
    Ip6Address routerIpv6;
    try {
        routerIpv4 = config.getRouterIpv4(deviceId);
        routerIpv6 = config.getRouterIpv6(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterIpPunts.");
        return;
    }
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not installing port-IP punts - not the master for dev:{} ", deviceId);
        return;
    }
    ForwardingObjective.Builder puntIp = DefaultForwardingObjective.builder();
    Set<IpAddress> allIps = new HashSet<>(config.getPortIPs(deviceId));
    allIps.add(routerIpv4);
    if (routerIpv6 != null) {
        allIps.add(routerIpv6);
    }
    for (IpAddress ipaddr : allIps) {
        TrafficSelector.Builder sbuilder = buildIpSelectorFromIpAddress(ipaddr);
        TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
        sbuilder.matchEthType(Ethernet.TYPE_IPV4);
        sbuilder.matchIPDst(IpPrefix.valueOf(ipaddr, IpPrefix.MAX_INET_MASK_LENGTH));
        tbuilder.setOutput(PortNumber.CONTROLLER);
        puntIp.withSelector(sbuilder.build());
        puntIp.withTreatment(tbuilder.build());
        puntIp.withFlag(Flag.VERSATILE).withPriority(SegmentRoutingService.HIGHEST_PRIORITY).makePermanent().fromApp(srManager.appId);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("IP punt rule for {} populated", ipaddr), (objective, error) -> log.warn("Failed to populate IP punt rule for {}: {}", ipaddr, error));
        srManager.flowObjectiveService.forward(deviceId, puntIp.add(context));
    }
}
#method_after
public void populateRouterIpPunts(DeviceId deviceId) {
    Ip4Address routerIpv4;
    Ip6Address routerIpv6;
    try {
        routerIpv4 = config.getRouterIpv4(deviceId);
        routerIpv6 = config.getRouterIpv6(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterIpPunts.");
        return;
    }
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not installing port-IP punts - not the master for dev:{} ", deviceId);
        return;
    }
    Set<IpAddress> allIps = new HashSet<>(config.getPortIPs(deviceId));
    allIps.add(routerIpv4);
    if (routerIpv6 != null) {
        allIps.add(routerIpv6);
    }
    for (IpAddress ipaddr : allIps) {
        TrafficSelector.Builder sbuilder = buildIpSelectorFromIpAddress(ipaddr);
        Optional<DeviceId> optDeviceId = Optional.of(deviceId);
        srManager.packetService.requestPackets(sbuilder.build(), PacketPriority.CONTROL, srManager.appId, optDeviceId);
    }
}
#end_block

#method_before
private TrafficSelector.Builder buildIpSelectorFromIpAddress(IpAddress addressToMatch) {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    /*
         * If the address is IPv4
         */
    if (addressToMatch.isIp4()) {
        selectorBuilder.matchEthType(Ethernet.TYPE_IPV4);
        selectorBuilder.matchIPDst(IpPrefix.valueOf(addressToMatch, IpPrefix.MAX_INET_MASK_LENGTH));
        return selectorBuilder;
    }
    /*
         * If the address is IPv6
         */
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV6);
    selectorBuilder.matchIPv6Dst(IpPrefix.valueOf(addressToMatch, IpPrefix.MAX_INET6_MASK_LENGTH));
    return selectorBuilder;
}
#method_after
private TrafficSelector.Builder buildIpSelectorFromIpAddress(IpAddress addressToMatch) {
    return buildIpSelectorFromIpPrefix(addressToMatch.toIpPrefix());
}
#end_block

#method_before
private void handleArpRequest(NeighbourMessageContext pkt, HostService hostService) {
    // ARP request for router. Send ARP reply.
    if (isArpForRouter(pkt)) {
        MacAddress targetMac = config.getRouterMacForAGatewayIp(pkt.target().getIp4Address());
        sendArpResponse(pkt, targetMac, hostService);
    } else {
        Set<Host> hosts = hostService.getHostsByIp(pkt.target());
        if (hosts.size() > 1) {
            log.warn("More than host with the same ip {}", pkt.target());
        }
        Host targetHost = hosts.stream().findFirst().orElse(null);
        // ARP request for known hosts. Send proxy ARP reply on behalf of the target.
        if (targetHost != null) {
            pkt.forward(targetHost.location());
        // ARP request for unknown host in the subnet. Flood in the subnet.
        } else {
            flood(pkt);
        }
    }
}
#method_after
private void handleArpRequest(NeighbourMessageContext pkt, HostService hostService) {
    // ARP request for router. Send ARP reply.
    if (isArpForRouter(pkt)) {
        MacAddress targetMac = config.getRouterMacForAGatewayIp(pkt.target().getIp4Address());
        sendArpResponse(pkt, targetMac, hostService);
    } else {
        Set<Host> hosts = hostService.getHostsByIp(pkt.target());
        if (hosts.size() > 1) {
            log.warn("More than one host with the same ip {}", pkt.target());
        }
        Host targetHost = hosts.stream().findFirst().orElse(null);
        // ARP request for known hosts. Send proxy ARP reply on behalf of the target.
        if (targetHost != null) {
            pkt.forward(targetHost.location());
        // ARP request for unknown host in the subnet. Flood in the subnet.
        } else {
            flood(pkt);
        }
    }
}
#end_block

#method_before
public Set<IpPrefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        ImmutableSet.Builder<IpPrefix> builder = ImmutableSet.builder();
        return builder.addAll(srinfo.subnets.values()).build();
    }
    return null;
}
#method_after
public Set<IpPrefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        ImmutableSet.Builder<IpPrefix> builder = ImmutableSet.builder();
        return builder.addAll(srinfo.subnets.values()).build();
    }
    return null;
}
#end_block

#method_before
public Set<IpPrefix> getPortSubnets(DeviceId deviceId, PortNumber port) {
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    if (isSuppressedPort(connectPoint)) {
        return Collections.emptySet();
    }
    Set<IpPrefix> subnets = srManager.interfaceService.getInterfacesByPort(connectPoint).stream().flatMap(intf -> intf.ipAddressesList().stream()).map(InterfaceIpAddress::subnetAddress).map(IpPrefix::getIp4Prefix).collect(Collectors.toSet());
    if (subnets.size() == 0) {
        log.info(NO_SUBNET, connectPoint);
        return Collections.emptySet();
    } else if (subnets.size() > 2) {
        log.warn(TOO_MANY_SUBNET, connectPoint);
        return Collections.emptySet();
    } else if (verifySubnets(subnets)) {
        return subnets;
    }
    log.warn(MISCONFIGURED, connectPoint);
    return Collections.emptySet();
}
#method_after
public Set<IpPrefix> getPortSubnets(DeviceId deviceId, PortNumber port) {
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    if (isSuppressedPort(connectPoint)) {
        return Collections.emptySet();
    }
    Set<IpPrefix> subnets = srManager.interfaceService.getInterfacesByPort(connectPoint).stream().flatMap(intf -> intf.ipAddressesList().stream()).map(InterfaceIpAddress::subnetAddress).map(IpPrefix::getIp4Prefix).collect(Collectors.toSet());
    if (subnets.isEmpty()) {
        log.info(NO_SUBNET, connectPoint);
        return Collections.emptySet();
    } else if (subnets.size() > 2) {
        log.warn(TOO_MANY_SUBNET, connectPoint);
        return Collections.emptySet();
    } else if (verifySubnets(subnets)) {
        return subnets;
    }
    log.warn(MISCONFIGURED, connectPoint);
    return Collections.emptySet();
}
#end_block

#method_before
public void populatePortAddressingRules(DeviceId deviceId) {
    rulePopulator.populateRouterIpPunts(deviceId);
    // Although device is added, sometimes device store does not have the
    // ports for this device yet. It results in missing filtering rules in the
    // switch. We will attempt it a few times. If it still does not work,
    // user can manually repopulate using CLI command sr-reroute-network
    PortFilterInfo firstRun = rulePopulator.populateRouterMacVlanFilters(deviceId);
    if (firstRun == null) {
        firstRun = new PortFilterInfo(0, 0, 0);
    }
    executorService.schedule(new RetryFilters(deviceId, firstRun), RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
}
#method_after
public void populatePortAddressingRules(DeviceId deviceId) {
    rulePopulator.populateRouterIpPunts(deviceId);
    rulePopulator.populateArpNdpPunts(deviceId);
    // Although device is added, sometimes device store does not have the
    // ports for this device yet. It results in missing filtering rules in the
    // switch. We will attempt it a few times. If it still does not work,
    // user can manually repopulate using CLI command sr-reroute-network
    PortFilterInfo firstRun = rulePopulator.populateRouterMacVlanFilters(deviceId);
    if (firstRun == null) {
        firstRun = new PortFilterInfo(0, 0, 0);
    }
    executorService.schedule(new RetryFilters(deviceId, firstRun), RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet, TrafficSelector meta) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId neighborId : ns.getDeviceIds()) {
            if (devicePortMap.get(neighborId) == null) {
                log.warn("Neighbor {} is not in the port map yet for dev:{}", neighborId, deviceId);
                return;
            } else if (devicePortMap.get(neighborId).size() == 0) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", neighborId);
                return;
            }
            MacAddress neighborMac;
            try {
                neighborMac = deviceConfig.getDeviceMac(neighborId);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromNeighborsets.");
                return;
            }
            for (PortNumber sp : devicePortMap.get(neighborId)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setEthDst(neighborMac).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                tBuilder.setOutput(sp);
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        if (meta != null) {
            nextObjBuilder.withMeta(meta);
        }
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupsFromNeighborsets installed NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("createGroupsFromNeighborsets failed to install NextObj {} on {}: {}", nextId, deviceId, error));
        NextObjective nextObj = nextObjBuilder.add(context);
        log.debug("**createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        flowObjectiveService.next(deviceId, nextObj);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#method_after
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet, TrafficSelector meta) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId neighborId : ns.getDeviceIds()) {
            if (devicePortMap.get(neighborId) == null) {
                log.warn("Neighbor {} is not in the port map yet for dev:{}", neighborId, deviceId);
                return;
            } else if (devicePortMap.get(neighborId).isEmpty()) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", neighborId);
                return;
            }
            MacAddress neighborMac;
            try {
                neighborMac = deviceConfig.getDeviceMac(neighborId);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromNeighborsets.");
                return;
            }
            for (PortNumber sp : devicePortMap.get(neighborId)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setEthDst(neighborMac).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                tBuilder.setOutput(sp);
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        if (meta != null) {
            nextObjBuilder.withMeta(meta);
        }
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupsFromNeighborsets installed NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("createGroupsFromNeighborsets failed to install NextObj {} on {}: {}", nextId, deviceId, error));
        NextObjective nextObj = nextObjBuilder.add(context);
        log.debug("**createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        flowObjectiveService.next(deviceId, nextObj);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    /*
         * This option is necessary to activate the support for NeighborDiscovery
         * protocol in the NRM.
         */
    compCfgService.preSetProperty("org.onosproject.incubator.net.neighbour.impl." + "NeighbourResolutionManager", "ndpEnabled", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    cfgListener.configureNetwork();
    routeService.addListener(routeListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.vrouter.Vrouter", "fibInstallerEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.incubator.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelay", "arpEnabled", "false");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    cfgListener.configureNetwork();
    routeService.addListener(routeListener);
    log.info("Started");
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("{} - we are still receiving ARP packets", ethernet);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipPacket = (IPv4) ethernet.getPayload();
        ipHandler.addToPacketBuffer(ipPacket);
        if (ipPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processPacketIn(pkt);
        } else {
            ipHandler.processPacketIn(pkt);
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
    /*
                 * TODO send to ICMPv6 handler and generalize the interaction with IP Handler
                 */
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        log.warn("{} - we are still receiving ARP packets from {}", context.inPacket().receivedFrom());
        log.debug("{}", ethernet);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipPacket = (IPv4) ethernet.getPayload();
        // ipHandler.addToPacketBuffer(ipPacket);
        if (ipPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processPacketIn(pkt);
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCP packets.
        // ipHandler.processPacketIn(pkt);
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6Packet = (IPv6) ethernet.getPayload();
    /*
                 * TODO send to ICMPv6 handler and generalize the interaction with IP Handler
                 */
    }
}
#end_block

#method_before
private void printDeviceSubnetMap(Map<DeviceId, Set<IpPrefix>> deviceSubnetMap) {
    deviceSubnetMap.forEach(((deviceId, ip4Prefices) -> {
        print("%s", deviceId);
        ip4Prefices.forEach(ip4Prefix -> {
            print("    %s", ip4Prefix);
        });
    }));
}
#method_after
private void printDeviceSubnetMap(Map<DeviceId, Set<IpPrefix>> deviceSubnetMap) {
    deviceSubnetMap.forEach(((deviceId, ipPrefices) -> {
        print("%s", deviceId);
        ipPrefices.forEach(ipPrefix -> {
            print("    %s", ipPrefix);
        });
    }));
}
#end_block

#method_before
@Override
protected List<FlowRule> processEthDstFilter(PortCriterion portCriterion, EthCriterion ethCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    // Consider PortNumber.ANY as wildcard. Match ETH_DST only
    if (portCriterion != null && portCriterion.port() == PortNumber.ANY) {
        return processEthDstOnlyFilter(ethCriterion, applicationId);
    }
    // Multicast MAC
    if (ethCriterion.mask() != null) {
        return processMcastEthDstFilter(ethCriterion, applicationId);
    }
    // handling untagged packets via assigned VLAN
    if (vidCriterion.vlanId() == VlanId.NONE) {
        vidCriterion = (VlanIdCriterion) Criteria.matchVlanId(assignedVlan);
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<PortNumber>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    List<FlowRule> rules = new ArrayList<FlowRule>();
    for (PortNumber pnum : portnums) {
        // for unicast IP packets
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(vidCriterion.vlanId());
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchEthDst(ethCriterion.mac());
        /*
             * Note: CpqD switches do not handle MPLS-related operation properly
             * for a packet with VLAN tag. We pop VLAN here as a workaround.
             * Side effect: HostService learns redundant hosts with same MAC but
             * different VLAN. No known side effect on the network reachability.
             */
        treatment.popVlan();
        treatment.transition(UNICAST_ROUTING_TABLE);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        // for MPLS packets
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(vidCriterion.vlanId());
        selector.matchEthType(Ethernet.MPLS_UNICAST);
        selector.matchEthDst(ethCriterion.mac());
        // workaround here again
        treatment.popVlan();
        treatment.transition(MPLS_TABLE_0);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        /*
             * TMAC rules for IPv6 packets
             */
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(vidCriterion.vlanId());
        selector.matchEthType(Ethernet.TYPE_IPV6);
        selector.matchEthDst(ethCriterion.mac());
        // workaround here again
        treatment.popVlan();
        treatment.transition(UNICAST_ROUTING_TABLE);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
    }
    return rules;
}
#method_after
@Override
protected List<FlowRule> processEthDstFilter(PortCriterion portCriterion, EthCriterion ethCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    // Consider PortNumber.ANY as wildcard. Match ETH_DST only
    if (portCriterion != null && portCriterion.port() == PortNumber.ANY) {
        return processEthDstOnlyFilter(ethCriterion, applicationId);
    }
    // Multicast MAC
    if (ethCriterion.mask() != null) {
        return processMcastEthDstFilter(ethCriterion, applicationId);
    }
    // handling untagged packets via assigned VLAN
    if (vidCriterion.vlanId() == VlanId.NONE) {
        vidCriterion = (VlanIdCriterion) Criteria.matchVlanId(assignedVlan);
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<PortNumber>();
    if (portCriterion.port() == PortNumber.ALL) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    List<FlowRule> rules = new ArrayList<FlowRule>();
    for (PortNumber pnum : portnums) {
        // for unicast IP packets
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(vidCriterion.vlanId());
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchEthDst(ethCriterion.mac());
        /*
             * Note: CpqD switches do not handle MPLS-related operation properly
             * for a packet with VLAN tag. We pop VLAN here as a workaround.
             * Side effect: HostService learns redundant hosts with same MAC but
             * different VLAN. No known side effect on the network reachability.
             */
        treatment.popVlan();
        treatment.transition(UNICAST_ROUTING_TABLE);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        // for MPLS packets
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(vidCriterion.vlanId());
        selector.matchEthType(Ethernet.MPLS_UNICAST);
        selector.matchEthDst(ethCriterion.mac());
        // workaround here again
        treatment.popVlan();
        treatment.transition(MPLS_TABLE_0);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        /*
             * TMAC rules for IPv6 packets
             */
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        selector.matchInPort(pnum);
        selector.matchVlanId(vidCriterion.vlanId());
        selector.matchEthType(Ethernet.TYPE_IPV6);
        selector.matchEthDst(ethCriterion.mac());
        /*
             * workaround here again, we are removing
             * the vlan tag before to go through the
             * rest of the pipeline
             */
        treatment.popVlan();
        treatment.transition(UNICAST_ROUTING_TABLE);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if ((ethType == null) || (ethType.ethType().toShort() != Ethernet.TYPE_IPV4) && (ethType.ethType().toShort() != Ethernet.MPLS_UNICAST) && (ethType.ethType().toShort() != Ethernet.TYPE_IPV6)) {
        log.warn("processSpecific: Unsupported forwarding objective criteria" + "ethType:{} in dev:{}", ethType, deviceId);
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    boolean defaultRule = false;
    int forTableId = -1;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            filteredSelector.matchVlanId(assignedVlan);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                // The entire IPV4_DST field is wildcarded intentionally
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
    } else if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        if (buildIpv6Selector(filteredSelector, fwd) < 0) {
            return Collections.emptyList();
        }
        forTableId = UNICAST_ROUTING_TABLE;
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
    }
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            /*
                 * NOTE: OF-DPA does not support immediate instruction in
                 * L3 unicast and MPLS table.
                 */
            tb.deferred().add(i);
        }
    }
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
        }
    }
    tb.transition(ACL_TABLE);
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    return flowRuleCollection;
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if ((ethType == null) || (ethType.ethType().toShort() != Ethernet.TYPE_IPV4) && (ethType.ethType().toShort() != Ethernet.MPLS_UNICAST) && (ethType.ethType().toShort() != Ethernet.TYPE_IPV6)) {
        log.warn("processSpecific: Unsupported forwarding objective criteria" + "ethType:{} in dev:{}", ethType, deviceId);
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    boolean defaultRule = false;
    int forTableId = -1;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            filteredSelector.matchVlanId(assignedVlan);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                // The entire IPV4_DST field is wildcarded intentionally
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
    } else if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        if (buildIpv6Selector(filteredSelector, fwd) < 0) {
            return Collections.emptyList();
        }
        forTableId = UNICAST_ROUTING_TABLE;
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
    }
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            /*
                 * NOTE: OF-DPA does not support immediate instruction in
                 * L3 unicast and MPLS table.
                 */
            tb.deferred().add(i);
        }
    }
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
        }
    }
    tb.transition(ACL_TABLE);
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        flowRuleCollection.add(defaultRoute(fwd, complementarySelector, forTableId, tb));
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    return flowRuleCollection;
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            // avoid matching on vlans
            return;
        } else if (criterion instanceof Icmpv6TypeCriterion || criterion instanceof Icmpv6CodeCriterion) {
            /*
                 * We silenty discard these criterions, our current
                 * OFDPA platform does not support these matches on
                 * the ACL table.
                 */
            log.warn("ICMPv6 Type and ICMPv6 Code are not supported");
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.add(o);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
@Override
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective");
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective must include ethType");
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            // avoid matching on vlans
            return;
        } else if (criterion instanceof Icmpv6TypeCriterion || criterion instanceof Icmpv6CodeCriterion) {
            /*
                 * We silenty discard these criterions, our current
                 * OFDPA platform does not support these matches on
                 * the ACL table.
                 */
            log.warn("ICMPv6 Type and ICMPv6 Code are not supported");
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.add(o);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
        if (fwd.treatment().clearedDeferred()) {
            ttBuilder.wipeDeferred();
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw, Set<DeviceId> nextHops, Set<Ip4Prefix> subnets) {
    boolean result;
    if (nextHops.isEmpty()) {
        nextHops.add(destSw);
    }
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean destIsEdge;
    Ip4Address destRouterIpv4;
    Ip6Address destRouterIpv6;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        destIsEdge = config.isEdgeDevice(destSw);
        destRouterIpv4 = config.getRouterIpv4(destSw);
        destRouterIpv6 = config.getRouterIpv6(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && destIsEdge) {
        subnets = (subnets != null && !subnets.isEmpty()) ? subnets : config.getSubnets(destSw);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for subnets {}", targetSw, destSw, subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw, nextHops);
        if (!result) {
            return false;
        }
        IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
        /*
             * If present we deal with IPv6 loopback.
             */
        if (destRouterIpv6 != null) {
            routerIpPrefix = destRouterIpv6.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
            if (!result) {
                return false;
            }
        }
    } else if (targetIsEdge) {
        // If the target switch is an edge router, then set IP rules for the router IP.
        IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
        if (destRouterIpv6 != null) {
            routerIpPrefix = destRouterIpv6.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
            if (!result) {
                return false;
            }
        }
    }
    // Populates MPLS rules to all routers
    log.debug("* populateEcmpRoutingRulePartial in device{} towards {} for all MPLS rules", targetSw, destSw);
    result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops, destRouterIpv4);
    if (!result) {
        return false;
    }
    /*
         * If present we will populate the MPLS rules for the IPv6 sid.
         */
    if (destRouterIpv6 != null) {
        result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops, destRouterIpv6);
        if (!result) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw, Set<DeviceId> nextHops, Set<Ip4Prefix> subnets) {
    boolean result;
    if (nextHops.isEmpty()) {
        nextHops.add(destSw);
    }
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean destIsEdge;
    Ip4Address destRouterIpv4;
    Ip6Address destRouterIpv6;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        destIsEdge = config.isEdgeDevice(destSw);
        destRouterIpv4 = config.getRouterIpv4(destSw);
        destRouterIpv6 = config.getRouterIpv6(destSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && destIsEdge) {
        subnets = (subnets != null && !subnets.isEmpty()) ? subnets : config.getSubnets(destSw);
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for subnets {}", targetSw, destSw, subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw, nextHops);
        if (!result) {
            return false;
        }
        IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
        /*
             * If present we deal with IPv6 loopback.
             */
        if (destRouterIpv6 != null) {
            routerIpPrefix = destRouterIpv6.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for v6 router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
            if (!result) {
                return false;
            }
        }
    } else if (targetIsEdge) {
        // If the target switch is an edge router, then set IP rules for the router IP.
        IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
        log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for router IP {}", targetSw, destSw, routerIpPrefix);
        result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
        if (!result) {
            return false;
        }
        if (destRouterIpv6 != null) {
            routerIpPrefix = destRouterIpv6.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {} for v6 router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix, destSw, nextHops);
            if (!result) {
                return false;
            }
        }
    }
    // Populates MPLS rules to all routers
    log.debug("* populateEcmpRoutingRulePartial in device{} towards {} for all MPLS rules", targetSw, destSw);
    result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops, destRouterIpv4);
    if (!result) {
        return false;
    }
    /*
         * If present we will populate the MPLS rules for the IPv6 sid.
         */
    if (destRouterIpv6 != null) {
        result = rulePopulator.populateMplsRule(targetSw, destSw, nextHops, destRouterIpv6);
        if (!result) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void populatePortAddressingRules(DeviceId deviceId) {
    rulePopulator.populateRouterIpPunts(deviceId);
    // Although device is added, sometimes device store does not have the
    // ports for this device yet. It results in missing filtering rules in the
    // switch. We will attempt it a few times. If it still does not work,
    // user can manually repopulate using CLI command sr-reroute-network
    PortFilterInfo firstRun = rulePopulator.populateRouterMacVlanFilters(deviceId);
    if (firstRun == null) {
        firstRun = new PortFilterInfo(0, 0, 0);
    }
    executorService.schedule(new RetryFilters(deviceId, firstRun), RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
}
#method_after
public void populatePortAddressingRules(DeviceId deviceId) {
    rulePopulator.populateRouterIpPunts(deviceId);
    rulePopulator.populateArpNdpPunts(deviceId);
    // Although device is added, sometimes device store does not have the
    // ports for this device yet. It results in missing filtering rules in the
    // switch. We will attempt it a few times. If it still does not work,
    // user can manually repopulate using CLI command sr-reroute-network
    PortFilterInfo firstRun = rulePopulator.populateRouterMacVlanFilters(deviceId);
    if (firstRun == null) {
        firstRun = new PortFilterInfo(0, 0, 0);
    }
    executorService.schedule(new RetryFilters(deviceId, firstRun), RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
public boolean populateIpRuleForRouter(DeviceId deviceId, IpPrefix ipPrefix, DeviceId destSw, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        if (ipPrefix.isIp4()) {
            segmentId = config.getIPv4SegmentId(destSw);
        } else {
            segmentId = config.getIPv6SegmentId(destSw);
            if (segmentId == -1) {
                log.warn("Aborting populateIpRuleForRouter.");
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForRouter.");
        return false;
    }
    TrafficSelector.Builder sbuilder = buildIpSelectorFromIpPrefix(ipPrefix);
    TrafficSelector selector = sbuilder.build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    NeighborSet ns;
    TrafficTreatment treatment;
    // is not set.
    if (nextHops.size() == 1 && nextHops.toArray()[0].equals(destSw)) {
        tbuilder.immediate().decNwTtl();
        ns = new NeighborSet(nextHops);
        treatment = tbuilder.build();
    } else {
        ns = new NeighborSet(nextHops, segmentId);
        treatment = null;
    }
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since neighbor sets are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    int nextId = srManager.getNextObjectiveId(deviceId, ns, metabuilder.build());
    if (nextId <= 0) {
        log.warn("No next objective in {} for ns: {}", deviceId, ns);
        return false;
    }
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().nextStep(nextId).withSelector(selector).withPriority(getPriorityFromPrefix(ipPrefix)).withFlag(ForwardingObjective.Flag.SPECIFIC);
    if (treatment != null) {
        fwdBuilder.withTreatment(treatment);
    }
    log.debug("Installing IPv4 forwarding objective " + "for router IP/subnet {} in switch {}", ipPrefix, deviceId);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("IP rule for router {} populated in dev:{}", ipPrefix, deviceId), (objective, error) -> log.warn("Failed to populate IP rule for router {}: {} in dev:{}", ipPrefix, error, deviceId));
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(context));
    rulePopulationCounter.incrementAndGet();
    return true;
}
#method_after
public boolean populateIpRuleForRouter(DeviceId deviceId, IpPrefix ipPrefix, DeviceId destSw, Set<DeviceId> nextHops) {
    int segmentId;
    try {
        if (ipPrefix.isIp4()) {
            segmentId = config.getIPv4SegmentId(destSw);
        } else {
            segmentId = config.getIPv6SegmentId(destSw);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateIpRuleForRouter.");
        return false;
    }
    TrafficSelector.Builder sbuilder = buildIpSelectorFromIpPrefix(ipPrefix);
    TrafficSelector selector = sbuilder.build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    NeighborSet ns;
    TrafficTreatment treatment;
    // is not set.
    if (nextHops.size() == 1 && nextHops.toArray()[0].equals(destSw)) {
        tbuilder.immediate().decNwTtl();
        ns = new NeighborSet(nextHops);
        treatment = tbuilder.build();
    } else {
        ns = new NeighborSet(nextHops, segmentId);
        treatment = null;
    }
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since neighbor sets are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    int nextId = srManager.getNextObjectiveId(deviceId, ns, metabuilder.build());
    if (nextId <= 0) {
        log.warn("No next objective in {} for ns: {}", deviceId, ns);
        return false;
    }
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().fromApp(srManager.appId).makePermanent().nextStep(nextId).withSelector(selector).withPriority(getPriorityFromPrefix(ipPrefix)).withFlag(ForwardingObjective.Flag.SPECIFIC);
    if (treatment != null) {
        fwdBuilder.withTreatment(treatment);
    }
    log.debug("Installing IPv4 forwarding objective " + "for router IP/subnet {} in switch {}", ipPrefix, deviceId);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("IP rule for router {} populated in dev:{}", ipPrefix, deviceId), (objective, error) -> log.warn("Failed to populate IP rule for router {}: {} in dev:{}", ipPrefix, error, deviceId));
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(context));
    rulePopulationCounter.incrementAndGet();
    return true;
}
#end_block

#method_before
public boolean populateMplsRule(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops, IpAddress routerIp) {
    int segmentId;
    try {
        if (routerIp.isIp4()) {
            segmentId = config.getIPv4SegmentId(destSwId);
        } else {
            segmentId = config.getIPv6SegmentId(destSwId);
            if (segmentId == -1) {
                log.warn("Aborting populateMplsRule.");
                return false;
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = new ArrayList<>();
    // TODO Handle the case of Bos == false
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchMplsBos(true);
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    // If the next hop is the destination router for the segment, do pop
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop", segmentId, targetSwId);
        // bos pop case (php)
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, true, true, metabuilder.build(), routerIp);
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX not-bos pop case,  SR app multi-label not implemented yet
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               true,
                                               false);*/
    } else {
        // next hop is not destination, SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop", segmentId, targetSwId);
        // continue case with bos - this does get triggered in edge routers
        // and in core routers - driver can handle depending on availability
        // of MPLS ECMP or not
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, false, true, metabuilder.build(), routerIp);
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX continue case with not-bos - SR app multi label not implemented yet
    // also requires MPLS ECMP
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               false,
                                               false); */
    }
    // debug messages below
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(SegmentRoutingService.DEFAULT_PRIORITY)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("MPLS rule {} for SID {} populated in dev:{} ", objective.id(), segmentId, targetSwId), (objective, error) -> log.warn("Failed to populate MPLS rule {} for SID {}: {} in dev:{}", objective.id(), segmentId, error, targetSwId));
        ForwardingObjective fob = fwdObjBuilder.add(context);
        log.debug("Sending MPLS fwd obj {} for SID {}-> next {} in sw: {}", fob.id(), segmentId, fob.nextId(), targetSwId);
        srManager.flowObjectiveService.forward(targetSwId, fob);
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#method_after
public boolean populateMplsRule(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops, IpAddress routerIp) {
    int segmentId;
    try {
        if (routerIp.isIp4()) {
            segmentId = config.getIPv4SegmentId(destSwId);
        } else {
            segmentId = config.getIPv6SegmentId(destSwId);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateMplsRule.");
        return false;
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = new ArrayList<>();
    // TODO Handle the case of Bos == false
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchMplsBos(true);
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
    // If the next hop is the destination router for the segment, do pop
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop", segmentId, targetSwId);
        // bos pop case (php)
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, true, true, metabuilder.build(), routerIp);
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX not-bos pop case,  SR app multi-label not implemented yet
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               true,
                                               false);*/
    } else {
        // next hop is not destination, SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop", segmentId, targetSwId);
        // continue case with bos - this does get triggered in edge routers
        // and in core routers - driver can handle depending on availability
        // of MPLS ECMP or not
        ForwardingObjective.Builder fwdObjBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, false, true, metabuilder.build(), routerIp);
        if (fwdObjBosBuilder == null) {
            return false;
        }
        fwdObjBuilders.add(fwdObjBosBuilder);
    // XXX continue case with not-bos - SR app multi label not implemented yet
    // also requires MPLS ECMP
    /*ForwardingObjective.Builder fwdObjNoBosBuilder =
                    getMplsForwardingObjective(deviceId,
                                               nextHops,
                                               false,
                                               false); */
    }
    // debug messages below
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(SegmentRoutingService.DEFAULT_PRIORITY)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("MPLS rule {} for SID {} populated in dev:{} ", objective.id(), segmentId, targetSwId), (objective, error) -> log.warn("Failed to populate MPLS rule {} for SID {}: {} in dev:{}", objective.id(), segmentId, error, targetSwId));
        ForwardingObjective fob = fwdObjBuilder.add(context);
        log.debug("Sending MPLS fwd obj {} for SID {}-> next {} in sw: {}", fob.id(), segmentId, fob.nextId(), targetSwId);
        srManager.flowObjectiveService.forward(targetSwId, fob);
        rulePopulationCounter.incrementAndGet();
    }
    return true;
}
#end_block

#method_before
public PortFilterInfo populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return null;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts != null && devPorts.size() == 0) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return null;
    }
    int disabledPorts = 0, suppressedPorts = 0, filteredPorts = 0;
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        if (!port.isEnabled()) {
            disabledPorts++;
            continue;
        }
        boolean isSuppressed = false;
        SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
        if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
            isSuppressed = true;
            suppressedPorts++;
        }
        Ip4Prefix portSubnet = config.getPortSubnet(deviceId, port.number());
        VlanId assignedVlan = (portSubnet == null || isSuppressed) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
        // vlan assignment is valid only if this instance is master
        if (srManager.mastershipService.isLocalMaster(deviceId)) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(srManager.appId);
        log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
        filteredPorts++;
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    }
    log.info("Filtering on dev:{}, disabledPorts:{}, suppressedPorts:{}, filteredPorts:{}", deviceId, disabledPorts, suppressedPorts, filteredPorts);
    return srManager.defaultRoutingHandler.new PortFilterInfo(disabledPorts, suppressedPorts, filteredPorts);
}
#method_after
public PortFilterInfo populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return null;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts == null || devPorts.isEmpty()) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return null;
    }
    int disabledPorts = 0, suppressedPorts = 0, filteredPorts = 0;
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        if (!port.isEnabled()) {
            disabledPorts++;
            continue;
        }
        boolean isSuppressed = false;
        SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
        if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
            isSuppressed = true;
            suppressedPorts++;
        }
        Ip4Prefix portSubnet = config.getPortSubnet(deviceId, port.number());
        VlanId assignedVlan = (portSubnet == null || isSuppressed) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
        // vlan assignment is valid only if this instance is master
        if (srManager.mastershipService.isLocalMaster(deviceId)) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(srManager.appId);
        log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
        filteredPorts++;
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    }
    log.info("Filtering on dev:{}, disabledPorts:{}, suppressedPorts:{}, filteredPorts:{}", deviceId, disabledPorts, suppressedPorts, filteredPorts);
    return srManager.defaultRoutingHandler.new PortFilterInfo(disabledPorts, suppressedPorts, filteredPorts);
}
#end_block

#method_before
public void populateRouterIpPunts(DeviceId deviceId) {
    Ip4Address routerIpv4;
    Ip6Address routerIpv6;
    try {
        routerIpv4 = config.getRouterIpv4(deviceId);
        routerIpv6 = config.getRouterIpv6(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterIpPunts.");
        return;
    }
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not installing port-IP punts - not the master for dev:{} ", deviceId);
        return;
    }
    ForwardingObjective.Builder puntIp = DefaultForwardingObjective.builder();
    Set<IpAddress> allIps = new HashSet<>(config.getPortIPs(deviceId));
    allIps.add(routerIpv4);
    if (routerIpv6 != null) {
        allIps.add(routerIpv6);
    }
    for (IpAddress ipaddr : allIps) {
        TrafficSelector.Builder sbuilder = buildIpSelectorFromIpAddress(ipaddr);
        TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
        sbuilder.matchEthType(Ethernet.TYPE_IPV4);
        sbuilder.matchIPDst(IpPrefix.valueOf(ipaddr, IpPrefix.MAX_INET_MASK_LENGTH));
        tbuilder.setOutput(PortNumber.CONTROLLER);
        puntIp.withSelector(sbuilder.build());
        puntIp.withTreatment(tbuilder.build());
        puntIp.withFlag(Flag.VERSATILE).withPriority(SegmentRoutingService.HIGHEST_PRIORITY).makePermanent().fromApp(srManager.appId);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("IP punt rule for {} populated", ipaddr), (objective, error) -> log.warn("Failed to populate IP punt rule for {}: {}", ipaddr, error));
        srManager.flowObjectiveService.forward(deviceId, puntIp.add(context));
    }
}
#method_after
public void populateRouterIpPunts(DeviceId deviceId) {
    Ip4Address routerIpv4;
    Ip6Address routerIpv6;
    try {
        routerIpv4 = config.getRouterIpv4(deviceId);
        routerIpv6 = config.getRouterIpv6(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterIpPunts.");
        return;
    }
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not installing port-IP punts - not the master for dev:{} ", deviceId);
        return;
    }
    Set<IpAddress> allIps = new HashSet<>(config.getPortIPs(deviceId));
    allIps.add(routerIpv4);
    if (routerIpv6 != null) {
        allIps.add(routerIpv6);
    }
    for (IpAddress ipaddr : allIps) {
        TrafficSelector.Builder sbuilder = buildIpSelectorFromIpAddress(ipaddr);
        Optional<DeviceId> optDeviceId = Optional.of(deviceId);
        srManager.packetService.requestPackets(sbuilder.build(), PacketPriority.CONTROL, srManager.appId, optDeviceId);
    }
}
#end_block

#method_before
private TrafficSelector.Builder buildIpSelectorFromIpAddress(IpAddress addressToMatch) {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    /*
         * If the address is IPv4
         */
    if (addressToMatch.isIp4()) {
        selectorBuilder.matchEthType(Ethernet.TYPE_IPV4);
        selectorBuilder.matchIPDst(IpPrefix.valueOf(addressToMatch, IpPrefix.MAX_INET_MASK_LENGTH));
        return selectorBuilder;
    }
    /*
         * If the address is IPv6
         */
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV6);
    selectorBuilder.matchIPv6Dst(IpPrefix.valueOf(addressToMatch, IpPrefix.MAX_INET6_MASK_LENGTH));
    return selectorBuilder;
}
#method_after
private TrafficSelector.Builder buildIpSelectorFromIpAddress(IpAddress addressToMatch) {
    return buildIpSelectorFromIpPrefix(addressToMatch.toIpPrefix());
}
#end_block

#method_before
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet, TrafficSelector meta) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId neighborId : ns.getDeviceIds()) {
            if (devicePortMap.get(neighborId) == null) {
                log.warn("Neighbor {} is not in the port map yet for dev:{}", neighborId, deviceId);
                return;
            } else if (devicePortMap.get(neighborId).size() == 0) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", neighborId);
                return;
            }
            MacAddress neighborMac;
            try {
                neighborMac = deviceConfig.getDeviceMac(neighborId);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromNeighborsets.");
                return;
            }
            for (PortNumber sp : devicePortMap.get(neighborId)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setEthDst(neighborMac).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                tBuilder.setOutput(sp);
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        if (meta != null) {
            nextObjBuilder.withMeta(meta);
        }
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupsFromNeighborsets installed NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("createGroupsFromNeighborsets failed to install NextObj {} on {}: {}", nextId, deviceId, error));
        NextObjective nextObj = nextObjBuilder.add(context);
        log.debug("**createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        flowObjectiveService.next(deviceId, nextObj);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#method_after
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet, TrafficSelector meta) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId neighborId : ns.getDeviceIds()) {
            if (devicePortMap.get(neighborId) == null) {
                log.warn("Neighbor {} is not in the port map yet for dev:{}", neighborId, deviceId);
                return;
            } else if (devicePortMap.get(neighborId).isEmpty()) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", neighborId);
                return;
            }
            MacAddress neighborMac;
            try {
                neighborMac = deviceConfig.getDeviceMac(neighborId);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromNeighborsets.");
                return;
            }
            for (PortNumber sp : devicePortMap.get(neighborId)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setEthDst(neighborMac).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                tBuilder.setOutput(sp);
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        if (meta != null) {
            nextObjBuilder.withMeta(meta);
        }
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupsFromNeighborsets installed NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("createGroupsFromNeighborsets failed to install NextObj {} on {}: {}", nextId, deviceId, error));
        NextObjective nextObj = nextObjBuilder.add(context);
        log.debug("**createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        flowObjectiveService.next(deviceId, nextObj);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#end_block

#method_before
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective:{} in dev:{}", fwd.id(), deviceId);
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective:{} must include ethType", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            VlanId vlanId = ((VlanIdCriterion) criterion).vlanId();
            // match untagged packets this way in the ACL table.
            if (vlanId.equals(VlanId.NONE)) {
                return;
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vlanId);
            sbuilder.extension(ofdpaMatchVlanVid, deviceId);
        } else if (criterion instanceof Icmpv6TypeCriterion || criterion instanceof Icmpv6CodeCriterion) {
            /*
                 * We silenty discard these criterions, our current
                 * OFDPA platform does not support these matches on
                 * the ACL table.
                 */
            log.warn("ICMPv6 Type and ICMPv6 Code are not supported");
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.add(o);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.info("Processing versatile forwarding objective:{} in dev:{}", fwd.id(), deviceId);
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective:{} must include ethType", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            VlanId vlanId = ((VlanIdCriterion) criterion).vlanId();
            // match untagged packets this way in the ACL table.
            if (vlanId.equals(VlanId.NONE)) {
                return;
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vlanId);
            sbuilder.extension(ofdpaMatchVlanVid, deviceId);
        } else if (criterion instanceof Icmpv6TypeCriterion || criterion instanceof Icmpv6CodeCriterion) {
            /*
                 * We silenty discard these criterions, our current
                 * OFDPA platform does not support these matches on
                 * the ACL table.
                 */
            log.warn("ICMPv6 Type and ICMPv6 Code are not supported");
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.add(o);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
        if (fwd.treatment().clearedDeferred()) {
            ttBuilder.wipeDeferred();
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
protected int buildIpv6Selector(TrafficSelector.Builder builderToUpdate, ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    IpPrefix ipv6Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV6_DST)).ip();
    if (ipv6Dst.isMulticast()) {
        log.warn("Multicast specific forwarding objective can only be ipv4");
        fail(fwd, ObjectiveError.BADPARAMS);
        return -1;
    } else {
        if (ipv6Dst.prefixLength() == 0) {
            log.warn("Default ipv6 route not supported for now");
            fail(fwd, ObjectiveError.BADPARAMS);
            return -1;
        } else {
            builderToUpdate.matchEthType(Ethernet.TYPE_IPV6).matchIPv6Dst(ipv6Dst);
        }
        log.debug("processing IPv6 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    }
    return 0;
}
#method_after
protected int buildIpv6Selector(TrafficSelector.Builder builderToUpdate, ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    IpPrefix ipv6Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV6_DST)).ip();
    if (ipv6Dst.isMulticast()) {
        log.warn("IPv6 Multicast is currently not supported");
        fail(fwd, ObjectiveError.BADPARAMS);
        return -1;
    } else {
        if (ipv6Dst.prefixLength() == 0) {
            log.warn("Default ipv6 route is currently not supported");
            fail(fwd, ObjectiveError.BADPARAMS);
            return -1;
        } else {
            builderToUpdate.matchEthType(Ethernet.TYPE_IPV6).matchIPv6Dst(ipv6Dst);
        }
        log.debug("processing IPv6 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    }
    return 0;
}
#end_block

#method_before
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            filteredSelector.extension(ofdpaMatchVlanVid, deviceId);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    /*
                         * NOTE: The switch does not support matching 0.0.0.0/0
                         * Split it into 0.0.0.0/1 and 128.0.0.0/1
                         */
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    tb.deferred().add(instr);
                }
            }
        }
    } else if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        if (buildIpv6Selector(filteredSelector, fwd) < 0) {
            return Collections.emptyList();
        }
        forTableId = UNICAST_ROUTING_TABLE;
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                    tb.immediate().add(instr);
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            tb.extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#method_after
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            filteredSelector.extension(ofdpaMatchVlanVid, deviceId);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    // NOTE: The switch does not support matching 0.0.0.0/0
                    // Split it into 0.0.0.0/1 and 128.0.0.0/1
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        if (buildIpv6Selector(filteredSelector, fwd) < 0) {
            return Collections.emptyList();
        }
        forTableId = UNICAST_ROUTING_TABLE;
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                // OF-DPA does not pop in MPLS table. Instead it requires
                // setting the MPLS_TYPE so pop can happen down the pipeline
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                    // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                    tb.immediate().decMplsTtl();
                }
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                    tb.immediate().add(instr);
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a MPLS interface,
            // or a MPLS SWAP (with-same) but that would have to be handled in the next-objective.
            // Also the pop-mpls logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        flowRuleCollection.add(defaultRoute(fwd, complementarySelector, forTableId, tb));
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    /*
         * This option is necessary to activate the support for NeighborDiscovery
         * protocol in the NRM.
         */
    compCfgService.preSetProperty("org.onosproject.incubator.net.neighbour.impl." + "NeighbourResolutionManager", "ndpEnabled", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    routeHandler = new RouteHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    /*
         * We push the packet requests to the packet service.
         */
    requestPackets();
    cfgListener.configureNetwork();
    routeService.addListener(routeListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<SubnetNextObjectiveStoreKey, Integer> subnetNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetNextObjStore = subnetNextObjMapBuilder.withName("subnetnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<SubnetAssignedVidStoreKey, VlanId> subnetVidStoreMapBuilder = storageService.eventuallyConsistentMapBuilder();
    subnetVidStore = subnetVidStoreMapBuilder.withName("subnetvidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.vrouter.Vrouter", "fibInstallerEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.incubator.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelay", "arpEnabled", "false");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    cordConfigHandler = new CordConfigHandler(this);
    routeHandler = new RouteHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    cordConfigService.addListener(cordConfigListener);
    cfgListener.configureNetwork();
    routeService.addListener(routeListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    /*
         * We withdraw the packet requests to the packet service.
         */
    cancelPackets();
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    cordConfigService.removeListener(cordConfigListener);
    routeService.removeListener(routeListener);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    nsNextObjStore.destroy();
    subnetNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    subnetVidStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    cordConfigService.removeListener(cordConfigListener);
    routeService.removeListener(routeListener);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    nsNextObjStore.destroy();
    subnetNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    subnetVidStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipPacket = (IPv4) ethernet.getPayload();
        ipHandler.addToPacketBuffer(ipPacket);
        if (ipPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processPacketIn(pkt);
        } else {
            ipHandler.processPacketIn(pkt);
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    log.trace("Rcvd pktin: {}", ethernet);
    if (ethernet.getEtherType() == TYPE_ARP) {
        arpHandler.processPacketIn(pkt);
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipPacket = (IPv4) ethernet.getPayload();
        // ipHandler.addToPacketBuffer(ipPacket);
        if (ipPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpHandler.processPacketIn(pkt);
        } else {
        // NOTE: We don't support IP learning at this moment so this
        // is not necessary. Also it causes duplication of DHCP packets.
        // ipHandler.processPacketIn(pkt);
        }
    }
}
#end_block

#method_before
@Override
public int getIPv4SegmentId(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getIPv4SegmentId for device{} is {}", deviceId, srinfo.ipv4NodeSid);
        return srinfo.ipv4NodeSid;
    } else {
        String message = "getSegmentId fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#method_after
@Override
public int getIPv4SegmentId(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getIPv4SegmentId for device{} is {}", deviceId, srinfo.ipv4NodeSid);
        return srinfo.ipv4NodeSid;
    } else {
        String message = "getIPv4SegmentId fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
@Override
public int getIPv6SegmentId(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getIPv6SegmentId for device{} is {}", deviceId, srinfo.ipv6NodeSid);
        return srinfo.ipv6NodeSid;
    }
    /*
         * If we don't have an IPv6 configuration, it should be fine.
         */
    return -1;
}
#method_after
@Override
public int getIPv6SegmentId(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getIPv6SegmentId for device{} is {}", deviceId, srinfo.ipv6NodeSid);
        return srinfo.ipv6NodeSid;
    } else {
        String message = "getIPv6SegmentId fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
@Override
public Ip4Address getRouterIpv4(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, srinfo.ipv4Loopback);
        return srinfo.ipv4Loopback;
    } else {
        String message = "getRouterIp fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#method_after
@Override
public Ip4Address getRouterIpv4(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getRouterIpv4 for device{} is {}", deviceId, srinfo.ipv4Loopback);
        return srinfo.ipv4Loopback;
    } else {
        String message = "getRouterIpv4 fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
@Override
public Ip6Address getRouterIpv6(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getDeviceIp for device{} is {}", deviceId, srinfo.ipv6Loopback);
        return srinfo.ipv6Loopback;
    }
    return null;
}
#method_after
@Override
public Ip6Address getRouterIpv6(DeviceId deviceId) throws DeviceConfigNotFoundException {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getRouterIpv6 for device{} is {}", deviceId, srinfo.ipv6Loopback);
        return srinfo.ipv6Loopback;
    } else {
        String message = "getRouterIpv6 fails for device: " + deviceId + ".";
        throw new DeviceConfigNotFoundException(message);
    }
}
#end_block

#method_before
public Set<Ip4Prefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        log.trace("getSubnets for device{} is {}", deviceId, srinfo.subnets.values());
        ImmutableSet.Builder<Ip4Prefix> builder = ImmutableSet.builder();
        return builder.addAll(srinfo.subnets.values()).build();
    }
    return null;
}
#method_after
public Set<Ip4Prefix> getSubnets(DeviceId deviceId) {
    SegmentRouterInfo srinfo = deviceConfigMap.get(deviceId);
    if (srinfo != null) {
        ImmutableSet.Builder<Ip4Prefix> builder = ImmutableSet.builder();
        return builder.addAll(srinfo.subnets.values()).build();
    }
    return null;
}
#end_block

#method_before
public Ip4Prefix getPortSubnet(DeviceId deviceId, PortNumber port) {
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    if (isSuppressedPort(connectPoint)) {
        return null;
    }
    Set<Ip4Prefix> subnets = srManager.interfaceService.getInterfacesByPort(connectPoint).stream().flatMap(intf -> intf.ipAddressesList().stream()).map(InterfaceIpAddress::subnetAddress).map(IpPrefix::getIp4Prefix).collect(Collectors.toSet());
    if (subnets.size() == 0) {
        log.info(NO_SUBNET, connectPoint);
        return null;
    } else if (subnets.size() > 1) {
        log.warn(TOO_MANY_SUBNET, connectPoint);
        return null;
    } else {
        return subnets.stream().findFirst().orElse(null);
    }
}
#method_after
public Ip4Prefix getPortSubnet(DeviceId deviceId, PortNumber port) {
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    if (isSuppressedPort(connectPoint)) {
        return null;
    }
    Set<Ip4Prefix> subnets = srManager.interfaceService.getInterfacesByPort(connectPoint).stream().flatMap(intf -> intf.ipAddressesList().stream()).map(InterfaceIpAddress::subnetAddress).map(IpPrefix::getIp4Prefix).collect(Collectors.toSet());
    if (subnets.isEmpty()) {
        log.info(NO_SUBNET, connectPoint);
        return null;
    } else if (subnets.size() > 1) {
        log.warn(TOO_MANY_SUBNET, connectPoint);
        return null;
    } else {
        return subnets.stream().findFirst().orElse(null);
    }
}
#end_block

#method_before
@Override
public void addListener(RouteListener listener) {
    synchronized (this) {
        log.debug("Synchronizing current routes to new listener");
        ListenerQueue l = createListenerQueue(listener);
        routeStore.getRouteTables().forEach(table -> {
            Collection<Route> routes = routeStore.getRoutes(table);
            if (routes != null) {
                routes.forEach(route -> {
                    NextHopData nextHopData = routeStore.getNextHop(route.nextHop());
                    if (nextHopData != null) {
                        l.post(new RouteEvent(RouteEvent.Type.ROUTE_ADDED, new ResolvedRoute(route, nextHopData.mac(), nextHopData.location())));
                    } else {
                        /*
                             * FIXME It is just a fix but this will not resolve our problem.
                             * Can we do something of more intelligent ?
                             */
                        log.warn("Abort sending route update, unfortunately the nextHop is null");
                    }
                });
            }
        });
        listeners.put(listener, l);
        l.start();
        log.debug("Route synchronization complete");
    }
}
#method_after
@Override
public void addListener(RouteListener listener) {
    synchronized (this) {
        log.debug("Synchronizing current routes to new listener");
        ListenerQueue l = createListenerQueue(listener);
        routeStore.getRouteTables().forEach(table -> {
            Collection<Route> routes = routeStore.getRoutes(table);
            if (routes != null) {
                routes.forEach(route -> {
                    NextHopData nextHopData = routeStore.getNextHop(route.nextHop());
                    if (nextHopData != null) {
                        l.post(new RouteEvent(RouteEvent.Type.ROUTE_ADDED, new ResolvedRoute(route, nextHopData.mac(), nextHopData.location())));
                    }
                });
            }
        });
        listeners.put(listener, l);
        l.start();
        log.debug("Route synchronization complete");
    }
}
#end_block

#method_before
public static boolean isLinkLocalAddress(byte[] targetIp) {
    return targetIp.length == Ip6Address.BYTE_LENGTH && (targetIp[0] & 0xff) == 0xfe && (targetIp[1] & 0xc0) == 0x80;
}
#method_after
public static boolean isLinkLocalAddress(byte[] targetIp) {
    checkArgument(targetIp.length == Ip6Address.BYTE_LENGTH);
    return (targetIp[0] & 0xff) == 0xfe && (targetIp[1] & 0xc0) == 0x80;
}
#end_block

#method_before
@Before
public void setUp() {
    deserializer = IPv6.deserializer();
}
#method_after
@Before
public void setUp() {
    deserializer = deserializer();
}
#end_block

#method_before
@Test
public void testSerialize() {
    IPv6 ipv6 = new IPv6();
    ipv6.setPayload(udp);
    ipv6.setVersion((byte) 6);
    ipv6.setTrafficClass((byte) 0x93);
    ipv6.setFlowLabel(0x13579);
    ipv6.setNextHeader(IPv6.PROTOCOL_UDP);
    ipv6.setHopLimit((byte) 32);
    ipv6.setSourceAddress(SOURCE_ADDRESS);
    ipv6.setDestinationAddress(DESTINATION_ADDRESS);
    assertArrayEquals(ipv6.serialize(), bytePacket);
}
#method_after
@Test
public void testSerialize() {
    IPv6 ipv6 = new IPv6();
    ipv6.setPayload(udp);
    ipv6.setVersion((byte) 6);
    ipv6.setTrafficClass((byte) 0x93);
    ipv6.setFlowLabel(0x13579);
    ipv6.setNextHeader(PROTOCOL_UDP);
    ipv6.setHopLimit((byte) 32);
    ipv6.setSourceAddress(SOURCE_ADDRESS);
    ipv6.setDestinationAddress(DESTINATION_ADDRESS);
    assertArrayEquals(ipv6.serialize(), bytePacket);
}
#end_block

#method_before
@Test
public void testDeserializeTruncated() throws Exception {
    // Run the truncation test only on the IPv6 header
    byte[] ipv6Header = new byte[IPv6.FIXED_HEADER_LENGTH];
    ByteBuffer.wrap(bytePacket).get(ipv6Header);
    PacketTestUtils.testDeserializeTruncated(deserializer, ipv6Header);
}
#method_after
@Test
public void testDeserializeTruncated() throws Exception {
    // Run the truncation test only on the IPv6 header
    byte[] ipv6Header = new byte[FIXED_HEADER_LENGTH];
    ByteBuffer.wrap(bytePacket).get(ipv6Header);
    PacketTestUtils.testDeserializeTruncated(deserializer, ipv6Header);
}
#end_block

#method_before
@Test
public void testDeserialize() throws DeserializationException {
    IPv6 ipv6 = deserializer.deserialize(bytePacket, 0, bytePacket.length);
    assertThat(ipv6.getVersion(), is((byte) 6));
    assertThat(ipv6.getTrafficClass(), is((byte) 0x93));
    assertThat(ipv6.getFlowLabel(), is(0x13579));
    assertThat(ipv6.getNextHeader(), is(IPv6.PROTOCOL_UDP));
    assertThat(ipv6.getHopLimit(), is((byte) 32));
    assertArrayEquals(ipv6.getSourceAddress(), SOURCE_ADDRESS);
    assertArrayEquals(ipv6.getDestinationAddress(), DESTINATION_ADDRESS);
}
#method_after
@Test
public void testDeserialize() throws DeserializationException {
    IPv6 ipv6 = deserializer.deserialize(bytePacket, 0, bytePacket.length);
    assertThat(ipv6.getVersion(), is((byte) 6));
    assertThat(ipv6.getTrafficClass(), is((byte) 0x93));
    assertThat(ipv6.getFlowLabel(), is(0x13579));
    assertThat(ipv6.getNextHeader(), is(PROTOCOL_UDP));
    assertThat(ipv6.getHopLimit(), is((byte) 32));
    assertArrayEquals(ipv6.getSourceAddress(), SOURCE_ADDRESS);
    assertArrayEquals(ipv6.getDestinationAddress(), DESTINATION_ADDRESS);
}
#end_block

#method_before
@Test
public void testEqual() {
    IPv6 packet1 = new IPv6();
    packet1.setPayload(udp);
    packet1.setVersion((byte) 6);
    packet1.setTrafficClass((byte) 0x93);
    packet1.setFlowLabel(0x13579);
    packet1.setNextHeader(IPv6.PROTOCOL_UDP);
    packet1.setHopLimit((byte) 32);
    packet1.setSourceAddress(SOURCE_ADDRESS);
    packet1.setDestinationAddress(DESTINATION_ADDRESS);
    IPv6 packet2 = new IPv6();
    packet2.setPayload(udp);
    packet2.setVersion((byte) 6);
    packet2.setTrafficClass((byte) 0x93);
    packet2.setFlowLabel(0x13579);
    packet2.setNextHeader(IPv6.PROTOCOL_UDP);
    packet2.setHopLimit((byte) 32);
    packet2.setSourceAddress(DESTINATION_ADDRESS);
    packet2.setDestinationAddress(SOURCE_ADDRESS);
    assertTrue(packet1.equals(packet1));
    assertFalse(packet1.equals(packet2));
}
#method_after
@Test
public void testEqual() {
    IPv6 packet1 = new IPv6();
    packet1.setPayload(udp);
    packet1.setVersion((byte) 6);
    packet1.setTrafficClass((byte) 0x93);
    packet1.setFlowLabel(0x13579);
    packet1.setNextHeader(PROTOCOL_UDP);
    packet1.setHopLimit((byte) 32);
    packet1.setSourceAddress(SOURCE_ADDRESS);
    packet1.setDestinationAddress(DESTINATION_ADDRESS);
    IPv6 packet2 = new IPv6();
    packet2.setPayload(udp);
    packet2.setVersion((byte) 6);
    packet2.setTrafficClass((byte) 0x93);
    packet2.setFlowLabel(0x13579);
    packet2.setNextHeader(PROTOCOL_UDP);
    packet2.setHopLimit((byte) 32);
    packet2.setSourceAddress(DESTINATION_ADDRESS);
    packet2.setDestinationAddress(SOURCE_ADDRESS);
    assertTrue(packet1.equals(packet1));
    assertFalse(packet1.equals(packet2));
}
#end_block

#method_before
@Test
public void testToStringIPv6() throws Exception {
    IPv6 ipv6 = deserializer.deserialize(bytePacket, 0, bytePacket.length);
    String str = ipv6.toString();
    assertTrue(StringUtils.contains(str, "version=" + (byte) 6));
    assertTrue(StringUtils.contains(str, "trafficClass=" + (byte) 0x93));
    assertTrue(StringUtils.contains(str, "flowLabel=" + 0x13579));
    assertTrue(StringUtils.contains(str, "nextHeader=" + IPv6.PROTOCOL_UDP));
    assertTrue(StringUtils.contains(str, "hopLimit=" + (byte) 32));
// TODO: test IPv6 source and destination address
}
#method_after
@Test
public void testToStringIPv6() throws Exception {
    IPv6 ipv6 = deserializer.deserialize(bytePacket, 0, bytePacket.length);
    String str = ipv6.toString();
    assertTrue(StringUtils.contains(str, "version=" + (byte) 6));
    assertTrue(StringUtils.contains(str, "trafficClass=" + (byte) 0x93));
    assertTrue(StringUtils.contains(str, "flowLabel=" + 0x13579));
    assertTrue(StringUtils.contains(str, "nextHeader=" + PROTOCOL_UDP));
    assertTrue(StringUtils.contains(str, "hopLimit=" + (byte) 32));
// TODO: test IPv6 source and destination address
}
#end_block

#method_before
@Test
public void testSolicitationNodeAddress() {
    assertTrue(Arrays.equals(SOLICITATION_NODE_ADDRESS, IPv6.solicitationNodeAddress(DESTINATION_ADDRESS)));
}
#method_after
@Test
public void testSolicitationNodeAddress() {
    assertArrayEquals(SOLICITATION_NODE_ADDRESS, getSolicitNodeAddress(DESTINATION_ADDRESS));
}
#end_block

#method_before
@Test
public void testMulticastAddress() {
    assertTrue(Arrays.equals(MULTICAST_ADDRESS, IPv6.multicastMacAddress(DESTINATION_ADDRESS)));
}
#method_after
@Test
public void testMulticastAddress() {
    assertArrayEquals(MULTICAST_ADDRESS, getMCastMacAddress(DESTINATION_ADDRESS));
}
#end_block

#method_before
@Test
public void testIsLinkLocalAddress() {
    assertFalse(IPv6.isLinkLocalAddress(SOURCE_ADDRESS));
    assertFalse(IPv6.isLinkLocalAddress(DESTINATION_ADDRESS));
    assertFalse(IPv6.isLinkLocalAddress(SOLICITATION_NODE_ADDRESS));
    assertTrue(IPv6.isLinkLocalAddress(LINK_LOCAL_ADDRESS_1));
    assertTrue(IPv6.isLinkLocalAddress(LINK_LOCAL_ADDRESS_2));
}
#method_after
@Test
public void testIsLinkLocalAddress() {
    assertFalse(isLinkLocalAddress(SOURCE_ADDRESS));
    assertFalse(isLinkLocalAddress(DESTINATION_ADDRESS));
    assertFalse(isLinkLocalAddress(SOLICITATION_NODE_ADDRESS));
    assertTrue(isLinkLocalAddress(LINK_LOCAL_ADDRESS_1));
    assertTrue(isLinkLocalAddress(LINK_LOCAL_ADDRESS_2));
}
#end_block

#method_before
@Test
public void testLinkLocalAddress() {
    assertTrue(Arrays.equals(IPv6.linkLocalAddress(MAC_ADDRESS_1), LINK_LOCAL_ADDRESS_1));
    assertTrue(Arrays.equals(IPv6.linkLocalAddress(MAC_ADDRESS_2), LINK_LOCAL_ADDRESS_2));
}
#method_after
@Test
public void testLinkLocalAddress() {
    assertArrayEquals(getLinkLocalAddress(MAC_ADDRESS_1), LINK_LOCAL_ADDRESS_1);
    assertArrayEquals(getLinkLocalAddress(MAC_ADDRESS_2), LINK_LOCAL_ADDRESS_2);
}
#end_block

#method_before
@Test
public void testMacAddress() {
    assertTrue(Arrays.equals(IPv6.macAddress(LINK_LOCAL_ADDRESS_1), MAC_ADDRESS_1));
    assertTrue(Arrays.equals(IPv6.macAddress(LINK_LOCAL_ADDRESS_2), MAC_ADDRESS_2));
}
#method_after
@Test
public void testMacAddress() {
    assertArrayEquals(getMacAddress(LINK_LOCAL_ADDRESS_1), MAC_ADDRESS_1);
    assertArrayEquals(getMacAddress(LINK_LOCAL_ADDRESS_2), MAC_ADDRESS_2);
}
#end_block

#method_before
public void execute() throws YangParsingException {
    synchronized (YangGenerator.class) {
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerServiceManager();
        // Create compiler param.
        YangCompilationParam param = new DefaultYangCompilationParam();
        // Need to get dependent schema paths to give inter jar dependencies.
        for (String jar : depJar) {
            try {
                File path = parseDepSchemaPath(jar, outputDirectory);
                if (path != null) {
                    param.addDependentSchema(Paths.get(path.getAbsolutePath()));
                }
            } catch (IOException e) {
                throw new YangCompilerException("Failed to parse dependent schema path");
            }
        }
        param.setCodeGenDir(Paths.get(outputDirectory));
        param.setMetadataGenDir(Paths.get(outputDirectory + SLASH + YANG_RESOURCES + SLASH));
        for (File file : models) {
            param.addYangFile(Paths.get(file.getAbsolutePath()));
        }
        // Compile yang files and generate java code.
        try {
            output = compiler.compileYangFiles(param);
        } catch (IOException e) {
            throw new YangParsingException(e);
        }
    }
}
#method_after
public void execute() throws YangParsingException {
    synchronized (YangGenerator.class) {
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Create compiler param.
        YangCompilationParam param = new DefaultYangCompilationParam();
        // Need to get dependent schema paths to give inter jar dependencies.
        for (String jar : depJar) {
            try {
                File path = parseDepSchemaPath(jar, outputDirectory);
                if (path != null) {
                    param.addDependentSchema(Paths.get(path.getAbsolutePath()));
                }
            } catch (IOException e) {
                throw new YangCompilerException("Failed to parse dependent schema path");
            }
        }
        param.setCodeGenDir(Paths.get(outputDirectory));
        param.setMetadataGenDir(Paths.get(outputDirectory + SLASH + YANG_RESOURCES + SLASH));
        for (File file : models) {
            param.addYangFile(Paths.get(file.getAbsolutePath()));
        }
        // Compile yang files and generate java code.
        try {
            output = compiler.compileYangFiles(param);
        } catch (IOException e) {
            throw new YangParsingException(e);
        }
    }
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    String metaDataGenDir;
    String outputDir;
    try {
        validateMavenVersion();
        /*
             * For deleting the generated code in previous build.
             */
        outputDir = getDirectory(baseDir, outputDirectory);
        deleteDirectory(outputDir + SLASH + TEMP);
        deleteDirectory(outputDir + SLASH + YANG_RESOURCES);
        String searchDir = getDirectory(baseDir, yangFilesDir);
        // Get the code gen directory.
        codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Get the meta data gen directory.
        metaDataGenDir = outputDir + SLASH + DEFAULT_JAR_RES_PATH;
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerServiceManager();
        // Need to get dependent schema paths to give inter jar dependencies.
        List<Path> depSchemas = resolveInterJarDependencies(project, localRepository, remoteRepository, outputDir);
        // Create compiler param.
        YangCompilationParam param = new DefaultYangCompilationParam();
        param.setCodeGenDir(Paths.get(codeGenDir));
        param.setMetadataGenDir(Paths.get(metaDataGenDir));
        for (Path path : depSchemas) {
            param.addDependentSchema(path);
        }
        for (String file : getYangFiles(searchDir)) {
            param.addYangFile(Paths.get(file));
        }
        // Compile yang files and generate java code.
        output = compiler.compileYangFiles(param);
        addToCompilationRoot(codeGenDir, project, context);
        addToProjectResource(outputDir + SLASH + TEMP + SLASH, project);
    } catch (YangCompilerException e) {
        String fileName = EMPTY_STRING;
        if (e.getYangFile() != null) {
            fileName = e.getYangFile().toString();
        }
        try {
            deleteDirectory(codeGenDir + getPackageDirPathFromJavaJPackage(DEFAULT_BASE_PKG));
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        getLog().info(e.getCause());
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + IN + fileName + " YANG file.");
    } catch (IOException e) {
        throw new MojoExecutionException("Failed to process files");
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    String metaDataGenDir;
    String outputDir;
    try {
        validateMavenVersion();
        /*
             * For deleting the generated code in previous build.
             */
        outputDir = getDirectory(baseDir, outputDirectory);
        deleteDirectory(outputDir + SLASH + TEMP);
        deleteDirectory(outputDir + SLASH + YANG_RESOURCES);
        String searchDir = getDirectory(baseDir, yangFilesDir);
        // Get the code gen directory.
        codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Get the meta data gen directory.
        metaDataGenDir = outputDir + SLASH + DEFAULT_JAR_RES_PATH;
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Need to get dependent schema paths to give inter jar dependencies.
        List<Path> depSchemas = resolveInterJarDependencies(project, localRepository, remoteRepository, outputDir);
        // Create compiler param.
        YangCompilationParam param = new DefaultYangCompilationParam();
        param.setCodeGenDir(Paths.get(codeGenDir));
        param.setMetadataGenDir(Paths.get(metaDataGenDir));
        for (Path path : depSchemas) {
            param.addDependentSchema(path);
        }
        for (String file : getYangFiles(searchDir)) {
            param.addYangFile(Paths.get(file));
        }
        // Compile yang files and generate java code.
        output = compiler.compileYangFiles(param);
        addToCompilationRoot(codeGenDir, project, context);
        addToProjectResource(outputDir + SLASH + TEMP + SLASH, project);
    } catch (YangCompilerException e) {
        String fileName = EMPTY_STRING;
        if (e.getYangFile() != null) {
            fileName = e.getYangFile().toString();
        }
        try {
            deleteDirectory(codeGenDir + getPackageDirPathFromJavaJPackage(DEFAULT_BASE_PKG));
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        getLog().info(e.getCause());
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + IN + fileName + " YANG file.");
    } catch (IOException e) {
        throw new MojoExecutionException("Failed to process files");
    }
}
#end_block

#method_before
private SparseAnnotations makePortAnnotation(String portName, String portMac) {
    SparseAnnotations annotations = DefaultAnnotations.EMPTY;
    String pName = Strings.emptyToNull(portName);
    String pMac = Strings.emptyToNull(portMac);
    if (pName != null && pMac != null) {
        annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, pName).set(AnnotationKeys.PORT_MAC, pMac).build();
    }
    return annotations;
}
#method_after
private SparseAnnotations makePortAnnotation(String portName, String portMac) {
    DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
    String pName = Strings.emptyToNull(portName);
    String pMac = Strings.emptyToNull(portMac);
    if (pName != null) {
        builder.set(AnnotationKeys.PORT_NAME, pName);
    }
    if (pMac != null) {
        builder.set(AnnotationKeys.PORT_MAC, pMac);
    }
    // Returns an empty annotation if both pName and pMac are null
    return builder.build();
}
#end_block

#method_before
private PortDescription buildPortDescription(PortDescPropertyType ptype, OFPortOptical port, OpenFlowOpticalSwitch opsw) {
    checkArgument(port.getDesc().size() >= 1);
    // Minimally functional fixture. This needs to be fixed as we add better support.
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    SparseAnnotations annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString());
    if (port.getVersion() == OFVersion.OF_13 && ptype == PortDescPropertyType.OPTICAL_TRANSPORT) {
        // At this point, not much is carried in the optical port message.
        LOG.debug("Optical transport port message {}", port.toString());
    } else {
        // removable once 1.4+ support complete.
        LOG.debug("Unsupported optical port properties");
    }
    OFPortDescPropOpticalTransport desc = port.getDesc().get(0);
    switch(desc.getPortSignalType()) {
        // FIXME: use constants once loxi has full optical extensions
        case // OMS port
        2:
            // Assume complete optical spectrum and 50 GHz grid
            // LINC-OE is only supported optical OF device for now
            Set<OchSignal> signals = null;
            if (opsw instanceof HandlerBehaviour) {
                DriverHandler driverHandler = ((HandlerBehaviour) opsw).handler();
                if (driverHandler != null && driverHandler.hasBehaviour(LambdaQuery.class)) {
                    try {
                        signals = driverHandler.behaviour(LambdaQuery.class).queryLambdas(portNo);
                    } catch (NullPointerException e) {
                        signals = null;
                    }
                }
            }
            Frequency minFreq;
            Frequency maxFreq;
            Frequency channelSpacing;
            if (signals == null || signals.isEmpty()) {
                minFreq = Spectrum.U_BAND_MIN;
                maxFreq = Spectrum.O_BAND_MAX;
                channelSpacing = Frequency.ofGHz(50);
            } else {
                Comparator<OchSignal> compare = (OchSignal a, OchSignal b) -> a.spacingMultiplier() - b.spacingMultiplier();
                OchSignal minOch = Collections.min(signals, compare);
                OchSignal maxOch = Collections.max(signals, compare);
                minFreq = minOch.centralFrequency();
                maxFreq = maxOch.centralFrequency();
                channelSpacing = minOch.channelSpacing().frequency();
            }
            return omsPortDescription(portNo, enabled, minFreq, maxFreq, channelSpacing, annotations);
        case // OCH port
        5:
            OchSignal signal = new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, 0, 4);
            return ochPortDescription(portNo, enabled, OduSignalType.ODU4, true, signal, annotations);
        default:
            break;
    }
    return new DefaultPortDescription(portNo, enabled, FIBER, 0, annotations);
}
#method_after
private PortDescription buildPortDescription(PortDescPropertyType ptype, OFPortOptical port, OpenFlowOpticalSwitch opsw) {
    checkArgument(!port.getDesc().isEmpty());
    // Minimally functional fixture. This needs to be fixed as we add better support.
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    SparseAnnotations annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString());
    if (port.getVersion() == OFVersion.OF_13 && ptype == PortDescPropertyType.OPTICAL_TRANSPORT) {
        // At this point, not much is carried in the optical port message.
        LOG.debug("Optical transport port message {}", port.toString());
    } else {
        // removable once 1.4+ support complete.
        LOG.debug("Unsupported optical port properties");
    }
    OFPortDescPropOpticalTransport desc = port.getDesc().get(0);
    switch(desc.getPortSignalType()) {
        // FIXME: use constants once loxi has full optical extensions
        case // OMS port
        2:
            // Assume complete optical spectrum and 50 GHz grid
            // LINC-OE is only supported optical OF device for now
            Set<OchSignal> signals = null;
            if (opsw instanceof HandlerBehaviour) {
                DriverHandler driverHandler = ((HandlerBehaviour) opsw).handler();
                if (driverHandler != null && driverHandler.hasBehaviour(LambdaQuery.class)) {
                    try {
                        signals = driverHandler.behaviour(LambdaQuery.class).queryLambdas(portNo);
                    } catch (NullPointerException e) {
                        signals = null;
                    }
                }
            }
            Frequency minFreq;
            Frequency maxFreq;
            Frequency channelSpacing;
            if (signals == null || signals.isEmpty()) {
                minFreq = Spectrum.U_BAND_MIN;
                maxFreq = Spectrum.O_BAND_MAX;
                channelSpacing = Frequency.ofGHz(50);
            } else {
                Comparator<OchSignal> compare = (OchSignal a, OchSignal b) -> a.spacingMultiplier() - b.spacingMultiplier();
                OchSignal minOch = Collections.min(signals, compare);
                OchSignal maxOch = Collections.max(signals, compare);
                minFreq = minOch.centralFrequency();
                maxFreq = maxOch.centralFrequency();
                channelSpacing = minOch.channelSpacing().frequency();
            }
            return omsPortDescription(portNo, enabled, minFreq, maxFreq, channelSpacing, annotations);
        case // OCH port
        5:
            OchSignal signal = new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, 0, 4);
            return ochPortDescription(portNo, enabled, OduSignalType.ODU4, true, signal, annotations);
        default:
            break;
    }
    return new DefaultPortDescription(portNo, enabled, FIBER, 0, annotations);
}
#end_block

#method_before
private PortDescription buildPortDescription(OFCalientPortDescStatsEntry port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    // Use the alias name if it's available
    String name = port.getName();
    List<OFCalientPortDescProp> props = port.getProperties();
    if (props != null && props.size() > 0) {
        OFCalientPortDescPropOptical propOptical = (OFCalientPortDescPropOptical) props.get(0);
        if (propOptical != null) {
            name = propOptical.getInAlias();
        }
    }
    // FIXME when Calient OF agent reports port status
    boolean enabled = true;
    SparseAnnotations annotations = makePortAnnotation(name, port.getHwAddr().toString());
    // Wavelength range: 1260 - 1630 nm, grid is irrelevant for this type of switch
    return omsPortDescription(portNo, enabled, Spectrum.U_BAND_MIN, Spectrum.O_BAND_MAX, Frequency.ofGHz(100), annotations);
}
#method_after
private PortDescription buildPortDescription(OFCalientPortDescStatsEntry port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    // Use the alias name if it's available
    String name = port.getName();
    List<OFCalientPortDescProp> props = port.getProperties();
    if (props != null && !props.isEmpty()) {
        OFCalientPortDescPropOptical propOptical = (OFCalientPortDescPropOptical) props.get(0);
        if (propOptical != null) {
            name = propOptical.getInAlias();
        }
    }
    // FIXME when Calient OF agent reports port status
    boolean enabled = true;
    SparseAnnotations annotations = makePortAnnotation(name, port.getHwAddr().toString());
    // Wavelength range: 1260 - 1630 nm, grid is irrelevant for this type of switch
    return omsPortDescription(portNo, enabled, Spectrum.U_BAND_MIN, Spectrum.O_BAND_MAX, Frequency.ofGHz(100), annotations);
}
#end_block

#method_before
public PortFilterInfo populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return null;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts != null && devPorts.isEmpty()) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return null;
    }
    int disabledPorts = 0, suppressedPorts = 0, filteredPorts = 0;
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        if (!port.isEnabled()) {
            disabledPorts++;
            continue;
        }
        boolean isSuppressed = false;
        SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
        if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
            isSuppressed = true;
            suppressedPorts++;
        }
        Ip4Prefix portSubnet = config.getPortSubnet(deviceId, port.number());
        VlanId assignedVlan = (portSubnet == null || isSuppressed) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
        // vlan assignment is valid only if this instance is master
        if (srManager.mastershipService.isLocalMaster(deviceId)) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(srManager.appId);
        log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
        filteredPorts++;
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    }
    log.info("Filtering on dev:{}, disabledPorts:{}, suppressedPorts:{}, filteredPorts:{}", deviceId, disabledPorts, suppressedPorts, filteredPorts);
    return srManager.defaultRoutingHandler.new PortFilterInfo(disabledPorts, suppressedPorts, filteredPorts);
}
#method_after
public PortFilterInfo populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return null;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts == null || devPorts.isEmpty()) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return null;
    }
    int disabledPorts = 0, suppressedPorts = 0, filteredPorts = 0;
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        if (!port.isEnabled()) {
            disabledPorts++;
            continue;
        }
        boolean isSuppressed = false;
        SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
        if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
            isSuppressed = true;
            suppressedPorts++;
        }
        Ip4Prefix portSubnet = config.getPortSubnet(deviceId, port.number());
        VlanId assignedVlan = (portSubnet == null || isSuppressed) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
        // vlan assignment is valid only if this instance is master
        if (srManager.mastershipService.isLocalMaster(deviceId)) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(srManager.appId);
        log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
        filteredPorts++;
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    }
    log.info("Filtering on dev:{}, disabledPorts:{}, suppressedPorts:{}, filteredPorts:{}", deviceId, disabledPorts, suppressedPorts, filteredPorts);
    return srManager.defaultRoutingHandler.new PortFilterInfo(disabledPorts, suppressedPorts, filteredPorts);
}
#end_block

#method_before
private List<Device> populateDevices(ControllerNode node) {
    DeviceService ds = get(DeviceService.class);
    MastershipService ms = get(MastershipService.class);
    return copyOf(ds.getDevices()).stream().filter(d -> ms.getMasterFor(d.id()).compareTo(node.id()) == 0).collect(Collectors.toList());
}
#method_after
private List<Device> populateDevices(ControllerNode node) {
    DeviceService ds = get(DeviceService.class);
    MastershipService ms = get(MastershipService.class);
    return copyOf(ds.getDevices()).stream().filter(d -> ms.getMasterFor(d.id()).equals(node.id())).collect(Collectors.toList());
}
#end_block

