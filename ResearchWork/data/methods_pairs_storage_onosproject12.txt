428
#method_before
@Override
public void setFeaturesReply(OFFeaturesReply featuresReply) {
    OFFeaturesReply.Builder builder = featuresReply.createBuilder();
    // do not try to set PORTS or ACTIONS,
    // they are not supported for this openflow version
    builder.setAuxiliaryId(featuresReply.getAuxiliaryId());
    builder.setDatapathId(featuresReply.getDatapathId());
    builder.setNBuffers(featuresReply.getNBuffers());
    builder.setReserved(featuresReply.getReserved());
    builder.setXid(featuresReply.getXid());
    Set<OFCapabilities> capabilities = new HashSet<>(featuresReply.getCapabilities());
    capabilities.add(OFCapabilities.GROUP_STATS);
    builder.setCapabilities(capabilities);
    OFFeaturesReply newFeaturesReply = builder.build();
    this.features = newFeaturesReply;
    if (featuresReply.getVersion().compareTo(OFVersion.OF_13) < 0) {
        // before OF 1.3, feature reply contains OFPortDescs
        replacePortDescsWith(featuresReply.getPorts());
    }
}
#method_after
@Override
public void setFeaturesReply(OFFeaturesReply featuresReply) {
    OFFeaturesReply.Builder builder = featuresReply.createBuilder();
    // do not try to set PORTS or ACTIONS,
    // they are not supported for this openflow version
    builder.setAuxiliaryId(featuresReply.getAuxiliaryId());
    builder.setDatapathId(featuresReply.getDatapathId());
    builder.setNBuffers(featuresReply.getNBuffers());
    builder.setReserved(featuresReply.getReserved());
    builder.setXid(featuresReply.getXid());
    Set<OFCapabilities> capabilities = new HashSet<>(featuresReply.getCapabilities());
    capabilities.add(OFCapabilities.GROUP_STATS);
    builder.setCapabilities(capabilities);
    super.setFeaturesReply(builder.build());
}
#end_block

#method_before
private static TableEntry encodePiTableEntry(PiTableEntry piTableEntry, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    TableEntry.Builder tableEntryMsgBuilder = TableEntry.newBuilder();
    P4InfoOuterClass.Table tableInfo = browser.tables().getByName(piTableEntry.table().id());
    // Table id.
    tableEntryMsgBuilder.setTableId(tableInfo.getPreamble().getId());
    // Priority.
    // FIXME: check on P4Runtime if/what is the default priority.
    int priority = piTableEntry.priority().orElse(0);
    tableEntryMsgBuilder.setPriority(priority);
    // Controller metadata (cookie)
    tableEntryMsgBuilder.setControllerMetadata(piTableEntry.cookie());
    // Timeout.
    if (piTableEntry.timeout().isPresent()) {
        log.warn("Found PI table entry with timeout set, not supported in P4Runtime: {}", piTableEntry);
    }
    // Table action.
    tableEntryMsgBuilder.setAction(encodePiTableAction(piTableEntry.action(), browser));
    // Field matches.
    for (PiFieldMatch piFieldMatch : piTableEntry.matchKey().fieldMatches()) {
        tableEntryMsgBuilder.addMatch(encodePiFieldMatch(piFieldMatch, tableInfo, browser));
    }
    return tableEntryMsgBuilder.build();
}
#method_after
private static TableEntry encodePiTableEntry(PiTableEntry piTableEntry, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    TableEntry.Builder tableEntryMsgBuilder = TableEntry.newBuilder();
    P4InfoOuterClass.Table tableInfo = browser.tables().getByName(piTableEntry.table().id());
    // Table id.
    tableEntryMsgBuilder.setTableId(tableInfo.getPreamble().getId());
    // Priority.
    // FIXME: check on P4Runtime if/what is the default priority.
    piTableEntry.priority().ifPresent(tableEntryMsgBuilder::setPriority);
    // Controller metadata (cookie)
    tableEntryMsgBuilder.setControllerMetadata(piTableEntry.cookie());
    // Timeout.
    if (piTableEntry.timeout().isPresent()) {
        log.warn("Found PI table entry with timeout set, not supported in P4Runtime: {}", piTableEntry);
    }
    // Table action.
    tableEntryMsgBuilder.setAction(encodePiTableAction(piTableEntry.action(), browser));
    // Field matches.
    for (PiFieldMatch piFieldMatch : piTableEntry.matchKey().fieldMatches()) {
        tableEntryMsgBuilder.addMatch(encodePiFieldMatch(piFieldMatch, tableInfo, browser));
    }
    return tableEntryMsgBuilder.build();
}
#end_block

#method_before
static PiTableAction decodeTableActionMsg(TableAction tableActionMsg, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    TableAction.TypeCase typeCase = tableActionMsg.getTypeCase();
    switch(typeCase) {
        case ACTION:
            Action actionMsg = tableActionMsg.getAction();
            return decodeActionMsg(actionMsg, browser);
        case ACTION_PROFILE_GROUP_ID:
            return PiActionGroupId.of(tableActionMsg.getActionProfileGroupId());
        default:
            throw new EncodeException(format("Decoding of table action type %s not implemented", typeCase.name()));
    }
}
#method_after
static PiTableAction decodeTableActionMsg(TableAction tableActionMsg, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    TableAction.TypeCase typeCase = tableActionMsg.getTypeCase();
    switch(typeCase) {
        case ACTION:
            Action actionMsg = tableActionMsg.getAction();
            return decodeActionMsg(actionMsg, browser);
        case ACTION_PROFILE_GROUP_ID:
            return PiActionGroupId.of(tableActionMsg.getActionProfileGroupId());
        case ACTION_PROFILE_MEMBER_ID:
            return PiActionGroupMemberId.of(tableActionMsg.getActionProfileMemberId());
        default:
            throw new EncodeException(format("Decoding of table action type %s not implemented", typeCase.name()));
    }
}
#end_block

#method_before
@GET
@Path("refresh")
public Response triggerRefresh() {
    get(SimpleFabricService.class).triggerRefresh();
    return Response.ok("simple fabric refresh triggered").build();
}
#method_after
@PUT
@Path("refresh")
public Response triggerRefresh() {
    get(SimpleFabricService.class).triggerRefresh();
    return Response.status(204).build();
}
#end_block

#method_before
@GET
@Path("flush")
public Response triggerFlush() {
    get(SimpleFabricService.class).triggerFlush();
    return Response.ok("simple fabric flush triggered").build();
}
#method_after
@PUT
@Path("flush")
public Response triggerFlush() {
    get(SimpleFabricService.class).triggerFlush();
    return Response.status(204).build();
}
#end_block

#method_before
private void dump(String subject, PrintStream out) {
    if (subject == "intents") {
        out.println("Reactive Routing Route Intents:\n");
        for (Intent entry : intentService.getIntents()) {
            if (reactiveAppId.equals(entry.appId())) {
                MultiPointToSinglePointIntent intent = (MultiPointToSinglePointIntent) entry;
                out.println("    " + intent.key().toString() + " to " + intent.egressPoint().toString() + " set " + intent.treatment().immediate().toString() + " from " + intent.ingressPoints().toString());
            }
        }
        out.println("");
        out.println("Reactive Routing Intercept Flow Rules:\n");
        List<FlowRule> rules = new ArrayList(interceptFlowRules);
        Collections.sort(rules, new Comparator<FlowRule>() {

            @Override
            public int compare(FlowRule a, FlowRule b) {
                int r = a.deviceId().toString().compareTo(b.deviceId().toString());
                // descending on priority
                return (r != 0) ? r : Integer.compare(b.priority(), a.priority());
            }
        });
        for (FlowRule rule : rules) {
            out.println("    device=" + rule.deviceId().toString() + " priority=" + rule.priority() + " selector=" + rule.selector().criteria().toString());
        }
        out.println("");
        out.println("Reactive Routing Intents to Be Purged:\n");
        for (Key key : toBePurgedIntentKeys) {
            out.println("    " + key.toString());
        }
        out.println("");
    } else if (subject == "reactive-intents") {
        for (Intent entry : intentService.getIntents()) {
            if (reactiveAppId.equals(entry.appId())) {
                MultiPointToSinglePointIntent intent = (MultiPointToSinglePointIntent) entry;
                out.println(intent.key().toString() + " to " + intent.egressPoint().toString() + " set " + intent.treatment().immediate().toString() + " from " + intent.ingressPoints().toString());
            }
        }
    }
}
#method_after
private void dump(String subject, PrintStream out) {
    if ("intents".equals(subject)) {
        out.println("Reactive Routing Route Intents:\n");
        for (Intent entry : intentService.getIntents()) {
            if (reactiveAppId.equals(entry.appId())) {
                MultiPointToSinglePointIntent intent = (MultiPointToSinglePointIntent) entry;
                out.println("    " + intent.key().toString() + " to " + intent.egressPoint().toString() + " set " + intent.treatment().immediate().toString() + " from " + intent.ingressPoints().toString());
            }
        }
        out.println("");
        out.println("Reactive Routing Intercept Flow Rules:\n");
        List<FlowRule> rules = new ArrayList(interceptFlowRules);
        Collections.sort(rules, new Comparator<FlowRule>() {

            @Override
            public int compare(FlowRule a, FlowRule b) {
                int r = a.deviceId().toString().compareTo(b.deviceId().toString());
                // descending on priority
                return (r != 0) ? r : Integer.compare(b.priority(), a.priority());
            }
        });
        for (FlowRule rule : rules) {
            out.println("    device=" + rule.deviceId().toString() + " priority=" + rule.priority() + " selector=" + rule.selector().criteria().toString());
        }
        out.println("");
        out.println("Reactive Routing Intents to Be Purged:\n");
        for (Key key : toBePurgedIntentKeys) {
            out.println("    " + key.toString());
        }
        out.println("");
    } else if ("reactive-intents".equals(subject)) {
        for (Intent entry : intentService.getIntents()) {
            if (reactiveAppId.equals(entry.appId())) {
                MultiPointToSinglePointIntent intent = (MultiPointToSinglePointIntent) entry;
                out.println(intent.key().toString() + " to " + intent.egressPoint().toString() + " set " + intent.treatment().immediate().toString() + " from " + intent.ingressPoints().toString());
            }
        }
    }
}
#end_block

#method_before
private void dump(String subject, PrintStream out) {
    if (subject == "intents") {
        out.println("L2Forward Broadcast Intents:\n");
        for (SinglePointToMultiPointIntent intent : bctIntentsMap.values()) {
            out.println("    " + intent.key().toString() + ": " + intent.selector().criteria() + ", [" + intent.filteredIngressPoint().connectPoint() + "] -> " + intent.filteredEgressPoints().stream().map(FilteredConnectPoint::connectPoint).collect(Collectors.toSet()));
        }
        out.println("");
        out.println("L2Forward Unicast Intents:\n");
        for (MultiPointToSinglePointIntent intent : uniIntentsMap.values()) {
            out.println("    " + intent.key().toString() + ": " + intent.selector().criteria() + ", [" + intent.filteredIngressPoints().stream().map(FilteredConnectPoint::connectPoint).collect(Collectors.toSet()) + "] -> " + intent.filteredEgressPoint().connectPoint());
        }
        out.println("");
        out.println("L2Forward Intents to Be Purged:\n");
        for (Key key : toBePurgedIntentKeys) {
            out.println("    " + key.toString());
        }
        out.println("");
    }
}
#method_after
private void dump(String subject, PrintStream out) {
    if ("intents".equals(subject)) {
        out.println("L2Forward Broadcast Intents:\n");
        for (SinglePointToMultiPointIntent intent : bctIntentsMap.values()) {
            out.println("    " + intent.key().toString() + ": " + intent.selector().criteria() + ", [" + intent.filteredIngressPoint().connectPoint() + "] -> " + intent.filteredEgressPoints().stream().map(FilteredConnectPoint::connectPoint).collect(Collectors.toSet()));
        }
        out.println("");
        out.println("L2Forward Unicast Intents:\n");
        for (MultiPointToSinglePointIntent intent : uniIntentsMap.values()) {
            out.println("    " + intent.key().toString() + ": " + intent.selector().criteria() + ", [" + intent.filteredIngressPoints().stream().map(FilteredConnectPoint::connectPoint).collect(Collectors.toSet()) + "] -> " + intent.filteredEgressPoint().connectPoint());
        }
        out.println("");
        out.println("L2Forward Intents to Be Purged:\n");
        for (Key key : toBePurgedIntentKeys) {
            out.println("    " + key.toString());
        }
        out.println("");
    }
}
#end_block

#method_before
protected void dump(String subject, PrintStream out) {
    if (subject == "show") {
        out.println("Static Configuration Flag:");
        out.println("    ALLOW_ETH_ADDRESS_SELECTOR=" + SimpleFabricService.ALLOW_ETH_ADDRESS_SELECTOR);
        out.println("    REACTIVE_SINGLE_TO_SINGLE=" + SimpleFabricService.REACTIVE_SINGLE_TO_SINGLE);
        out.println("    REACTIVE_ALLOW_LINK_CP=" + SimpleFabricService.REACTIVE_ALLOW_LINK_CP);
        out.println("    REACTIVE_HASHED_PATH_SELECTION=" + SimpleFabricService.REACTIVE_HASHED_PATH_SELECTION);
        out.println("    REACTIVE_MATCH_IP_PROTO=" + SimpleFabricService.REACTIVE_MATCH_IP_PROTO);
        out.println("");
        out.println("SimpleFabricAppId:");
        out.println("    " + getAppId());
        out.println("");
        out.println("l2Networks:");
        for (L2Network l2Network : getL2Networks()) {
            out.println("    " + l2Network);
        }
        out.println("");
        out.println("ipSubnets:");
        for (IpSubnet ipSubnet : getIpSubnets()) {
            out.println("    " + ipSubnet);
        }
        out.println("");
        out.println("borderRoutes:");
        for (Route route : getBorderRoutes()) {
            out.println("    " + route);
        }
    }
}
#method_after
protected void dump(String subject, PrintStream out) {
    if ("show".equals(subject)) {
        out.println("Static Configuration Flag:");
        out.println("    ALLOW_IPV6=" + SimpleFabricService.ALLOW_IPV6);
        out.println("    ALLOW_ETH_ADDRESS_SELECTOR=" + SimpleFabricService.ALLOW_ETH_ADDRESS_SELECTOR);
        out.println("    REACTIVE_SINGLE_TO_SINGLE=" + SimpleFabricService.REACTIVE_SINGLE_TO_SINGLE);
        out.println("    REACTIVE_ALLOW_LINK_CP=" + SimpleFabricService.REACTIVE_ALLOW_LINK_CP);
        out.println("    REACTIVE_HASHED_PATH_SELECTION=" + SimpleFabricService.REACTIVE_HASHED_PATH_SELECTION);
        out.println("    REACTIVE_MATCH_IP_PROTO=" + SimpleFabricService.REACTIVE_MATCH_IP_PROTO);
        out.println("");
        out.println("SimpleFabricAppId:");
        out.println("    " + getAppId());
        out.println("");
        out.println("l2Networks:");
        for (L2Network l2Network : getL2Networks()) {
            out.println("    " + l2Network);
        }
        out.println("");
        out.println("ipSubnets:");
        for (IpSubnet ipSubnet : getIpSubnets()) {
            out.println("    " + ipSubnet);
        }
        out.println("");
        out.println("borderRoutes:");
        for (Route route : getBorderRoutes()) {
            out.println("    " + route);
        }
    }
}
#end_block

#method_before
private static String lambdaToAnnotationHz(long lambda) {
    // annotations is in Hz
    return Long.toString(lambda == 0 ? lambda : (c * 1_000_000_000 / lambda * 100));
}
#method_after
private static String lambdaToAnnotationHz(long lambda) {
    // annotations is in Hz
    return Long.toString(lambda == 0 ? lambda : (C * 1_000_000_000 / lambda * 100));
}
#end_block

#method_before
private static String mhzToAnnotationNm(long freqMhz) {
    // annotations is in nm
    return Long.toString(freqMhz == 0 ? freqMhz : (c * 1_000_000_000 / Frequency.ofMHz(freqMhz).asHz()));
}
#method_after
private static String mhzToAnnotationNm(long freqMhz) {
    // annotations is in nm
    return Long.toString(freqMhz == 0 ? freqMhz : (C * 1_000_000_000 / Frequency.ofMHz(freqMhz).asHz()));
}
#end_block

#method_before
private static String freqLmdaToAnnotation(long freqLmda) {
    if (useFreq) {
        if (propFreq) {
            mhzToAnnotation(freqLmda);
        } else {
            mhzToAnnotationNm(freqLmda);
        }
    } else if (propFreq) {
        lambdaToAnnotationHz(freqLmda);
    }
    return Double.toString(freqLmda / 100.0);
}
#method_after
private static String freqLmdaToAnnotation(long freqLmda, boolean useFreq) {
    if (useFreq) {
        if (propFreq) {
            mhzToAnnotation(freqLmda);
        } else {
            mhzToAnnotationNm(freqLmda);
        }
    } else if (propFreq) {
        lambdaToAnnotationHz(freqLmda);
    }
    return Double.toString(freqLmda / 100.0);
}
#end_block

#method_before
private Collection<PortStatistics> buildPortStatistics(DeviceId deviceId, List<OFPortStatsEntry> entries) {
    HashSet<PortStatistics> stats = Sets.newHashSet();
    for (OFPortStatsEntry entry : entries) {
        try {
            if (entry == null || entry.getPortNo() == null || entry.getPortNo().getPortNumber() < 0) {
                continue;
            }
            DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
            boolean propSupported = entry.getVersion().getWireVersion() >= OFVersion.OF_14.getWireVersion();
            Optional<OFPortStatsPropOptical> optical = propSupported ? entry.getProperties().stream().filter(OFPortStatsPropOptical.class::isInstance).map(OFPortStatsPropOptical.class::cast).findAny() : Optional.empty();
            if (optical.isPresent()) {
                long flags = optical.get().getFlags();
                int txTune = OFPortStatsOpticalFlagsSerializerVer14.TX_TUNE_VAL;
                long txFreq = optical.get().getTxFreqLmda();
                long txOffset = optical.get().getTxOffset();
                long txGridSpan = optical.get().getTxGridSpan();
                annotations.set(AK_TX_TUNE_FEATURE, ((flags & txTune) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TX_FREQ_HZ, freqLmdaToAnnotation(txFreq));
                annotations.set(AK_TX_OFFSET_HZ, freqLmdaToAnnotation(txOffset));
                annotations.set(AK_TX_GRID_SPAN_HZ, freqLmdaToAnnotation(txGridSpan));
                int rxTune = OFPortStatsOpticalFlagsSerializerVer14.RX_TUNE_VAL;
                long rxFreq = optical.get().getRxFreqLmda();
                long rxOffset = optical.get().getRxOffset();
                long rxGridSpan = optical.get().getRxGridSpan();
                annotations.set(AK_RX_TUNE_FEATURE, ((flags & rxTune) != 0) ? "enabled" : "disabled");
                annotations.set(AK_RX_FREQ_HZ, freqLmdaToAnnotation(rxFreq));
                annotations.set(AK_RX_OFFSET_HZ, freqLmdaToAnnotation(rxOffset));
                annotations.set(AK_RX_GRID_SPAN_HZ, freqLmdaToAnnotation(rxGridSpan));
                int txPwrVal = OFPortStatsOpticalFlagsSerializerVer14.TX_PWR_VAL;
                int txPwr = optical.get().getTxPwr();
                annotations.set(AK_TX_PWR_FEATURE, ((flags & txPwrVal) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TX_PWR, Integer.toString(txPwr));
                int rxPwrVal = OFPortStatsOpticalFlagsSerializerVer14.RX_PWR_VAL;
                int rxPwr = optical.get().getRxPwr();
                annotations.set(AK_RX_PWR_FEATURE, ((flags & rxPwrVal) != 0) ? "enabled" : "disabled");
                annotations.set(AK_RX_PWR, Integer.toString(rxPwr));
                int txBias = OFPortStatsOpticalFlagsSerializerVer14.TX_BIAS_VAL;
                int biasCurrent = optical.get().getBiasCurrent();
                annotations.set(AK_TX_BIAS_FEATURE, ((flags & txBias) != 0) ? "enabled" : "disabled");
                annotations.set(AK_BIAS_CURRENT, Integer.toString(biasCurrent));
                int txTemp = OFPortStatsOpticalFlagsSerializerVer14.TX_TEMP_VAL;
                int temperature = optical.get().getTemperature();
                annotations.set(AK_TX_TEMP_FEATURE, ((flags & txTemp) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TEMPERATURE, Integer.toString(temperature));
            }
            DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();
            DefaultPortStatistics stat = builder.setDeviceId(deviceId).setPort(entry.getPortNo().getPortNumber()).setPacketsReceived(entry.getRxPackets().getValue()).setPacketsSent(entry.getTxPackets().getValue()).setBytesReceived(entry.getRxBytes().getValue()).setBytesSent(entry.getTxBytes().getValue()).setPacketsRxDropped(entry.getRxDropped().getValue()).setPacketsTxDropped(entry.getTxDropped().getValue()).setPacketsRxErrors(entry.getRxErrors().getValue()).setPacketsTxErrors(entry.getTxErrors().getValue()).setDurationSec(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationSec()).setDurationNano(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationNsec()).setAnnotations(annotations.build()).build();
            stats.add(stat);
        } catch (Exception e) {
            LOG.warn("Unable to process port stats", e);
        }
    }
    return Collections.unmodifiableSet(stats);
}
#method_after
private Collection<PortStatistics> buildPortStatistics(DeviceId deviceId, List<OFPortStatsEntry> entries) {
    HashSet<PortStatistics> stats = Sets.newHashSet();
    final Dpid dpid = dpid(deviceId.uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    for (OFPortStatsEntry entry : entries) {
        try {
            if (entry == null || entry.getPortNo() == null || entry.getPortNo().getPortNumber() < 0) {
                continue;
            }
            DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
            boolean propSupported = entry.getVersion().getWireVersion() >= OFVersion.OF_14.getWireVersion();
            Optional<OFPortStatsPropOptical> optical = propSupported ? entry.getProperties().stream().filter(OFPortStatsPropOptical.class::isInstance).map(OFPortStatsPropOptical.class::cast).findAny() : Optional.empty();
            if (optical.isPresent()) {
                long flags = optical.get().getFlags();
                boolean useFreq = false;
                for (OFPortDesc pd : sw.getPorts()) {
                    if (pd.getPortNo().equals(entry.getPortNo())) {
                        for (OFPortDescProp prop : pd.getProperties()) {
                            if (prop instanceof OFPortDescPropOptical) {
                                OFPortDescPropOptical oprop = (OFPortDescPropOptical) prop;
                                long supported = oprop.getSupported();
                                int useFreqVal = OFOpticalPortFeaturesSerializerVer14.USE_FREQ_VAL;
                                if ((supported & useFreqVal) != 0) {
                                    useFreq = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                int txTune = OFPortStatsOpticalFlagsSerializerVer14.TX_TUNE_VAL;
                long txFreq = optical.get().getTxFreqLmda();
                long txOffset = optical.get().getTxOffset();
                long txGridSpan = optical.get().getTxGridSpan();
                annotations.set(AK_TX_TUNE_FEATURE, ((flags & txTune) != 0) ? "enabled" : "disabled");
                annotations.set(propFreq ? AK_TX_FREQ_HZ : AK_TX_LMDA_NM, freqLmdaToAnnotation(txFreq, useFreq));
                annotations.set(propFreq ? AK_TX_OFFSET_HZ : AK_TX_OFFSET_LMDA_NM, freqLmdaToAnnotation(txOffset, useFreq));
                annotations.set(propFreq ? AK_TX_GRID_SPAN_HZ : AK_TX_GRID_SPAN_LMDA_NM, freqLmdaToAnnotation(txGridSpan, useFreq));
                int rxTune = OFPortStatsOpticalFlagsSerializerVer14.RX_TUNE_VAL;
                long rxFreq = optical.get().getRxFreqLmda();
                long rxOffset = optical.get().getRxOffset();
                long rxGridSpan = optical.get().getRxGridSpan();
                annotations.set(AK_RX_TUNE_FEATURE, ((flags & rxTune) != 0) ? "enabled" : "disabled");
                annotations.set(propFreq ? AK_RX_FREQ_HZ : AK_RX_LMDA_NM, freqLmdaToAnnotation(rxFreq, useFreq));
                annotations.set(propFreq ? AK_RX_OFFSET_HZ : AK_RX_OFFSET_LMDA_NM, freqLmdaToAnnotation(rxOffset, useFreq));
                annotations.set(propFreq ? AK_RX_GRID_SPAN_HZ : AK_RX_GRID_SPAN_LMDA_NM, freqLmdaToAnnotation(rxGridSpan, useFreq));
                int txPwrVal = OFPortStatsOpticalFlagsSerializerVer14.TX_PWR_VAL;
                int txPwr = optical.get().getTxPwr();
                annotations.set(AK_TX_PWR_FEATURE, ((flags & txPwrVal) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TX_PWR, Integer.toString(txPwr));
                int rxPwrVal = OFPortStatsOpticalFlagsSerializerVer14.RX_PWR_VAL;
                int rxPwr = optical.get().getRxPwr();
                annotations.set(AK_RX_PWR_FEATURE, ((flags & rxPwrVal) != 0) ? "enabled" : "disabled");
                annotations.set(AK_RX_PWR, Integer.toString(rxPwr));
                int txBias = OFPortStatsOpticalFlagsSerializerVer14.TX_BIAS_VAL;
                int biasCurrent = optical.get().getBiasCurrent();
                annotations.set(AK_TX_BIAS_FEATURE, ((flags & txBias) != 0) ? "enabled" : "disabled");
                annotations.set(AK_BIAS_CURRENT, Integer.toString(biasCurrent));
                int txTemp = OFPortStatsOpticalFlagsSerializerVer14.TX_TEMP_VAL;
                int temperature = optical.get().getTemperature();
                annotations.set(AK_TX_TEMP_FEATURE, ((flags & txTemp) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TEMPERATURE, Integer.toString(temperature));
            }
            DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();
            DefaultPortStatistics stat = builder.setDeviceId(deviceId).setPort(entry.getPortNo().getPortNumber()).setPacketsReceived(entry.getRxPackets().getValue()).setPacketsSent(entry.getTxPackets().getValue()).setBytesReceived(entry.getRxBytes().getValue()).setBytesSent(entry.getTxBytes().getValue()).setPacketsRxDropped(entry.getRxDropped().getValue()).setPacketsTxDropped(entry.getTxDropped().getValue()).setPacketsRxErrors(entry.getRxErrors().getValue()).setPacketsTxErrors(entry.getTxErrors().getValue()).setDurationSec(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationSec()).setDurationNano(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationNsec()).setAnnotations(annotations.build()).build();
            stats.add(stat);
        } catch (Exception e) {
            LOG.warn("Unable to process port stats", e);
        }
    }
    return Collections.unmodifiableSet(stats);
}
#end_block

#method_before
@Override
public void switchAdded(Dpid dpid) {
    if (providerService == null) {
        return;
    }
    DeviceId did = deviceId(uri(dpid));
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null) {
        LOG.error("Switch {} is not found", dpid);
        return;
    }
    ChassisId cId = new ChassisId(dpid.value());
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, sw.factory().getVersion().toString()).set(AnnotationKeys.CHANNEL_ID, sw.channelId()).set(AnnotationKeys.MANAGEMENT_ADDRESS, sw.channelId().split(":")[0]);
    // FIXME following ignores driver specified by name
    Driver driver = driverService.getDriver(sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription());
    // FIXME: The following breaks the STC tests and will require to be revisited.
    // if (driver != null) {
    // annotationsBuilder.set(AnnotationKeys.DRIVER, driver.name());
    // }
    SparseAnnotations annotations = annotationsBuilder.build();
    DeviceDescription description = new DefaultDeviceDescription(did.uri(), sw.deviceType(), sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription(), sw.serialNumber(), cId, annotations);
    providerService.deviceConnected(did, description);
    providerService.updatePorts(did, buildPortDescriptions(sw));
    PortStatsCollector psc = new PortStatsCollector(timer, sw, portStatsPollFrequency);
    stopCollectorIfNeeded(collectors.put(dpid, psc));
    psc.start();
    // figure out race condition for collectors.remove() and collectors.put()
    if (controller.getSwitch(dpid) == null) {
        switchRemoved(dpid);
    }
}
#method_after
@Override
public void switchAdded(Dpid dpid) {
    if (providerService == null) {
        return;
    }
    DeviceId did = deviceId(uri(dpid));
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null) {
        LOG.error("Switch {} is not found", dpid);
        return;
    }
    ChassisId cId = new ChassisId(dpid.value());
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, sw.factory().getVersion().toString()).set(AnnotationKeys.CHANNEL_ID, sw.channelId()).set(AnnotationKeys.MANAGEMENT_ADDRESS, sw.channelId().split(":")[0]);
    // FIXME following ignores driver specified by name
    Driver driver = driverService.getDriver(sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription());
    // FIXME: The following breaks the STC tests and will require to be revisited.
    // if (driver != null) {
    // annotationsBuilder.set(AnnotationKeys.DRIVER, driver.name());
    // }
    SparseAnnotations annotations = annotationsBuilder.build();
    DeviceDescription description = new DefaultDeviceDescription(did.uri(), sw.deviceType(), sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription(), sw.serialNumber(), cId, annotations);
    providerService.deviceConnected(did, description);
    providerService.updatePorts(did, buildPortDescriptions(sw));
    if (sw.features().getCapabilities().contains(OFCapabilities.PORT_STATS)) {
        PortStatsCollector psc = new PortStatsCollector(timer, sw, portStatsPollFrequency);
        stopCollectorIfNeeded(collectors.put(dpid, psc));
        psc.start();
    }
    // figure out race condition for collectors.remove() and collectors.put()
    if (controller.getSwitch(dpid) == null) {
        switchRemoved(dpid);
    }
}
#end_block

#method_before
private PortDescription buildPortDescription14(OFPortDesc port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    boolean adminDown = port.getConfig().contains(OFPortConfig.PORT_DOWN);
    Builder annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString(), adminDown);
    Optional<OFPortDescPropEthernet> ether = port.getProperties().stream().filter(OFPortDescPropEthernet.class::isInstance).map(OFPortDescPropEthernet.class::cast).findAny();
    if (ether.isPresent()) {
        // TODO parse other part of OFPortDescPropEthernet if necessary
        return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
    }
    Optional<OFPortDescPropOptical> optical = port.getProperties().stream().filter(OFPortDescPropOptical.class::isInstance).map(OFPortDescPropOptical.class::cast).findAny();
    if (optical.isPresent()) {
        // optical port
        // FIXME is there a OF version neutral way to access
        // OFOpticalPortFeaturesSerializerVer14
        long supported = optical.get().getSupported();
        long rxMin = optical.get().getRxMinFreqLmda();
        long rxMax = optical.get().getRxMaxFreqLmda();
        long rxGrid = optical.get().getRxGridFreqLmda();
        long txMin = optical.get().getTxMinFreqLmda();
        long txMax = optical.get().getTxMaxFreqLmda();
        long txGrid = optical.get().getTxGridFreqLmda();
        int txTune = OFOpticalPortFeaturesSerializerVer14.TX_TUNE_VAL;
        int rxTune = OFOpticalPortFeaturesSerializerVer14.RX_TUNE_VAL;
        annotations.set(AK_TX_TUNE_FEATURE, ((supported & txTune) != 0) ? "enabled" : "disabled");
        annotations.set(AK_RX_TUNE_FEATURE, ((supported & rxTune) != 0) ? "enabled" : "disabled");
        // wire value for OFOpticalPortFeatures.USE_FREQ
        useFreq = (supported & OFOpticalPortFeaturesSerializerVer14.USE_FREQ_VAL) != 0;
        annotations.set(AK_RX_MIN_FREQ_HZ, freqLmdaToAnnotation(rxMin));
        annotations.set(AK_RX_MAX_FREQ_HZ, freqLmdaToAnnotation(rxMax));
        annotations.set(AK_RX_GRID_HZ, freqLmdaToAnnotation(rxGrid));
        annotations.set(AK_TX_MIN_FREQ_HZ, freqLmdaToAnnotation(txMin));
        annotations.set(AK_TX_MAX_FREQ_HZ, freqLmdaToAnnotation(txMax));
        annotations.set(AK_TX_GRID_HZ, freqLmdaToAnnotation(txGrid));
        // unless Device models Tx/Rx ports as separate port
        if (rxMin == txMin) {
            annotations.set(AK_MIN_FREQ_HZ, freqLmdaToAnnotation(rxMin));
        }
        if (rxMax == txMax) {
            annotations.set(AK_MAX_FREQ_HZ, freqLmdaToAnnotation(rxMax));
        }
        if (rxGrid == txGrid) {
            annotations.set(AK_GRID_HZ, freqLmdaToAnnotation(rxGrid));
        }
        int txPwr = OFOpticalPortFeaturesSerializerVer14.TX_PWR_VAL;
        long txPwrMin = optical.get().getTxPwrMin();
        long txPwrMax = optical.get().getTxPwrMax();
        annotations.set(AK_TX_PWR_FEATURE, ((supported & txPwr) != 0) ? "enabled" : "disabled");
        annotations.set(AK_TX_PWR_MIN, Long.toString(txPwrMin));
        annotations.set(AK_TX_PWR_MAX, Long.toString(txPwrMax));
        return new DefaultPortDescription(portNo, enabled, FIBER, portSpeed(port), annotations.build());
    }
    // fall back default
    return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
}
#method_after
private PortDescription buildPortDescription14(OFPortDesc port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    boolean adminDown = port.getConfig().contains(OFPortConfig.PORT_DOWN);
    Builder annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString(), adminDown);
    Optional<OFPortDescPropEthernet> ether = port.getProperties().stream().filter(OFPortDescPropEthernet.class::isInstance).map(OFPortDescPropEthernet.class::cast).findAny();
    if (ether.isPresent()) {
        // TODO parse other part of OFPortDescPropEthernet if necessary
        return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
    }
    Optional<OFPortDescPropOptical> optical = port.getProperties().stream().filter(OFPortDescPropOptical.class::isInstance).map(OFPortDescPropOptical.class::cast).findAny();
    if (optical.isPresent()) {
        // optical port
        // FIXME is there a OF version neutral way to access
        // OFOpticalPortFeaturesSerializerVer14
        long supported = optical.get().getSupported();
        long rxMin = optical.get().getRxMinFreqLmda();
        long rxMax = optical.get().getRxMaxFreqLmda();
        long rxGrid = optical.get().getRxGridFreqLmda();
        long txMin = optical.get().getTxMinFreqLmda();
        long txMax = optical.get().getTxMaxFreqLmda();
        long txGrid = optical.get().getTxGridFreqLmda();
        int txTune = OFOpticalPortFeaturesSerializerVer14.TX_TUNE_VAL;
        int rxTune = OFOpticalPortFeaturesSerializerVer14.RX_TUNE_VAL;
        annotations.set(AK_TX_TUNE_FEATURE, ((supported & txTune) != 0) ? "enabled" : "disabled");
        annotations.set(AK_RX_TUNE_FEATURE, ((supported & rxTune) != 0) ? "enabled" : "disabled");
        // wire value for OFOpticalPortFeatures.USE_FREQ
        boolean useFreq = (supported & OFOpticalPortFeaturesSerializerVer14.USE_FREQ_VAL) != 0;
        annotations.set(AK_USE_FREQ_FEATURE, useFreq ? "enabled" : "disabled");
        annotations.set(propFreq ? AK_RX_MIN_FREQ_HZ : AK_RX_MIN_LMDA_NM, freqLmdaToAnnotation(rxMin, useFreq));
        annotations.set(propFreq ? AK_RX_MAX_FREQ_HZ : AK_RX_MAX_LMDA_NM, freqLmdaToAnnotation(rxMax, useFreq));
        annotations.set(propFreq ? AK_RX_GRID_HZ : AK_RX_GRID_LMDA_NM, freqLmdaToAnnotation(rxGrid, useFreq));
        annotations.set(propFreq ? AK_TX_MIN_FREQ_HZ : AK_TX_MIN_LMDA_NM, freqLmdaToAnnotation(txMin, useFreq));
        annotations.set(propFreq ? AK_TX_MAX_FREQ_HZ : AK_TX_MAX_LMDA_NM, freqLmdaToAnnotation(txMax, useFreq));
        annotations.set(propFreq ? AK_TX_GRID_HZ : AK_TX_GRID_LMDA_NM, freqLmdaToAnnotation(txGrid, useFreq));
        // unless Device models Tx/Rx ports as separate port
        if (rxMin == txMin) {
            annotations.set(propFreq ? AK_MIN_FREQ_HZ : AK_MIN_LMDA_NM, freqLmdaToAnnotation(rxMin, useFreq));
        }
        if (rxMax == txMax) {
            annotations.set(propFreq ? AK_MAX_FREQ_HZ : AK_MAX_LMDA_NM, freqLmdaToAnnotation(rxMax, useFreq));
        }
        if (rxGrid == txGrid) {
            annotations.set(propFreq ? AK_GRID_HZ : AK_GRID_LMDA_NM, freqLmdaToAnnotation(rxGrid, useFreq));
        }
        int txPwr = OFOpticalPortFeaturesSerializerVer14.TX_PWR_VAL;
        long txPwrMin = optical.get().getTxPwrMin();
        long txPwrMax = optical.get().getTxPwrMax();
        annotations.set(AK_TX_PWR_FEATURE, ((supported & txPwr) != 0) ? "enabled" : "disabled");
        annotations.set(AK_TX_PWR_MIN, Long.toString(txPwrMin));
        annotations.set(AK_TX_PWR_MAX, Long.toString(txPwrMax));
        return new DefaultPortDescription(portNo, enabled, FIBER, portSpeed(port), annotations.build());
    }
    // fall back default
    return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
}
#end_block

#method_before
@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof RIPngEntry)) {
        return false;
    }
    final RIPngEntry that = (RIPngEntry) obj;
    return super.equals(that) && Objects.equals(metric, metric) && Objects.equals(routeTag, that.routeTag) && Objects.equals(prefixLen, that.prefixLen) && Arrays.equals(prefix, that.prefix) && Objects.equals(routeTag, that.routeTag);
}
#method_after
@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof RIPngEntry)) {
        return false;
    }
    final RIPngEntry that = (RIPngEntry) obj;
    return super.equals(that) && Objects.equals(metric, that.metric) && Objects.equals(routeTag, that.routeTag) && Objects.equals(prefixLen, that.prefixLen) && Arrays.equals(prefix, that.prefix) && Objects.equals(routeTag, that.routeTag);
}
#end_block

#method_before
@Override
public String toString() {
    return "RIPngEntry [prefix=" + this.prefix + ", route tag=" + this.routeTag + ", prefix length=" + this.prefixLen + ", metric = " + this.metric + "]";
}
#method_after
@Override
public String toString() {
    return "RIPngEntry [prefix=" + Arrays.toString(this.prefix) + ", route tag=" + this.routeTag + ", prefix length=" + this.prefixLen + ", metric = " + this.metric + "]";
}
#end_block

#method_before
private void fpmMessage(FpmPeer peer, FpmHeader fpmMessage) {
    if (fpmMessage.type() == FpmHeader.FPM_TYPE_KEEPALIVE) {
        return;
    }
    Netlink netlink = fpmMessage.netlink();
    RtNetlink rtNetlink = netlink.rtNetlink();
    if (log.isTraceEnabled()) {
        log.trace("Received FPM message: {}", fpmMessage);
    }
    if (!(rtNetlink.protocol() == RtProtocol.ZEBRA || rtNetlink.protocol() == RtProtocol.UNSPEC)) {
        log.trace("Ignoring non-zebra route");
        return;
    }
    IpAddress dstAddress = null;
    IpAddress gateway = null;
    for (RouteAttribute attribute : rtNetlink.attributes()) {
        if (attribute.type() == RouteAttribute.RTA_DST) {
            RouteAttributeDst raDst = (RouteAttributeDst) attribute;
            dstAddress = raDst.dstAddress();
        } else if (attribute.type() == RouteAttribute.RTA_GATEWAY) {
            RouteAttributeGateway raGateway = (RouteAttributeGateway) attribute;
            gateway = raGateway.gateway();
        }
    }
    if (dstAddress == null) {
        log.error("Dst address missing!");
        return;
    }
    IpPrefix prefix = IpPrefix.valueOf(dstAddress, rtNetlink.dstLength());
    // Ignore routes that we sent.
    if ((prefix.isIp4() && (gateway.equals(pdPushNextHopIPv4))) || (prefix.isIp6() && (gateway.equals(pdPushNextHopIPv6)))) {
        if (routeInDhcpStore(prefix) || routeInRipStore(prefix)) {
            return;
        }
    }
    List<Route> updates = new LinkedList<>();
    List<Route> withdraws = new LinkedList<>();
    Route route;
    switch(netlink.type()) {
        case RTM_NEWROUTE:
            if (gateway == null) {
                // We ignore interface routes with no gateway for now.
                return;
            }
            route = new Route(Route.Source.FPM, prefix, gateway, clusterService.getLocalNode().id());
            Route oldRoute = fpmRoutes.get(peer).put(prefix, route);
            if (oldRoute != null) {
                log.trace("Swapping {} with {}", oldRoute, route);
                withdraws.add(oldRoute);
            }
            updates.add(route);
            break;
        case RTM_DELROUTE:
            Route existing = fpmRoutes.get(peer).remove(prefix);
            if (existing == null) {
                log.warn("Got delete for non-existent prefix");
                return;
            }
            route = new Route(Route.Source.FPM, prefix, existing.nextHop(), clusterService.getLocalNode().id());
            withdraws.add(route);
            break;
        case RTM_GETROUTE:
        default:
            break;
    }
    routeService.withdraw(withdraws);
    routeService.update(updates);
}
#method_after
private void fpmMessage(FpmPeer peer, FpmHeader fpmMessage) {
    if (fpmMessage.type() == FpmHeader.FPM_TYPE_KEEPALIVE) {
        return;
    }
    Netlink netlink = fpmMessage.netlink();
    RtNetlink rtNetlink = netlink.rtNetlink();
    if (log.isTraceEnabled()) {
        log.trace("Received FPM message: {}", fpmMessage);
    }
    if (!(rtNetlink.protocol() == RtProtocol.ZEBRA || rtNetlink.protocol() == RtProtocol.UNSPEC)) {
        log.trace("Ignoring non-zebra route");
        return;
    }
    IpAddress dstAddress = null;
    IpAddress gateway = null;
    for (RouteAttribute attribute : rtNetlink.attributes()) {
        if (attribute.type() == RouteAttribute.RTA_DST) {
            RouteAttributeDst raDst = (RouteAttributeDst) attribute;
            dstAddress = raDst.dstAddress();
        } else if (attribute.type() == RouteAttribute.RTA_GATEWAY) {
            RouteAttributeGateway raGateway = (RouteAttributeGateway) attribute;
            gateway = raGateway.gateway();
        }
    }
    if (dstAddress == null) {
        log.error("Dst address missing!");
        return;
    }
    IpPrefix prefix = IpPrefix.valueOf(dstAddress, rtNetlink.dstLength());
    // Ignore routes that we sent.
    if ((prefix.isIp4() && (gateway.equals(pdPushNextHopIPv4))) || gateway.equals(pdPushNextHopIPv6)) {
        if (routeInDhcpStore(prefix) || routeInRipStore(prefix)) {
            return;
        }
    }
    List<Route> updates = new LinkedList<>();
    List<Route> withdraws = new LinkedList<>();
    Route route;
    switch(netlink.type()) {
        case RTM_NEWROUTE:
            if (gateway == null) {
                // We ignore interface routes with no gateway for now.
                return;
            }
            route = new Route(Route.Source.FPM, prefix, gateway, clusterService.getLocalNode().id());
            Route oldRoute = fpmRoutes.get(peer).put(prefix, route);
            if (oldRoute != null) {
                log.trace("Swapping {} with {}", oldRoute, route);
                withdraws.add(oldRoute);
            }
            updates.add(route);
            break;
        case RTM_DELROUTE:
            Route existing = fpmRoutes.get(peer).remove(prefix);
            if (existing == null) {
                log.warn("Got delete for non-existent prefix");
                return;
            }
            route = new Route(Route.Source.FPM, prefix, existing.nextHop(), clusterService.getLocalNode().id());
            withdraws.add(route);
            break;
        case RTM_GETROUTE:
        default:
            break;
    }
    routeService.withdraw(withdraws);
    routeService.update(updates);
}
#end_block

#method_before
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. Abort packet processing dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgTypeVal = dhcp6Payload.getMsgType();
    MsgType msgType = DHCP6.MsgType.getType(msgTypeVal);
    log.warn("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incomming ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (MSG_TYPE_FROM_CLIENT.contains(msgTypeVal)) {
        List<InternalPacket> ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        for (InternalPacket internalPacket : ethernetClientPacket) {
            forwardPacket(internalPacket);
        }
    } else if (MSG_TYPE_FROM_SERVER.contains(msgTypeVal)) {
        log.warn("calling processDhcp6PacketFromServer with RELAY_REPL {}", msgTypeVal);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgTypeVal);
    }
}
#method_after
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. Abort packet processing dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgTypeVal = dhcp6Payload.getMsgType();
    MsgType msgType = DHCP6.MsgType.getType(msgTypeVal);
    log.debug("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incomming ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (MSG_TYPE_FROM_CLIENT.contains(msgTypeVal)) {
        List<InternalPacket> ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        for (InternalPacket internalPacket : ethernetClientPacket) {
            forwardPacket(internalPacket);
        }
    } else if (MSG_TYPE_FROM_SERVER.contains(msgTypeVal)) {
        log.debug("calling processDhcp6PacketFromServer with RELAY_REPL {}", msgTypeVal);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgTypeVal);
    }
}
#end_block

#method_before
private IpAddressInfo extractIpAddress(DHCP6 dhcp6) {
    IpAddressInfo ipInfo = new IpAddressInfo();
    log.debug("extractIpAddress  enters dhcp6 {}.", dhcp6);
    // Extract IPv6 address from IA NA ot IA TA option
    Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
    Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
    Optional<Dhcp6IaAddressOption> iaAddressOption;
    if (iaNaOption.isPresent()) {
        log.debug("Found IPv6 address from iaNaOption {}", iaNaOption);
        iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else if (iaTaOption.isPresent()) {
        log.debug("Found IPv6 address from iaTaOption {}", iaTaOption);
        iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else {
        log.warn("No IPv6 address found from iaTaOption {}", iaTaOption);
        iaAddressOption = Optional.empty();
    }
    if (iaAddressOption.isPresent()) {
        ipInfo.ip6Address = iaAddressOption.get().getIp6Address();
        ipInfo.prefTime = iaAddressOption.get().getPreferredLifetime();
        log.debug("Found IPv6 address from iaAddressOption {}", iaAddressOption);
    } else {
        log.debug("Can't find IPv6 address from DHCPv6 {}", dhcp6);
        return null;
    }
    return ipInfo;
}
#method_after
private IpAddressInfo extractIpAddress(DHCP6 dhcp6) {
    IpAddressInfo ipInfo = new IpAddressInfo();
    log.debug("extractIpAddress  enters dhcp6 {}.", dhcp6);
    // Extract IPv6 address from IA NA ot IA TA option
    Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
    Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
    Optional<Dhcp6IaAddressOption> iaAddressOption;
    if (iaNaOption.isPresent()) {
        log.debug("Found IPv6 address from iaNaOption {}", iaNaOption);
        iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else if (iaTaOption.isPresent()) {
        log.debug("Found IPv6 address from iaTaOption {}", iaTaOption);
        iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else {
        log.info("No IPv6 address found from iaTaOption {}", iaTaOption);
        iaAddressOption = Optional.empty();
    }
    if (iaAddressOption.isPresent()) {
        ipInfo.ip6Address = iaAddressOption.get().getIp6Address();
        ipInfo.prefTime = iaAddressOption.get().getPreferredLifetime();
        log.debug("Found IPv6 address from iaAddressOption {}", iaAddressOption);
    } else {
        log.debug("Can't find IPv6 address from DHCPv6 {}", dhcp6);
        return null;
    }
    return ipInfo;
}
#end_block

#method_before
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    Byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    } else {
        record = record.clone();
    }
    Boolean isMsgRelease = dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host for directly connected.");
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    // return;
    }
    record.getV6Counters().incrementCounter(dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    if (!directConnFlag) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(srcMac);
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    dhcpRelayCountersStore.incrementCounter(gCount, dhcp6HandlerUtil.findMsgType(true, directConnFlag, dhcp6Packet));
}
#method_after
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    } else {
        record = record.clone();
    }
    Boolean isMsgRelease = dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    }
    record.getV6Counters().incrementCounter(dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    if (!directConnFlag) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(srcMac);
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.debug("ipAddress not found. Do not add Host for directly connected.");
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
            record.updateAddrPrefTime(ipInfo.prefTime);
            record.updateLastIp6Update();
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
            record.pdPrefix(pdInfo.pdPrefix);
            record.updatePdPrefTime(pdInfo.prefTime);
            record.updateLastPdUpdate();
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.getV6Counters().incrementCounter(dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    dhcpRelayCountersStore.incrementCounter(gCount, dhcp6HandlerUtil.findMsgType(false, directConnFlag, dhcp6Relay));
}
#method_after
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
            record.updateAddrPrefTime(ipInfo.prefTime);
            record.updateLastIp6Update();
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
            record.pdPrefix(pdInfo.pdPrefix);
            record.updatePdPrefTime(pdInfo.prefTime);
            record.updateLastPdUpdate();
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.getV6Counters().incrementCounter(dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
private List<InternalPacket> processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip6Address relayAgentIp = dhcp6HandlerUtil.getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
        return null;
    }
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherReply = dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, newServerInfo, serverInterface);
        removeHostOrRoute(directConnFlag, clientConnectionPoint, clientDhcp6, clientPacket, clientIpv6, clientInterface);
        InternalPacket internalPacket = new Dhcp6HandlerUtil().new InternalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.warn("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#method_after
private List<InternalPacket> processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip6Address relayAgentIp = dhcp6HandlerUtil.getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
        return null;
    }
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!dhcp6HandlerUtil.checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherReply = dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, newServerInfo, serverInterface);
        removeHostOrRoute(directConnFlag, clientConnectionPoint, clientDhcp6, clientPacket, clientIpv6, clientInterface);
        InternalPacket internalPacket = new Dhcp6HandlerUtil().new InternalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.debug("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#end_block

#method_before
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    setDhcpServerConfigs(configs, defaultServerInfoList);
}
#method_after
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    log.debug("setDefaultDhcpServerConfigs is called.");
    setDhcpServerConfigs(configs, defaultServerInfoList);
}
#end_block

#method_before
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    setDhcpServerConfigs(configs, indirectServerInfoList);
}
#method_after
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    log.debug("setIndirectDhcpServerConfigs is called.");
    setDhcpServerConfigs(configs, indirectServerInfoList);
}
#end_block

#method_before
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    log.warn("config size {}.", configs.size());
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    Boolean isConfigValid = false;
    for (DhcpServerConfig serverConfig : configs) {
        if (serverConfig.getDhcpServerIp6().isPresent()) {
            isConfigValid = true;
            break;
        }
    }
    if (!isConfigValid) {
        log.warn("No IP V6 server address found.");
        // No IP V6 address found
        return;
    }
    for (DhcpServerInfo oldServerInfo : serverInfoList) {
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp6().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp6().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    serverInfoList.clear();
    for (DhcpServerConfig serverConfig : configs) {
        // Create new server info according to the config
        DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V6);
        checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
        checkState(newServerInfo.getDhcpServerIp6().isPresent(), "IP of DHCP server not exists");
        log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp6().orElse(null));
        Ip6Address serverIp = newServerInfo.getDhcpServerIp6().get();
        Ip6Address ipToProbe;
        if (newServerInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = newServerInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = newServerInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = newServerInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            Host host = hosts.iterator().next();
            newServerInfo.setDhcpConnectVlan(host.vlan());
            newServerInfo.setDhcpConnectMac(host.mac());
            log.warn("Host found host {}", host);
        } else {
            log.warn("No host found host ip {}", ipToProbe);
        }
        // Add new server info
        synchronized (this) {
            serverInfoList.add(newServerInfo);
        }
        if (!hosts.isEmpty()) {
            requestDhcpPacket(serverIp);
        }
    }
}
#method_after
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    log.debug("config size {}.", configs.size());
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    Boolean isConfigValid = false;
    for (DhcpServerConfig serverConfig : configs) {
        if (serverConfig.getDhcpServerIp6().isPresent()) {
            isConfigValid = true;
            break;
        }
    }
    if (!isConfigValid) {
        log.warn("No IP V6 server address found.");
        // No IP V6 address found
        return;
    }
    for (DhcpServerInfo oldServerInfo : serverInfoList) {
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp6().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp6().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    serverInfoList.clear();
    for (DhcpServerConfig serverConfig : configs) {
        // Create new server info according to the config
        DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V6);
        checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
        checkState(newServerInfo.getDhcpServerIp6().isPresent(), "IP of DHCP server not exists");
        log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp6().orElse(null));
        Ip6Address serverIp = newServerInfo.getDhcpServerIp6().get();
        Ip6Address ipToProbe;
        if (newServerInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = newServerInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = newServerInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = newServerInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            Host host = hosts.iterator().next();
            newServerInfo.setDhcpConnectVlan(host.vlan());
            newServerInfo.setDhcpConnectMac(host.mac());
            log.warn("Host found host {}", host);
        } else {
            log.warn("No host found host ip {}", ipToProbe);
        }
        // Add new server info
        synchronized (this) {
            serverInfoList.add(newServerInfo);
        }
        if (!hosts.isEmpty()) {
            requestDhcpPacket(serverIp);
        }
    }
}
#end_block

#method_before
private DhcpServerInfo getHostInfoForServerInfo(DhcpServerInfo serverInfo, List<DhcpServerInfo> sererInfoList) {
    DhcpServerInfo newServerInfo = null;
    MacAddress dhcpServerConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
    VlanId dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    ConnectPoint dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
    if (dhcpServerConnectMac != null && dhcpConnectVlan != null) {
        newServerInfo = serverInfo;
        log.warn("DHCP server {} host info found. ConnectPt{}  Mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
    } else {
        log.warn("DHCP server {} not resolve yet connectPt {} mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
        Ip6Address ipToProbe;
        if (serverInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = serverInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = serverInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = serverInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Dynamically probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            int serverInfoIndex = sererInfoList.indexOf(serverInfo);
            Host host = hosts.iterator().next();
            serverInfo.setDhcpConnectVlan(host.vlan());
            serverInfo.setDhcpConnectMac(host.mac());
            // replace the serverInfo in the list
            sererInfoList.set(serverInfoIndex, serverInfo);
            newServerInfo = serverInfo;
            log.warn("Dynamically host found host {}", host);
        } else {
            log.warn("No host found host ip {} dynamically", ipToProbe);
        }
    }
    return newServerInfo;
}
#method_after
private DhcpServerInfo getHostInfoForServerInfo(DhcpServerInfo serverInfo, List<DhcpServerInfo> sererInfoList) {
    DhcpServerInfo newServerInfo = null;
    MacAddress dhcpServerConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
    VlanId dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    ConnectPoint dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
    if (dhcpServerConnectMac != null && dhcpConnectVlan != null) {
        newServerInfo = serverInfo;
        log.info("DHCP server {} host info found. ConnectPt{}  Mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
    } else {
        log.warn("DHCP server {} not resolve yet connectPt {} mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
        Ip6Address ipToProbe;
        if (serverInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = serverInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = serverInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = serverInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.info("Dynamically probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            int serverInfoIndex = sererInfoList.indexOf(serverInfo);
            Host host = hosts.iterator().next();
            serverInfo.setDhcpConnectVlan(host.vlan());
            serverInfo.setDhcpConnectMac(host.mac());
            // replace the serverInfo in the list
            sererInfoList.set(serverInfoIndex, serverInfo);
            newServerInfo = serverInfo;
            log.warn("Dynamically host found host {}", host);
        } else {
            log.warn("No host found host ip {} dynamically", ipToProbe);
        }
    }
    return newServerInfo;
}
#end_block

#method_before
public int getDhcp6PollInterval() {
    return dhcp6PollInterval;
}
#method_after
private int getDhcp6PollInterval() {
    return dhcp6PollInterval;
}
#end_block

#method_before
@Override
protected void execute() {
    List<DhcpServerInfo> defaultDhcpServerInfoList = DHCP_RELAY_SERVICE.getDefaultDhcpServerInfoList();
    List<DhcpServerInfo> indirectDhcpServerInfoList = DHCP_RELAY_SERVICE.getIndirectDhcpServerInfoList();
    if (defaultDhcpServerInfoList.isEmpty() && indirectDhcpServerInfoList.isEmpty()) {
        print(MISSING_SERVER_CFG);
        return;
    }
    if (!defaultDhcpServerInfoList.isEmpty()) {
        print(DEFAULT_SERVERS);
        listServers(defaultDhcpServerInfoList);
    }
    if (!indirectDhcpServerInfoList.isEmpty()) {
        print(INDIRECT_SERVERS);
        listServers(indirectDhcpServerInfoList);
    }
    // DHCP records
    Collection<DhcpRecord> records = DHCP_RELAY_SERVICE.getDhcpRecords();
    if (records.isEmpty()) {
        print(NO_RECORDS);
        return;
    }
    // Handle display of counters
    boolean toResetFlag;
    if (counter != null) {
        if (counter.equals("counter") || reset.equals("[counter]")) {
            print(CONUTER_HEADER);
        } else {
            print("first parameter is [counter]");
            return;
        }
        if (reset != null) {
            if (reset.equals("reset") || reset.equals("[reset]")) {
                toResetFlag = true;
            } else {
                print("Last parameter is [reset]");
                return;
            }
        } else {
            toResetFlag = false;
        }
        records.forEach(record -> {
            print(COUNTER_HOST, record.macAddress(), record.vlanId(), record.locations(), record.directlyConnected() ? DIRECTLY : EMPTY);
            DhcpRelayCounters v6Counters = record.getV6Counters();
            Map<String, Integer> countersMap = v6Counters.getCounters();
            countersMap.forEach((name, value) -> {
                print("%-30s  ............................  %-4d packets", name, value);
            });
            if (toResetFlag) {
                v6Counters.resetCounters();
            }
        });
        return;
    }
    // Handle display of records
    print(HEADER);
    records.forEach(record -> print(HOST, record.macAddress(), record.vlanId(), record.locations(), record.directlyConnected() ? DIRECTLY : EMPTY, Tools.timeAgo(record.lastSeen()), ip4State(record), ip6State(record)));
}
#method_after
@Override
protected void execute() {
    List<DhcpServerInfo> defaultDhcpServerInfoList = DHCP_RELAY_SERVICE.getDefaultDhcpServerInfoList();
    List<DhcpServerInfo> indirectDhcpServerInfoList = DHCP_RELAY_SERVICE.getIndirectDhcpServerInfoList();
    if (defaultDhcpServerInfoList.isEmpty() && indirectDhcpServerInfoList.isEmpty()) {
        print(MISSING_SERVER_CFG);
        return;
    }
    if (!defaultDhcpServerInfoList.isEmpty()) {
        print(DEFAULT_SERVERS);
        listServers(defaultDhcpServerInfoList);
    }
    if (!indirectDhcpServerInfoList.isEmpty()) {
        print(INDIRECT_SERVERS);
        listServers(indirectDhcpServerInfoList);
    }
    // DHCP records
    Collection<DhcpRecord> records = DHCP_RELAY_SERVICE.getDhcpRecords();
    if (records.isEmpty()) {
        print(NO_RECORDS);
        return;
    }
    // Handle display of counters
    boolean toResetFlag;
    if (counter != null) {
        if (counter.equals("counter") || reset.equals("[counter]")) {
            print(CONUTER_HEADER);
        } else {
            print("first parameter is [counter]");
            return;
        }
        if (reset != null) {
            if (reset.equals("reset") || reset.equals("[reset]")) {
                toResetFlag = true;
            } else {
                print("Last parameter is [reset]");
                return;
            }
        } else {
            toResetFlag = false;
        }
        records.forEach(record -> {
            print(COUNTER_HOST, record.macAddress(), record.vlanId(), record.locations(), record.directlyConnected() ? DIRECTLY : EMPTY);
            DhcpRelayCounters v6Counters = record.getV6Counters();
            Map<String, Integer> countersMap = v6Counters.getCounters();
            countersMap.forEach((name, value) -> {
                print("%-30s  ............................  %-4d packets", name, value);
            });
            if (toResetFlag) {
                v6Counters.resetCounters();
                record.updateLastSeen();
                DHCP_RELAY_SERVICE.updateDhcpRecord(HostId.hostId(record.macAddress(), record.vlanId()), record);
            }
        });
        return;
    }
    // Handle display of records
    print(HEADER);
    records.forEach(record -> print(HOST, record.macAddress(), record.vlanId(), record.locations(), record.directlyConnected() ? DIRECTLY : EMPTY, Tools.timeAgo(record.lastSeen()), ip4State(record), ip6State(record)));
}
#end_block

#method_before
public DhcpRelayCounters getV6Counters() {
    if (v6Counters == null) {
        v6Counters = new DhcpRelayCounters();
    }
    return v6Counters;
}
#method_after
public DhcpRelayCounters getV6Counters() {
    return v6Counters;
}
#end_block

#method_before
public DhcpRecord clone() {
    DhcpRecord newRecord = new DhcpRecord(HostId.hostId(macAddress, vlanId));
    locations.forEach(newRecord::addLocation);
    newRecord.directlyConnected = directlyConnected;
    newRecord.nextHop = nextHop;
    newRecord.nextHopTemp = nextHopTemp;
    newRecord.ip4Address = ip4Address;
    newRecord.ip4Status = ip4Status;
    newRecord.ip6Address = ip6Address;
    newRecord.pdPrefix = pdPrefix;
    newRecord.ip6Status = ip6Status;
    newRecord.lastSeen = lastSeen;
    newRecord.addrPrefTime = addrPrefTime;
    newRecord.pdPrefTime = pdPrefTime;
    newRecord.v6Counters = v6Counters;
    return newRecord;
}
#method_after
public DhcpRecord clone() {
    DhcpRecord newRecord = new DhcpRecord(HostId.hostId(macAddress, vlanId));
    locations.forEach(newRecord::addLocation);
    newRecord.directlyConnected = directlyConnected;
    newRecord.nextHop = nextHop;
    newRecord.nextHopTemp = nextHopTemp;
    newRecord.ip4Address = ip4Address;
    newRecord.ip4Status = ip4Status;
    newRecord.ip6Address = ip6Address;
    newRecord.pdPrefix = pdPrefix;
    newRecord.ip6Status = ip6Status;
    newRecord.lastSeen = lastSeen;
    newRecord.lastIp6Update = lastIp6Update;
    newRecord.lastPdUpdate = lastPdUpdate;
    newRecord.addrPrefTime = addrPrefTime;
    newRecord.pdPrefTime = pdPrefTime;
    newRecord.v6Counters = v6Counters;
    return newRecord;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(locations, macAddress, vlanId, ip4Address, ip4Status, nextHop, nextHopTemp, ip6Address, pdPrefix, ip6Status, lastSeen, addrPrefTime, pdPrefTime, v6Counters);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(locations, macAddress, vlanId, ip4Address, ip4Status, nextHop, nextHopTemp, ip6Address, pdPrefix, ip6Status, lastSeen, lastIp6Update, lastPdUpdate, addrPrefTime, pdPrefTime, v6Counters);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DhcpRecord)) {
        return false;
    }
    DhcpRecord that = (DhcpRecord) obj;
    return Objects.equals(locations, that.locations) && Objects.equals(macAddress, that.macAddress) && Objects.equals(vlanId, that.vlanId) && Objects.equals(ip4Address, that.ip4Address) && Objects.equals(ip4Status, that.ip4Status) && Objects.equals(nextHop, that.nextHop) && Objects.equals(nextHopTemp, that.nextHopTemp) && Objects.equals(ip6Address, that.ip6Address) && Objects.equals(pdPrefix, that.pdPrefix) && Objects.equals(ip6Status, that.ip6Status) && Objects.equals(lastSeen, that.lastSeen) && Objects.equals(directlyConnected, that.directlyConnected) && Objects.equals(addrPrefTime, that.addrPrefTime) && Objects.equals(pdPrefTime, that.pdPrefTime) && Objects.equals(v6Counters, that.v6Counters);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DhcpRecord)) {
        return false;
    }
    DhcpRecord that = (DhcpRecord) obj;
    return Objects.equals(locations, that.locations) && Objects.equals(macAddress, that.macAddress) && Objects.equals(vlanId, that.vlanId) && Objects.equals(ip4Address, that.ip4Address) && Objects.equals(ip4Status, that.ip4Status) && Objects.equals(nextHop, that.nextHop) && Objects.equals(nextHopTemp, that.nextHopTemp) && Objects.equals(ip6Address, that.ip6Address) && Objects.equals(pdPrefix, that.pdPrefix) && Objects.equals(ip6Status, that.ip6Status) && Objects.equals(lastSeen, that.lastSeen) && Objects.equals(lastIp6Update, that.lastIp6Update) && Objects.equals(lastPdUpdate, that.lastPdUpdate) && Objects.equals(directlyConnected, that.directlyConnected) && Objects.equals(addrPrefTime, that.addrPrefTime) && Objects.equals(pdPrefTime, that.pdPrefTime) && Objects.equals(v6Counters, that.v6Counters);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("locations", locations).add("macAddress", macAddress).add("vlanId", vlanId).add("ip4Address", ip4Address).add("ip4State", ip4Status).add("nextHop", nextHop).add("nextHopTemp", nextHopTemp).add("ip6Address", ip6Address).add("pdPrefix", pdPrefix).add("ip6State", ip6Status).add("lastSeen", lastSeen).add("directlyConnected", directlyConnected).add("addPrefTime", addrPrefTime).add("pdPrefTime", pdPrefTime).add("v6Counters", v6Counters).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("locations", locations).add("macAddress", macAddress).add("vlanId", vlanId).add("ip4Address", ip4Address).add("ip4State", ip4Status).add("nextHop", nextHop).add("nextHopTemp", nextHopTemp).add("ip6Address", ip6Address).add("pdPrefix", pdPrefix).add("ip6State", ip6Status).add("lastSeen", lastSeen).add("lastIp6Update", lastIp6Update).add("lastPdUpdate", lastPdUpdate).add("directlyConnected", directlyConnected).add("addPrefTime", addrPrefTime).add("pdPrefTime", pdPrefTime).add("v6Counters", v6Counters).toString();
}
#end_block

#method_before
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. Abort packet processing dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgTypeVal = dhcp6Payload.getMsgType();
    MsgType msgType = DHCP6.MsgType.getType(msgTypeVal);
    log.warn("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incomming ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (MSG_TYPE_FROM_CLIENT.contains(msgTypeVal)) {
        List<InternalPacket> ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        for (InternalPacket internalPacket : ethernetClientPacket) {
            forwardPacket(internalPacket);
        }
    } else if (MSG_TYPE_FROM_SERVER.contains(msgTypeVal)) {
        log.warn("calling processDhcp6PacketFromServer with RELAY_REPL {}", msgTypeVal);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgTypeVal);
    }
}
#method_after
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. Abort packet processing dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgTypeVal = dhcp6Payload.getMsgType();
    MsgType msgType = DHCP6.MsgType.getType(msgTypeVal);
    log.debug("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incomming ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (MSG_TYPE_FROM_CLIENT.contains(msgTypeVal)) {
        List<InternalPacket> ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        for (InternalPacket internalPacket : ethernetClientPacket) {
            forwardPacket(internalPacket);
        }
    } else if (MSG_TYPE_FROM_SERVER.contains(msgTypeVal)) {
        log.debug("calling processDhcp6PacketFromServer with RELAY_REPL {}", msgTypeVal);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgTypeVal);
    }
}
#end_block

#method_before
private IpAddressInfo extractIpAddress(DHCP6 dhcp6) {
    IpAddressInfo ipInfo = new IpAddressInfo();
    log.debug("extractIpAddress  enters dhcp6 {}.", dhcp6);
    // Extract IPv6 address from IA NA ot IA TA option
    Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
    Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
    Optional<Dhcp6IaAddressOption> iaAddressOption;
    if (iaNaOption.isPresent()) {
        log.debug("Found IPv6 address from iaNaOption {}", iaNaOption);
        iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else if (iaTaOption.isPresent()) {
        log.debug("Found IPv6 address from iaTaOption {}", iaTaOption);
        iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else {
        log.warn("No IPv6 address found from iaTaOption {}", iaTaOption);
        iaAddressOption = Optional.empty();
    }
    if (iaAddressOption.isPresent()) {
        ipInfo.ip6Address = iaAddressOption.get().getIp6Address();
        ipInfo.prefTime = iaAddressOption.get().getPreferredLifetime();
        log.debug("Found IPv6 address from iaAddressOption {}", iaAddressOption);
    } else {
        log.debug("Can't find IPv6 address from DHCPv6 {}", dhcp6);
        return null;
    }
    return ipInfo;
}
#method_after
private IpAddressInfo extractIpAddress(DHCP6 dhcp6) {
    IpAddressInfo ipInfo = new IpAddressInfo();
    log.debug("extractIpAddress  enters dhcp6 {}.", dhcp6);
    // Extract IPv6 address from IA NA ot IA TA option
    Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
    Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
    Optional<Dhcp6IaAddressOption> iaAddressOption;
    if (iaNaOption.isPresent()) {
        log.debug("Found IPv6 address from iaNaOption {}", iaNaOption);
        iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else if (iaTaOption.isPresent()) {
        log.debug("Found IPv6 address from iaTaOption {}", iaTaOption);
        iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else {
        log.info("No IPv6 address found from iaTaOption {}", iaTaOption);
        iaAddressOption = Optional.empty();
    }
    if (iaAddressOption.isPresent()) {
        ipInfo.ip6Address = iaAddressOption.get().getIp6Address();
        ipInfo.prefTime = iaAddressOption.get().getPreferredLifetime();
        log.debug("Found IPv6 address from iaAddressOption {}", iaAddressOption);
    } else {
        log.debug("Can't find IPv6 address from DHCPv6 {}", dhcp6);
        return null;
    }
    return ipInfo;
}
#end_block

#method_before
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    Byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    } else {
        record = record.clone();
    }
    Boolean isMsgRelease = dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host for directly connected.");
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    // return;
    }
    record.getV6Counters().incrementCounter(dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    if (!directConnFlag) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(srcMac);
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    dhcpRelayCountersStore.incrementCounter(gCount, dhcp6HandlerUtil.findMsgType(true, directConnFlag, dhcp6Packet));
}
#method_after
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    } else {
        record = record.clone();
    }
    Boolean isMsgRelease = dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    }
    record.getV6Counters().incrementCounter(dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    if (!directConnFlag) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(srcMac);
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.debug("ipAddress not found. Do not add Host for directly connected.");
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.getV6Counters().incrementCounter(dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    dhcpRelayCountersStore.incrementCounter(gCount, dhcp6HandlerUtil.findMsgType(false, directConnFlag, dhcp6Relay));
}
#method_after
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.getV6Counters().incrementCounter(dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
private List<InternalPacket> processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip6Address relayAgentIp = dhcp6HandlerUtil.getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
        return null;
    }
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherReply = dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, newServerInfo, serverInterface);
        removeHostOrRoute(directConnFlag, clientConnectionPoint, clientDhcp6, clientPacket, clientIpv6, clientInterface);
        InternalPacket internalPacket = new Dhcp6HandlerUtil().new InternalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.warn("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#method_after
private List<InternalPacket> processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip6Address relayAgentIp = dhcp6HandlerUtil.getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
        return null;
    }
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!dhcp6HandlerUtil.checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherReply = dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, newServerInfo, serverInterface);
        removeHostOrRoute(directConnFlag, clientConnectionPoint, clientDhcp6, clientPacket, clientIpv6, clientInterface);
        InternalPacket internalPacket = new Dhcp6HandlerUtil().new InternalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.debug("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#end_block

#method_before
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    setDhcpServerConfigs(configs, defaultServerInfoList);
}
#method_after
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    log.debug("setDefaultDhcpServerConfigs is called.");
    setDhcpServerConfigs(configs, defaultServerInfoList);
}
#end_block

#method_before
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    setDhcpServerConfigs(configs, indirectServerInfoList);
}
#method_after
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    log.debug("setIndirectDhcpServerConfigs is called.");
    setDhcpServerConfigs(configs, indirectServerInfoList);
}
#end_block

#method_before
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    log.warn("config size {}.", configs.size());
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    Boolean isConfigValid = false;
    for (DhcpServerConfig serverConfig : configs) {
        if (serverConfig.getDhcpServerIp6().isPresent()) {
            isConfigValid = true;
            break;
        }
    }
    if (!isConfigValid) {
        log.warn("No IP V6 server address found.");
        // No IP V6 address found
        return;
    }
    for (DhcpServerInfo oldServerInfo : serverInfoList) {
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp6().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp6().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    serverInfoList.clear();
    for (DhcpServerConfig serverConfig : configs) {
        // Create new server info according to the config
        DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V6);
        checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
        checkState(newServerInfo.getDhcpServerIp6().isPresent(), "IP of DHCP server not exists");
        log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp6().orElse(null));
        Ip6Address serverIp = newServerInfo.getDhcpServerIp6().get();
        Ip6Address ipToProbe;
        if (newServerInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = newServerInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = newServerInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = newServerInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            Host host = hosts.iterator().next();
            newServerInfo.setDhcpConnectVlan(host.vlan());
            newServerInfo.setDhcpConnectMac(host.mac());
            log.warn("Host found host {}", host);
        } else {
            log.warn("No host found host ip {}", ipToProbe);
        }
        // Add new server info
        synchronized (this) {
            serverInfoList.add(newServerInfo);
        }
        if (!hosts.isEmpty()) {
            requestDhcpPacket(serverIp);
        }
    }
}
#method_after
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    log.debug("config size {}.", configs.size());
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    Boolean isConfigValid = false;
    for (DhcpServerConfig serverConfig : configs) {
        if (serverConfig.getDhcpServerIp6().isPresent()) {
            isConfigValid = true;
            break;
        }
    }
    if (!isConfigValid) {
        log.warn("No IP V6 server address found.");
        // No IP V6 address found
        return;
    }
    for (DhcpServerInfo oldServerInfo : serverInfoList) {
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp6().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp6().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    serverInfoList.clear();
    for (DhcpServerConfig serverConfig : configs) {
        // Create new server info according to the config
        DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V6);
        checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
        checkState(newServerInfo.getDhcpServerIp6().isPresent(), "IP of DHCP server not exists");
        log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp6().orElse(null));
        Ip6Address serverIp = newServerInfo.getDhcpServerIp6().get();
        Ip6Address ipToProbe;
        if (newServerInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = newServerInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = newServerInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = newServerInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            Host host = hosts.iterator().next();
            newServerInfo.setDhcpConnectVlan(host.vlan());
            newServerInfo.setDhcpConnectMac(host.mac());
            log.warn("Host found host {}", host);
        } else {
            log.warn("No host found host ip {}", ipToProbe);
        }
        // Add new server info
        synchronized (this) {
            serverInfoList.add(newServerInfo);
        }
        if (!hosts.isEmpty()) {
            requestDhcpPacket(serverIp);
        }
    }
}
#end_block

#method_before
private DhcpServerInfo getHostInfoForServerInfo(DhcpServerInfo serverInfo, List<DhcpServerInfo> sererInfoList) {
    DhcpServerInfo newServerInfo = null;
    MacAddress dhcpServerConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
    VlanId dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    ConnectPoint dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
    if (dhcpServerConnectMac != null && dhcpConnectVlan != null) {
        newServerInfo = serverInfo;
        log.warn("DHCP server {} host info found. ConnectPt{}  Mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
    } else {
        log.warn("DHCP server {} not resolve yet connectPt {} mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
        Ip6Address ipToProbe;
        if (serverInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = serverInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = serverInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = serverInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Dynamically probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            int serverInfoIndex = sererInfoList.indexOf(serverInfo);
            Host host = hosts.iterator().next();
            serverInfo.setDhcpConnectVlan(host.vlan());
            serverInfo.setDhcpConnectMac(host.mac());
            // replace the serverInfo in the list
            sererInfoList.set(serverInfoIndex, serverInfo);
            newServerInfo = serverInfo;
            log.warn("Dynamically host found host {}", host);
        } else {
            log.warn("No host found host ip {} dynamically", ipToProbe);
        }
    }
    return newServerInfo;
}
#method_after
private DhcpServerInfo getHostInfoForServerInfo(DhcpServerInfo serverInfo, List<DhcpServerInfo> sererInfoList) {
    DhcpServerInfo newServerInfo = null;
    MacAddress dhcpServerConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
    VlanId dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    ConnectPoint dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
    if (dhcpServerConnectMac != null && dhcpConnectVlan != null) {
        newServerInfo = serverInfo;
        log.info("DHCP server {} host info found. ConnectPt{}  Mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
    } else {
        log.warn("DHCP server {} not resolve yet connectPt {} mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
        Ip6Address ipToProbe;
        if (serverInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = serverInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = serverInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = serverInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.info("Dynamically probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            int serverInfoIndex = sererInfoList.indexOf(serverInfo);
            Host host = hosts.iterator().next();
            serverInfo.setDhcpConnectVlan(host.vlan());
            serverInfo.setDhcpConnectMac(host.mac());
            // replace the serverInfo in the list
            sererInfoList.set(serverInfoIndex, serverInfo);
            newServerInfo = serverInfo;
            log.warn("Dynamically host found host {}", host);
        } else {
            log.warn("No host found host ip {} dynamically", ipToProbe);
        }
    }
    return newServerInfo;
}
#end_block

#method_before
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. Abort packet processing dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgTypeVal = dhcp6Payload.getMsgType();
    MsgType msgType = DHCP6.MsgType.getType(msgTypeVal);
    log.warn("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incomming ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (MSG_TYPE_FROM_CLIENT.contains(msgTypeVal)) {
        List<InternalPacket> ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        for (InternalPacket internalPacket : ethernetClientPacket) {
            forwardPacket(internalPacket);
        }
    } else if (MSG_TYPE_FROM_SERVER.contains(msgTypeVal)) {
        log.warn("calling processDhcp6PacketFromServer with RELAY_REPL {}", msgTypeVal);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgTypeVal);
    }
}
#method_after
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. Abort packet processing dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgTypeVal = dhcp6Payload.getMsgType();
    MsgType msgType = DHCP6.MsgType.getType(msgTypeVal);
    log.debug("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incomming ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (MSG_TYPE_FROM_CLIENT.contains(msgTypeVal)) {
        List<InternalPacket> ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        for (InternalPacket internalPacket : ethernetClientPacket) {
            forwardPacket(internalPacket);
        }
    } else if (MSG_TYPE_FROM_SERVER.contains(msgTypeVal)) {
        log.debug("calling processDhcp6PacketFromServer with RELAY_REPL {}", msgTypeVal);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgTypeVal);
    }
}
#end_block

#method_before
private IpAddressInfo extractIpAddress(DHCP6 dhcp6) {
    IpAddressInfo ipInfo = new IpAddressInfo();
    log.debug("extractIpAddress  enters dhcp6 {}.", dhcp6);
    // Extract IPv6 address from IA NA ot IA TA option
    Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
    Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
    Optional<Dhcp6IaAddressOption> iaAddressOption;
    if (iaNaOption.isPresent()) {
        log.debug("Found IPv6 address from iaNaOption {}", iaNaOption);
        iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else if (iaTaOption.isPresent()) {
        log.debug("Found IPv6 address from iaTaOption {}", iaTaOption);
        iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else {
        log.warn("No IPv6 address found from iaTaOption {}", iaTaOption);
        iaAddressOption = Optional.empty();
    }
    if (iaAddressOption.isPresent()) {
        ipInfo.ip6Address = iaAddressOption.get().getIp6Address();
        ipInfo.prefTime = iaAddressOption.get().getPreferredLifetime();
        log.debug("Found IPv6 address from iaAddressOption {}", iaAddressOption);
    } else {
        log.debug("Can't find IPv6 address from DHCPv6 {}", dhcp6);
        return null;
    }
    return ipInfo;
}
#method_after
private IpAddressInfo extractIpAddress(DHCP6 dhcp6) {
    IpAddressInfo ipInfo = new IpAddressInfo();
    log.debug("extractIpAddress  enters dhcp6 {}.", dhcp6);
    // Extract IPv6 address from IA NA ot IA TA option
    Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
    Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
    Optional<Dhcp6IaAddressOption> iaAddressOption;
    if (iaNaOption.isPresent()) {
        log.debug("Found IPv6 address from iaNaOption {}", iaNaOption);
        iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else if (iaTaOption.isPresent()) {
        log.debug("Found IPv6 address from iaTaOption {}", iaTaOption);
        iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else {
        log.info("No IPv6 address found from iaTaOption {}", iaTaOption);
        iaAddressOption = Optional.empty();
    }
    if (iaAddressOption.isPresent()) {
        ipInfo.ip6Address = iaAddressOption.get().getIp6Address();
        ipInfo.prefTime = iaAddressOption.get().getPreferredLifetime();
        log.debug("Found IPv6 address from iaAddressOption {}", iaAddressOption);
    } else {
        log.debug("Can't find IPv6 address from DHCPv6 {}", dhcp6);
        return null;
    }
    return ipInfo;
}
#end_block

#method_before
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    Byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    }
    Boolean isMsgRelease = dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host for directly connected.");
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    if (!directConnFlag) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(srcMac);
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
}
#method_after
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    }
    Boolean isMsgRelease = dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    if (!directConnFlag) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(srcMac);
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
}
#end_block

#method_before
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.debug("ipAddress not found. Do not add Host for directly connected.");
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
}
#method_after
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            return;
        }
        DHCP6 leafDhcp = dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
}
#end_block

#method_before
private List<InternalPacket> processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip6Address relayAgentIp = dhcp6HandlerUtil.getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherReply = dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, newServerInfo, serverInterface);
        removeHostOrRoute(directConnFlag, clientConnectionPoint, clientDhcp6, clientPacket, clientIpv6, clientInterface);
        InternalPacket internalPacket = new Dhcp6HandlerUtil().new InternalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.warn("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#method_after
private List<InternalPacket> processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip6Address relayAgentIp = dhcp6HandlerUtil.getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!dhcp6HandlerUtil.checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherReply = dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, newServerInfo, serverInterface);
        removeHostOrRoute(directConnFlag, clientConnectionPoint, clientDhcp6, clientPacket, clientIpv6, clientInterface);
        InternalPacket internalPacket = new Dhcp6HandlerUtil().new InternalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.debug("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#end_block

#method_before
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    log.warn("setDefaultDhcpServerConfigs is called.");
    setDhcpServerConfigs(configs, defaultServerInfoList);
}
#method_after
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    log.debug("setDefaultDhcpServerConfigs is called.");
    setDhcpServerConfigs(configs, defaultServerInfoList);
}
#end_block

#method_before
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    log.warn("setIndirectDhcpServerConfigs is called.");
    setDhcpServerConfigs(configs, indirectServerInfoList);
}
#method_after
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    log.debug("setIndirectDhcpServerConfigs is called.");
    setDhcpServerConfigs(configs, indirectServerInfoList);
}
#end_block

#method_before
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    log.warn("config size {}.", configs.size());
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    Boolean isConfigValid = false;
    for (DhcpServerConfig serverConfig : configs) {
        if (serverConfig.getDhcpServerIp6().isPresent()) {
            isConfigValid = true;
            break;
        }
    }
    if (!isConfigValid) {
        log.warn("No IP V6 server address found.");
        // No IP V6 address found
        return;
    }
    for (DhcpServerInfo oldServerInfo : serverInfoList) {
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp6().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp6().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    serverInfoList.clear();
    for (DhcpServerConfig serverConfig : configs) {
        // Create new server info according to the config
        DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V6);
        checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
        checkState(newServerInfo.getDhcpServerIp6().isPresent(), "IP of DHCP server not exists");
        log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp6().orElse(null));
        Ip6Address serverIp = newServerInfo.getDhcpServerIp6().get();
        Ip6Address ipToProbe;
        if (newServerInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = newServerInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = newServerInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = newServerInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            Host host = hosts.iterator().next();
            newServerInfo.setDhcpConnectVlan(host.vlan());
            newServerInfo.setDhcpConnectMac(host.mac());
            log.warn("Host found host {}", host);
        } else {
            log.warn("No host found host ip {}", ipToProbe);
        }
        // Add new server info
        synchronized (this) {
            serverInfoList.add(newServerInfo);
        }
        if (!hosts.isEmpty()) {
            requestDhcpPacket(serverIp);
        }
    }
}
#method_after
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    log.debug("config size {}.", configs.size());
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    Boolean isConfigValid = false;
    for (DhcpServerConfig serverConfig : configs) {
        if (serverConfig.getDhcpServerIp6().isPresent()) {
            isConfigValid = true;
            break;
        }
    }
    if (!isConfigValid) {
        log.warn("No IP V6 server address found.");
        // No IP V6 address found
        return;
    }
    for (DhcpServerInfo oldServerInfo : serverInfoList) {
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp6().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp6().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    serverInfoList.clear();
    for (DhcpServerConfig serverConfig : configs) {
        // Create new server info according to the config
        DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V6);
        checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
        checkState(newServerInfo.getDhcpServerIp6().isPresent(), "IP of DHCP server not exists");
        log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp6().orElse(null));
        Ip6Address serverIp = newServerInfo.getDhcpServerIp6().get();
        Ip6Address ipToProbe;
        if (newServerInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = newServerInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = newServerInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = newServerInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            Host host = hosts.iterator().next();
            newServerInfo.setDhcpConnectVlan(host.vlan());
            newServerInfo.setDhcpConnectMac(host.mac());
            log.warn("Host found host {}", host);
        } else {
            log.warn("No host found host ip {}", ipToProbe);
        }
        // Add new server info
        synchronized (this) {
            serverInfoList.add(newServerInfo);
        }
        if (!hosts.isEmpty()) {
            requestDhcpPacket(serverIp);
        }
    }
}
#end_block

#method_before
private DhcpServerInfo getHostInfoForServerInfo(DhcpServerInfo serverInfo, List<DhcpServerInfo> sererInfoList) {
    DhcpServerInfo newServerInfo = null;
    MacAddress dhcpServerConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
    VlanId dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    ConnectPoint dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
    if (dhcpServerConnectMac != null && dhcpConnectVlan != null) {
        newServerInfo = serverInfo;
        log.warn("DHCP server {} host info found. ConnectPt{}  Mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
    } else {
        log.warn("DHCP server {} not resolve yet connectPt {} mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
        Ip6Address ipToProbe;
        if (serverInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = serverInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = serverInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = serverInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.warn("Dynamically probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            int serverInfoIndex = sererInfoList.indexOf(serverInfo);
            Host host = hosts.iterator().next();
            serverInfo.setDhcpConnectVlan(host.vlan());
            serverInfo.setDhcpConnectMac(host.mac());
            // replace the serverInfo in the list
            sererInfoList.set(serverInfoIndex, serverInfo);
            newServerInfo = serverInfo;
            log.warn("Dynamically host found host {}", host);
        } else {
            log.warn("No host found host ip {} dynamically", ipToProbe);
        }
    }
    return newServerInfo;
}
#method_after
private DhcpServerInfo getHostInfoForServerInfo(DhcpServerInfo serverInfo, List<DhcpServerInfo> sererInfoList) {
    DhcpServerInfo newServerInfo = null;
    MacAddress dhcpServerConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
    VlanId dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    ConnectPoint dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
    if (dhcpServerConnectMac != null && dhcpConnectVlan != null) {
        newServerInfo = serverInfo;
        log.info("DHCP server {} host info found. ConnectPt{}  Mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
    } else {
        log.warn("DHCP server {} not resolve yet connectPt {} mac {} vlan {}", serverInfo.getDhcpServerIp6(), dhcpServerConnectPoint, dhcpServerConnectMac, dhcpConnectVlan);
        Ip6Address ipToProbe;
        if (serverInfo.getDhcpGatewayIp6().isPresent()) {
            ipToProbe = serverInfo.getDhcpGatewayIp6().get();
        } else {
            ipToProbe = serverInfo.getDhcpServerIp6().orElse(null);
        }
        String hostToProbe = serverInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
        log.info("Dynamically probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            int serverInfoIndex = sererInfoList.indexOf(serverInfo);
            Host host = hosts.iterator().next();
            serverInfo.setDhcpConnectVlan(host.vlan());
            serverInfo.setDhcpConnectMac(host.mac());
            // replace the serverInfo in the list
            sererInfoList.set(serverInfoIndex, serverInfo);
            newServerInfo = serverInfo;
            log.warn("Dynamically host found host {}", host);
        } else {
            log.warn("No host found host ip {} dynamically", ipToProbe);
        }
    }
    return newServerInfo;
}
#end_block

#method_before
private String findNextHopIp(Predicate<IpAddress> ipFilter, MacAddress nextHopMac, VlanId vlanId) {
    print("ipFilter=%s nextHopMac=%s vlanId=%s", ipFilter, nextHopMac, vlanId);
    if (ipFilter == null || nextHopMac == null || vlanId == null) {
        return NA;
    }
    Host host = HOST_SERVICE.getHost(HostId.hostId(nextHopMac, vlanId));
    if (host == null) {
        return NA;
    }
    return host.ipAddresses().stream().filter(ipFilter).filter(ip -> !ip.isLinkLocal()).map(Object::toString).findFirst().orElse(NA);
}
#method_after
private String findNextHopIp(Predicate<IpAddress> ipFilter, MacAddress nextHopMac, VlanId vlanId) {
    if (ipFilter == null || nextHopMac == null || vlanId == null) {
        return NA;
    }
    Host host = HOST_SERVICE.getHost(HostId.hostId(nextHopMac, vlanId));
    if (host == null) {
        return NA;
    }
    return host.ipAddresses().stream().filter(ipFilter).filter(ip -> !ip.isLinkLocal()).map(Object::toString).findFirst().orElse(NA);
}
#end_block

#method_before
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("extractPrefix  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress gwMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    Byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(gwMac.toBytes(), ":"), vlanId);
    // add host or route
    Boolean isMsgRelease = isDhcp6Release(dhcp6Packet);
    IpAddress ip;
    IpPrefix ipPrefix = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ip = extractIpAddress(dhcp6Packet);
        if (ip != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(gwMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                // Remove host's ip of  when dhcp release msg is received
                providerService.removeIpFromHost(hostId, ip);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host for directly connected.");
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(gwMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", gwMac, vlanId);
            return;
        }
        DHCP6 leafDhcp = getDhcp6Leaf(dhcp6Packet);
        ip = extractIpAddress(leafDhcp);
        if (ip == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ip.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        ipPrefix = extractPrefix(leafDhcp);
        if (ipPrefix == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(ipPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(ipPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        log.warn("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        return;
    }
    HostId hostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
    if (leafMsgType == DHCP6.MsgType.RELEASE.value()) {
        log.warn("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ip != null) {
                log.warn("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (ipPrefix != null) {
                log.warn("DhcpRelay Record pdPrefix is set to null.");
                record.pdPrefix(null);
            }
            log.warn("ip {} pd {}", record.ip6Address(), record.pdPrefix());
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
                dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
        return;
    }
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip6Status(DHCP6.MsgType.getType(dhcp6Packet.getMsgType()));
    record.setDirectlyConnected(directConnFlag);
    if (!directConnFlag) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(gwMac);
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(HostId.hostId(leafClientMac, vlanId), record);
}
#method_after
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("extractPrefix  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress gwMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(gwMac.toBytes(), ":"), vlanId);
    // add host or route
    boolean isMsgRelease = isDhcp6Release(dhcp6Packet);
    IpAddress ip;
    IpPrefix ipPrefix = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ip = extractIpAddress(dhcp6Packet);
        if (ip != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(gwMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                // Remove host's ip of  when dhcp release msg is received
                providerService.removeIpFromHost(hostId, ip);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host {} for directly connected.", HostId.hostId(gwMac, vlanId).toString());
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(gwMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", gwMac, vlanId);
            return;
        }
        DHCP6 leafDhcp = getDhcp6Leaf(dhcp6Packet);
        ip = extractIpAddress(leafDhcp);
        if (ip == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ip.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        ipPrefix = extractPrefix(leafDhcp);
        if (ipPrefix == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(ipPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(ipPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        log.warn("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        return;
    }
    HostId hostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
    if (leafMsgType == DHCP6.MsgType.RELEASE.value()) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ip != null) {
                log.warn("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (ipPrefix != null) {
                log.warn("DhcpRelay Record pdPrefix is set to null.");
                record.pdPrefix(null);
            }
            log.debug("ip {} pd {}", record.ip6Address(), record.pdPrefix());
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
                dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
        return;
    }
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip6Status(DHCP6.MsgType.getType(dhcp6Packet.getMsgType()));
    record.setDirectlyConnected(directConnFlag);
    if (!directConnFlag) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(gwMac);
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(HostId.hostId(leafClientMac, vlanId), record);
}
#end_block

#method_before
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress gwMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    // add host or route
    IpAddress ip;
    IpPrefix ipPrefix = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ip = extractIpAddress(embeddedDhcp6);
        if (ip != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ip);
                HostId hostId = HostId.hostId(gwMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(gwMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(gwMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host for directly connected.");
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(gwMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", gwMac, vlanId);
            return;
        }
        DHCP6 leafDhcp = getDhcp6Leaf(embeddedDhcp6);
        ip = extractIpAddress(leafDhcp);
        if (ip == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        ipPrefix = extractPrefix(leafDhcp);
        if (ipPrefix == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord record = new FpmRecord(ipPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(ipPrefix, record);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.warn("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        return;
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ip == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", DHCP6.MsgType.getType(leafMsgType));
        return;
    }
    HostId hostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ip != null) {
            log.warn("IP6 address is being stored into dhcp-relay store.");
            log.warn("IP6 address {}", HexString.toHexString(ip.toOctets(), ":"));
            record.ip6Address(ip.getIp6Address());
        } else {
            log.warn("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (ipPrefix != null) {
            log.warn("IP6 PD address is being stored into dhcp-relay store.");
            log.warn("IP6 PD address {}", HexString.toHexString(ipPrefix.address().toOctets(), ":"));
            record.pdPrefix(ipPrefix);
        } else {
            log.warn("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.ip6Status(DHCP6.MsgType.getType(dhcp6Relay.getMsgType()));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(HostId.hostId(leafClientMac, vlanId), record);
}
#method_after
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress gwMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    // add host or route
    IpAddress ip;
    IpPrefix ipPrefix = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ip = extractIpAddress(embeddedDhcp6);
        if (ip != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ip);
                HostId hostId = HostId.hostId(gwMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(gwMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(gwMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host {} for directly connected.", HostId.hostId(gwMac, vlanId).toString());
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(gwMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", gwMac, vlanId);
            return;
        }
        DHCP6 leafDhcp = getDhcp6Leaf(embeddedDhcp6);
        ip = extractIpAddress(leafDhcp);
        if (ip == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        ipPrefix = extractPrefix(leafDhcp);
        if (ipPrefix == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord record = new FpmRecord(ipPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(ipPrefix, record);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        return;
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ip == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", DHCP6.MsgType.getType(leafMsgType));
        return;
    }
    HostId hostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ip != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("IP6 address {}", HexString.toHexString(ip.toOctets(), ":"));
            record.ip6Address(ip.getIp6Address());
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (ipPrefix != null) {
            log.debug("IP6 PD address is being stored into dhcp-relay store.");
            log.debug("IP6 PD address {}", HexString.toHexString(ipPrefix.address().toOctets(), ":"));
            record.pdPrefix(ipPrefix);
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.ip6Status(DHCP6.MsgType.getType(dhcp6Relay.getMsgType()));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(HostId.hostId(leafClientMac, vlanId), record);
}
#end_block

#method_before
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    DhcpServerInfo serverInfo;
    Ip6Address dhcpServerIp = null;
    ConnectPoint dhcpServerConnectPoint = null;
    MacAddress dhcpConnectMac = null;
    VlanId dhcpConnectVlan = null;
    Ip6Address dhcpGatewayIp = null;
    Ip6Address indirectDhcpServerIp = null;
    ConnectPoint indirectDhcpServerConnectPoint = null;
    MacAddress indirectDhcpConnectMac = null;
    VlanId indirectDhcpConnectVlan = null;
    Ip6Address indirectDhcpGatewayIp = null;
    Ip6Address indirectRelayAgentIpFromCfg = null;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        indirectDhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        indirectRelayAgentIpFromCfg = serverInfo.getRelayAgentIp6(receivedFromDevice).orElse(null);
    }
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Interface serverInterface;
    if (directConnFlag) {
        serverInterface = getServerInterface();
    } else {
        serverInterface = getIndirectServerInterface();
        if (serverInterface == null) {
            // Indirect server interface not found, use default server interface
            serverInterface = getServerInterface();
        }
    }
    if (serverInterface == null) {
        log.warn("Can't get {} server interface, ignore", directConnFlag ? "direct" : "indirect");
        return null;
    }
    Ip6Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP v6 address for server Interface {}", serverInterface);
        return null;
    }
    Ethernet etherReply = clientPacket.duplicate();
    etherReply.setSourceMACAddress(macFacingServer);
    if ((directConnFlag && dhcpConnectMac == null) || !directConnFlag && indirectDhcpConnectMac == null && dhcpConnectMac == null) {
        log.trace("Packet received from {} connected client.", directConnFlag ? "directly" : "indirectly");
        log.debug("DHCP6 {} not yet resolved .. Aborting DHCP packet processing from client on port: {}", (dhcpGatewayIp == null) ? "server IP " + dhcpServerIp : "gateway IP " + dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point direct {} directConn {} indirectConn {} is not set up yet", directConnFlag, dhcpServerConnectPoint, indirectDhcpServerConnectPoint);
        return null;
    }
    etherReply.setDestinationMACAddress(dhcpConnectMac);
    etherReply.setVlanID(dhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(ipFacingServer.toOctets());
    ipv6Packet.setDestinationAddress(dhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    removeHostOrRoute(directConnFlag, clientConnectionPoint, dhcp6Packet, clientPacket, clientIpv6, clientInterface);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (indirectDhcpServerIp == null) {
            log.debug("indirect DhcpServerIp not available, use default DhcpServerIp {}", HexString.toHexString(dhcpServerIp.toOctets()));
        } else {
            // Check if mac is obtained for valid server ip
            if (indirectDhcpConnectMac == null) {
                log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (indirectDhcpGatewayIp == null) ? "server IP " + indirectDhcpServerIp : "gateway IP " + indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
                return null;
            }
            etherReply.setDestinationMACAddress(indirectDhcpConnectMac);
            etherReply.setVlanID(indirectDhcpConnectVlan.toShort());
            ipv6Packet.setDestinationAddress(indirectDhcpServerIp.toOctets());
        }
        if (indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.trace("indirect connection: relayAgentIp NOT availale from config file! Use dynamic. {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(indirectRelayAgentIpFromCfg.toOctets());
            log.trace("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // writeRequestDhcp6Record(directConnFlag, clientConnectionPoint, clientPacket, dhcp6Packet);
    // peer address: address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<>();
    // directly connected case, hop count is zero; otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString() + ":";
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (clientPacket.getVlanID() & 0xff);
    vlanIdBytes[1] = (byte) ((clientPacket.getVlanID() >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    log.trace("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} vlan {}", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length, vlanIdBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    ipv6Packet.setHopLimit((byte) 64);
    etherReply.setPayload(ipv6Packet);
    if (directConnFlag || indirectDhcpServerIp == null) {
        return new InternalPacket(etherReply, dhcpServerConnectPoint);
    } else {
        return new InternalPacket(etherReply, indirectDhcpServerConnectPoint);
    }
}
#method_after
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    DhcpServerInfo serverInfo;
    Ip6Address dhcpServerIp = null;
    ConnectPoint dhcpServerConnectPoint = null;
    MacAddress dhcpConnectMac = null;
    VlanId dhcpConnectVlan = null;
    Ip6Address dhcpGatewayIp = null;
    Ip6Address indirectDhcpServerIp = null;
    ConnectPoint indirectDhcpServerConnectPoint = null;
    MacAddress indirectDhcpConnectMac = null;
    VlanId indirectDhcpConnectVlan = null;
    Ip6Address indirectDhcpGatewayIp = null;
    Ip6Address indirectRelayAgentIpFromCfg = null;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        indirectDhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        indirectRelayAgentIpFromCfg = serverInfo.getRelayAgentIp6(receivedFromDevice).orElse(null);
    }
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Interface serverInterface;
    if (directConnFlag) {
        serverInterface = getServerInterface();
    } else {
        serverInterface = getIndirectServerInterface();
        if (serverInterface == null) {
            // Indirect server interface not found, use default server interface
            serverInterface = getServerInterface();
        }
    }
    if (serverInterface == null) {
        log.warn("Can't get {} server interface, ignore", directConnFlag ? "direct" : "indirect");
        return null;
    }
    Ip6Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP v6 address for server Interface {}", serverInterface);
        return null;
    }
    Ethernet etherReply = clientPacket.duplicate();
    etherReply.setSourceMACAddress(macFacingServer);
    if ((directConnFlag && dhcpConnectMac == null) || !directConnFlag && indirectDhcpConnectMac == null && dhcpConnectMac == null) {
        log.trace("Packet received from {} connected client.", directConnFlag ? "directly" : "indirectly");
        log.debug("DHCP6 {} not yet resolved .. Aborting DHCP packet processing from client on port: {}", (dhcpGatewayIp == null) ? "server IP " + dhcpServerIp : "gateway IP " + dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point direct {} directConn {} indirectConn {} is not set up yet", directConnFlag, dhcpServerConnectPoint, indirectDhcpServerConnectPoint);
        return null;
    }
    etherReply.setDestinationMACAddress(dhcpConnectMac);
    etherReply.setVlanID(dhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(ipFacingServer.toOctets());
    ipv6Packet.setDestinationAddress(dhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    removeHostOrRoute(directConnFlag, clientConnectionPoint, dhcp6Packet, clientPacket, clientIpv6, clientInterface);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (indirectDhcpServerIp == null) {
            log.debug("indirect DhcpServerIp not available, use default DhcpServerIp {}", HexString.toHexString(dhcpServerIp.toOctets()));
        } else {
            // Check if mac is obtained for valid server ip
            if (indirectDhcpConnectMac == null) {
                log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (indirectDhcpGatewayIp == null) ? "server IP " + indirectDhcpServerIp : "gateway IP " + indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
                return null;
            }
            etherReply.setDestinationMACAddress(indirectDhcpConnectMac);
            etherReply.setVlanID(indirectDhcpConnectVlan.toShort());
            ipv6Packet.setDestinationAddress(indirectDhcpServerIp.toOctets());
        }
        if (indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.trace("indirect connection: relayAgentIp NOT availale from config file! Use dynamic. {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(indirectRelayAgentIpFromCfg.toOctets());
            log.trace("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // peer address: address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<>();
    // directly connected case, hop count is zero; otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString() + ":";
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (clientPacket.getVlanID() & 0xff);
    vlanIdBytes[1] = (byte) ((clientPacket.getVlanID() >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    log.trace("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} vlan {}", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length, vlanIdBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    ipv6Packet.setHopLimit((byte) 64);
    etherReply.setPayload(ipv6Packet);
    if (directConnFlag || indirectDhcpServerIp == null) {
        return new InternalPacket(etherReply, dhcpServerConnectPoint);
    } else {
        return new InternalPacket(etherReply, indirectDhcpServerConnectPoint);
    }
}
#end_block

#method_before
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    // TODO: refactor
    DhcpServerInfo serverInfo;
    Ip6Address dhcpServerIp = null;
    ConnectPoint dhcpServerConnectPoint = null;
    MacAddress dhcpConnectMac = null;
    VlanId dhcpConnectVlan = null;
    Ip6Address dhcpGatewayIp = null;
    Ip6Address indirectDhcpServerIp = null;
    ConnectPoint indirectDhcpServerConnectPoint = null;
    MacAddress indirectDhcpConnectMac = null;
    VlanId indirectDhcpConnectVlan = null;
    Ip6Address indirectDhcpGatewayIp = null;
    Ip6Address indirectRelayAgentIpFromCfg = null;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        indirectDhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        indirectRelayAgentIpFromCfg = serverInfo.getRelayAgentIp6(receivedFromDevice).orElse(null);
    }
    // get dhcp6 header.
    Ethernet etherReply = receivedPacket.duplicate();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = directlyConnected(dhcp6Relay);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if ((directConnFlag || (!directConnFlag && indirectDhcpServerIp == null)) && !inPort.equals(dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for direct or indirect-null", inPort, dhcpServerConnectPoint);
        return null;
    }
    if (!directConnFlag && indirectDhcpServerIp != null && !inPort.equals(indirectDhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for indirect", inPort, indirectDhcpServerConnectPoint);
        return null;
    }
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId vlanIdInUse = VlanId.vlanId(interfaceIdOption.getVlanId());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot get client interface for from packet, abort... vlan {}", vlanIdInUse.toString());
        return null;
    }
    MacAddress relayAgentMac = clientInterface.mac();
    if (relayAgentMac == null) {
        log.warn("Can not get client interface mac, abort packet..");
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac;
    Ip6Address peerAddress = Ip6Address.valueOf(dhcp6Relay.getPeerAddress());
    Set<Host> clients = hostService.getHostsByIp(peerAddress);
    if (clients.isEmpty()) {
        log.trace("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.trace("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            return null;
        }
        log.trace("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    // add host or route
    addHostOrRoute(directConnFlag, clientConnectionPoint, dhcp6Relay, embeddedDhcp6, clientMac, clientInterface);
    // writeResponseDhcp6Record(directConnFlag, clientConnectionPoint, vlanIdInUse,
    // receivedPacket, dhcp6Relay, embeddedDhcp6);
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#method_after
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    // TODO: refactor
    DhcpServerInfo serverInfo;
    Ip6Address dhcpServerIp = null;
    ConnectPoint dhcpServerConnectPoint = null;
    MacAddress dhcpConnectMac = null;
    VlanId dhcpConnectVlan = null;
    Ip6Address dhcpGatewayIp = null;
    Ip6Address indirectDhcpServerIp = null;
    ConnectPoint indirectDhcpServerConnectPoint = null;
    MacAddress indirectDhcpConnectMac = null;
    VlanId indirectDhcpConnectVlan = null;
    Ip6Address indirectDhcpGatewayIp = null;
    Ip6Address indirectRelayAgentIpFromCfg = null;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        indirectDhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        indirectRelayAgentIpFromCfg = serverInfo.getRelayAgentIp6(receivedFromDevice).orElse(null);
    }
    // get dhcp6 header.
    Ethernet etherReply = receivedPacket.duplicate();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = directlyConnected(dhcp6Relay);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if ((directConnFlag || (!directConnFlag && indirectDhcpServerIp == null)) && !inPort.equals(dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for direct or indirect-null", inPort, dhcpServerConnectPoint);
        return null;
    }
    if (!directConnFlag && indirectDhcpServerIp != null && !inPort.equals(indirectDhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for indirect", inPort, indirectDhcpServerConnectPoint);
        return null;
    }
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId vlanIdInUse = VlanId.vlanId(interfaceIdOption.getVlanId());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot get client interface for from packet, abort... vlan {}", vlanIdInUse.toString());
        return null;
    }
    MacAddress relayAgentMac = clientInterface.mac();
    if (relayAgentMac == null) {
        log.warn("Can not get client interface mac, abort packet..");
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac;
    Ip6Address peerAddress = Ip6Address.valueOf(dhcp6Relay.getPeerAddress());
    Set<Host> clients = hostService.getHostsByIp(peerAddress);
    if (clients.isEmpty()) {
        log.trace("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.trace("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            return null;
        }
        log.trace("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    // add host or route
    addHostOrRoute(directConnFlag, clientConnectionPoint, dhcp6Relay, embeddedDhcp6, clientMac, clientInterface);
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#end_block

#method_before
private static String freqLmdaToAnnotation(long freqLmda) {
    return useFreq ? mhzToAnnotation(freqLmda) : lambdaToAnnotationHz(freqLmda);
}
#method_after
private static String freqLmdaToAnnotation(long freqLmda, boolean useFreq) {
    return useFreq ? mhzToAnnotation(freqLmda) : lambdaToAnnotationHz(freqLmda);
}
#end_block

#method_before
private Collection<PortStatistics> buildPortStatistics(DeviceId deviceId, List<OFPortStatsEntry> entries) {
    HashSet<PortStatistics> stats = Sets.newHashSet();
    for (OFPortStatsEntry entry : entries) {
        try {
            if (entry == null || entry.getPortNo() == null || entry.getPortNo().getPortNumber() < 0) {
                continue;
            }
            DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
            boolean propSupported = entry.getVersion().getWireVersion() >= OFVersion.OF_14.getWireVersion();
            Optional<OFPortStatsPropOptical> optical = propSupported ? entry.getProperties().stream().filter(OFPortStatsPropOptical.class::isInstance).map(OFPortStatsPropOptical.class::cast).findAny() : Optional.empty();
            if (optical.isPresent()) {
                long flags = optical.get().getFlags();
                int txTune = OFPortStatsOpticalFlagsSerializerVer14.TX_TUNE_VAL;
                long txFreq = optical.get().getTxFreqLmda();
                long txOffset = optical.get().getTxOffset();
                long txGridSpan = optical.get().getTxGridSpan();
                annotations.set(AK_TX_TUNE_FEATURE, ((flags & txTune) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TX_FREQ_HZ, freqLmdaToAnnotation(txFreq));
                annotations.set(AK_TX_OFFSET_HZ, freqLmdaToAnnotation(txOffset));
                annotations.set(AK_TX_GRID_SPAN_HZ, freqLmdaToAnnotation(txGridSpan));
                int rxTune = OFPortStatsOpticalFlagsSerializerVer14.RX_TUNE_VAL;
                long rxFreq = optical.get().getRxFreqLmda();
                long rxOffset = optical.get().getRxOffset();
                long rxGridSpan = optical.get().getRxGridSpan();
                annotations.set(AK_RX_TUNE_FEATURE, ((flags & rxTune) != 0) ? "enabled" : "disabled");
                annotations.set(AK_RX_FREQ_HZ, freqLmdaToAnnotation(rxFreq));
                annotations.set(AK_RX_OFFSET_HZ, freqLmdaToAnnotation(rxOffset));
                annotations.set(AK_RX_GRID_SPAN_HZ, freqLmdaToAnnotation(rxGridSpan));
                int txPwrVal = OFPortStatsOpticalFlagsSerializerVer14.TX_PWR_VAL;
                int txPwr = optical.get().getTxPwr();
                annotations.set(AK_TX_PWR_FEATURE, ((flags & txPwrVal) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TX_PWR, Integer.toString(txPwr));
                int rxPwrVal = OFPortStatsOpticalFlagsSerializerVer14.RX_PWR_VAL;
                int rxPwr = optical.get().getRxPwr();
                annotations.set(AK_RX_PWR_FEATURE, ((flags & rxPwrVal) != 0) ? "enabled" : "disabled");
                annotations.set(AK_RX_PWR, Integer.toString(rxPwr));
                int txBias = OFPortStatsOpticalFlagsSerializerVer14.TX_BIAS_VAL;
                int biasCurrent = optical.get().getBiasCurrent();
                annotations.set(AK_TX_BIAS_FEATURE, ((flags & txBias) != 0) ? "enabled" : "disabled");
                annotations.set(AK_BIAS_CURRENT, Integer.toString(biasCurrent));
                int txTemp = OFPortStatsOpticalFlagsSerializerVer14.TX_TEMP_VAL;
                int temperature = optical.get().getTemperature();
                annotations.set(AK_TX_TEMP_FEATURE, ((flags & txTemp) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TEMPERATURE, Integer.toString(temperature));
            }
            DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();
            DefaultPortStatistics stat = builder.setDeviceId(deviceId).setPort(entry.getPortNo().getPortNumber()).setPacketsReceived(entry.getRxPackets().getValue()).setPacketsSent(entry.getTxPackets().getValue()).setBytesReceived(entry.getRxBytes().getValue()).setBytesSent(entry.getTxBytes().getValue()).setPacketsRxDropped(entry.getRxDropped().getValue()).setPacketsTxDropped(entry.getTxDropped().getValue()).setPacketsRxErrors(entry.getRxErrors().getValue()).setPacketsTxErrors(entry.getTxErrors().getValue()).setDurationSec(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationSec()).setDurationNano(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationNsec()).setAnnotations(annotations.build()).build();
            stats.add(stat);
        } catch (Exception e) {
            LOG.warn("Unable to process port stats", e);
        }
    }
    return Collections.unmodifiableSet(stats);
}
#method_after
private Collection<PortStatistics> buildPortStatistics(DeviceId deviceId, List<OFPortStatsEntry> entries) {
    HashSet<PortStatistics> stats = Sets.newHashSet();
    final Dpid dpid = dpid(deviceId.uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    for (OFPortStatsEntry entry : entries) {
        try {
            if (entry == null || entry.getPortNo() == null || entry.getPortNo().getPortNumber() < 0) {
                continue;
            }
            DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
            boolean propSupported = entry.getVersion().getWireVersion() >= OFVersion.OF_14.getWireVersion();
            Optional<OFPortStatsPropOptical> optical = propSupported ? entry.getProperties().stream().filter(OFPortStatsPropOptical.class::isInstance).map(OFPortStatsPropOptical.class::cast).findAny() : Optional.empty();
            if (optical.isPresent()) {
                long flags = optical.get().getFlags();
                boolean useFreq = false;
                for (OFPortDesc pd : sw.getPorts()) {
                    if (pd.getPortNo().equals(entry.getPortNo())) {
                        for (OFPortDescProp prop : pd.getProperties()) {
                            if (prop instanceof OFPortDescPropOptical) {
                                OFPortDescPropOptical oprop = (OFPortDescPropOptical) prop;
                                long supported = oprop.getSupported();
                                int useFreqVal = OFOpticalPortFeaturesSerializerVer14.USE_FREQ_VAL;
                                if ((supported & useFreqVal) != 0) {
                                    useFreq = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                int txTune = OFPortStatsOpticalFlagsSerializerVer14.TX_TUNE_VAL;
                long txFreq = optical.get().getTxFreqLmda();
                long txOffset = optical.get().getTxOffset();
                long txGridSpan = optical.get().getTxGridSpan();
                annotations.set(AK_TX_TUNE_FEATURE, ((flags & txTune) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TX_FREQ_HZ, freqLmdaToAnnotation(txFreq, useFreq));
                annotations.set(AK_TX_OFFSET_HZ, freqLmdaToAnnotation(txOffset, useFreq));
                annotations.set(AK_TX_GRID_SPAN_HZ, freqLmdaToAnnotation(txGridSpan, useFreq));
                int rxTune = OFPortStatsOpticalFlagsSerializerVer14.RX_TUNE_VAL;
                long rxFreq = optical.get().getRxFreqLmda();
                long rxOffset = optical.get().getRxOffset();
                long rxGridSpan = optical.get().getRxGridSpan();
                annotations.set(AK_RX_TUNE_FEATURE, ((flags & rxTune) != 0) ? "enabled" : "disabled");
                annotations.set(AK_RX_FREQ_HZ, freqLmdaToAnnotation(rxFreq, useFreq));
                annotations.set(AK_RX_OFFSET_HZ, freqLmdaToAnnotation(rxOffset, useFreq));
                annotations.set(AK_RX_GRID_SPAN_HZ, freqLmdaToAnnotation(rxGridSpan, useFreq));
                int txPwrVal = OFPortStatsOpticalFlagsSerializerVer14.TX_PWR_VAL;
                int txPwr = optical.get().getTxPwr();
                annotations.set(AK_TX_PWR_FEATURE, ((flags & txPwrVal) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TX_PWR, Integer.toString(txPwr));
                int rxPwrVal = OFPortStatsOpticalFlagsSerializerVer14.RX_PWR_VAL;
                int rxPwr = optical.get().getRxPwr();
                annotations.set(AK_RX_PWR_FEATURE, ((flags & rxPwrVal) != 0) ? "enabled" : "disabled");
                annotations.set(AK_RX_PWR, Integer.toString(rxPwr));
                int txBias = OFPortStatsOpticalFlagsSerializerVer14.TX_BIAS_VAL;
                int biasCurrent = optical.get().getBiasCurrent();
                annotations.set(AK_TX_BIAS_FEATURE, ((flags & txBias) != 0) ? "enabled" : "disabled");
                annotations.set(AK_BIAS_CURRENT, Integer.toString(biasCurrent));
                int txTemp = OFPortStatsOpticalFlagsSerializerVer14.TX_TEMP_VAL;
                int temperature = optical.get().getTemperature();
                annotations.set(AK_TX_TEMP_FEATURE, ((flags & txTemp) != 0) ? "enabled" : "disabled");
                annotations.set(AK_TEMPERATURE, Integer.toString(temperature));
            }
            DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();
            DefaultPortStatistics stat = builder.setDeviceId(deviceId).setPort(entry.getPortNo().getPortNumber()).setPacketsReceived(entry.getRxPackets().getValue()).setPacketsSent(entry.getTxPackets().getValue()).setBytesReceived(entry.getRxBytes().getValue()).setBytesSent(entry.getTxBytes().getValue()).setPacketsRxDropped(entry.getRxDropped().getValue()).setPacketsTxDropped(entry.getTxDropped().getValue()).setPacketsRxErrors(entry.getRxErrors().getValue()).setPacketsTxErrors(entry.getTxErrors().getValue()).setDurationSec(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationSec()).setDurationNano(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationNsec()).setAnnotations(annotations.build()).build();
            stats.add(stat);
        } catch (Exception e) {
            LOG.warn("Unable to process port stats", e);
        }
    }
    return Collections.unmodifiableSet(stats);
}
#end_block

#method_before
private PortDescription buildPortDescription14(OFPortDesc port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    boolean adminDown = port.getConfig().contains(OFPortConfig.PORT_DOWN);
    Builder annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString(), adminDown);
    Optional<OFPortDescPropEthernet> ether = port.getProperties().stream().filter(OFPortDescPropEthernet.class::isInstance).map(OFPortDescPropEthernet.class::cast).findAny();
    if (ether.isPresent()) {
        // TODO parse other part of OFPortDescPropEthernet if necessary
        return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
    }
    Optional<OFPortDescPropOptical> optical = port.getProperties().stream().filter(OFPortDescPropOptical.class::isInstance).map(OFPortDescPropOptical.class::cast).findAny();
    if (optical.isPresent()) {
        // optical port
        // FIXME is there a OF version neutral way to access
        // OFOpticalPortFeaturesSerializerVer14
        long supported = optical.get().getSupported();
        long rxMin = optical.get().getRxMinFreqLmda();
        long rxMax = optical.get().getRxMaxFreqLmda();
        long rxGrid = optical.get().getRxGridFreqLmda();
        long txMin = optical.get().getTxMinFreqLmda();
        long txMax = optical.get().getTxMaxFreqLmda();
        long txGrid = optical.get().getTxGridFreqLmda();
        int txTune = OFOpticalPortFeaturesSerializerVer14.TX_TUNE_VAL;
        int rxTune = OFOpticalPortFeaturesSerializerVer14.RX_TUNE_VAL;
        annotations.set(AK_TX_TUNE_FEATURE, ((supported & txTune) != 0) ? "enabled" : "disabled");
        annotations.set(AK_RX_TUNE_FEATURE, ((supported & rxTune) != 0) ? "enabled" : "disabled");
        // wire value for OFOpticalPortFeatures.USE_FREQ
        useFreq = (supported & OFOpticalPortFeaturesSerializerVer14.USE_FREQ_VAL) != 0;
        annotations.set(AK_RX_MIN_FREQ_HZ, freqLmdaToAnnotation(rxMin));
        annotations.set(AK_RX_MAX_FREQ_HZ, freqLmdaToAnnotation(rxMax));
        annotations.set(AK_RX_GRID_HZ, freqLmdaToAnnotation(rxGrid));
        annotations.set(AK_TX_MIN_FREQ_HZ, freqLmdaToAnnotation(txMin));
        annotations.set(AK_TX_MAX_FREQ_HZ, freqLmdaToAnnotation(txMax));
        annotations.set(AK_TX_GRID_HZ, freqLmdaToAnnotation(txGrid));
        // unless Device models Tx/Rx ports as separate port
        if (rxMin == txMin) {
            annotations.set(AK_MIN_FREQ_HZ, freqLmdaToAnnotation(rxMin));
        }
        if (rxMax == txMax) {
            annotations.set(AK_MAX_FREQ_HZ, freqLmdaToAnnotation(rxMax));
        }
        if (rxGrid == txGrid) {
            annotations.set(AK_GRID_HZ, freqLmdaToAnnotation(rxGrid));
        }
        int txPwr = OFOpticalPortFeaturesSerializerVer14.TX_PWR_VAL;
        long txPwrMin = optical.get().getTxPwrMin();
        long txPwrMax = optical.get().getTxPwrMax();
        annotations.set(AK_TX_PWR_FEATURE, ((supported & txPwr) != 0) ? "enabled" : "disabled");
        annotations.set(AK_TX_PWR_MIN, Long.toString(txPwrMin));
        annotations.set(AK_TX_PWR_MAX, Long.toString(txPwrMax));
        return new DefaultPortDescription(portNo, enabled, FIBER, portSpeed(port), annotations.build());
    }
    // fall back default
    return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
}
#method_after
private PortDescription buildPortDescription14(OFPortDesc port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    boolean adminDown = port.getConfig().contains(OFPortConfig.PORT_DOWN);
    Builder annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString(), adminDown);
    Optional<OFPortDescPropEthernet> ether = port.getProperties().stream().filter(OFPortDescPropEthernet.class::isInstance).map(OFPortDescPropEthernet.class::cast).findAny();
    if (ether.isPresent()) {
        // TODO parse other part of OFPortDescPropEthernet if necessary
        return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
    }
    Optional<OFPortDescPropOptical> optical = port.getProperties().stream().filter(OFPortDescPropOptical.class::isInstance).map(OFPortDescPropOptical.class::cast).findAny();
    if (optical.isPresent()) {
        // optical port
        // FIXME is there a OF version neutral way to access
        // OFOpticalPortFeaturesSerializerVer14
        long supported = optical.get().getSupported();
        long rxMin = optical.get().getRxMinFreqLmda();
        long rxMax = optical.get().getRxMaxFreqLmda();
        long rxGrid = optical.get().getRxGridFreqLmda();
        long txMin = optical.get().getTxMinFreqLmda();
        long txMax = optical.get().getTxMaxFreqLmda();
        long txGrid = optical.get().getTxGridFreqLmda();
        int txTune = OFOpticalPortFeaturesSerializerVer14.TX_TUNE_VAL;
        int rxTune = OFOpticalPortFeaturesSerializerVer14.RX_TUNE_VAL;
        annotations.set(AK_TX_TUNE_FEATURE, ((supported & txTune) != 0) ? "enabled" : "disabled");
        annotations.set(AK_RX_TUNE_FEATURE, ((supported & rxTune) != 0) ? "enabled" : "disabled");
        // wire value for OFOpticalPortFeatures.USE_FREQ
        boolean useFreq = (supported & OFOpticalPortFeaturesSerializerVer14.USE_FREQ_VAL) != 0;
        annotations.set(AK_USE_FREQ_FEATURE, useFreq ? "enabled" : "disabled");
        annotations.set(AK_RX_MIN_FREQ_HZ, freqLmdaToAnnotation(rxMin, useFreq));
        annotations.set(AK_RX_MAX_FREQ_HZ, freqLmdaToAnnotation(rxMax, useFreq));
        annotations.set(AK_RX_GRID_HZ, freqLmdaToAnnotation(rxGrid, useFreq));
        annotations.set(AK_TX_MIN_FREQ_HZ, freqLmdaToAnnotation(txMin, useFreq));
        annotations.set(AK_TX_MAX_FREQ_HZ, freqLmdaToAnnotation(txMax, useFreq));
        annotations.set(AK_TX_GRID_HZ, freqLmdaToAnnotation(txGrid, useFreq));
        // unless Device models Tx/Rx ports as separate port
        if (rxMin == txMin) {
            annotations.set(AK_MIN_FREQ_HZ, freqLmdaToAnnotation(rxMin, useFreq));
        }
        if (rxMax == txMax) {
            annotations.set(AK_MAX_FREQ_HZ, freqLmdaToAnnotation(rxMax, useFreq));
        }
        if (rxGrid == txGrid) {
            annotations.set(AK_GRID_HZ, freqLmdaToAnnotation(rxGrid, useFreq));
        }
        int txPwr = OFOpticalPortFeaturesSerializerVer14.TX_PWR_VAL;
        long txPwrMin = optical.get().getTxPwrMin();
        long txPwrMax = optical.get().getTxPwrMax();
        annotations.set(AK_TX_PWR_FEATURE, ((supported & txPwr) != 0) ? "enabled" : "disabled");
        annotations.set(AK_TX_PWR_MIN, Long.toString(txPwrMin));
        annotations.set(AK_TX_PWR_MAX, Long.toString(txPwrMax));
        return new DefaultPortDescription(portNo, enabled, FIBER, portSpeed(port), annotations.build());
    }
    // fall back default
    return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
}
#end_block

#method_before
public void retryHash(Link link, boolean linkDown, boolean firstTime) {
    MacAddress neighborMac;
    try {
        neighborMac = deviceConfig.getDeviceMac(link.dst().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting retryHash.");
        return;
    }
    // find all the destinationSets related to link
    Set<DestinationSetNextObjectiveStoreKey> dsKeySet = dsNextObjStore.entrySet().stream().filter(entry -> !entry.getKey().destinationSet().mplsSet() || (entry.getKey().destinationSet().mplsSet() && srManager.getMplsEcmp())).filter(entry -> entry.getKey().deviceId().equals(deviceId)).filter(entry -> entry.getValue().containsNextHop(link.dst().deviceId())).map(entry -> entry.getKey()).collect(Collectors.toSet());
    log.debug("retryHash: dsNextObjStore contents for linkSrc {} -> linkDst {}: {}", deviceId, link.dst().deviceId(), dsKeySet);
    for (DestinationSetNextObjectiveStoreKey dsKey : dsKeySet) {
        NextNeighbors nextHops = dsNextObjStore.get(dsKey);
        if (nextHops == null) {
            log.warn("retryHash in device {}, but global store has no record " + "for dsKey:{}", deviceId, dsKey);
            continue;
        }
        int nextId = nextHops.nextId();
        Set<DeviceId> dstSet = nextHops.getDstForNextHop(link.dst().deviceId());
        if (!linkDown) {
            List<PortLabel> pl = Lists.newArrayList();
            if (firstTime) {
                // to the same hash group are avoided by the driver.
                for (PortNumber p : devicePortMap.get(link.dst().deviceId())) {
                    dstSet.forEach(dst -> {
                        int edgeLabel = dsKey.destinationSet().getEdgeLabel(dst);
                        pl.add(new PortLabel(p, edgeLabel));
                    });
                }
                addToHashedNextObjective(pl, neighborMac, nextId);
            } else {
                // handle only the port that came up
                dstSet.forEach(dst -> {
                    int edgeLabel = dsKey.destinationSet().getEdgeLabel(dst);
                    pl.add(new PortLabel(link.src().port(), edgeLabel));
                });
                addToHashedNextObjective(pl, neighborMac, nextId);
            }
        } else {
            // linkdown
            List<PortLabel> pl = Lists.newArrayList();
            dstSet.forEach(dst -> {
                int edgeLabel = dsKey.destinationSet().getEdgeLabel(dst);
                pl.add(new PortLabel(link.src().port(), edgeLabel));
            });
            removeFromHashedNextObjective(pl, neighborMac, nextId);
        }
    }
}
#method_after
public void retryHash(Link link, boolean linkDown, boolean firstTime) {
    MacAddress neighborMac;
    try {
        neighborMac = deviceConfig.getDeviceMac(link.dst().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting retryHash.");
        return;
    }
    // find all the destinationSets related to link
    Set<DestinationSetNextObjectiveStoreKey> dsKeySet = dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(deviceId)).filter(entry -> !entry.getKey().destinationSet().mplsSet() || (entry.getKey().destinationSet().mplsSet() && srManager.getMplsEcmp())).filter(entry -> entry.getValue().containsNextHop(link.dst().deviceId())).map(entry -> entry.getKey()).collect(Collectors.toSet());
    log.debug("retryHash: dsNextObjStore contents for linkSrc {} -> linkDst {}: {}", deviceId, link.dst().deviceId(), dsKeySet);
    for (DestinationSetNextObjectiveStoreKey dsKey : dsKeySet) {
        NextNeighbors nextHops = dsNextObjStore.get(dsKey);
        if (nextHops == null) {
            log.warn("retryHash in device {}, but global store has no record " + "for dsKey:{}", deviceId, dsKey);
            continue;
        }
        int nextId = nextHops.nextId();
        Set<DeviceId> dstSet = nextHops.getDstForNextHop(link.dst().deviceId());
        if (!linkDown) {
            List<PortLabel> pl = Lists.newArrayList();
            if (firstTime) {
                // to the same hash group are avoided by the driver.
                for (PortNumber p : devicePortMap.get(link.dst().deviceId())) {
                    dstSet.forEach(dst -> {
                        int edgeLabel = dsKey.destinationSet().getEdgeLabel(dst);
                        pl.add(new PortLabel(p, edgeLabel));
                    });
                }
                addToHashedNextObjective(pl, neighborMac, nextId);
            } else {
                // handle only the port that came up
                dstSet.forEach(dst -> {
                    int edgeLabel = dsKey.destinationSet().getEdgeLabel(dst);
                    pl.add(new PortLabel(link.src().port(), edgeLabel));
                });
                addToHashedNextObjective(pl, neighborMac, nextId);
            }
        } else {
            // linkdown
            List<PortLabel> pl = Lists.newArrayList();
            dstSet.forEach(dst -> {
                int edgeLabel = dsKey.destinationSet().getEdgeLabel(dst);
                pl.add(new PortLabel(link.src().port(), edgeLabel));
            });
            removeFromHashedNextObjective(pl, neighborMac, nextId);
        }
    }
}
#end_block

#method_before
public boolean removeGroup(int objectiveId) {
    for (Map.Entry<DestinationSetNextObjectiveStoreKey, NextNeighbors> e : dsNextObjStore.entrySet()) {
        if (e.getValue().nextId() != objectiveId) {
            continue;
        }
        // XXX Right now it is just used in TunnelHandler
        // remember in future that PW transit groups could
        // be Indirect groups
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(objectiveId).withType(NextObjective.Type.HASHED).fromApp(appId);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("RemoveGroup removes NextObj {} on {}", objectiveId, deviceId), (objective, error) -> log.warn("RemoveGroup failed to remove NextObj {} on {}: {}", objectiveId, deviceId, error));
        NextObjective nextObjective = nextObjBuilder.remove(context);
        log.info("**removeGroup: Submited " + "next objective {} in device {}", objectiveId, deviceId);
        flowObjectiveService.next(deviceId, nextObjective);
        dsNextObjStore.remove(e.getKey());
        return true;
    }
    return false;
}
#method_after
public boolean removeGroup(int objectiveId) {
    for (Map.Entry<DestinationSetNextObjectiveStoreKey, NextNeighbors> e : dsNextObjStore.entrySet()) {
        if (e.getValue().nextId() != objectiveId) {
            continue;
        }
        // Right now it is just used in TunnelHandler
        // remember in future that PW transit groups could
        // be Indirect groups
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(objectiveId).withType(NextObjective.Type.HASHED).fromApp(appId);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("RemoveGroup removes NextObj {} on {}", objectiveId, deviceId), (objective, error) -> log.warn("RemoveGroup failed to remove NextObj {} on {}: {}", objectiveId, deviceId, error));
        NextObjective nextObjective = nextObjBuilder.remove(context);
        log.info("**removeGroup: Submited " + "next objective {} in device {}", objectiveId, deviceId);
        flowObjectiveService.next(deviceId, nextObjective);
        dsNextObjStore.remove(e.getKey());
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public void run() {
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    DefaultRoutingHandler rh = srManager.getRoutingHandler();
    if (rh == null) {
        return;
    }
    if (!rh.isRoutingStable()) {
        return;
    }
    rh.acquireRoutingLock();
    try {
        log.trace("running bucket corrector for dev: {}", deviceId);
        Set<DestinationSetNextObjectiveStoreKey> dsKeySet = dsNextObjStore.entrySet().stream().filter(entry -> !entry.getKey().destinationSet().mplsSet() || (entry.getKey().destinationSet().mplsSet() && srManager.getMplsEcmp())).filter(entry -> entry.getKey().deviceId().equals(deviceId)).map(entry -> entry.getKey()).collect(Collectors.toSet());
        for (DestinationSetNextObjectiveStoreKey dsKey : dsKeySet) {
            NextNeighbors next = dsNextObjStore.get(dsKey);
            if (next == null) {
                continue;
            }
            int nid = next.nextId();
            if (nextId != null && nextId != nid) {
                continue;
            }
            log.trace("bkt-corr: dsNextObjStore for device {}: {}", deviceId, dsKey, next);
            TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder();
            metabuilder.matchVlanId(INTERNAL_VLAN);
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nid).withType(NextObjective.Type.HASHED).withMeta(metabuilder.build()).fromApp(appId);
            next.dstNextHops().forEach((dstDev, nextHops) -> {
                int edgeLabel = dsKey.destinationSet().getEdgeLabel(dstDev);
                nextHops.forEach(neighbor -> {
                    MacAddress neighborMac;
                    try {
                        neighborMac = deviceConfig.getDeviceMac(neighbor);
                    } catch (DeviceConfigNotFoundException e) {
                        log.warn(e.getMessage() + " Aborting neighbor" + neighbor);
                        return;
                    }
                    devicePortMap.get(neighbor).forEach(port -> {
                        log.trace("verify in device {} nextId {}: bucket with" + " port/label {}/{} to dst {} via {}", deviceId, nid, port, edgeLabel, dstDev, neighbor);
                        nextObjBuilder.addTreatment(treatmentBuilder(port, neighborMac, edgeLabel));
                    });
                });
            });
            NextObjective nextObjective = nextObjBuilder.verify();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    } finally {
        rh.releaseRoutingLock();
    }
}
#method_after
@Override
public void run() {
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    DefaultRoutingHandler rh = srManager.getRoutingHandler();
    if (rh == null) {
        return;
    }
    if (!rh.isRoutingStable()) {
        return;
    }
    rh.acquireRoutingLock();
    try {
        log.trace("running bucket corrector for dev: {}", deviceId);
        Set<DestinationSetNextObjectiveStoreKey> dsKeySet = dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(deviceId)).filter(entry -> !entry.getKey().destinationSet().mplsSet() || (entry.getKey().destinationSet().mplsSet() && srManager.getMplsEcmp())).map(entry -> entry.getKey()).collect(Collectors.toSet());
        for (DestinationSetNextObjectiveStoreKey dsKey : dsKeySet) {
            NextNeighbors next = dsNextObjStore.get(dsKey);
            if (next == null) {
                continue;
            }
            int nid = next.nextId();
            if (nextId != null && nextId != nid) {
                continue;
            }
            log.trace("bkt-corr: dsNextObjStore for device {}: {}", deviceId, dsKey, next);
            TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder();
            metabuilder.matchVlanId(INTERNAL_VLAN);
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nid).withType(NextObjective.Type.HASHED).withMeta(metabuilder.build()).fromApp(appId);
            next.dstNextHops().forEach((dstDev, nextHops) -> {
                int edgeLabel = dsKey.destinationSet().getEdgeLabel(dstDev);
                nextHops.forEach(neighbor -> {
                    MacAddress neighborMac;
                    try {
                        neighborMac = deviceConfig.getDeviceMac(neighbor);
                    } catch (DeviceConfigNotFoundException e) {
                        log.warn(e.getMessage() + " Aborting neighbor" + neighbor);
                        return;
                    }
                    devicePortMap.get(neighbor).forEach(port -> {
                        log.trace("verify in device {} nextId {}: bucket with" + " port/label {}/{} to dst {} via {}", deviceId, nid, port, edgeLabel, dstDev, neighbor);
                        nextObjBuilder.addTreatment(treatmentBuilder(port, neighborMac, edgeLabel));
                    });
                });
            });
            NextObjective nextObjective = nextObjBuilder.verify();
            flowObjectiveService.next(deviceId, nextObjective);
        }
    } finally {
        rh.releaseRoutingLock();
    }
}
#end_block

#method_before
protected static PortNumber readOutPortFromTreatment(TrafficTreatment tt) {
    for (Instruction ins : tt.allInstructions()) {
        if (ins.type() == Instruction.Type.OUTPUT) {
            return ((Instructions.OutputInstruction) ins).port();
        }
    }
    return null;
}
#method_after
static PortNumber readOutPortFromTreatment(TrafficTreatment tt) {
    for (Instruction ins : tt.allInstructions()) {
        if (ins.type() == Instruction.Type.OUTPUT) {
            return ((Instructions.OutputInstruction) ins).port();
        }
    }
    return null;
}
#end_block

#method_before
protected static int readLabelFromTreatment(TrafficTreatment tt) {
    for (Instruction ins : tt.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction insl2 = (L2ModificationInstruction) ins;
            if (insl2.subtype() == L2SubType.MPLS_LABEL) {
                return ((L2ModificationInstruction.ModMplsLabelInstruction) insl2).label().id();
            }
        }
    }
    return -1;
}
#method_after
static int readLabelFromTreatment(TrafficTreatment tt) {
    for (Instruction ins : tt.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction insl2 = (L2ModificationInstruction) ins;
            if (insl2.subtype() == L2SubType.MPLS_LABEL) {
                return ((L2ModificationInstruction.ModMplsLabelInstruction) insl2).label().id();
            }
        }
    }
    return -1;
}
#end_block

#method_before
protected static List<GroupBucket> generateNextGroupBuckets(List<GroupInfo> groupInfos, GroupDescription.Type bucketType) {
    List<GroupBucket> newBuckets = Lists.newArrayList();
    groupInfos.forEach(groupInfo -> {
        GroupDescription groupDesc = groupInfo.nextGroupDesc();
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
        treatmentBuilder.group(new GroupId(groupDesc.givenGroupId()));
        GroupBucket newBucket = null;
        switch(bucketType) {
            case ALL:
                newBucket = DefaultGroupBucket.createAllGroupBucket(treatmentBuilder.build());
                break;
            case INDIRECT:
                newBucket = DefaultGroupBucket.createIndirectGroupBucket(treatmentBuilder.build());
                break;
            case SELECT:
                newBucket = DefaultGroupBucket.createSelectGroupBucket(treatmentBuilder.build());
                break;
            case FAILOVER:
            // TODO: support failover bucket type
            default:
                log.warn("Unknown bucket type: {}", bucketType);
                break;
        }
        if (newBucket != null) {
            newBuckets.add(newBucket);
        }
    });
    return ImmutableList.copyOf(newBuckets);
}
#method_after
static List<GroupBucket> generateNextGroupBuckets(List<GroupInfo> groupInfos, GroupDescription.Type bucketType) {
    List<GroupBucket> newBuckets = Lists.newArrayList();
    groupInfos.forEach(groupInfo -> {
        GroupDescription groupDesc = groupInfo.nextGroupDesc();
        TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
        treatmentBuilder.group(new GroupId(groupDesc.givenGroupId()));
        GroupBucket newBucket = null;
        switch(bucketType) {
            case ALL:
                newBucket = DefaultGroupBucket.createAllGroupBucket(treatmentBuilder.build());
                break;
            case INDIRECT:
                newBucket = DefaultGroupBucket.createIndirectGroupBucket(treatmentBuilder.build());
                break;
            case SELECT:
                newBucket = DefaultGroupBucket.createSelectGroupBucket(treatmentBuilder.build());
                break;
            case FAILOVER:
            // TODO: support failover bucket type
            default:
                log.warn("Unknown bucket type: {}", bucketType);
                break;
        }
        if (newBucket != null) {
            newBuckets.add(newBucket);
        }
    });
    return ImmutableList.copyOf(newBuckets);
}
#end_block

#method_before
@Override
public void run() {
    // from unhandled exceptions
    try {
        if (groupHandler.pendingGroups().size() != 0) {
            log.debug("pending groups being checked: {}", groupHandler.pendingGroups().asMap().keySet());
        }
        if (groupHandler.pendingAddNextObjectives().size() != 0) {
            log.debug("pending add-next-obj being checked: {}", groupHandler.pendingAddNextObjectives().asMap().keySet());
        }
        Set<GroupKey> keys = groupHandler.pendingGroups().asMap().keySet().stream().filter(key -> groupHandler.groupService.getGroup(groupHandler.deviceId, key) != null).collect(Collectors.toSet());
        Set<GroupKey> otherkeys = groupHandler.pendingAddNextObjectives().asMap().keySet().stream().filter(otherkey -> groupHandler.groupService.getGroup(groupHandler.deviceId, otherkey) != null).collect(Collectors.toSet());
        keys.addAll(otherkeys);
        keys.forEach(key -> groupHandler.processPendingAddGroupsOrNextObjs(key, false));
    } catch (Exception exception) {
        // Just log. It is safe for now.
        log.warn("Uncaught exception is detected", exception);
    }
}
#method_after
@Override
public void run() {
    // from unhandled exceptions
    try {
        if (groupHandler.pendingGroups().size() != 0) {
            log.debug("pending groups being checked: {}", groupHandler.pendingGroups().asMap().keySet());
        }
        if (groupHandler.pendingAddNextObjectives().size() != 0) {
            log.debug("pending add-next-obj being checked: {}", groupHandler.pendingAddNextObjectives().asMap().keySet());
        }
        Set<GroupKey> keys = groupHandler.pendingGroups().asMap().keySet().stream().filter(key -> groupHandler.groupService.getGroup(groupHandler.deviceId, key) != null).collect(Collectors.toSet());
        Set<GroupKey> otherkeys = groupHandler.pendingAddNextObjectives().asMap().keySet().stream().filter(otherkey -> groupHandler.groupService.getGroup(groupHandler.deviceId, otherkey) != null).collect(Collectors.toSet());
        keys.addAll(otherkeys);
        keys.forEach(key -> groupHandler.processPendingAddGroupsOrNextObjs(key, false));
    } catch (Exception exception) {
        // Just log. It is safe for now.
        log.warn("Uncaught exception is detected: {}", exception.getMessage());
        log.debug("Uncaught exception is detected (full stack trace): ", exception);
    }
}
#end_block

#method_before
@Override
public ImmutableByteSequence read(Kryo kryo, Input input, Class<ImmutableByteSequence> type) {
    int length = input.readInt();
    byte[] data = new byte[length];
    int bytesRead = input.read(data);
    if (bytesRead != length) {
        throw new IllegalStateException("Byte sequence serializer read expected " + Integer.toString(length) + " but got " + Integer.toString(bytesRead));
    }
    return ImmutableByteSequence.copyFrom(data);
}
#method_after
@Override
public ImmutableByteSequence read(Kryo kryo, Input input, Class<ImmutableByteSequence> type) {
    int length = input.readInt();
    byte[] data = new byte[length];
    int bytesRead = input.read(data);
    if (bytesRead != length) {
        throw new IllegalStateException("Byte sequence serializer read expected " + length + " but got " + bytesRead);
    }
    return ImmutableByteSequence.copyFrom(data);
}
#end_block

#method_before
@Override
public void removeDevice(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    DeviceEvent event = store.removeDevice(deviceId);
    if (event != null) {
        log.info("Device {} administratively removed", deviceId);
        post(event);
        deviceLocalStatus.remove(deviceId);
    }
}
#method_after
@Override
public void removeDevice(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    DeviceEvent event = store.removeDevice(deviceId);
    if (event != null) {
        log.info("Device {} administratively removed", deviceId);
        post(event);
    }
}
#end_block

#method_before
@Override
public void notify(DeviceEvent event) {
    post(event);
}
#method_after
@Override
public void notify(DeviceEvent event) {
    post(event);
    if (event.type().equals(DeviceEvent.Type.DEVICE_REMOVED)) {
        deviceLocalStatus.remove(event.subject().id());
    }
}
#end_block

#method_before
public boolean createTable(String tableName) {
    CompletableFuture<Boolean> future = copycat.submit("createTable", tableName);
    try {
        return future.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new DatabaseException(e);
    }
}
#method_after
public boolean createTable(String tableName) {
    return submit("createTable", tableName);
}
#end_block

#method_before
public boolean createTable(String tableName, int ttlMillis) {
    CompletableFuture<Boolean> future = copycat.submit("createTable", tableName, ttlMillis);
    try {
        return future.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new DatabaseException(e);
    }
}
#method_after
public boolean createTable(String tableName, int ttlMillis) {
    return submit("createTable", tableName, ttlMillis);
}
#end_block

#method_before
public void dropTable(String tableName) {
    CompletableFuture<Void> future = copycat.submit("dropTable", tableName);
    try {
        future.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new DatabaseException(e);
    }
}
#method_after
public void dropTable(String tableName) {
    submit("dropTable", tableName);
}
#end_block

#method_before
public void dropAllTables() {
    CompletableFuture<Void> future = copycat.submit("dropAllTables");
    try {
        future.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new DatabaseException(e);
    }
}
#method_after
public void dropAllTables() {
    submit("dropAllTables");
}
#end_block

#method_before
public Set<String> listTables() {
    CompletableFuture<Set<String>> future = copycat.submit("listTables");
    try {
        return future.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new DatabaseException(e);
    }
}
#method_after
public Set<String> listTables() {
    return submit("listTables");
}
#end_block

#method_before
public List<ReadResult> batchRead(BatchReadRequest batchRequest) {
    CompletableFuture<List<ReadResult>> future = copycat.submit("read", batchRequest);
    try {
        return future.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new DatabaseException(e);
    }
}
#method_after
public List<ReadResult> batchRead(BatchReadRequest batchRequest) {
    return submit("read", batchRequest);
}
#end_block

#method_before
public List<WriteResult> batchWrite(BatchWriteRequest batchRequest) {
    CompletableFuture<List<WriteResult>> future = copycat.submit("write", batchRequest);
    try {
        return future.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new DatabaseException(e);
    }
}
#method_after
public List<WriteResult> batchWrite(BatchWriteRequest batchRequest) {
    return submit("write", batchRequest);
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    locksToAcquire.clear();
    log.info("Started.");
}
#method_after
@Deactivate
public void deactivate() {
    clusterCommunicator.removeSubscriber(DatabaseStateMachine.DATABASE_UPDATE_EVENTS);
    locksToAcquire.clear();
    log.info("Stopped.");
}
#end_block

#method_before
@Override
public void handle(ClusterMessage message) {
    TableModificationEvent event = DatabaseStateMachine.SERIALIZER.decode(message.payload());
    if (!event.tableName().equals(ONOS_LOCK_TABLE_NAME)) {
        return;
    }
    String path = event.key();
    if (!locksToAcquire.containsKey(path)) {
        return;
    }
    if (event.type() == TableModificationEvent.Type.ROW_DELETED) {
        List<LockRequest> existingRequests = locksToAcquire.get(path);
        if (existingRequests == null) {
            return;
        }
        log.info("Path {} is now available for locking. There are {} outstanding " + "requests waiting for it.", event.key(), existingRequests.size());
        synchronized (existingRequests) {
            Iterator<LockRequest> existingRequestIterator = existingRequests.iterator();
            while (existingRequestIterator.hasNext()) {
                LockRequest request = existingRequestIterator.next();
                if (DateTime.now().isAfter(request.requestExpirationTime())) {
                    // request expired.
                    existingRequestIterator.remove();
                } else {
                    if (request.lock().tryLock(request.leaseDurationMillis())) {
                        request.future().complete(DateTime.now().plusMillis(request.leaseDurationMillis()));
                        existingRequestIterator.remove();
                    }
                }
            }
        }
    }
}
#method_after
@Override
public void handle(ClusterMessage message) {
    TableModificationEvent event = DatabaseStateMachine.SERIALIZER.decode(message.payload());
    if (event.tableName().equals(ONOS_LOCK_TABLE_NAME) && event.type().equals(TableModificationEvent.Type.ROW_DELETED)) {
        THREAD_POOL.submit(new RetryLockTask(event.key()));
    }
}
#end_block

#method_before
@Override
public void lock(int leaseDurationMillis) {
    if (isLocked() && lockExpirationTime.isAfter(DateTime.now().plusMillis(leaseDurationMillis))) {
        // Current expiration time is beyond what is requested.
        return;
    } else {
        tryLock(Long.MAX_VALUE, leaseDurationMillis);
    }
}
#method_after
@Override
public void lock(int leaseDurationMillis) {
    if (isLocked() && lockExpirationTime.isAfter(DateTime.now().plusMillis(leaseDurationMillis))) {
        // Current expiration time is beyond what is requested.
        return;
    } else {
        tryLock(MAX_WAIT_TIME_MS, leaseDurationMillis);
    }
}
#end_block

#method_before
@Override
public boolean extendExpiration(int leaseDurationMillis) {
    if (isLocked()) {
        if (lockExpirationTime.isAfter(DateTime.now().plusMillis(leaseDurationMillis))) {
            return true;
        } else {
            if (tryLock(leaseDurationMillis)) {
                log.debug("Succeeded in extending lock {} expiration time to {}", lockExpirationTime);
                return true;
            } else {
                return false;
            }
        }
    } else {
        log.warn("Ignoring request to extend expiration for lock {}." + "extendExpiration must be called for locks that are already acquired.", path);
        return false;
    }
}
#method_after
@Override
public boolean extendExpiration(int leaseDurationMillis) {
    if (!isLocked()) {
        log.warn("Ignoring request to extend expiration for lock {}." + " ExtendExpiration must be called for locks that are already acquired.", path);
    }
    if (databaseService.putIfValueMatches(DistributedLockManager.ONOS_LOCK_TABLE_NAME, path, lockId, lockId)) {
        lockExpirationTime = DateTime.now().plusMillis(leaseDurationMillis);
        log.debug("Succeeded in extending lock {} expiration time to {}", lockExpirationTime);
        return true;
    } else {
        log.info("Failed to extend expiration for {}", path);
        return false;
    }
}
#end_block

#method_before
@Command
public List<WriteResult> write(BatchWriteRequest batchRequest) {
    // applicability check
    boolean abort = false;
    List<WriteStatus> validationResults = new ArrayList<>(batchRequest.batchSize());
    for (WriteRequest request : batchRequest.getAsList()) {
        Map<String, VersionedValue> table = state.getTable(request.tableName());
        if (table == null) {
            validationResults.add(WriteStatus.NO_SUCH_TABLE);
            abort = true;
            continue;
        }
        final VersionedValue value = table.get(request.key());
        WriteStatus result = checkIfApplicable(request, value);
        validationResults.add(result);
        if (result != WriteStatus.OK) {
            abort = true;
        }
    }
    List<WriteResult> results = new ArrayList<>(batchRequest.batchSize());
    if (abort) {
        for (WriteStatus validationResult : validationResults) {
            if (validationResult == WriteStatus.OK) {
                // aborted due to applicability check failure on other request
                results.add(new WriteResult(WriteStatus.ABORTED, null));
            } else {
                results.add(new WriteResult(validationResult, null));
            }
        }
        return results;
    }
    List<TableModificationEvent> tableModificationEvents = Lists.newLinkedList();
    // apply changes
    for (WriteRequest request : batchRequest.getAsList()) {
        Map<String, VersionedValue> table = state.getTable(request.tableName());
        TableModificationEvent tableModificationEvent = null;
        // TODO: If we need isolation, we need to block reads also
        synchronized (table) {
            switch(request.type()) {
                case PUT:
                case PUT_IF_ABSENT:
                case PUT_IF_VALUE:
                case PUT_IF_VERSION:
                    VersionedValue newValue = new VersionedValue(request.newValue(), state.nextVersion());
                    VersionedValue previousValue = table.put(request.key(), newValue);
                    WriteResult putResult = new WriteResult(WriteStatus.OK, previousValue);
                    results.add(putResult);
                    tableModificationEvent = (previousValue == null) ? TableModificationEvent.rowAdded(request.tableName(), request.key(), newValue) : TableModificationEvent.rowUpdated(request.tableName(), request.key(), newValue);
                    break;
                case REMOVE:
                case REMOVE_IF_VALUE:
                case REMOVE_IF_VERSION:
                    VersionedValue removedValue = table.remove(request.key());
                    WriteResult removeResult = new WriteResult(WriteStatus.OK, removedValue);
                    results.add(removeResult);
                    if (removedValue != null) {
                        tableModificationEvent = TableModificationEvent.rowDeleted(request.tableName(), request.key(), removedValue);
                    }
                    break;
                default:
                    log.error("Invalid WriteRequest type {}", request.type());
                    break;
            }
        }
        if (tableModificationEvent != null) {
            tableModificationEvents.add(tableModificationEvent);
        }
    }
    // notify listeners of table mod events.
    updatesExecutor.submit(new Runnable() {

        @Override
        public void run() {
            for (DatabaseUpdateEventListener listener : listeners) {
                for (TableModificationEvent tableModificationEvent : tableModificationEvents) {
                    // log.info("Publishing table modification event: {}", tableModificationEvent);
                    listener.tableModified(tableModificationEvent);
                }
            }
        }
    });
    return results;
}
#method_after
@Command
public List<WriteResult> write(BatchWriteRequest batchRequest) {
    // applicability check
    boolean abort = false;
    List<WriteResult> results = new ArrayList<>(batchRequest.batchSize());
    for (WriteRequest request : batchRequest.getAsList()) {
        Map<String, VersionedValue> table = state.getTable(request.tableName());
        if (table == null) {
            results.add(new WriteResult(WriteStatus.NO_SUCH_TABLE, null));
            abort = true;
            continue;
        }
        final VersionedValue value = table.get(request.key());
        WriteStatus result = checkIfApplicable(request, value);
        results.add(new WriteResult(result, value));
        if (result != WriteStatus.OK) {
            abort = true;
        }
    }
    if (abort) {
        for (int i = 0; i < results.size(); ++i) {
            if (results.get(i).status() == WriteStatus.OK) {
                results.set(i, new WriteResult(WriteStatus.ABORTED, null));
            }
        }
        return results;
    }
    List<TableModificationEvent> tableModificationEvents = Lists.newLinkedList();
    // apply changes
    for (WriteRequest request : batchRequest.getAsList()) {
        Map<String, VersionedValue> table = state.getTable(request.tableName());
        TableModificationEvent tableModificationEvent = null;
        // TODO: If we need isolation, we need to block reads also
        synchronized (table) {
            switch(request.type()) {
                case PUT:
                case PUT_IF_ABSENT:
                case PUT_IF_VALUE:
                case PUT_IF_VERSION:
                    VersionedValue newValue = new VersionedValue(request.newValue(), state.nextVersion());
                    VersionedValue previousValue = table.put(request.key(), newValue);
                    WriteResult putResult = new WriteResult(WriteStatus.OK, previousValue);
                    results.add(putResult);
                    tableModificationEvent = (previousValue == null) ? TableModificationEvent.rowAdded(request.tableName(), request.key(), newValue) : TableModificationEvent.rowUpdated(request.tableName(), request.key(), newValue);
                    break;
                case REMOVE:
                case REMOVE_IF_VALUE:
                case REMOVE_IF_VERSION:
                    VersionedValue removedValue = table.remove(request.key());
                    WriteResult removeResult = new WriteResult(WriteStatus.OK, removedValue);
                    results.add(removeResult);
                    if (removedValue != null) {
                        tableModificationEvent = TableModificationEvent.rowDeleted(request.tableName(), request.key(), removedValue);
                    }
                    break;
                default:
                    log.error("Invalid WriteRequest type {}", request.type());
                    break;
            }
        }
        if (tableModificationEvent != null) {
            tableModificationEvents.add(tableModificationEvent);
        }
    }
    // notify listeners of table mod events.
    updatesExecutor.submit(new Runnable() {

        @Override
        public void run() {
            for (DatabaseUpdateEventListener listener : listeners) {
                for (TableModificationEvent tableModificationEvent : tableModificationEvents) {
                    log.trace("Publishing table modification event: {}", tableModificationEvent);
                    listener.tableModified(tableModificationEvent);
                }
            }
        }
    });
    return results;
}
#end_block

#method_before
@Override
public void tableModified(TableModificationEvent event) {
    log.debug("Received a table modification event {}", event);
    if (!tableEntryExpirationMap.containsKey(event.tableName())) {
        return;
    }
    Map<DatabaseRow, Long> map = tableEntryExpirationMap.get(event.tableName());
    DatabaseRow row = new DatabaseRow(event.tableName(), event.key());
    Long eventVersion = event.value().version();
    switch(event.type()) {
        case ROW_DELETED:
            map.remove(row, eventVersion);
            if (isLocalMemberLeader.get()) {
                try {
                    clusterCommunicator.broadcastIncludeSelf(new ClusterMessage(localNode.id(), DatabaseStateMachine.DATABASE_UPDATE_EVENTS, DatabaseStateMachine.SERIALIZER.encode(event)));
                } catch (IOException e) {
                    log.error("Failed to broadcast a database row deleted event.", e);
                }
            }
            break;
        case ROW_ADDED:
        case ROW_UPDATED:
            // To account for potential reordering of notifications,
            // check to make sure we are replacing an old version with a new version
            Long currentVersion = map.get(row);
            if (currentVersion == null || currentVersion < eventVersion) {
                map.put(row, eventVersion);
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void tableModified(TableModificationEvent event) {
    log.debug("{}: Received {}", localNode.id(), event);
    if (!tableEntryExpirationMap.containsKey(event.tableName())) {
        return;
    }
    Map<DatabaseRow, Long> map = tableEntryExpirationMap.get(event.tableName());
    DatabaseRow row = new DatabaseRow(event.tableName(), event.key());
    Long eventVersion = event.value().version();
    switch(event.type()) {
        case ROW_DELETED:
            map.remove(row, eventVersion);
            if (isLocalMemberLeader.get()) {
                try {
                    log.debug("Broadcasting {} to the entire cluster", event);
                    clusterCommunicator.broadcastIncludeSelf(new ClusterMessage(localNode.id(), DatabaseStateMachine.DATABASE_UPDATE_EVENTS, DatabaseStateMachine.SERIALIZER.encode(event)));
                } catch (IOException e) {
                    log.error("Failed to broadcast a database row deleted event.", e);
                }
            }
            break;
        case ROW_ADDED:
        case ROW_UPDATED:
            // To account for potential reordering of notifications,
            // check to make sure we are replacing an old version with a new version
            Long currentVersion = map.get(row);
            if (currentVersion == null || currentVersion < eventVersion) {
                map.put(row, eventVersion);
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void expired(DatabaseRow row, Long version) {
    log.debug("Received an expiration event for row: {}, version: {}", row, version);
    Map<DatabaseRow, Long> map = tableEntryExpirationMap.get(row.tableName);
    try {
        if (isLocalMemberLeader.get()) {
            if (!databaseService.removeIfVersionMatches(row.tableName, row.key, version)) {
                log.info("Entry in database was updated right before its expiration.");
            } else {
                log.info("Successfully expired old entry with key ({}) from table ({})", row.key, row.tableName);
            }
        } else {
            // Everyone else function as standby just in case they need to take over
            if (map != null) {
                map.putIfAbsent(row, version);
            }
        }
    } catch (Exception e) {
        log.warn("Failed to delete entry from the database after ttl " + "expiration. Operation will be retried.", e);
        map.putIfAbsent(row, version);
    }
}
#method_after
@Override
public void expired(DatabaseRow row, Long version) {
    THREAD_POOL.submit(new ExpirationTask(row, version));
}
#end_block

#method_before
@Override
public void handle(LeaderElectEvent event) {
    isLocalMemberLeader.set(localMember.equals(event.leader()));
}
#method_after
@Override
public void handle(LeaderElectEvent event) {
    isLocalMemberLeader.set(localMember.equals(event.leader()));
    if (isLocalMemberLeader.get()) {
        log.info("{} is now the leader of Raft cluster", localNode.id());
    }
}
#end_block

#method_before
@Override
public void snapshotInstalled(State state) {
    if (!tableEntryExpirationMap.isEmpty()) {
        return;
    }
    for (String tableName : state.getTableNames()) {
        TableMetadata metadata = state.getTableMetadata(tableName);
        if (!metadata.expireOldEntries()) {
            continue;
        }
        Map<DatabaseRow, Long> tableExpirationMap = ExpiringMap.builder().expiration(metadata.ttlMillis(), TimeUnit.MILLISECONDS).expirationListener(expirationObserver).expirationPolicy(ExpirationPolicy.CREATED).build();
        for (Map.Entry<String, VersionedValue> entry : state.getTable(tableName).entrySet()) {
            tableExpirationMap.put(new DatabaseRow(tableName, entry.getKey()), entry.getValue().version());
        }
        tableEntryExpirationMap.put(tableName, tableExpirationMap);
    }
}
#method_after
@Override
public void snapshotInstalled(State state) {
    if (!tableEntryExpirationMap.isEmpty()) {
        return;
    }
    log.debug("Received a snapshot installed notification");
    for (String tableName : state.getTableNames()) {
        TableMetadata metadata = state.getTableMetadata(tableName);
        if (!metadata.expireOldEntries()) {
            continue;
        }
        Map<DatabaseRow, Long> tableExpirationMap = ExpiringMap.builder().expiration(metadata.ttlMillis(), TimeUnit.MILLISECONDS).expirationListener(expirationObserver).expirationPolicy(ExpirationPolicy.CREATED).build();
        for (Map.Entry<String, VersionedValue> entry : state.getTable(tableName).entrySet()) {
            tableExpirationMap.put(new DatabaseRow(tableName, entry.getKey()), entry.getValue().version());
        }
        tableEntryExpirationMap.put(tableName, tableExpirationMap);
    }
}
#end_block

#method_before
static P4InfoBrowser getP4InfoBrowser(PiPipeconf pipeconf) {
    try {
        return BROWSERS.get(pipeconf.id(), () -> {
            P4Info p4info = PipeconfHelper.getP4Info(pipeconf);
            if (p4info == null) {
                return null;
            } else {
                return new P4InfoBrowser(p4info);
            }
        });
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}
#method_after
static P4InfoBrowser getP4InfoBrowser(PiPipeconf pipeconf) {
    try {
        return BROWSERS.get(pipeconf.id(), () -> {
            P4Info p4info = PipeconfHelper.getP4Info(pipeconf);
            if (p4info == null) {
                return null;
            } else {
                return new P4InfoBrowser(p4info);
            }
        });
    } catch (ExecutionException e) {
        log.error("Exception while accessing the P4InfoBrowser cache", e);
        return null;
    }
}
#end_block

#method_before
public void init() {
    PwaasConfig config = cfgService.getConfig(srManager.appId(), PwaasConfig.class);
    if (config == null) {
        return;
    }
    log.info("Deploying already pre-existing pseudowires!");
    // gather pseudowires
    Set<DefaultL2TunnelDescription> pwToAdd = config.getPwIds().stream().map(config::getPwDescription).collect(Collectors.toSet());
    // deploy pseudowires
    deploy(pwToAdd);
}
#method_after
public void init() {
    PwaasConfig config = srManager.cfgService.getConfig(srManager.appId(), PwaasConfig.class);
    if (config == null) {
        return;
    }
    log.info("Deploying existing pseudowires");
    // gather pseudowires
    Set<DefaultL2TunnelDescription> pwToAdd = config.getPwIds().stream().map(config::getPwDescription).collect(Collectors.toSet());
    // deploy pseudowires
    deploy(pwToAdd);
}
#end_block

#method_before
private PortDescription buildPortDescription14(OFPortDesc port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    boolean adminDown = port.getConfig().contains(OFPortConfig.PORT_DOWN);
    Builder annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString(), adminDown);
    Optional<OFPortDescPropEthernet> ether = port.getProperties().stream().filter(OFPortDescPropEthernet.class::isInstance).map(OFPortDescPropEthernet.class::cast).findAny();
    if (ether.isPresent()) {
        // TODO parse other part of OFPortDescPropEthernet if necessary
        return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
    }
    Optional<OFPortDescPropOptical> optical = port.getProperties().stream().filter(OFPortDescPropOptical.class::isInstance).map(OFPortDescPropOptical.class::cast).findAny();
    if (optical.isPresent()) {
        // optical port
        // FIXME is there a OF version neutral way to access
        // OFOpticalPortFeaturesSerializerVer14
        long supported = optical.get().getSupported();
        long rxMin = optical.get().getRxMinFreqLmda();
        long rxMax = optical.get().getRxMaxFreqLmda();
        long rxGrid = optical.get().getRxGridFreqLmda();
        long txMin = optical.get().getTxMinFreqLmda();
        long txMax = optical.get().getTxMaxFreqLmda();
        long txGrid = optical.get().getTxGridFreqLmda();
        // wire value for OFOpticalPortFeatures.USE_FREQ
        long useFreq = OFOpticalPortFeaturesSerializerVer14.USE_FREQ_VAL;
        if ((supported & useFreq) != 0) {
            // unit is in Frequency Mhz
            annotations.set(AK_RX_MIN_FREQ_HZ, mhzToAnnotation(rxMin));
            annotations.set(AK_RX_MAX_FREQ_HZ, mhzToAnnotation(rxMax));
            annotations.set(AK_RX_GRID_HZ, mhzToAnnotation(rxGrid));
            annotations.set(AK_TX_MIN_FREQ_HZ, mhzToAnnotation(txMin));
            annotations.set(AK_TX_MAX_FREQ_HZ, mhzToAnnotation(txMax));
            annotations.set(AK_TX_GRID_HZ, mhzToAnnotation(txGrid));
            // unless Device models Tx/Rx ports as separate port
            if (rxMin == txMin) {
                annotations.set(AK_MIN_FREQ_HZ, mhzToAnnotation(rxMin));
            }
            if (rxMax == txMax) {
                annotations.set(AK_MAX_FREQ_HZ, mhzToAnnotation(rxMax));
            }
            if (rxGrid == txGrid) {
                annotations.set(AK_GRID_HZ, mhzToAnnotation(rxGrid));
            }
        } else {
            // unit is in Lambda nm * 100
            annotations.set(AK_RX_MIN_FREQ_HZ, lambdaToAnnotationHz(rxMin));
            annotations.set(AK_RX_MAX_FREQ_HZ, lambdaToAnnotationHz(rxMax));
            annotations.set(AK_RX_GRID_HZ, lambdaToAnnotationHz(rxGrid));
            annotations.set(AK_TX_MIN_FREQ_HZ, lambdaToAnnotationHz(txMin));
            annotations.set(AK_TX_MAX_FREQ_HZ, lambdaToAnnotationHz(txMax));
            annotations.set(AK_TX_GRID_HZ, lambdaToAnnotationHz(txGrid));
            // unless Device models Tx/Rx ports as separate port
            if (rxMin == txMin) {
                annotations.set(AK_MIN_FREQ_HZ, lambdaToAnnotationHz(rxMin));
            }
            if (rxMax == txMax) {
                annotations.set(AK_MAX_FREQ_HZ, lambdaToAnnotationHz(rxMax));
            }
            if (rxGrid == txGrid) {
                annotations.set(AK_GRID_HZ, lambdaToAnnotationHz(rxGrid));
            }
        }
        // TODO parse other part of OFPortDescPropOptical
        // Tx/Rx tunable, ...
        // Power is configurable or now
        int txPwr = OFOpticalPortFeaturesSerializerVer14.TX_PWR_VAL;
        if ((supported & txPwr) != 0) {
            long txPwrMin = optical.get().getTxPwrMin();
            annotations.set(AK_TX_PWR_MIN, Long.toString(txPwrMin));
            long txPwrMax = optical.get().getTxPwrMax();
            annotations.set(AK_TX_PWR_MAX, Long.toString(txPwrMax));
        }
        return new DefaultPortDescription(portNo, enabled, FIBER, portSpeed(port), annotations.build());
    }
    // fall back default
    return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
}
#method_after
private PortDescription buildPortDescription14(OFPortDesc port) {
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    boolean adminDown = port.getConfig().contains(OFPortConfig.PORT_DOWN);
    Builder annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString(), adminDown);
    Optional<OFPortDescPropEthernet> ether = port.getProperties().stream().filter(OFPortDescPropEthernet.class::isInstance).map(OFPortDescPropEthernet.class::cast).findAny();
    if (ether.isPresent()) {
        // TODO parse other part of OFPortDescPropEthernet if necessary
        return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
    }
    Optional<OFPortDescPropOptical> optical = port.getProperties().stream().filter(OFPortDescPropOptical.class::isInstance).map(OFPortDescPropOptical.class::cast).findAny();
    if (optical.isPresent()) {
        // optical port
        // FIXME is there a OF version neutral way to access
        // OFOpticalPortFeaturesSerializerVer14
        long supported = optical.get().getSupported();
        long rxMin = optical.get().getRxMinFreqLmda();
        long rxMax = optical.get().getRxMaxFreqLmda();
        long rxGrid = optical.get().getRxGridFreqLmda();
        long txMin = optical.get().getTxMinFreqLmda();
        long txMax = optical.get().getTxMaxFreqLmda();
        long txGrid = optical.get().getTxGridFreqLmda();
        int txTune = OFOpticalPortFeaturesSerializerVer14.TX_TUNE_VAL;
        int rxTune = OFOpticalPortFeaturesSerializerVer14.RX_TUNE_VAL;
        annotations.set(AK_TX_TUNE_FEATURE, ((supported & txTune) != 0) ? "enabled" : "disabled");
        annotations.set(AK_RX_TUNE_FEATURE, ((supported & rxTune) != 0) ? "enabled" : "disabled");
        // wire value for OFOpticalPortFeatures.USE_FREQ
        long useFreq = OFOpticalPortFeaturesSerializerVer14.USE_FREQ_VAL;
        if ((supported & useFreq) != 0) {
            // unit is in Frequency Mhz
            annotations.set(AK_RX_MIN_FREQ_HZ, mhzToAnnotation(rxMin));
            annotations.set(AK_RX_MAX_FREQ_HZ, mhzToAnnotation(rxMax));
            annotations.set(AK_RX_GRID_HZ, mhzToAnnotation(rxGrid));
            annotations.set(AK_TX_MIN_FREQ_HZ, mhzToAnnotation(txMin));
            annotations.set(AK_TX_MAX_FREQ_HZ, mhzToAnnotation(txMax));
            annotations.set(AK_TX_GRID_HZ, mhzToAnnotation(txGrid));
            // unless Device models Tx/Rx ports as separate port
            if (rxMin == txMin) {
                annotations.set(AK_MIN_FREQ_HZ, mhzToAnnotation(rxMin));
            }
            if (rxMax == txMax) {
                annotations.set(AK_MAX_FREQ_HZ, mhzToAnnotation(rxMax));
            }
            if (rxGrid == txGrid) {
                annotations.set(AK_GRID_HZ, mhzToAnnotation(rxGrid));
            }
        } else {
            // unit is in Lambda nm * 100
            annotations.set(AK_RX_MIN_FREQ_HZ, lambdaToAnnotationHz(rxMin));
            annotations.set(AK_RX_MAX_FREQ_HZ, lambdaToAnnotationHz(rxMax));
            annotations.set(AK_RX_GRID_HZ, lambdaToAnnotationHz(rxGrid));
            annotations.set(AK_TX_MIN_FREQ_HZ, lambdaToAnnotationHz(txMin));
            annotations.set(AK_TX_MAX_FREQ_HZ, lambdaToAnnotationHz(txMax));
            annotations.set(AK_TX_GRID_HZ, lambdaToAnnotationHz(txGrid));
            // unless Device models Tx/Rx ports as separate port
            if (rxMin == txMin) {
                annotations.set(AK_MIN_FREQ_HZ, lambdaToAnnotationHz(rxMin));
            }
            if (rxMax == txMax) {
                annotations.set(AK_MAX_FREQ_HZ, lambdaToAnnotationHz(rxMax));
            }
            if (rxGrid == txGrid) {
                annotations.set(AK_GRID_HZ, lambdaToAnnotationHz(rxGrid));
            }
        }
        int txPwr = OFOpticalPortFeaturesSerializerVer14.TX_PWR_VAL;
        long txPwrMin = optical.get().getTxPwrMin();
        long txPwrMax = optical.get().getTxPwrMax();
        annotations.set(AK_TX_PWR_FEATURE, ((supported & txPwr) != 0) ? "enabled" : "disabled");
        annotations.set(AK_TX_PWR_MIN, Long.toString(txPwrMin));
        annotations.set(AK_TX_PWR_MAX, Long.toString(txPwrMax));
        return new DefaultPortDescription(portNo, enabled, FIBER, portSpeed(port), annotations.build());
    }
    // fall back default
    return new DefaultPortDescription(portNo, enabled, COPPER, portSpeed(port), annotations.build());
}
#end_block

#method_before
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.serviceDirectory = context.directory();
    this.deviceId = deviceId;
    coreService = serviceDirectory.get(CoreService.class);
    flowRuleService = serviceDirectory.get(FlowRuleService.class);
    groupService = serviceDirectory.get(GroupService.class);
    meterService = serviceDirectory.get(MeterService.class);
    deviceService = serviceDirectory.get(DeviceService.class);
    flowObjectiveStore = context.store();
    appId = coreService.registerApplication(APPLICATION_ID);
    // Initialization of model specific features
    initializePipeline();
}
#method_after
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.deviceId = deviceId;
    serviceDirectory = context.directory();
    coreService = serviceDirectory.get(CoreService.class);
    flowRuleService = serviceDirectory.get(FlowRuleService.class);
    groupService = serviceDirectory.get(GroupService.class);
    meterService = serviceDirectory.get(MeterService.class);
    deviceService = serviceDirectory.get(DeviceService.class);
    flowObjectiveStore = context.store();
    appId = coreService.registerApplication(APPLICATION_ID);
    device = deviceService.getDevice(deviceId);
    deviceHwVersion = device.hwVersion();
    // Initialization of model specific features
    log.info("HP Driver - Initializing unsupported features for switch {}", deviceHwVersion);
    initUnSupportedFeatures();
    log.debug("HP Driver - Initializing features supported in hardware");
    initHardwareCriteria();
    initHardwareInstructions();
    log.debug("HP Driver - Initializing pipeline");
    installHPTableZero();
    installHPHardwareTable();
    installHPSoftwareTable();
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective fwd) {
    if (fwd.treatment() != null) {
        /**
         * If UNSUPPORTED features included in ForwardingObjective a warning message is generated.
         * Flow rule is anyway sent to the device, device will reply with an OFP_ERROR.
         * Moreover, checkUnSupportedFeatures function generates further warnings specifying
         * each unsupported feature.
         */
        if (checkUnSupportedFeatures(fwd)) {
            log.warn("HP Generic Driver - specified ForwardingObjective contains UNSUPPORTED FEATURES");
        }
        /**
         * Treatment with CLEAR_ACTIONS is not supported in hardware.
         * Here a default treatment is built without CLEAR_ACTIONS.
         * Then fwd.treatment and related meter is copied.
         */
        TrafficTreatment.Builder noClearTreatment = DefaultTrafficTreatment.builder();
        fwd.treatment().allInstructions().stream().forEach(noClearTreatment::add);
        if (fwd.treatment().metered() != null) {
            noClearTreatment.meter(fwd.treatment().metered().meterId());
        }
        // TODO enable use of CLEAR actions in software table
        // Then we create a new forwarding rule without the unsupported actions
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(fwd.selector()).withTreatment(noClearTreatment.build()).withPriority(fwd.priority()).fromApp(fwd.appId());
        // Table to be used depends on the specific switch hardware and ForwardingObjective
        ruleBuilder.forTable(TableIdForForwardingObjective(fwd));
        if (fwd.permanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(fwd.timeout());
        }
        log.info("HP Generic Driver - installing fwd.treatment {}", fwd.toString());
        log.info("HP Generic Driver - installing noclear.treatment ruleBuilder {}", ruleBuilder.toString());
        installObjective(ruleBuilder, fwd);
    } else {
        NextObjective nextObjective;
        NextGroup next;
        TrafficTreatment treatment;
        if (fwd.op() == ADD) {
            // Give a try to the cache. Doing an operation
            // on the store seems to be very expensive.
            nextObjective = pendingAddNext.getIfPresent(fwd.nextId());
            // We will try with the store
            if (nextObjective == null) {
                next = flowObjectiveStore.getNextGroup(fwd.nextId());
                // the treatment in order to re-build the flow rule.
                if (next == null) {
                    fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
                    return;
                }
                treatment = appKryo.deserialize(next.data());
            } else {
                pendingAddNext.invalidate(fwd.nextId());
                treatment = nextObjective.next().iterator().next();
            }
        } else {
            // We get the NextGroup from the remove operation.
            // Doing an operation on the store seems to be very expensive.
            next = flowObjectiveStore.removeNextGroup(fwd.nextId());
            if (next == null) {
                fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
                return;
            }
            treatment = appKryo.deserialize(next.data());
        }
        // If the treatment is null we cannot re-build the original flow
        if (treatment == null) {
            fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
            return;
        }
        // Finally we build the flow rule and push to the flowrule subsystem.
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(fwd.selector()).fromApp(fwd.appId()).withPriority(fwd.priority()).withTreatment(treatment);
        if (fwd.permanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(fwd.timeout());
        }
        installObjective(ruleBuilder, fwd);
    }
}
#method_after
@Override
public void forward(ForwardingObjective fwd) {
    if (fwd.treatment() != null) {
        /**
         * If UNSUPPORTED features included in ForwardingObjective a warning message is generated.
         * FlowRule is anyway sent to the device, device will reply with an OFP_ERROR.
         * Moreover, checkUnSupportedFeatures function generates further warnings specifying
         * each unsupported feature.
         */
        if (checkUnSupportedFeatures(fwd)) {
            log.warn("HP Driver - specified ForwardingObjective contains UNSUPPORTED FEATURES");
        }
        // Create the FlowRule starting from the ForwardingObjective
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(fwd.selector()).withTreatment(fwd.treatment()).withPriority(fwd.priority()).fromApp(fwd.appId());
        // Table to be used depends on the specific switch hardware and ForwardingObjective
        ruleBuilder.forTable(tableIdForForwardingObjective(fwd));
        if (fwd.permanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(fwd.timeout());
        }
        log.debug("HP Driver - installing fwd.treatment {}", fwd.toString());
        installObjective(ruleBuilder, fwd);
    } else {
        NextObjective nextObjective;
        NextGroup next;
        TrafficTreatment treatment;
        if (fwd.op() == ADD) {
            // Give a try to the cache. Doing an operation
            // on the store seems to be very expensive.
            nextObjective = pendingAddNext.getIfPresent(fwd.nextId());
            // We will try with the store
            if (nextObjective == null) {
                next = flowObjectiveStore.getNextGroup(fwd.nextId());
                // the treatment in order to re-build the flow rule.
                if (next == null) {
                    fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
                    return;
                }
                treatment = appKryo.deserialize(next.data());
            } else {
                pendingAddNext.invalidate(fwd.nextId());
                treatment = nextObjective.next().iterator().next();
            }
        } else {
            // We get the NextGroup from the remove operation.
            // Doing an operation on the store seems to be very expensive.
            next = flowObjectiveStore.removeNextGroup(fwd.nextId());
            if (next == null) {
                fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
                return;
            }
            treatment = appKryo.deserialize(next.data());
        }
        // If the treatment is null we cannot re-build the original flow
        if (treatment == null) {
            fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
            return;
        }
        // Finally we build the flow rule and push to the flowrule subsystem.
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(fwd.selector()).fromApp(fwd.appId()).withPriority(fwd.priority()).withTreatment(treatment);
        if (fwd.permanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(fwd.timeout());
        }
        installObjective(ruleBuilder, fwd);
    }
}
#end_block

#method_before
protected void installObjective(FlowRule.Builder ruleBuilder, Objective objective) {
    FlowRuleOperations.Builder flowBuilder = FlowRuleOperations.builder();
    switch(objective.op()) {
        case ADD:
            log.trace("HP Generic Driver - Requested ADD of objective " + objective.toString());
            log.warn("HP Generic Driver - Requested ADD of objective ");
            FlowRule addRule = ruleBuilder.build();
            log.trace("HP Generic Driver - built rule is " + addRule.toString());
            flowBuilder.add(addRule);
            break;
        case REMOVE:
            log.trace("HP Generic Driver - Requested REMOVE of objective " + objective.toString());
            log.warn("HP Generic Driver - Requested REMOVE of objective ");
            FlowRule removeRule = ruleBuilder.build();
            log.trace("HP Generic Driver - built rule is " + removeRule.toString());
            flowBuilder.remove(removeRule);
            break;
        default:
            log.warn("HP Generic Driver - Unknown operation {}", objective.op());
    }
    flowRuleService.apply(flowBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            objective.context().ifPresent(context -> context.onSuccess(objective));
            log.trace("HP Generic Driver - Installed objective " + objective.toString());
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            objective.context().ifPresent(context -> context.onError(objective, ObjectiveError.FLOWINSTALLATIONFAILED));
            log.trace("HP Generic Driver - Objective installation failed" + objective.toString());
        }
    }));
}
#method_after
protected void installObjective(FlowRule.Builder ruleBuilder, Objective objective) {
    FlowRuleOperations.Builder flowBuilder = FlowRuleOperations.builder();
    switch(objective.op()) {
        case ADD:
            log.trace("HP Driver - Requested ADD of objective " + objective.toString());
            FlowRule addRule = ruleBuilder.build();
            log.trace("HP Driver - built rule is " + addRule.toString());
            flowBuilder.add(addRule);
            break;
        case REMOVE:
            log.trace("HP Driver - Requested REMOVE of objective " + objective.toString());
            FlowRule removeRule = ruleBuilder.build();
            log.trace("HP Driver - built rule is " + removeRule.toString());
            flowBuilder.remove(removeRule);
            break;
        default:
            log.warn("HP Driver - Unknown operation {}", objective.op());
    }
    flowRuleService.apply(flowBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            objective.context().ifPresent(context -> context.onSuccess(objective));
            log.trace("HP Driver - Installed objective " + objective.toString());
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            objective.context().ifPresent(context -> context.onError(objective, ObjectiveError.FLOWINSTALLATIONFAILED));
            log.trace("HP Driver - Objective installation failed" + objective.toString());
        }
    }));
}
#end_block

#method_before
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion port;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        port = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            EthCriterion eth = (EthCriterion) c;
            FlowRule.Builder rule = processEthFiler(filt, eth, port);
            rule.forDevice(deviceId).fromApp(applicationId);
            ops = install ? ops.add(rule.build()) : ops.remove(rule.build());
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            VlanIdCriterion vlan = (VlanIdCriterion) c;
            FlowRule.Builder rule = processVlanFiler(filt, vlan, port);
            rule.forDevice(deviceId).fromApp(applicationId);
            ops = install ? ops.add(rule.build()) : ops.remove(rule.build());
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            IPCriterion ip = (IPCriterion) c;
            FlowRule.Builder rule = processIpFilter(filt, ip, port);
            rule.forDevice(deviceId).fromApp(applicationId);
            ops = install ? ops.add(rule.build()) : ops.remove(rule.build());
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.trace("HP Generic Driver - Applied filtering rules");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.info("HP Generic Driver - Failed to apply filtering rules");
        }
    }));
}
#method_after
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion port;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        port = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST) {
            EthCriterion eth = (EthCriterion) c;
            FlowRule.Builder rule = processEthFilter(filt, eth, port);
            rule.forDevice(deviceId).fromApp(applicationId);
            ops = install ? ops.add(rule.build()) : ops.remove(rule.build());
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            VlanIdCriterion vlan = (VlanIdCriterion) c;
            FlowRule.Builder rule = processVlanFilter(filt, vlan, port);
            rule.forDevice(deviceId).fromApp(applicationId);
            ops = install ? ops.add(rule.build()) : ops.remove(rule.build());
        } else if (c.type() == Criterion.Type.IPV4_DST) {
            IPCriterion ip = (IPCriterion) c;
            FlowRule.Builder rule = processIpFilter(filt, ip, port);
            rule.forDevice(deviceId).fromApp(applicationId);
            ops = install ? ops.add(rule.build()) : ops.remove(rule.build());
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", c.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.trace("HP Driver - Applied filtering rules");
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.trace("HP Driver - Failed to apply filtering rules");
        }
    }));
}
#end_block

#method_before
// All GROUP types are supported in software by HP3500 switches
@Override
protected FlowRule.Builder setDefaultTableIdForFlowObjective(FlowRule.Builder ruleBuilder) {
    log.info("HP V3500 Driver - Setting default table id to software table {}", HP_SOFTWARE_TABLE);
    return ruleBuilder.forTable(HP_SOFTWARE_TABLE);
}
#method_after
@Override
protected FlowRule.Builder setDefaultTableIdForFlowObjective(FlowRule.Builder ruleBuilder) {
    log.debug("HP V3500 Driver - Setting default table id to software table {}", HP_SOFTWARE_TABLE);
    return ruleBuilder.forTable(HP_SOFTWARE_TABLE);
}
#end_block

#method_before
private void initUnSupportedFeatures() {
    // Initialize unsupported criteria
    this.unsupported_criteria.add(Criterion.Type.METADATA);
    this.unsupported_criteria.add(Criterion.Type.IP_ECN);
    this.unsupported_criteria.add(Criterion.Type.SCTP_SRC);
    this.unsupported_criteria.add(Criterion.Type.SCTP_SRC_MASKED);
    this.unsupported_criteria.add(Criterion.Type.SCTP_DST);
    this.unsupported_criteria.add(Criterion.Type.SCTP_DST_MASKED);
    this.unsupported_criteria.add(Criterion.Type.IPV6_ND_SLL);
    this.unsupported_criteria.add(Criterion.Type.IPV6_ND_TLL);
    this.unsupported_criteria.add(Criterion.Type.MPLS_LABEL);
    this.unsupported_criteria.add(Criterion.Type.MPLS_TC);
    this.unsupported_criteria.add(Criterion.Type.MPLS_BOS);
    this.unsupported_criteria.add(Criterion.Type.PBB_ISID);
    this.unsupported_criteria.add(Criterion.Type.TUNNEL_ID);
    this.unsupported_criteria.add(Criterion.Type.IPV6_EXTHDR);
    // Initialize unsupported instructions
    this.unsupported_instructions.add(Instruction.Type.QUEUE);
    this.unsupported_instructions.add(Instruction.Type.METADATA);
    this.unsupported_instructions.add(Instruction.Type.L0MODIFICATION);
    this.unsupported_instructions.add(Instruction.Type.L1MODIFICATION);
    this.unsupported_instructions.add(Instruction.Type.PROTOCOL_INDEPENDENT);
    this.unsupported_instructions.add(Instruction.Type.EXTENSION);
    this.unsupported_instructions.add(Instruction.Type.STAT_TRIGGER);
    // Initialize unsupported L2MODIFICATION actions
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.MPLS_PUSH);
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.MPLS_POP);
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.MPLS_LABEL);
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.MPLS_BOS);
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.DEC_MPLS_TTL);
    // Initialize unsupported L3MODIFICATION actions
    this.unsupported_l3mod.add(L3ModificationInstruction.L3SubType.TTL_IN);
    this.unsupported_l3mod.add(L3ModificationInstruction.L3SubType.TTL_OUT);
    this.unsupported_l3mod.add(L3ModificationInstruction.L3SubType.DEC_TTL);
// All L4MODIFICATION actions are supported
}
#method_after
@Override
protected void initUnSupportedFeatures() {
    // Initialize unsupported criteria
    unsupportedCriteria.add(Criterion.Type.METADATA);
    unsupportedCriteria.add(Criterion.Type.IP_ECN);
    unsupportedCriteria.add(Criterion.Type.SCTP_SRC);
    unsupportedCriteria.add(Criterion.Type.SCTP_SRC_MASKED);
    unsupportedCriteria.add(Criterion.Type.SCTP_DST);
    unsupportedCriteria.add(Criterion.Type.SCTP_DST_MASKED);
    unsupportedCriteria.add(Criterion.Type.IPV6_ND_SLL);
    unsupportedCriteria.add(Criterion.Type.IPV6_ND_TLL);
    unsupportedCriteria.add(Criterion.Type.MPLS_LABEL);
    unsupportedCriteria.add(Criterion.Type.MPLS_TC);
    unsupportedCriteria.add(Criterion.Type.MPLS_BOS);
    unsupportedCriteria.add(Criterion.Type.PBB_ISID);
    unsupportedCriteria.add(Criterion.Type.TUNNEL_ID);
    unsupportedCriteria.add(Criterion.Type.IPV6_EXTHDR);
    // Initialize unsupported instructions
    unsupportedInstructions.add(Instruction.Type.QUEUE);
    unsupportedInstructions.add(Instruction.Type.METADATA);
    unsupportedInstructions.add(Instruction.Type.L0MODIFICATION);
    unsupportedInstructions.add(Instruction.Type.L1MODIFICATION);
    unsupportedInstructions.add(Instruction.Type.PROTOCOL_INDEPENDENT);
    unsupportedInstructions.add(Instruction.Type.EXTENSION);
    unsupportedInstructions.add(Instruction.Type.STAT_TRIGGER);
    // Initialize unsupported L2MODIFICATION actions
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.MPLS_PUSH);
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.MPLS_POP);
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.MPLS_LABEL);
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.MPLS_BOS);
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.DEC_MPLS_TTL);
    // Initialize unsupported L3MODIFICATION actions
    unsupportedL3mod.add(L3ModificationInstruction.L3SubType.TTL_IN);
    unsupportedL3mod.add(L3ModificationInstruction.L3SubType.TTL_OUT);
    unsupportedL3mod.add(L3ModificationInstruction.L3SubType.DEC_TTL);
// All L4MODIFICATION actions are supported
}
#end_block

#method_before
protected void initHardwareCriteria() {
    log.info("HP V3500 Driver - Initializing hardware supported criteria");
    hardware_criteria.add(Criterion.Type.IN_PORT);
    hardware_criteria.add(Criterion.Type.VLAN_VID);
    // Match in hardware is supported only for ETH_TYPE == IPv4 (0x0800)
    hardware_criteria.add(Criterion.Type.ETH_TYPE);
    hardware_criteria.add(Criterion.Type.IPV4_SRC);
    hardware_criteria.add(Criterion.Type.IPV4_DST);
    hardware_criteria.add(Criterion.Type.IP_PROTO);
    hardware_criteria.add(Criterion.Type.IP_DSCP);
    hardware_criteria.add(Criterion.Type.TCP_SRC);
    hardware_criteria.add(Criterion.Type.TCP_DST);
}
#method_after
@Override
protected void initHardwareCriteria() {
    log.debug("HP V3500 Driver - Initializing hardware supported criteria");
    hardwareCriteria.add(Criterion.Type.IN_PORT);
    hardwareCriteria.add(Criterion.Type.VLAN_VID);
    // Match in hardware is supported only for ETH_TYPE == IPv4 (0x0800)
    hardwareCriteria.add(Criterion.Type.ETH_TYPE);
    hardwareCriteria.add(Criterion.Type.IPV4_SRC);
    hardwareCriteria.add(Criterion.Type.IPV4_DST);
    hardwareCriteria.add(Criterion.Type.IP_PROTO);
    hardwareCriteria.add(Criterion.Type.IP_DSCP);
    hardwareCriteria.add(Criterion.Type.TCP_SRC);
    hardwareCriteria.add(Criterion.Type.TCP_DST);
}
#end_block

#method_before
protected void initHardwareInstructions() {
    log.info("HP V3500 Driver - Initializing hardware supported instructions");
    // If the output is on CONTROLLER PORT the rule is processed in software
    hardware_instructions.add(Instruction.Type.OUTPUT);
    // Only modification of VLAN priority (VLAN_PCP) is supported in hardware
    hardware_instructions.add(Instruction.Type.L2MODIFICATION);
    hardware_instructions_l2mod.add(L2ModificationInstruction.L2SubType.VLAN_PCP);
// TODO also L3MODIFICATION of IP_DSCP is supported in hardware
}
#method_after
@Override
protected void initHardwareInstructions() {
    log.debug("HP V3500 Driver - Initializing hardware supported instructions");
    // If the output is on CONTROLLER PORT the rule is processed in software
    hardwareInstructions.add(Instruction.Type.OUTPUT);
    // Only modification of VLAN priority (VLAN_PCP) is supported in hardware
    hardwareInstructions.add(Instruction.Type.L2MODIFICATION);
    hardwareInstructionsL2mod.add(L2ModificationInstruction.L2SubType.VLAN_PCP);
// TODO also L3MODIFICATION of IP_DSCP is supported in hardware
}
#end_block

#method_before
@Override
protected boolean checkUnSupportedFeatures(ForwardingObjective fwd) {
    boolean unsupported_features = false;
    for (Criterion criterion : fwd.selector().criteria()) {
        if (this.unsupported_criteria.contains(criterion.type())) {
            log.warn("HP V3500 Driver - unsupported criteria {}", criterion.type());
            unsupported_features = true;
        }
    }
    for (Instruction instruction : fwd.treatment().allInstructions()) {
        if (this.unsupported_instructions.contains(instruction.type())) {
            log.warn("HP V3500 Driver - unsupported instruction {}", instruction.type());
            unsupported_features = true;
        }
        if (instruction.type() == Instruction.Type.L2MODIFICATION) {
            if (this.unsupported_l2mod.contains(((L2ModificationInstruction) instruction).subtype())) {
                log.warn("HP V3500 Driver - unsupported L2MODIFICATION instruction {}", ((L2ModificationInstruction) instruction).subtype());
                unsupported_features = true;
            }
        }
        if (instruction.type() == Instruction.Type.L3MODIFICATION) {
            if (this.unsupported_l3mod.contains(((L3ModificationInstruction) instruction).subtype())) {
                log.warn("HP V3500 Driver - unsupported L3MODIFICATION instruction {}", ((L3ModificationInstruction) instruction).subtype());
                unsupported_features = true;
            }
        }
    }
    return unsupported_features;
}
#method_after
@Override
protected boolean checkUnSupportedFeatures(ForwardingObjective fwd) {
    boolean unsupportedFeatures = false;
    for (Criterion criterion : fwd.selector().criteria()) {
        if (this.unsupportedCriteria.contains(criterion.type())) {
            log.warn("HP V3500 Driver - unsupported criteria {}", criterion.type());
            unsupportedFeatures = true;
        }
    }
    for (Instruction instruction : fwd.treatment().allInstructions()) {
        if (this.unsupportedInstructions.contains(instruction.type())) {
            log.warn("HP V3500 Driver - unsupported instruction {}", instruction.type());
            unsupportedFeatures = true;
        }
        if (instruction.type() == Instruction.Type.L2MODIFICATION) {
            if (this.unsupportedL2mod.contains(((L2ModificationInstruction) instruction).subtype())) {
                log.warn("HP V3500 Driver - unsupported L2MODIFICATION instruction {}", ((L2ModificationInstruction) instruction).subtype());
                unsupportedFeatures = true;
            }
        }
        if (instruction.type() == Instruction.Type.L3MODIFICATION) {
            if (this.unsupportedL3mod.contains(((L3ModificationInstruction) instruction).subtype())) {
                log.warn("HP V3500 Driver - unsupported L3MODIFICATION instruction {}", ((L3ModificationInstruction) instruction).subtype());
                unsupportedFeatures = true;
            }
        }
    }
    return unsupportedFeatures;
}
#end_block

#method_before
private void initUnSupportedFeatures() {
    // Initialize unsupported criteria
    this.unsupported_criteria.add(Criterion.Type.METADATA);
    this.unsupported_criteria.add(Criterion.Type.IP_ECN);
    this.unsupported_criteria.add(Criterion.Type.SCTP_SRC);
    this.unsupported_criteria.add(Criterion.Type.SCTP_SRC_MASKED);
    this.unsupported_criteria.add(Criterion.Type.SCTP_DST);
    this.unsupported_criteria.add(Criterion.Type.SCTP_DST_MASKED);
    this.unsupported_criteria.add(Criterion.Type.IPV6_ND_SLL);
    this.unsupported_criteria.add(Criterion.Type.IPV6_ND_TLL);
    this.unsupported_criteria.add(Criterion.Type.MPLS_LABEL);
    this.unsupported_criteria.add(Criterion.Type.MPLS_TC);
    this.unsupported_criteria.add(Criterion.Type.MPLS_BOS);
    this.unsupported_criteria.add(Criterion.Type.PBB_ISID);
    this.unsupported_criteria.add(Criterion.Type.TUNNEL_ID);
    this.unsupported_criteria.add(Criterion.Type.IPV6_EXTHDR);
    // Initialize unsupported instructions
    this.unsupported_instructions.add(Instruction.Type.QUEUE);
    this.unsupported_instructions.add(Instruction.Type.METADATA);
    this.unsupported_instructions.add(Instruction.Type.L0MODIFICATION);
    this.unsupported_instructions.add(Instruction.Type.L1MODIFICATION);
    this.unsupported_instructions.add(Instruction.Type.PROTOCOL_INDEPENDENT);
    this.unsupported_instructions.add(Instruction.Type.EXTENSION);
    this.unsupported_instructions.add(Instruction.Type.STAT_TRIGGER);
    // Initialize unsupportet L2MODIFICATION actions
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.MPLS_PUSH);
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.MPLS_POP);
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.MPLS_LABEL);
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.MPLS_BOS);
    this.unsupported_l2mod.add(L2ModificationInstruction.L2SubType.DEC_MPLS_TTL);
    // Initialize unsupported L3MODIFICATION actions
    this.unsupported_l3mod.add(L3ModificationInstruction.L3SubType.TTL_IN);
    this.unsupported_l3mod.add(L3ModificationInstruction.L3SubType.TTL_OUT);
    this.unsupported_l3mod.add(L3ModificationInstruction.L3SubType.DEC_TTL);
// All L4MODIFICATION actions are supported
}
#method_after
@Override
protected void initUnSupportedFeatures() {
    // Initialize unsupported criteria
    unsupportedCriteria.add(Criterion.Type.METADATA);
    unsupportedCriteria.add(Criterion.Type.IP_ECN);
    unsupportedCriteria.add(Criterion.Type.SCTP_SRC);
    unsupportedCriteria.add(Criterion.Type.SCTP_SRC_MASKED);
    unsupportedCriteria.add(Criterion.Type.SCTP_DST);
    unsupportedCriteria.add(Criterion.Type.SCTP_DST_MASKED);
    unsupportedCriteria.add(Criterion.Type.IPV6_ND_SLL);
    unsupportedCriteria.add(Criterion.Type.IPV6_ND_TLL);
    unsupportedCriteria.add(Criterion.Type.MPLS_LABEL);
    unsupportedCriteria.add(Criterion.Type.MPLS_TC);
    unsupportedCriteria.add(Criterion.Type.MPLS_BOS);
    unsupportedCriteria.add(Criterion.Type.PBB_ISID);
    unsupportedCriteria.add(Criterion.Type.TUNNEL_ID);
    unsupportedCriteria.add(Criterion.Type.IPV6_EXTHDR);
    // Initialize unsupported instructions
    unsupportedInstructions.add(Instruction.Type.QUEUE);
    unsupportedInstructions.add(Instruction.Type.METADATA);
    unsupportedInstructions.add(Instruction.Type.L0MODIFICATION);
    unsupportedInstructions.add(Instruction.Type.L1MODIFICATION);
    unsupportedInstructions.add(Instruction.Type.PROTOCOL_INDEPENDENT);
    unsupportedInstructions.add(Instruction.Type.EXTENSION);
    unsupportedInstructions.add(Instruction.Type.STAT_TRIGGER);
    // Initialize unsupportet L2MODIFICATION actions
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.MPLS_PUSH);
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.MPLS_POP);
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.MPLS_LABEL);
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.MPLS_BOS);
    unsupportedL2mod.add(L2ModificationInstruction.L2SubType.DEC_MPLS_TTL);
    // Initialize unsupported L3MODIFICATION actions
    unsupportedL3mod.add(L3ModificationInstruction.L3SubType.TTL_IN);
    unsupportedL3mod.add(L3ModificationInstruction.L3SubType.TTL_OUT);
    unsupportedL3mod.add(L3ModificationInstruction.L3SubType.DEC_TTL);
// All L4MODIFICATION actions are supported
}
#end_block

#method_before
protected void initHardwareCriteria() {
    log.debug("HP V3800 Driver - Initializing hardware supported criteria");
    hardware_criteria.add(Criterion.Type.IN_PORT);
    hardware_criteria.add(Criterion.Type.VLAN_VID);
    hardware_criteria.add(Criterion.Type.VLAN_PCP);
    // Match in hardware is not supported ETH_TYPE == VLAN (0x8100)
    hardware_criteria.add(Criterion.Type.ETH_TYPE);
    hardware_criteria.add(Criterion.Type.ETH_SRC);
    hardware_criteria.add(Criterion.Type.ETH_DST);
    hardware_criteria.add(Criterion.Type.IPV4_SRC);
    hardware_criteria.add(Criterion.Type.IPV4_DST);
    hardware_criteria.add(Criterion.Type.IP_PROTO);
    hardware_criteria.add(Criterion.Type.IP_DSCP);
    hardware_criteria.add(Criterion.Type.TCP_SRC);
    hardware_criteria.add(Criterion.Type.TCP_DST);
}
#method_after
@Override
protected void initHardwareCriteria() {
    log.debug("HP V3800 Driver - Initializing hardware supported criteria");
    hardwareCriteria.add(Criterion.Type.IN_PORT);
    hardwareCriteria.add(Criterion.Type.VLAN_VID);
    hardwareCriteria.add(Criterion.Type.VLAN_PCP);
    // Match in hardware is not supported ETH_TYPE == VLAN (0x8100)
    hardwareCriteria.add(Criterion.Type.ETH_TYPE);
    hardwareCriteria.add(Criterion.Type.ETH_SRC);
    hardwareCriteria.add(Criterion.Type.ETH_DST);
    hardwareCriteria.add(Criterion.Type.IPV4_SRC);
    hardwareCriteria.add(Criterion.Type.IPV4_DST);
    hardwareCriteria.add(Criterion.Type.IP_PROTO);
    hardwareCriteria.add(Criterion.Type.IP_DSCP);
    hardwareCriteria.add(Criterion.Type.TCP_SRC);
    hardwareCriteria.add(Criterion.Type.TCP_DST);
}
#end_block

#method_before
protected void initHardwareInstructions() {
    log.info("HP V3800 Driver - Initializing hardware supported instructions");
    hardware_instructions.add(Instruction.Type.OUTPUT);
    // Only modification of VLAN priority (VLAN_PCP) is supported in hardware
    hardware_instructions.add(Instruction.Type.L2MODIFICATION);
    hardware_instructions_l2mod.add(L2ModificationInstruction.L2SubType.ETH_SRC);
    hardware_instructions_l2mod.add(L2ModificationInstruction.L2SubType.ETH_DST);
    hardware_instructions_l2mod.add(L2ModificationInstruction.L2SubType.VLAN_ID);
    hardware_instructions_l2mod.add(L2ModificationInstruction.L2SubType.VLAN_PCP);
    // Only GROUP of type ALL is supported in hardware
    // Moreover, for hardware support, each bucket must contain one and only one instruction of type OUTPUT
    hardware_instructions.add(Instruction.Type.GROUP);
    hardware_groups.add(Group.Type.ALL);
// TODO also L3MODIFICATION of IP_DSCP is supported in hardware
}
#method_after
@Override
protected void initHardwareInstructions() {
    log.debug("HP V3800 Driver - Initializing hardware supported instructions");
    hardwareInstructions.add(Instruction.Type.OUTPUT);
    // Only modification of VLAN priority (VLAN_PCP) is supported in hardware
    hardwareInstructions.add(Instruction.Type.L2MODIFICATION);
    hardwareInstructionsL2mod.add(L2ModificationInstruction.L2SubType.ETH_SRC);
    hardwareInstructionsL2mod.add(L2ModificationInstruction.L2SubType.ETH_DST);
    hardwareInstructionsL2mod.add(L2ModificationInstruction.L2SubType.VLAN_ID);
    hardwareInstructionsL2mod.add(L2ModificationInstruction.L2SubType.VLAN_PCP);
    // Only GROUP of type ALL is supported in hardware
    // Moreover, for hardware support, each bucket must contain one and only one instruction of type OUTPUT
    hardwareInstructions.add(Instruction.Type.GROUP);
    hardwareGroups.add(Group.Type.ALL);
// TODO also L3MODIFICATION of IP_DSCP is supported in hardware
}
#end_block

#method_before
@Override
protected boolean checkUnSupportedFeatures(ForwardingObjective fwd) {
    boolean unsupported_features = false;
    for (Criterion criterion : fwd.selector().criteria()) {
        if (this.unsupported_criteria.contains(criterion.type())) {
            log.warn("HP V3800 Driver - unsupported criteria {}", criterion.type());
            unsupported_features = true;
        }
    }
    for (Instruction instruction : fwd.treatment().allInstructions()) {
        if (this.unsupported_instructions.contains(instruction.type())) {
            log.warn("HP V3800 Driver - unsupported instruction {}", instruction.type());
            unsupported_features = true;
        }
        if (instruction.type() == Instruction.Type.L2MODIFICATION) {
            if (this.unsupported_l2mod.contains(((L2ModificationInstruction) instruction).subtype())) {
                log.warn("HP V3800 Driver - unsupported L2MODIFICATION instruction {}", ((L2ModificationInstruction) instruction).subtype());
                unsupported_features = true;
            }
        }
        if (instruction.type() == Instruction.Type.L3MODIFICATION) {
            if (this.unsupported_l3mod.contains(((L3ModificationInstruction) instruction).subtype())) {
                log.warn("HP V3800 Driver - unsupported L3MODIFICATION instruction {}", ((L3ModificationInstruction) instruction).subtype());
                unsupported_features = true;
            }
        }
    }
    return unsupported_features;
}
#method_after
@Override
protected boolean checkUnSupportedFeatures(ForwardingObjective fwd) {
    boolean unsupportedFeatures = false;
    for (Criterion criterion : fwd.selector().criteria()) {
        if (this.unsupportedCriteria.contains(criterion.type())) {
            log.warn("HP V3800 Driver - unsupported criteria {}", criterion.type());
            unsupportedFeatures = true;
        }
    }
    for (Instruction instruction : fwd.treatment().allInstructions()) {
        if (this.unsupportedInstructions.contains(instruction.type())) {
            log.warn("HP V3800 Driver - unsupported instruction {}", instruction.type());
            unsupportedFeatures = true;
        }
        if (instruction.type() == Instruction.Type.L2MODIFICATION) {
            if (this.unsupportedL2mod.contains(((L2ModificationInstruction) instruction).subtype())) {
                log.warn("HP V3800 Driver - unsupported L2MODIFICATION instruction {}", ((L2ModificationInstruction) instruction).subtype());
                unsupportedFeatures = true;
            }
        }
        if (instruction.type() == Instruction.Type.L3MODIFICATION) {
            if (this.unsupportedL3mod.contains(((L3ModificationInstruction) instruction).subtype())) {
                log.warn("HP V3800 Driver - unsupported L3MODIFICATION instruction {}", ((L3ModificationInstruction) instruction).subtype());
                unsupportedFeatures = true;
            }
        }
    }
    return unsupportedFeatures;
}
#end_block

#method_before
@Override
public void channelInactive(ChannelHandlerContext ctx) throws Exception {
    log.info("Switch disconnected callback for sw:{}. Cleaning up ...", getSwitchInfoString());
    if (dispatcher != null) {
        dispatcher.shutdown();
        SharedExecutors.getPoolThreadExecutor().submit(dispatcher::shutdownNow);
        dispatcher = null;
    }
    if (thisdpid != 0) {
        if (!duplicateDpidFound) {
            // if the disconnected switch (on this ChannelHandler)
            // was not one with a duplicate-dpid, it is safe to remove all
            // state for it at the controller. Notice that if the disconnected
            // switch was a duplicate-dpid, calling the method below would clear
            // all state for the original switch (with the same dpid),
            // which we obviously don't want.
            log.info("{}:removal called", getSwitchInfoString());
            if (sw != null) {
                sw.removeConnectedSwitch();
            }
        } else {
            // A duplicate was disconnected on this ChannelHandler,
            // this is the same switch reconnecting, but the original state was
            // not cleaned up - XXX check liveness of original ChannelHandler
            log.info("{}:duplicate found", getSwitchInfoString());
            duplicateDpidFound = Boolean.FALSE;
        }
    } else {
        log.warn("no dpid in channelHandler registered for " + "disconnected switch {}", getSwitchInfoString());
    }
}
#method_after
@Override
public void channelInactive(ChannelHandlerContext ctx) throws Exception {
    log.info("Switch disconnected callback for sw:{}. Cleaning up ...", getSwitchInfoString());
    if (dispatcher != null) {
        dispatcher.shutdownNow();
        dispatcher = null;
    }
    if (thisdpid != 0) {
        if (!duplicateDpidFound) {
            // if the disconnected switch (on this ChannelHandler)
            // was not one with a duplicate-dpid, it is safe to remove all
            // state for it at the controller. Notice that if the disconnected
            // switch was a duplicate-dpid, calling the method below would clear
            // all state for the original switch (with the same dpid),
            // which we obviously don't want.
            log.info("{}:removal called", getSwitchInfoString());
            if (sw != null) {
                sw.removeConnectedSwitch();
            }
        } else {
            // A duplicate was disconnected on this ChannelHandler,
            // this is the same switch reconnecting, but the original state was
            // not cleaned up - XXX check liveness of original ChannelHandler
            log.info("{}:duplicate found", getSwitchInfoString());
            duplicateDpidFound = Boolean.FALSE;
        }
    } else {
        log.warn("no dpid in channelHandler registered for " + "disconnected switch {}", getSwitchInfoString());
    }
}
#end_block

#method_before
@Override
protected void processPwNextObjective(NextObjective nextObjective) {
    log.info("Started deploying nextObjective for pseudowire!");
    TrafficTreatment treatment = nextObjective.next().iterator().next();
    Deque<GroupKey> gkeyChain = new ArrayDeque<>();
    GroupChainElem groupChainElem;
    GroupKey groupKey;
    GroupDescription groupDescription;
    // Now we separate the mpls actions from the l2/l3 actions
    TrafficTreatment.Builder l2L3Treatment = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder mplsTreatment = DefaultTrafficTreatment.builder();
    createL2L3AndMplsTreatments(treatment, l2L3Treatment, mplsTreatment);
    // We create the chain from mpls intf group to
    // l2 intf group.
    GroupInfo groupInfo = createL2L3ChainInternal(l2L3Treatment.build(), nextObjective.id(), nextObjective.appId(), true, nextObjective.meta(), false);
    if (groupInfo == null) {
        log.error("Could not process nextObj={} in dev:{}", nextObjective.id(), deviceId);
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.GROUPINSTALLATIONFAILED);
        return;
    }
    // We update the chain with the last two groups;
    gkeyChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
    gkeyChain.addFirst(groupInfo.nextGroupDesc().appCookie());
    // We retrieve also all mpls instructions.
    List<List<Instruction>> mplsInstructionSets = Lists.newArrayList();
    List<Instruction> mplsInstructionSet = Lists.newArrayList();
    L3ModificationInstruction l3Ins;
    for (Instruction ins : treatment.allInstructions()) {
        // Each mpls instruction set is delimited by a
        // copy ttl outward action.
        mplsInstructionSet.add(ins);
        if (ins.type() == Instruction.Type.L3MODIFICATION) {
            l3Ins = (L3ModificationInstruction) ins;
            if (l3Ins.subtype() == TTL_OUT) {
                mplsInstructionSets.add(mplsInstructionSet);
                mplsInstructionSet = Lists.newArrayList();
            }
        }
    }
    if (mplsInstructionSets.size() > MAX_DEPTH_UNPROTECTED_PW) {
        log.error("Next Objective for pseudo wire should have at " + "most {} mpls instruction sets. Next Objective Id:{}", MAX_DEPTH_UNPROTECTED_PW, nextObjective.id());
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    log.info("Size of mpls instructions is {}.", mplsInstructionSets.size());
    log.info("mpls instructions sets are {}.", mplsInstructionSets);
    int nextGid = groupInfo.nextGroupDesc().givenGroupId();
    int index;
    // this is for inter-co pws
    if (mplsInstructionSets.size() == MAX_DEPTH_UNPROTECTED_PW) {
        log.info("Creating mpls chains for inter-co pw!");
        // We deal with the label 2 group.
        index = getNextAvailableIndex();
        groupDescription = createMplsTunnelLabelGroup(nextGid, OfdpaMplsGroupSubType.MPLS_TUNNEL_LABEL_2, index, mplsInstructionSets.get(2), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        // We update the chain.
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        // We have to create tunnel label group and
        // l2 vpn group before to send the inner most
        // group. We update the nextGid.
        nextGid = groupDescription.givenGroupId();
        groupInfo = new GroupInfo(groupInfo.innerMostGroupDesc(), groupDescription);
        log.debug("Trying Label 2 Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
    }
    // inside a single co
    if (mplsInstructionSets.size() == 2) {
        log.info("Creating mpls chains for leaf-leaf pw!");
        // We deal with the label 1 group.
        index = getNextAvailableIndex();
        groupDescription = createMplsTunnelLabelGroup(nextGid, OfdpaMplsGroupSubType.MPLS_TUNNEL_LABEL_1, index, mplsInstructionSets.get(1), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        // We have to create the l2 vpn group before
        // to send the inner most group.
        nextGid = groupDescription.givenGroupId();
        groupInfo = new GroupInfo(groupInfo.innerMostGroupDesc(), groupDescription);
        log.debug("Trying Label 1 Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
        // Finally we create the l2 vpn group.
        index = getNextAvailableIndex();
        groupDescription = createMplsL2VpnGroup(nextGid, index, mplsInstructionSets.get(0), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObjective);
        updatePendingNextObjective(groupKey, ofdpaGrp);
        log.debug("Trying L2 Vpn Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
        // Finally we send the innermost group.
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    }
    // only one label is used
    if (mplsInstructionSets.size() == 1) {
        log.info("Creating mpls chains for leaf-spine pw!");
        // Finally we create the l2 vpn group.
        index = getNextAvailableIndex();
        groupDescription = createMplsL2VpnGroup(nextGid, index, mplsInstructionSets.get(0), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObjective);
        updatePendingNextObjective(groupKey, ofdpaGrp);
        log.debug("Trying L2 Vpn Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
        // Finally we send the innermost group.
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    }
}
#method_after
@Override
protected void processPwNextObjective(NextObjective nextObjective) {
    log.info("Started deploying nextObjective id={} for pseudowire", nextObjective.id());
    TrafficTreatment treatment = nextObjective.next().iterator().next();
    Deque<GroupKey> gkeyChain = new ArrayDeque<>();
    GroupChainElem groupChainElem;
    GroupKey groupKey;
    GroupDescription groupDescription;
    // Now we separate the mpls actions from the l2/l3 actions
    TrafficTreatment.Builder l2L3Treatment = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder mplsTreatment = DefaultTrafficTreatment.builder();
    createL2L3AndMplsTreatments(treatment, l2L3Treatment, mplsTreatment);
    // We create the chain from mpls intf group to
    // l2 intf group.
    GroupInfo groupInfo = createL2L3ChainInternal(l2L3Treatment.build(), nextObjective.id(), nextObjective.appId(), true, nextObjective.meta(), false);
    if (groupInfo == null) {
        log.error("Could not process nextObj={} in dev:{}", nextObjective.id(), deviceId);
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.GROUPINSTALLATIONFAILED);
        return;
    }
    // We update the chain with the last two groups;
    gkeyChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
    gkeyChain.addFirst(groupInfo.nextGroupDesc().appCookie());
    // We retrieve also all mpls instructions.
    List<List<Instruction>> mplsInstructionSets = Lists.newArrayList();
    List<Instruction> mplsInstructionSet = Lists.newArrayList();
    L3ModificationInstruction l3Ins;
    for (Instruction ins : treatment.allInstructions()) {
        // Each mpls instruction set is delimited by a
        // copy ttl outward action.
        mplsInstructionSet.add(ins);
        if (ins.type() == Instruction.Type.L3MODIFICATION) {
            l3Ins = (L3ModificationInstruction) ins;
            if (l3Ins.subtype() == TTL_OUT) {
                mplsInstructionSets.add(mplsInstructionSet);
                mplsInstructionSet = Lists.newArrayList();
            }
        }
    }
    if (mplsInstructionSets.size() > MAX_DEPTH_UNPROTECTED_PW) {
        log.error("Next Objective for pseudo wire should have at " + "most {} mpls instruction sets. Next Objective Id:{}", MAX_DEPTH_UNPROTECTED_PW, nextObjective.id());
        Ofdpa2Pipeline.fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    log.debug("Size of mpls instructions is {}.", mplsInstructionSets.size());
    log.debug("mpls instructions sets are {}.", mplsInstructionSets);
    int nextGid = groupInfo.nextGroupDesc().givenGroupId();
    int index;
    // this is for inter-co pws
    if (mplsInstructionSets.size() == MAX_DEPTH_UNPROTECTED_PW) {
        log.debug("Creating inter-co pw mpls chains with nextid {}", nextObjective.id());
        // We deal with the label 2 group.
        index = getNextAvailableIndex();
        groupDescription = createMplsTunnelLabelGroup(nextGid, OfdpaMplsGroupSubType.MPLS_TUNNEL_LABEL_2, index, mplsInstructionSets.get(2), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        // We update the chain.
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        // We have to create tunnel label group and
        // l2 vpn group before to send the inner most
        // group. We update the nextGid.
        nextGid = groupDescription.givenGroupId();
        groupInfo = new GroupInfo(groupInfo.innerMostGroupDesc(), groupDescription);
        log.debug("Trying Label 2 Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
    }
    // inside a single co
    if (mplsInstructionSets.size() == 2) {
        log.debug("Creating leaf-leaf pw mpls chains with nextid {}", nextObjective.id());
        // We deal with the label 1 group.
        index = getNextAvailableIndex();
        groupDescription = createMplsTunnelLabelGroup(nextGid, OfdpaMplsGroupSubType.MPLS_TUNNEL_LABEL_1, index, mplsInstructionSets.get(1), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        // We have to create the l2 vpn group before
        // to send the inner most group.
        nextGid = groupDescription.givenGroupId();
        groupInfo = new GroupInfo(groupInfo.innerMostGroupDesc(), groupDescription);
        log.debug("Trying Label 1 Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
        // Finally we create the l2 vpn group.
        index = getNextAvailableIndex();
        groupDescription = createMplsL2VpnGroup(nextGid, index, mplsInstructionSets.get(0), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObjective);
        updatePendingNextObjective(groupKey, ofdpaGrp);
        log.debug("Trying L2 Vpn Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
        // Finally we send the innermost group.
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    }
    // only one label is used
    if (mplsInstructionSets.size() == 1) {
        log.debug("Creating leaf-spine pw mpls chains with nextid {}", nextObjective.id());
        // Finally we create the l2 vpn group.
        index = getNextAvailableIndex();
        groupDescription = createMplsL2VpnGroup(nextGid, index, mplsInstructionSets.get(0), nextObjective.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObjective);
        updatePendingNextObjective(groupKey, ofdpaGrp);
        log.debug("Trying L2 Vpn Group: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(nextGid), groupKey, nextObjective.id());
        // Finally we send the innermost group.
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    }
}
#end_block

#method_before
public void processPwaasConfigAdded(NetworkConfigEvent event) {
    log.info("Network event : Pseudowire configuration added!");
    PwaasConfig config = (PwaasConfig) event.config().get();
    // gather pseudowires
    Set<DefaultL2TunnelDescription> pwToAdd = config.getPwIds().stream().map(config::getPwDescription).collect(Collectors.toSet());
    // deploy pseudowires
    deploy(pwToAdd);
}
#method_after
public void processPwaasConfigAdded(NetworkConfigEvent event) {
    checkArgument(event.config().isPresent(), "Config is not presented in PwaasConfigAdded event {}", event);
    log.info("Network event : Pseudowire configuration added!");
    PwaasConfig config = (PwaasConfig) event.config().get();
    // gather pseudowires
    Set<DefaultL2TunnelDescription> pwToAdd = config.getPwIds().stream().map(config::getPwDescription).collect(Collectors.toSet());
    // deploy pseudowires
    deploy(pwToAdd);
}
#end_block

#method_before
public VlanId determineEgressVlan(VlanId ingressOuter, VlanId ingressInner, VlanId egressOuter, VlanId egressInner) {
    // validity of vlan combinations was checked at verifyPseudowire
    if (!(ingressOuter.equals(VlanId.NONE))) {
        return egressOuter;
    } else if (!(ingressInner.equals(VlanId.NONE))) {
        return egressInner;
    } else {
        return VlanId.vlanId("None");
    }
}
#method_after
private VlanId determineEgressVlan(VlanId ingressOuter, VlanId ingressInner, VlanId egressOuter, VlanId egressInner) {
    // validity of vlan combinations was checked at verifyPseudowire
    if (!(ingressOuter.equals(VlanId.NONE))) {
        return egressOuter;
    } else if (!(ingressInner.equals(VlanId.NONE))) {
        return egressInner;
    } else {
        return VlanId.vlanId("None");
    }
}
#end_block

#method_before
private void deploy(Set<DefaultL2TunnelDescription> pwToAdd) {
    Result result;
    for (DefaultL2TunnelDescription currentL2Tunnel : pwToAdd) {
        // only the master of CP1 will program this pseudowire
        if (!srManager.isMasterOf(currentL2Tunnel.l2TunnelPolicy().cP1())) {
            continue;
        }
        try {
            // and pass the appropriate flag in them.
            if (!srManager.deviceConfiguration().isEdgeDevice(currentL2Tunnel.l2TunnelPolicy().cP1().deviceId()) && !srManager.deviceConfiguration().isEdgeDevice(currentL2Tunnel.l2TunnelPolicy().cP2().deviceId())) {
                log.info("Can not deploy pseudowire from spine to spine!");
                result = Result.INTERNAL_ERROR;
            } else if (srManager.deviceConfiguration().isEdgeDevice(currentL2Tunnel.l2TunnelPolicy().cP1().deviceId()) && srManager.deviceConfiguration().isEdgeDevice(currentL2Tunnel.l2TunnelPolicy().cP2().deviceId())) {
                log.info("Deploying a leaf-leaf pseudowire {}", currentL2Tunnel.l2Tunnel().tunnelId());
                result = deployPseudowire(currentL2Tunnel, false);
            } else {
                log.info("Deploying a leaf-spine pseudowire {}", currentL2Tunnel.l2Tunnel().tunnelId());
                result = deployPseudowire(currentL2Tunnel, true);
            }
        } catch (DeviceConfigNotFoundException e) {
            log.error("Exception caught when deploying pseudowire: {}", e.toString());
            result = Result.INTERNAL_ERROR;
        }
        switch(result) {
            case INTERNAL_ERROR:
                log.warn("Could not deploy pseudowire {}, internal error!", currentL2Tunnel.l2Tunnel().tunnelId());
                break;
            case WRONG_PARAMETERS:
                log.warn("Could not deploy pseudowire {}, wrong parameters!", currentL2Tunnel.l2Tunnel().tunnelId());
                break;
            case ADDITION_ERROR:
                log.warn("Could not deploy pseudowire {}, error in populating rules!", currentL2Tunnel.l2Tunnel().tunnelId());
                break;
            default:
                log.info("Pseudowire with {} succesfully deployed!", currentL2Tunnel.l2Tunnel().tunnelId());
                break;
        }
    }
}
#method_after
private void deploy(Set<DefaultL2TunnelDescription> pwToAdd) {
    Result result;
    for (DefaultL2TunnelDescription currentL2Tunnel : pwToAdd) {
        ConnectPoint cp1 = currentL2Tunnel.l2TunnelPolicy().cP1();
        ConnectPoint cp2 = currentL2Tunnel.l2TunnelPolicy().cP2();
        long tunnelId = currentL2Tunnel.l2TunnelPolicy().tunnelId();
        // only the master of CP1 will program this pseudowire
        if (!srManager.isMasterOf(cp1)) {
            log.debug("Not the master of {}. Ignore pseudo wire deployment id={}", cp1, tunnelId);
            continue;
        }
        try {
            // and pass the appropriate flag in them.
            if (!srManager.deviceConfiguration().isEdgeDevice(cp1.deviceId()) && !srManager.deviceConfiguration().isEdgeDevice(cp2.deviceId())) {
                log.warn("Can not deploy pseudowire from spine to spine!");
                result = Result.INTERNAL_ERROR;
            } else if (srManager.deviceConfiguration().isEdgeDevice(cp1.deviceId()) && srManager.deviceConfiguration().isEdgeDevice(cp2.deviceId())) {
                log.info("Deploying a leaf-leaf pseudowire {}", tunnelId);
                result = deployPseudowire(currentL2Tunnel, false);
            } else {
                log.info("Deploying a leaf-spine pseudowire {}", tunnelId);
                result = deployPseudowire(currentL2Tunnel, true);
            }
        } catch (DeviceConfigNotFoundException e) {
            log.error("Exception caught when deploying pseudowire", e.toString());
            result = Result.INTERNAL_ERROR;
        }
        switch(result) {
            case INTERNAL_ERROR:
                log.warn("Could not deploy pseudowire {}, internal error!", tunnelId);
                break;
            case WRONG_PARAMETERS:
                log.warn("Could not deploy pseudowire {}, wrong parameters!", tunnelId);
                break;
            case ADDITION_ERROR:
                log.warn("Could not deploy pseudowire {}, error in populating rules!", tunnelId);
                break;
            default:
                log.info("Pseudowire with {} succesfully deployed!", tunnelId);
                break;
        }
    }
}
#end_block

#method_before
public void processPwaasConfigUpdated(NetworkConfigEvent event) {
    log.info("Pseudowire configuration updated.");
    // We retrieve the old pseudo wires.
    PwaasConfig prevConfig = (PwaasConfig) event.prevConfig().get();
    Set<Long> prevPws = prevConfig.getPwIds();
    // We retrieve the new pseudo wires.
    PwaasConfig config = (PwaasConfig) event.config().get();
    Set<Long> newPws = config.getPwIds();
    // We compute the pseudo wires to update.
    Set<Long> updPws = newPws.stream().filter(tunnelId -> prevPws.contains(tunnelId) && !config.getPwDescription(tunnelId).equals(prevConfig.getPwDescription(tunnelId))).collect(Collectors.toSet());
    // The pseudo wires to remove.
    Set<Long> rmvPWs = prevPws.stream().filter(tunnelId -> !newPws.contains(tunnelId)).collect(Collectors.toSet());
    Set<DefaultL2TunnelDescription> pwToRemove = rmvPWs.stream().map(prevConfig::getPwDescription).collect(Collectors.toSet());
    tearDown(pwToRemove);
    // The pseudo wires to add.
    Set<Long> addedPWs = newPws.stream().filter(tunnelId -> !prevPws.contains(tunnelId)).collect(Collectors.toSet());
    Set<DefaultL2TunnelDescription> pwToAdd = addedPWs.stream().map(config::getPwDescription).collect(Collectors.toSet());
    deploy(pwToAdd);
    // The pseudo wires to update.
    updPws.forEach(tunnelId -> updatePw(prevConfig.getPwDescription(tunnelId), config.getPwDescription(tunnelId)));
    log.info("Pseudowires removed : {}, Pseudowires updated : {}, Pseudowires added : {}", rmvPWs, updPws, addedPWs);
}
#method_after
public void processPwaasConfigUpdated(NetworkConfigEvent event) {
    checkArgument(event.config().isPresent(), "Config is not presented in PwaasConfigUpdated event {}", event);
    checkArgument(event.prevConfig().isPresent(), "PrevConfig is not presented in PwaasConfigUpdated event {}", event);
    log.info("Pseudowire configuration updated.");
    // We retrieve the old pseudo wires.
    PwaasConfig prevConfig = (PwaasConfig) event.prevConfig().get();
    Set<Long> prevPws = prevConfig.getPwIds();
    // We retrieve the new pseudo wires.
    PwaasConfig config = (PwaasConfig) event.config().get();
    Set<Long> newPws = config.getPwIds();
    // We compute the pseudo wires to update.
    Set<Long> updPws = newPws.stream().filter(tunnelId -> prevPws.contains(tunnelId) && !config.getPwDescription(tunnelId).equals(prevConfig.getPwDescription(tunnelId))).collect(Collectors.toSet());
    // The pseudo wires to remove.
    Set<Long> rmvPWs = prevPws.stream().filter(tunnelId -> !newPws.contains(tunnelId)).collect(Collectors.toSet());
    Set<DefaultL2TunnelDescription> pwToRemove = rmvPWs.stream().map(prevConfig::getPwDescription).collect(Collectors.toSet());
    tearDown(pwToRemove);
    // The pseudo wires to add.
    Set<Long> addedPWs = newPws.stream().filter(tunnelId -> !prevPws.contains(tunnelId)).collect(Collectors.toSet());
    Set<DefaultL2TunnelDescription> pwToAdd = addedPWs.stream().map(config::getPwDescription).collect(Collectors.toSet());
    deploy(pwToAdd);
    // The pseudo wires to update.
    updPws.forEach(tunnelId -> updatePw(prevConfig.getPwDescription(tunnelId), config.getPwDescription(tunnelId)));
    log.info("Pseudowires removed : {}, Pseudowires updated : {}, Pseudowires added : {}", rmvPWs, updPws, addedPWs);
}
#end_block

#method_before
public void updatePw(DefaultL2TunnelDescription oldPw, DefaultL2TunnelDescription newPw) {
    long tunnelId = oldPw.l2Tunnel().tunnelId();
    // only the master of CP1 will update this pseudowire
    if (!srManager.isMasterOf(oldPw.l2TunnelPolicy().cP1())) {
        return;
    }
    // only determine if the new pseudowire is leaf-spine, because
    // removal process is the same for both leaf-leaf and leaf-spine
    // pws.
    boolean newPwSpine;
    try {
        if (srManager.deviceConfiguration().isEdgeDevice(newPw.l2TunnelPolicy().cP1().deviceId()) && srManager.deviceConfiguration().isEdgeDevice(newPw.l2TunnelPolicy().cP2().deviceId())) {
            newPwSpine = false;
        } else {
            newPwSpine = true;
        }
    } catch (DeviceConfigNotFoundException e) {
        // if exception is caught treat the newpw as leaf-leaf
        newPwSpine = false;
    }
    // copy the variable here because we need to
    // use it in lambda thus it needs to be final
    boolean finalNewPwSpine = newPwSpine;
    log.info("Updating pseudowire {}", oldPw.l2Tunnel().tunnelId());
    // The async tasks to orchestrate the next and
    // forwarding update.
    CompletableFuture<ObjectiveError> fwdInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdPwFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revPwFuture = new CompletableFuture<>();
    // First we remove both policy.
    log.debug("Start deleting fwd policy for {}", tunnelId);
    // first delete all information from our stores
    // we can not do it asynchronously
    l2PolicyStore.remove(Long.toString(tunnelId));
    l2TunnelStore.remove(Long.toString(tunnelId));
    VlanId egressVlan = determineEgressVlan(oldPw.l2TunnelPolicy().cP1OuterTag(), oldPw.l2TunnelPolicy().cP1InnerTag(), oldPw.l2TunnelPolicy().cP2OuterTag(), oldPw.l2TunnelPolicy().cP2InnerTag());
    deletePolicy(tunnelId, oldPw.l2TunnelPolicy().cP1(), oldPw.l2TunnelPolicy().cP1InnerTag(), oldPw.l2TunnelPolicy().cP1OuterTag(), egressVlan, fwdInitNextFuture, FWD);
    log.debug("Update process : Start deleting rev policy for {}", tunnelId);
    egressVlan = determineEgressVlan(oldPw.l2TunnelPolicy().cP2OuterTag(), oldPw.l2TunnelPolicy().cP2InnerTag(), oldPw.l2TunnelPolicy().cP1OuterTag(), oldPw.l2TunnelPolicy().cP1InnerTag());
    deletePolicy(tunnelId, oldPw.l2TunnelPolicy().cP2(), oldPw.l2TunnelPolicy().cP2InnerTag(), oldPw.l2TunnelPolicy().cP2OuterTag(), egressVlan, revInitNextFuture, REV);
    // Finally we remove both the tunnels.
    fwdInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Fwd policy removed. " + "Now remove fwd {} for {}", INITIATION, tunnelId);
            tearDownPseudoWireInit(tunnelId, oldPw.l2TunnelPolicy().cP1(), fwdTermNextFuture, FWD);
        }
    });
    revInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Rev policy removed. " + "Now remove rev {} for {}", INITIATION, tunnelId);
            tearDownPseudoWireInit(tunnelId, oldPw.l2TunnelPolicy().cP2(), revTermNextFuture, REV);
        }
    });
    fwdTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Fwd {} removed. " + "Now remove fwd {} for {}", INITIATION, TERMINATION, tunnelId);
            tearDownPseudoWireTerm(oldPw.l2Tunnel(), oldPw.l2TunnelPolicy().cP2(), fwdPwFuture, FWD);
        }
    });
    revTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Rev {} removed. " + "Now remove rev {} for {}", INITIATION, TERMINATION, tunnelId);
            tearDownPseudoWireTerm(oldPw.l2Tunnel(), oldPw.l2TunnelPolicy().cP1(), revPwFuture, REV);
        }
    });
    // get path here, need to use the same for fwd and rev direction
    List<Link> path = getPath(newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP2());
    if (path == null) {
        log.info("Deploying process : " + "No path between the connection points for pseudowire {}", newPw.l2Tunnel().tunnelId());
        return;
    }
    Link fwdNextHop, revNextHop;
    if (!finalNewPwSpine) {
        if (path.size() != 2) {
            log.info("Update process : Error, path between two leafs should have size of 2, for pseudowire {}", newPw.l2Tunnel().tunnelId());
            return;
        }
        fwdNextHop = path.get(0);
        revNextHop = reverseLink(path.get(1));
    } else {
        if (path.size() != 1) {
            log.info("Update process : Error, path between leaf spine should equal to 2, for pseudowire {}", newPw.l2Tunnel().tunnelId());
            return;
        }
        fwdNextHop = path.get(0);
        revNextHop = reverseLink(path.get(0));
    }
    newPw.l2Tunnel().setPath(path);
    // At the end we install the updated PW.
    fwdPwFuture.thenAcceptAsync(status -> {
        if (status == null) {
            // Upgrade stores and book keeping information, need to move this here
            // cause this call is asynchronous.
            l2PolicyStore.put(Long.toString(tunnelId), newPw.l2TunnelPolicy());
            l2TunnelStore.put(Long.toString(tunnelId), newPw.l2Tunnel());
            log.debug("Update process : Deploying new fwd pw for {}", tunnelId);
            Result lamdaResult = deployPseudoWireInit(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP2(), FWD, fwdNextHop, finalNewPwSpine);
            if (lamdaResult != SUCCESS) {
                return;
            }
            VlanId egressVlanId = determineEgressVlan(newPw.l2TunnelPolicy().cP1OuterTag(), newPw.l2TunnelPolicy().cP1InnerTag(), newPw.l2TunnelPolicy().cP2OuterTag(), newPw.l2TunnelPolicy().cP2InnerTag());
            lamdaResult = deployPolicy(tunnelId, newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP1InnerTag(), newPw.l2TunnelPolicy().cP1OuterTag(), egressVlanId, lamdaResult.nextId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            deployPseudoWireTerm(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP2OuterTag(), FWD, finalNewPwSpine);
        }
    });
    revPwFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Deploying new rev pw for {}", tunnelId);
            Result lamdaResult = deployPseudoWireInit(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP1(), REV, revNextHop, finalNewPwSpine);
            if (lamdaResult != SUCCESS) {
                return;
            }
            VlanId egressVlanId = determineEgressVlan(newPw.l2TunnelPolicy().cP2OuterTag(), newPw.l2TunnelPolicy().cP2InnerTag(), newPw.l2TunnelPolicy().cP1OuterTag(), newPw.l2TunnelPolicy().cP1InnerTag());
            lamdaResult = deployPolicy(tunnelId, newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP2InnerTag(), newPw.l2TunnelPolicy().cP2OuterTag(), egressVlanId, lamdaResult.nextId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            deployPseudoWireTerm(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP1OuterTag(), REV, finalNewPwSpine);
        }
    });
}
#method_after
private void updatePw(DefaultL2TunnelDescription oldPw, DefaultL2TunnelDescription newPw) {
    ConnectPoint oldCp1 = oldPw.l2TunnelPolicy().cP1();
    long tunnelId = oldPw.l2Tunnel().tunnelId();
    // only the master of CP1 will update this pseudowire
    if (!srManager.isMasterOf(oldPw.l2TunnelPolicy().cP1())) {
        log.debug("Not the master of {}. Ignore pseudo wire update id={}", oldCp1, tunnelId);
        return;
    }
    // only determine if the new pseudowire is leaf-spine, because
    // removal process is the same for both leaf-leaf and leaf-spine
    // pws.
    boolean newPwSpine;
    try {
        newPwSpine = !srManager.deviceConfiguration().isEdgeDevice(newPw.l2TunnelPolicy().cP1().deviceId()) || !srManager.deviceConfiguration().isEdgeDevice(newPw.l2TunnelPolicy().cP2().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        // if exception is caught treat the newpw as leaf-leaf
        newPwSpine = false;
    }
    // copy the variable here because we need to
    // use it in lambda thus it needs to be final
    boolean finalNewPwSpine = newPwSpine;
    log.info("Updating pseudowire {}", oldPw.l2Tunnel().tunnelId());
    // The async tasks to orchestrate the next and
    // forwarding update.
    CompletableFuture<ObjectiveError> fwdInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdPwFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revPwFuture = new CompletableFuture<>();
    // First we remove both policy.
    log.debug("Start deleting fwd policy for {}", tunnelId);
    // first delete all information from our stores
    // we can not do it asynchronously
    l2PolicyStore.remove(Long.toString(tunnelId));
    l2TunnelStore.remove(Long.toString(tunnelId));
    VlanId egressVlan = determineEgressVlan(oldPw.l2TunnelPolicy().cP1OuterTag(), oldPw.l2TunnelPolicy().cP1InnerTag(), oldPw.l2TunnelPolicy().cP2OuterTag(), oldPw.l2TunnelPolicy().cP2InnerTag());
    deletePolicy(tunnelId, oldPw.l2TunnelPolicy().cP1(), oldPw.l2TunnelPolicy().cP1InnerTag(), oldPw.l2TunnelPolicy().cP1OuterTag(), egressVlan, fwdInitNextFuture, FWD);
    log.debug("Update process : Start deleting rev policy for {}", tunnelId);
    egressVlan = determineEgressVlan(oldPw.l2TunnelPolicy().cP2OuterTag(), oldPw.l2TunnelPolicy().cP2InnerTag(), oldPw.l2TunnelPolicy().cP1OuterTag(), oldPw.l2TunnelPolicy().cP1InnerTag());
    deletePolicy(tunnelId, oldPw.l2TunnelPolicy().cP2(), oldPw.l2TunnelPolicy().cP2InnerTag(), oldPw.l2TunnelPolicy().cP2OuterTag(), egressVlan, revInitNextFuture, REV);
    // Finally we remove both the tunnels.
    fwdInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Fwd policy removed. " + "Now remove fwd {} for {}", INITIATION, tunnelId);
            tearDownPseudoWireInit(tunnelId, oldPw.l2TunnelPolicy().cP1(), fwdTermNextFuture, FWD);
        }
    });
    revInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Rev policy removed. " + "Now remove rev {} for {}", INITIATION, tunnelId);
            tearDownPseudoWireInit(tunnelId, oldPw.l2TunnelPolicy().cP2(), revTermNextFuture, REV);
        }
    });
    fwdTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Fwd {} removed. " + "Now remove fwd {} for {}", INITIATION, TERMINATION, tunnelId);
            tearDownPseudoWireTerm(oldPw.l2Tunnel(), oldPw.l2TunnelPolicy().cP2(), fwdPwFuture, FWD);
        }
    });
    revTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Rev {} removed. " + "Now remove rev {} for {}", INITIATION, TERMINATION, tunnelId);
            tearDownPseudoWireTerm(oldPw.l2Tunnel(), oldPw.l2TunnelPolicy().cP1(), revPwFuture, REV);
        }
    });
    // get path here, need to use the same for fwd and rev direction
    List<Link> path = getPath(newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP2());
    if (path == null) {
        log.info("Deploying process : " + "No path between the connection points for pseudowire {}", newPw.l2Tunnel().tunnelId());
        return;
    }
    Link fwdNextHop, revNextHop;
    if (!finalNewPwSpine) {
        if (path.size() != 2) {
            log.info("Update process : Error, path between two leafs should have size of 2, for pseudowire {}", newPw.l2Tunnel().tunnelId());
            return;
        }
        fwdNextHop = path.get(0);
        revNextHop = reverseLink(path.get(1));
    } else {
        if (path.size() != 1) {
            log.info("Update process : Error, path between leaf spine should equal to 2, for pseudowire {}", newPw.l2Tunnel().tunnelId());
            return;
        }
        fwdNextHop = path.get(0);
        revNextHop = reverseLink(path.get(0));
    }
    newPw.l2Tunnel().setPath(path);
    // At the end we install the updated PW.
    fwdPwFuture.thenAcceptAsync(status -> {
        if (status == null) {
            // Upgrade stores and book keeping information, need to move this here
            // cause this call is asynchronous.
            l2PolicyStore.put(Long.toString(tunnelId), newPw.l2TunnelPolicy());
            l2TunnelStore.put(Long.toString(tunnelId), newPw.l2Tunnel());
            log.debug("Update process : Deploying new fwd pw for {}", tunnelId);
            Result lamdaResult = deployPseudoWireInit(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP2(), FWD, fwdNextHop, finalNewPwSpine);
            if (lamdaResult != SUCCESS) {
                return;
            }
            VlanId egressVlanId = determineEgressVlan(newPw.l2TunnelPolicy().cP1OuterTag(), newPw.l2TunnelPolicy().cP1InnerTag(), newPw.l2TunnelPolicy().cP2OuterTag(), newPw.l2TunnelPolicy().cP2InnerTag());
            lamdaResult = deployPolicy(tunnelId, newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP1InnerTag(), newPw.l2TunnelPolicy().cP1OuterTag(), egressVlanId, lamdaResult.nextId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            deployPseudoWireTerm(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP2OuterTag(), FWD, finalNewPwSpine);
        }
    });
    revPwFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Deploying new rev pw for {}", tunnelId);
            Result lamdaResult = deployPseudoWireInit(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP1(), REV, revNextHop, finalNewPwSpine);
            if (lamdaResult != SUCCESS) {
                return;
            }
            VlanId egressVlanId = determineEgressVlan(newPw.l2TunnelPolicy().cP2OuterTag(), newPw.l2TunnelPolicy().cP2InnerTag(), newPw.l2TunnelPolicy().cP1OuterTag(), newPw.l2TunnelPolicy().cP1InnerTag());
            lamdaResult = deployPolicy(tunnelId, newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP2InnerTag(), newPw.l2TunnelPolicy().cP2OuterTag(), egressVlanId, lamdaResult.nextId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            deployPseudoWireTerm(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP1OuterTag(), REV, finalNewPwSpine);
        }
    });
}
#end_block

#method_before
public void processPwaasConfigRemoved(NetworkConfigEvent event) {
    log.info("Network event : Pseudowire configuration removed!");
    PwaasConfig config = (PwaasConfig) event.prevConfig().get();
    Set<DefaultL2TunnelDescription> pwToRemove = config.getPwIds().stream().map(config::getPwDescription).collect(Collectors.toSet());
    // We teardown all the pseudo wire deployed
    tearDown(pwToRemove);
}
#method_after
public void processPwaasConfigRemoved(NetworkConfigEvent event) {
    checkArgument(event.prevConfig().isPresent(), "PrevConfig is not presented in PwaasConfigRemoved event {}", event);
    log.info("Network event : Pseudowire configuration removed!");
    PwaasConfig config = (PwaasConfig) event.prevConfig().get();
    Set<DefaultL2TunnelDescription> pwToRemove = config.getPwIds().stream().map(config::getPwDescription).collect(Collectors.toSet());
    // We teardown all the pseudo wire deployed
    tearDown(pwToRemove);
}
#end_block

#method_before
public Result tearDownPseudowire(long l2TunnelId) {
    CompletableFuture<ObjectiveError> fwdInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revTermNextFuture = new CompletableFuture<>();
    if (l2TunnelId == 0) {
        log.warn("Removal process : Tunnel id cannot be 0");
        return Result.WRONG_PARAMETERS;
    }
    // check existence of tunnels/policy in the store, if one is missing abort!
    Versioned<DefaultL2Tunnel> l2TunnelVersioned = l2TunnelStore.get(Long.toString(l2TunnelId));
    Versioned<DefaultL2TunnelPolicy> l2TunnelPolicyVersioned = l2PolicyStore.get(Long.toString(l2TunnelId));
    if ((l2TunnelVersioned == null) || (l2TunnelPolicyVersioned == null)) {
        log.warn("Removal process : Policy and/or tunnel missing for tunnel id {}", l2TunnelId);
        return Result.REMOVAL_ERROR;
    }
    DefaultL2TunnelDescription pwToRemove = new DefaultL2TunnelDescription(l2TunnelVersioned.value(), l2TunnelPolicyVersioned.value());
    // remove the tunnels and the policies from the store
    l2PolicyStore.remove(Long.toString(l2TunnelId));
    l2TunnelStore.remove(Long.toString(l2TunnelId));
    log.info("Removal process : Tearing down forward direction of pseudowire {}", l2TunnelId);
    VlanId egressVlan = determineEgressVlan(pwToRemove.l2TunnelPolicy().cP1OuterTag(), pwToRemove.l2TunnelPolicy().cP1InnerTag(), pwToRemove.l2TunnelPolicy().cP2OuterTag(), pwToRemove.l2TunnelPolicy().cP2InnerTag());
    deletePolicy(l2TunnelId, pwToRemove.l2TunnelPolicy().cP1(), pwToRemove.l2TunnelPolicy().cP1InnerTag(), pwToRemove.l2TunnelPolicy().cP1OuterTag(), egressVlan, fwdInitNextFuture, FWD);
    fwdInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            // Finally we will tear down the pseudo wire.
            tearDownPseudoWireInit(l2TunnelId, pwToRemove.l2TunnelPolicy().cP1(), fwdTermNextFuture, FWD);
        }
    });
    fwdTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            tearDownPseudoWireTerm(pwToRemove.l2Tunnel(), pwToRemove.l2TunnelPolicy().cP2(), null, FWD);
        }
    });
    log.info("Removal process : Tearing down reverse direction of pseudowire {}", l2TunnelId);
    egressVlan = determineEgressVlan(pwToRemove.l2TunnelPolicy().cP2OuterTag(), pwToRemove.l2TunnelPolicy().cP2InnerTag(), pwToRemove.l2TunnelPolicy().cP1OuterTag(), pwToRemove.l2TunnelPolicy().cP1InnerTag());
    // We do the same operations on the reverse side.
    deletePolicy(l2TunnelId, pwToRemove.l2TunnelPolicy().cP2(), pwToRemove.l2TunnelPolicy().cP2InnerTag(), pwToRemove.l2TunnelPolicy().cP2OuterTag(), egressVlan, revInitNextFuture, REV);
    revInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            tearDownPseudoWireInit(l2TunnelId, pwToRemove.l2TunnelPolicy().cP2(), revTermNextFuture, REV);
        }
    });
    revTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            tearDownPseudoWireTerm(pwToRemove.l2Tunnel(), pwToRemove.l2TunnelPolicy().cP1(), null, REV);
        }
    });
    return Result.SUCCESS;
}
#method_after
private Result tearDownPseudowire(long l2TunnelId) {
    CompletableFuture<ObjectiveError> fwdInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revTermNextFuture = new CompletableFuture<>();
    if (l2TunnelId == 0) {
        log.warn("Removal process : Tunnel id cannot be 0");
        return Result.WRONG_PARAMETERS;
    }
    // check existence of tunnels/policy in the store, if one is missing abort!
    Versioned<DefaultL2Tunnel> l2TunnelVersioned = l2TunnelStore.get(Long.toString(l2TunnelId));
    Versioned<DefaultL2TunnelPolicy> l2TunnelPolicyVersioned = l2PolicyStore.get(Long.toString(l2TunnelId));
    if ((l2TunnelVersioned == null) || (l2TunnelPolicyVersioned == null)) {
        log.warn("Removal process : Policy and/or tunnel missing for tunnel id {}", l2TunnelId);
        return Result.REMOVAL_ERROR;
    }
    DefaultL2TunnelDescription pwToRemove = new DefaultL2TunnelDescription(l2TunnelVersioned.value(), l2TunnelPolicyVersioned.value());
    // remove the tunnels and the policies from the store
    l2PolicyStore.remove(Long.toString(l2TunnelId));
    l2TunnelStore.remove(Long.toString(l2TunnelId));
    log.info("Removal process : Tearing down forward direction of pseudowire {}", l2TunnelId);
    VlanId egressVlan = determineEgressVlan(pwToRemove.l2TunnelPolicy().cP1OuterTag(), pwToRemove.l2TunnelPolicy().cP1InnerTag(), pwToRemove.l2TunnelPolicy().cP2OuterTag(), pwToRemove.l2TunnelPolicy().cP2InnerTag());
    deletePolicy(l2TunnelId, pwToRemove.l2TunnelPolicy().cP1(), pwToRemove.l2TunnelPolicy().cP1InnerTag(), pwToRemove.l2TunnelPolicy().cP1OuterTag(), egressVlan, fwdInitNextFuture, FWD);
    fwdInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            // Finally we will tear down the pseudo wire.
            tearDownPseudoWireInit(l2TunnelId, pwToRemove.l2TunnelPolicy().cP1(), fwdTermNextFuture, FWD);
        }
    });
    fwdTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            tearDownPseudoWireTerm(pwToRemove.l2Tunnel(), pwToRemove.l2TunnelPolicy().cP2(), null, FWD);
        }
    });
    log.info("Removal process : Tearing down reverse direction of pseudowire {}", l2TunnelId);
    egressVlan = determineEgressVlan(pwToRemove.l2TunnelPolicy().cP2OuterTag(), pwToRemove.l2TunnelPolicy().cP2InnerTag(), pwToRemove.l2TunnelPolicy().cP1OuterTag(), pwToRemove.l2TunnelPolicy().cP1InnerTag());
    // We do the same operations on the reverse side.
    deletePolicy(l2TunnelId, pwToRemove.l2TunnelPolicy().cP2(), pwToRemove.l2TunnelPolicy().cP2InnerTag(), pwToRemove.l2TunnelPolicy().cP2OuterTag(), egressVlan, revInitNextFuture, REV);
    revInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            tearDownPseudoWireInit(l2TunnelId, pwToRemove.l2TunnelPolicy().cP2(), revTermNextFuture, REV);
        }
    });
    revTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            tearDownPseudoWireTerm(pwToRemove.l2Tunnel(), pwToRemove.l2TunnelPolicy().cP1(), null, REV);
        }
    });
    return Result.SUCCESS;
}
#end_block

#method_before
public void tearDown(Set<DefaultL2TunnelDescription> pwToRemove) {
    Result result;
    // We remove all the pw in the configuration file.
    for (DefaultL2TunnelDescription currentL2Tunnel : pwToRemove) {
        // only the master of CP1 will program this pseudowire
        if (!srManager.isMasterOf(currentL2Tunnel.l2TunnelPolicy().cP1())) {
            continue;
        }
        // no need to differentiate here between leaf-leaf and leaf-spine, because
        // the only change is in the groups, which we do not remove either way
        log.info("Removing pseudowire {}", currentL2Tunnel.l2Tunnel().tunnelId());
        result = tearDownPseudowire(currentL2Tunnel.l2Tunnel().tunnelId());
        switch(result) {
            case WRONG_PARAMETERS:
                log.warn("Error in supplied parameters for the pseudowire removal with tunnel id {}!", currentL2Tunnel.l2Tunnel().tunnelId());
                break;
            case REMOVAL_ERROR:
                log.warn("Error in pseudowire removal with tunnel id {}!", currentL2Tunnel.l2Tunnel().tunnelId());
                break;
            default:
                log.warn("Pseudowire with tunnel id {} was removed successfully", currentL2Tunnel.l2Tunnel().tunnelId());
        }
    }
}
#method_after
public void tearDown(Set<DefaultL2TunnelDescription> pwToRemove) {
    Result result;
    // We remove all the pw in the configuration file.
    for (DefaultL2TunnelDescription currentL2Tunnel : pwToRemove) {
        ConnectPoint cp1 = currentL2Tunnel.l2TunnelPolicy().cP1();
        ConnectPoint cp2 = currentL2Tunnel.l2TunnelPolicy().cP2();
        long tunnelId = currentL2Tunnel.l2TunnelPolicy().tunnelId();
        // only the master of CP1 will program this pseudowire
        if (!srManager.isMasterOf(cp1)) {
            log.debug("Not the master of {}. Ignore pseudo wire removal id={}", cp1, tunnelId);
            continue;
        }
        // no need to differentiate here between leaf-leaf and leaf-spine, because
        // the only change is in the groups, which we do not remove either way
        log.info("Removing pseudowire {}", tunnelId);
        result = tearDownPseudowire(tunnelId);
        switch(result) {
            case WRONG_PARAMETERS:
                log.warn("Error in supplied parameters for the pseudowire removal with tunnel id {}!", tunnelId);
                break;
            case REMOVAL_ERROR:
                log.warn("Error in pseudowire removal with tunnel id {}!", tunnelId);
                break;
            default:
                log.warn("Pseudowire with tunnel id {} was removed successfully", tunnelId);
        }
    }
}
#end_block

#method_before
@Test
public void processAnydataTest() {
    reg.registerAnydataSchema(DefaultDataValue.class, DefaultTunnel.class);
    DefaultConfigurationSchedules c1 = new DefaultConfigurationSchedules();
    DefaultTarget target = new DefaultTarget();
    target.object(new Xpath10("te-links"));
    target.operation(new Operation(CONFIGURE));
    DefaultTunnel tunnel = new DefaultTunnel();
    tunnel.name("p2p");
    DefaultConfig config = new DefaultConfig();
    config.name("p2p");
    tunnel.config(config);
    DefaultTunnel tunnel1 = new DefaultTunnel();
    tunnel1.name("p2p1");
    DefaultConfig config1 = new DefaultConfig();
    config1.name("p2p1");
    tunnel1.config(config1);
    DefaultDataValue dataValue = new DefaultDataValue();
    dataValue.addAnydata(tunnel);
    dataValue.addAnydata(tunnel1);
    DefaultSchedules schedules = new DefaultSchedules();
    DefaultSchedule schedule = new DefaultSchedule();
    schedule.scheduleDuration("PT108850373514M");
    schedule.start(DateAndTime.of("2016-09-12T23:20:50.52Z"));
    long val = 11;
    schedule.scheduleId(val);
    schedules.addToSchedule(schedule);
    target.schedules(schedules);
    target.dataValue(dataValue);
    c1.addToTarget(target);
    data = new Builder();
    data.addModelObject(c1);
    rscData = treeBuilder.getResourceData(data.build());
    List<DataNode> nodes = rscData.dataNodes();
    DataNode n = nodes.get(0);
    validateDataNodeTree(n);
}
#method_after
@Test
public void processAnydataTest() {
    ModelObjectId id = new ModelObjectId.Builder().addChild(DefaultConfigurationSchedules.class).addChild(DefaultTarget.class, null).addChild(DefaultDataValue.class).build();
    ModelObjectId id1 = new ModelObjectId.Builder().addChild(DefaultTe.class).addChild(DefaultTunnels.class).addChild(DefaultTunnel.class, null).build();
    reg.registerAnydataSchema(id, id1);
    DefaultConfigurationSchedules c1 = new DefaultConfigurationSchedules();
    DefaultTarget target = new DefaultTarget();
    target.object(new Xpath10("te-links"));
    target.operation(new Operation(CONFIGURE));
    DefaultTunnel tunnel = new DefaultTunnel();
    tunnel.name("p2p");
    DefaultConfig config = new DefaultConfig();
    config.name("p2p");
    config.type(TunnelP2p.class);
    config.identifier(19899);
    config.description("OTN tunnel segment within the Huawei OTN Domain");
    config.encoding(LspEncodingOduk.class);
    config.protectionType(LspProtUnprotected.class);
    config.adminStatus(StateUp.class);
    config.providerId(new TeGlobalId(200));
    config.clientId(new TeGlobalId(1000));
    config.teTopologyId(new TeTopologyId("11"));
    config.source(new IpAddress(new IpAddressUnion(new Ipv4Address("0.67.0.76"))));
    config.destination(new IpAddress(new IpAddressUnion(new Ipv4Address("0.67.0.77"))));
    config.setupPriority(((short) 7));
    config.holdPriority(((short) 6));
    config.signalingType(PathSignalingRsvpte.class);
    DefaultAugmentedTeConfig cong = new DefaultAugmentedTeConfig();
    cong.payloadTreatment(TRANSPORT);
    cong.srcTpn(1);
    cong.srcClientSignal(ClientSignal10GbElan.class);
    cong.srcTributarySlotCount(1);
    DefaultSrcTributarySlots srcTributarySlots = new DefaultSrcTributarySlots();
    srcTributarySlots.addToValues((short) 1);
    cong.srcTributarySlots(srcTributarySlots);
    cong.dstTpn(13);
    cong.dstTributarySlotCount(1);
    DefaultDstTributarySlots dstTributarySlots = new DefaultDstTributarySlots();
    dstTributarySlots.addToValues((short) 1);
    cong.dstTributarySlots(dstTributarySlots);
    cong.dstTributarySlots().addToValues((short) 1);
    cong.dstClientSignal(ClientSignalOdu2e.class);
    config.addAugmentation(cong);
    Bandwidth bandwidth = new DefaultBandwidth();
    org.onosproject.yang.gen.v11.actnietfte.rev20170310.actnietfte.tetunnelbandwidthtop.bandwidth.DefaultConfig confg = new org.onosproject.yang.gen.v11.actnietfte.rev20170310.actnietfte.tetunnelbandwidthtop.bandwidth.DefaultConfig();
    confg.specificationType(new TeBandwidthType(SPECIFIED));
    BigInteger i = new BigInteger("10000000000");
    confg.setBandwidth(new BandwidthKbps(i));
    bandwidth.config(confg);
    tunnel.bandwidth(bandwidth);
    DefaultP2PprimaryPath p2PprimaryPath = new DefaultP2PprimaryPath();
    p2PprimaryPath.name("Primary path");
    org.onosproject.yang.gen.v11.actnietfte.rev20170310.actnietfte.p2pprimarypathproperties.DefaultConfig cc = new org.onosproject.yang.gen.v11.actnietfte.rev20170310.actnietfte.p2pprimarypathproperties.DefaultConfig();
    cc.name("Primary path");
    cc.useCspf(true);
    cc.namedExplicitPath("OTN-ERO-L0L1Service_lq_02_2b032409-8ec8-4b63" + "-ab9e-6fa9365913f0");
    cc.namedPathConstraint("OTN-PATH-CONSTRAINT-L0L1Service" + "_lq_02_2b032409-8ec8-4b63-ab9e" + "-6fa9365913f0");
    p2PprimaryPath.config(cc);
    DefaultP2PprimaryPaths p2PprimaryPaths = new DefaultP2PprimaryPaths();
    p2PprimaryPaths.addToP2PprimaryPath(p2PprimaryPath);
    tunnel.p2PprimaryPaths(p2PprimaryPaths);
    tunnel.config(config);
    DefaultDataValue dataValue = new DefaultDataValue();
    dataValue.addAnydata(tunnel);
    DefaultSchedules schedules = new DefaultSchedules();
    DefaultSchedule schedule = new DefaultSchedule();
    schedule.scheduleDuration("PT108850373514M");
    schedule.start(DateAndTime.of("2016-09-12T23:20:50.52Z"));
    long val = 11;
    schedule.scheduleId(val);
    schedules.addToSchedule(schedule);
    target.schedules(schedules);
    target.dataValue(dataValue);
    c1.addToTarget(target);
    data = new Builder();
    data.addModelObject(c1);
    rscData = treeBuilder.getResourceData(data.build());
    List<DataNode> nodes = rscData.dataNodes();
    DataNode n = nodes.get(0);
    validateDataNodeTree(n);
}
#end_block

#method_before
@Test
public void anydataTest() {
    DataNode.Builder dBlr = initializeDataNode(context);
    context.getRegistry().registerAnydataSchema(DefaultDataValue.class, DefaultTunnel.class);
    DataNode dataNode = actnDataTree(dBlr);
    ResourceData data = DefaultResourceData.builder().addDataNode(dataNode).build();
    DefaultYobBuilder builder = new DefaultYobBuilder(context.getRegistry());
    ModelObjectData modelObjectData = builder.getYangObject(data);
    List<ModelObject> modelObjectList = modelObjectData.modelObjects();
    ModelObject modelObject = modelObjectList.get(0);
    DefaultConfigurationSchedules c1 = ((DefaultConfigurationSchedules) modelObject);
    DefaultTarget target = ((DefaultTarget) c1.target().get(0));
    assertThat(target.object().toString(), is("te-links"));
    Operation obj = target.operation();
    assertThat(obj.enumeration().toString(), is("configure"));
    DefaultDataValue dataValue = (DefaultDataValue) target.dataValue();
    List<InnerModelObject> tunnel = dataValue.anydata(DefaultTunnel.class);
    assertThat(((DefaultTunnel) tunnel.get(0)).name().toString(), is("p2p"));
    Config config = ((DefaultTunnel) tunnel.get(0)).config();
    assertThat(config.name().toString(), is("p2p"));
    assertThat(((DefaultTunnel) tunnel.get(1)).name().toString(), is("p2p1"));
    config = ((DefaultTunnel) tunnel.get(1)).config();
    assertThat(config.name().toString(), is("p2p1"));
    Schedules schedules = target.schedules();
    Schedule schedule = schedules.schedule().get(0);
    assertThat(((Long) schedule.scheduleId()).toString(), is("11"));
    assertThat(schedule.start().toString(), is("2016-09-12T23:20:50.52Z"));
    assertThat(schedule.scheduleDuration().toString(), is("PT108850373514M"));
}
#method_after
@Test
public void anydataTest() {
    DataNode.Builder dBlr = initializeDataNode(context);
    ModelObjectId id = new ModelObjectId.Builder().addChild(DefaultConfigurationSchedules.class).addChild(DefaultTarget.class, null).addChild(DefaultDataValue.class).build();
    ModelObjectId id1 = new ModelObjectId.Builder().addChild(DefaultTe.class).addChild(DefaultTunnels.class).addChild(DefaultTunnel.class, null).build();
    context.getRegistry().registerAnydataSchema(id, id1);
    DataNode dataNode = actnDataTree(dBlr);
    ResourceData data = DefaultResourceData.builder().addDataNode(dataNode).build();
    DefaultYobBuilder builder = new DefaultYobBuilder(context.getRegistry());
    ModelObjectData modelObjectData = builder.getYangObject(data);
    List<ModelObject> modelObjectList = modelObjectData.modelObjects();
    ModelObject modelObject = modelObjectList.get(0);
    DefaultConfigurationSchedules c1 = ((DefaultConfigurationSchedules) modelObject);
    DefaultTarget target = ((DefaultTarget) c1.target().get(0));
    assertThat(target.object().toString(), is("te-links"));
    Operation obj = target.operation();
    assertThat(obj.enumeration().toString(), is("configure"));
    DefaultDataValue dataValue = (DefaultDataValue) target.dataValue();
    List<InnerModelObject> tunnel = dataValue.anydata(DefaultTunnel.class);
    assertThat(((DefaultTunnel) tunnel.get(0)).name().toString(), is("p2p"));
    Config config = ((DefaultTunnel) tunnel.get(0)).config();
    assertThat(config.name().toString(), is("p2p"));
    assertThat(config.type().toString(), is(TunnelP2p.class.toString()));
    assertThat(config.identifier(), is(19899));
    assertThat(config.description().toString(), is("OTN tunnel segment within the Huawei OTN Domain"));
    assertThat(config.encoding().toString(), is(LspEncodingOduk.class.toString()));
    assertThat(config.protectionType().toString(), is(LspProtUnprotected.class.toString()));
    assertThat(config.adminStatus().toString(), is(StateUp.class.toString()));
    assertThat(config.providerId().toString(), is("200"));
    assertThat(config.clientId().toString(), is("1000"));
    assertThat(config.teTopologyId().toString(), is("11"));
    assertThat(config.source().toString(), is("0.67.0.76"));
    assertThat(config.destination().toString(), is("0.67.0.77"));
    assertThat(config.setupPriority(), is(((short) 7)));
    assertThat(config.holdPriority(), is(((short) 6)));
    assertThat(config.signalingType().toString(), is(PathSignalingRsvpte.class.toString()));
    DefaultAugmentedTeConfig cong = config.augmentation(DefaultAugmentedTeConfig.class);
    assertThat(cong.payloadTreatment().toString(), is("transport"));
    assertThat(cong.srcTpn(), is(1));
    assertThat(cong.srcTributarySlotCount(), is(1));
    assertThat(cong.srcTributarySlots().values().get(0), is(((short) 1)));
    assertThat(cong.srcClientSignal().toString(), is(ClientSignal10GbElan.class.toString()));
    assertThat(cong.dstClientSignal().toString(), is(ClientSignalOdu2e.class.toString()));
    assertThat(cong.dstTpn(), is(13));
    assertThat(cong.dstTributarySlotCount(), is(1));
    assertThat(cong.dstTributarySlots().values().get(0), is(((short) 1)));
    Bandwidth bandwidth = ((DefaultTunnel) tunnel.get(0)).bandwidth();
    assertThat(bandwidth.config().specificationType().toString(), is("SPECIFIED"));
    assertThat(bandwidth.config().setBandwidth().toString(), is("10000000000"));
    P2PprimaryPath path = ((DefaultTunnel) tunnel.get(0)).p2PprimaryPaths().p2PprimaryPath().get(0);
    assertThat(path.name(), is("Primary path"));
    assertThat(path.config().name(), is("Primary path"));
    assertThat(path.config().useCspf(), is(true));
    assertThat(path.config().namedExplicitPath().toString(), is("OTN-ERO-L0L1Service_lq_02_2b032409-8ec8-4b63-ab9e-6fa9365913f0"));
    assertThat(path.config().namedPathConstraint().toString(), is("OTN-PATH-CONSTRAINT-L0L1Service_lq_02_2b032409-8ec8-4b63-ab9e-6fa9365913f0"));
    Schedules schedules = target.schedules();
    Schedule schedule = schedules.schedule().get(0);
    assertThat(((Long) schedule.scheduleId()).toString(), is("11"));
    assertThat(schedule.start().toString(), is("2016-09-12T23:20:50.52Z"));
    assertThat(schedule.scheduleDuration().toString(), is("PT108850373514M"));
}
#end_block

#method_before
public DataNode buildDnForAnydata() {
    dBlr = initializeDataNode(context);
    value = null;
    // Adding container c1
    dBlr = addDataNode(dBlr, "c1", TANY_NS, value, null);
    // Adding anydata container
    dBlr = addDataNode(dBlr, "mydata2", TANY_NS, value, null);
    context.getRegistry().registerAnydataSchema(Mydata2.class, Node.class);
    context.getRegistry().registerAnydataSchema(Mydata2.class, DefaultLink.class);
    context.getRegistry().registerAnydataSchema(Mydata2.class, SupportingTerminationPoint.class);
    // Adding list inside anydata container
    dBlr = addDataNode(dBlr, "link", NW_TOPO_NAME_SPACE, value, null);
    value = "link-id";
    dBlr = addDataNode(dBlr, "link-id", NW_TOPO_NAME_SPACE, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "source", NW_TOPO_NAME_SPACE, value, null);
    value = "source-node";
    dBlr = addDataNode(dBlr, "source-node", NW_TOPO_NAME_SPACE, value, null);
    dBlr = exitDataNode(dBlr);
    // exit source
    dBlr = exitDataNode(dBlr);
    // exit link
    dBlr = exitDataNode(dBlr);
    // Adding list inside anydata container
    value = null;
    dBlr = addDataNode(dBlr, "node", IETFNS, value, null);
    // Adding key element node-id
    value = "node1";
    dBlr = addDataNode(dBlr, "node-id", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    // Adding list inside list
    dBlr = addDataNode(dBlr, "supporting-node", null, value, null);
    // Adding key element network-ref
    value = "network3";
    dBlr = addDataNode(dBlr, "network-ref", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "network4";
    // Adding key element node-ref
    dBlr = addDataNode(dBlr, "node-ref", null, value, null);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    return dBlr.build();
}
#method_after
public DataNode buildDnForAnydata() {
    dBlr = initializeDataNode(context);
    value = null;
    // Adding container c1
    dBlr = addDataNode(dBlr, "c1", TANY_NS, value, null);
    // Adding anydata container
    dBlr = addDataNode(dBlr, "mydata2", TANY_NS, value, null);
    ModelObjectId id = new ModelObjectId.Builder().addChild(DefaultC1.class).addChild(DefaultMydata2.class).build();
    ModelObjectId id1 = new ModelObjectId.Builder().addChild(DefaultNetworks.class).addChild(DefaultNetwork.class, null).addChild(DefaultNode.class, null).build();
    ModelObjectId id2 = new ModelObjectId.Builder().addChild(DefaultNetworks.class).addChild(DefaultNetwork.class, null).addChild(DefaultLink.class, null).build();
    context.getRegistry().registerAnydataSchema(id, id1);
    context.getRegistry().registerAnydataSchema(id, id2);
    // Adding list inside anydata container
    dBlr = addDataNode(dBlr, "link", NW_TOPO_NAME_SPACE, value, null);
    value = "link-id";
    dBlr = addDataNode(dBlr, "link-id", NW_TOPO_NAME_SPACE, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "source", NW_TOPO_NAME_SPACE, value, null);
    value = "source-node";
    dBlr = addDataNode(dBlr, "source-node", NW_TOPO_NAME_SPACE, value, null);
    dBlr = exitDataNode(dBlr);
    // exit source
    dBlr = exitDataNode(dBlr);
    // exit link
    dBlr = exitDataNode(dBlr);
    // Adding list inside anydata container
    value = null;
    dBlr = addDataNode(dBlr, "node", IETFNS, value, null);
    // Adding key element node-id
    value = "node1";
    dBlr = addDataNode(dBlr, "node-id", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    // Adding list inside list
    dBlr = addDataNode(dBlr, "supporting-node", null, value, null);
    // Adding key element network-ref
    value = "network3";
    dBlr = addDataNode(dBlr, "network-ref", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "network4";
    // Adding key element node-ref
    dBlr = addDataNode(dBlr, "node-ref", null, value, null);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    return dBlr.build();
}
#end_block

#method_before
@Test
public void atcnDataNodeTest() {
    TestYangSerializerContext context = new TestYangSerializerContext();
    DataNode.Builder dBlr = initializeDataNode(context);
    context.getRegistry().registerAnydataSchema(DefaultDataValue.class, DefaultTunnel.class);
    DataNode n = actnDataTree(dBlr);
    validateDataNodeTree(n);
}
#method_after
@Test
public void atcnDataNodeTest() {
    TestYangSerializerContext context = new TestYangSerializerContext();
    DataNode.Builder dBlr = initializeDataNode(context);
    ModelObjectId id = new ModelObjectId.Builder().addChild(DefaultConfigurationSchedules.class).addChild(DefaultTarget.class, null).addChild(DefaultDataValue.class).build();
    ModelObjectId id1 = new ModelObjectId.Builder().addChild(DefaultTe.class).addChild(DefaultTunnels.class).addChild(DefaultTunnel.class, null).build();
    context.getRegistry().registerAnydataSchema(id, id1);
    DataNode n = actnDataTree(dBlr);
    validateDataNodeTree(n);
}
#end_block

#method_before
public static DataNode actnDataTree(DataNode.Builder dBlr) {
    String value = null;
    // Adding container configuration-schedules
    dBlr = addDataNode(dBlr, "configuration-schedules", ACTN_SCHD_NS, value, null);
    // Adding list target
    dBlr = addDataNode(dBlr, "target", ACTN_SCHD_NS, value, null);
    value = "te-links";
    dBlr = addDataNode(dBlr, "object", ACTN_SCHD_NS, value, null);
    dBlr = exitDataNode(dBlr);
    value = "configure";
    dBlr = addDataNode(dBlr, "operation", ACTN_SCHD_NS, value, null);
    dBlr = exitDataNode(dBlr);
    // Adding anydata container
    value = null;
    dBlr = addDataNode(dBlr, "data-value", ACTN_SCHD_NS, value, null);
    dBlr = addDataNode(dBlr, "tunnel", ACTN_TE, value, null);
    value = "p2p";
    dBlr = addDataNode(dBlr, "name", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "config", null, value, null);
    value = "p2p";
    dBlr = addDataNode(dBlr, "name", null, value, null);
    dBlr = exitDataNode(dBlr);
    // config
    dBlr = exitDataNode(dBlr);
    // tunnel
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "tunnel", ACTN_TE, value, null);
    value = "p2p1";
    dBlr = addDataNode(dBlr, "name", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "config", null, value, null);
    value = "p2p1";
    dBlr = addDataNode(dBlr, "name", null, value, null);
    dBlr = exitDataNode(dBlr);
    // config
    dBlr = exitDataNode(dBlr);
    // tunnel1
    dBlr = exitDataNode(dBlr);
    // data-value
    dBlr = exitDataNode(dBlr);
    value = null;
    // Adding container schedules
    dBlr = addDataNode(dBlr, "schedules", ACTN_SCHD_NS, value, null);
    // Adding list schedules
    dBlr = addDataNode(dBlr, "schedule", null, value, null);
    value = "11";
    dBlr = addDataNode(dBlr, "schedule-id", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "2016-09-12T23:20:50.52Z";
    dBlr = addDataNode(dBlr, "start", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "PT108850373514M";
    dBlr = addDataNode(dBlr, "schedule-duration", null, value, null);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    return dBlr.build();
}
#method_after
public static DataNode actnDataTree(DataNode.Builder dBlr) {
    String value = null;
    // Adding container configuration-schedules
    dBlr = addDataNode(dBlr, "configuration-schedules", ACTN_SCHD_NS, value, null);
    // Adding list target
    dBlr = addDataNode(dBlr, "target", ACTN_SCHD_NS, value, null);
    value = "te-links";
    dBlr = addDataNode(dBlr, "object", ACTN_SCHD_NS, value, null);
    dBlr = exitDataNode(dBlr);
    value = "configure";
    dBlr = addDataNode(dBlr, "operation", ACTN_SCHD_NS, value, null);
    dBlr = exitDataNode(dBlr);
    // Adding anydata container
    value = null;
    dBlr = addDataNode(dBlr, "data-value", ACTN_SCHD_NS, value, null);
    dBlr = getTunnelBuilder(dBlr, "p2p");
    dBlr = getTunnelBuilder(dBlr, "p2p1");
    // data-value
    dBlr = exitDataNode(dBlr);
    value = null;
    // Adding container schedules
    dBlr = addDataNode(dBlr, "schedules", ACTN_SCHD_NS, value, null);
    // Adding list schedules
    dBlr = addDataNode(dBlr, "schedule", null, value, null);
    value = "11";
    dBlr = addDataNode(dBlr, "schedule-id", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "2016-09-12T23:20:50.52Z";
    dBlr = addDataNode(dBlr, "start", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "PT108850373514M";
    dBlr = addDataNode(dBlr, "schedule-duration", null, value, null);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    return dBlr.build();
}
#end_block

#method_before
public static void validateDataNodeTree(DataNode node) {
    // Validating the data node.
    DataNode n = node;
    validateDataNode(n, "configuration-schedules", ACTN_SCHD_NS, SINGLE_INSTANCE_NODE, true, null);
    Iterator<DataNode> it = ((InnerNode) n).childNodes().values().iterator();
    n = it.next();
    validateDataNode(n, "target", ACTN_SCHD_NS, MULTI_INSTANCE_NODE, true, null);
    Iterator<KeyLeaf> keyIt = ((ListKey) n.key()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "object", ACTN_SCHD_NS, "te-links");
    Iterator<DataNode> it1 = ((InnerNode) n).childNodes().values().iterator();
    n = it1.next();
    validateDataNode(n, "object", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "te-links");
    n = it1.next();
    validateDataNode(n, "operation", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "configure");
    n = it1.next();
    validateDataNode(n, "data-value", ACTN_SCHD_NS, SINGLE_INSTANCE_NODE, true, null);
    Iterator<DataNode> it3 = ((InnerNode) n).childNodes().values().iterator();
    n = it3.next();
    validateDataNode(n, "tunnel", ACTN_TE, MULTI_INSTANCE_NODE, true, null);
    keyIt = ((ListKey) n.key()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "name", ACTN_TE, "p2p");
    Iterator<DataNode> it4 = ((InnerNode) n).childNodes().values().iterator();
    n = it4.next();
    validateDataNode(n, "name", ACTN_TE, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "p2p");
    n = it4.next();
    validateDataNode(n, "config", ACTN_TE, SINGLE_INSTANCE_NODE, true, null);
    it4 = ((InnerNode) n).childNodes().values().iterator();
    n = it4.next();
    validateDataNode(n, "name", ACTN_TE, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "p2p");
    n = it3.next();
    validateDataNode(n, "tunnel", ACTN_TE, MULTI_INSTANCE_NODE, true, null);
    keyIt = ((ListKey) n.key()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "name", ACTN_TE, "p2p1");
    it3 = ((InnerNode) n).childNodes().values().iterator();
    n = it3.next();
    validateDataNode(n, "name", ACTN_TE, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "p2p1");
    n = it3.next();
    validateDataNode(n, "config", ACTN_TE, SINGLE_INSTANCE_NODE, true, null);
    it3 = ((InnerNode) n).childNodes().values().iterator();
    n = it3.next();
    validateDataNode(n, "name", ACTN_TE, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "p2p1");
    n = it1.next();
    validateDataNode(n, "schedules", ACTN_SCHD_NS, SINGLE_INSTANCE_NODE, true, null);
    Iterator<DataNode> it2 = ((InnerNode) n).childNodes().values().iterator();
    n = it2.next();
    validateDataNode(n, "schedule", ACTN_SCHD_NS, MULTI_INSTANCE_NODE, true, null);
    keyIt = ((ListKey) n.key()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "schedule-id", ACTN_SCHD_NS, "11");
    it1 = ((InnerNode) n).childNodes().values().iterator();
    n = it1.next();
    validateDataNode(n, "schedule-id", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "11");
    n = it1.next();
    validateDataNode(n, "start", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "2016-09-12T23:20:50.52Z");
    n = it1.next();
    validateDataNode(n, "schedule-duration", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "PT108850373514M");
    walkINTree(node, EXPECTED);
}
#method_after
public static void validateDataNodeTree(DataNode node) {
    // Validating the data node.
    DataNode n = node;
    validateDataNode(n, "configuration-schedules", ACTN_SCHD_NS, SINGLE_INSTANCE_NODE, true, null);
    Iterator<DataNode> it = ((InnerNode) n).childNodes().values().iterator();
    n = it.next();
    validateDataNode(n, "target", ACTN_SCHD_NS, MULTI_INSTANCE_NODE, true, null);
    Iterator<KeyLeaf> keyIt = ((ListKey) n.key()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "object", ACTN_SCHD_NS, "te-links");
    Iterator<DataNode> it1 = ((InnerNode) n).childNodes().values().iterator();
    n = it1.next();
    validateDataNode(n, "object", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "te-links");
    n = it1.next();
    validateDataNode(n, "operation", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "configure");
    n = it1.next();
    validateDataNode(n, "data-value", ACTN_SCHD_NS, SINGLE_INSTANCE_NODE, true, null);
    Iterator<DataNode> it5 = ((InnerNode) n).childNodes().values().iterator();
    tunnelValidator(it5.next(), "p2p");
    n = it5.next();
    tunnelValidator(n, "p2p1");
    n = it1.next();
    validateDataNode(n, "schedules", ACTN_SCHD_NS, SINGLE_INSTANCE_NODE, true, null);
    it1 = ((InnerNode) n).childNodes().values().iterator();
    n = it1.next();
    validateDataNode(n, "schedule", ACTN_SCHD_NS, MULTI_INSTANCE_NODE, true, null);
    keyIt = ((ListKey) n.key()).keyLeafs().iterator();
    validateLeafDataNode(keyIt.next(), "schedule-id", ACTN_SCHD_NS, "11");
    it1 = ((InnerNode) n).childNodes().values().iterator();
    n = it1.next();
    validateDataNode(n, "schedule-id", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "11");
    n = it1.next();
    validateDataNode(n, "start", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "2016-09-12T23:20:50.52Z");
    n = it1.next();
    validateDataNode(n, "schedule-duration", ACTN_SCHD_NS, SINGLE_INSTANCE_LEAF_VALUE_NODE, false, "PT108850373514M");
}
#end_block

#method_before
public static ONOSLLDP onosLLDP(String deviceId, ChassisId chassisId, int portNum, String portDesc) {
    ONOSLLDP probe = onosLLDP(deviceId, chassisId, portNum);
    if (portDesc != null && !portDesc.isEmpty()) {
        LLDPTLV portDescTlv = new LLDPTLV().setType(PORT_DESC_TLV_TYPE).setLength((short) portDesc.length()).setValue(portDesc.getBytes(StandardCharsets.UTF_8));
        probe.addOptionalTLV(portDescTlv);
    }
    return probe;
}
#method_after
public static ONOSLLDP onosLLDP(String deviceId, ChassisId chassisId, int portNum, String portDesc) {
    ONOSLLDP probe = onosLLDP(deviceId, chassisId, portNum);
    if (portDesc != null && !portDesc.isEmpty()) {
        byte[] bPortDesc = portDesc.getBytes(StandardCharsets.UTF_8);
        if (bPortDesc.length > LLDPTLV.MAX_LENGTH) {
            bPortDesc = Arrays.copyOf(bPortDesc, LLDPTLV.MAX_LENGTH);
        }
        LLDPTLV portDescTlv = new LLDPTLV().setType(PORT_DESC_TLV_TYPE).setLength((short) bPortDesc.length).setValue(bPortDesc);
        probe.addOptionalTLV(portDescTlv);
    }
    return probe;
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean defaultRule = false;
    boolean popMpls = false;
    boolean emptyGroup = false;
    boolean allowDefaultRoute = true;
    int mplsNextTable = ACL_TABLE;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            filteredSelector.matchVlanId(assignedVlan);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                if (allowDefaultRoute) {
                    // The entire IPV4_DST field is wildcarded intentionally
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
                } else {
                    // NOTE: The switch does not support matching 0.0.0.0/0
                    // Split it into 0.0.0.0/1 and 128.0.0.0/1
                    filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("0.0.0.0/1"));
                    complementarySelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf("128.0.0.0/1"));
                    defaultRule = true;
                }
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                    // setting the MPLS_TYPE so pop can happen down the pipeline
                    if (!new String("MPLS_POP:mpls_unicast").equals(((L2ModificationInstruction) instr).toString())) {
                        tb.immediate().add(instr);
                    }
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a
            // MPLS interface, or a MPLS SWAP (with-same) but that would
            // have to be handled in the next-objective. Also the pop-mpls
            // logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // check if group is empty
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                emptyGroup = true;
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        FlowRule.Builder rule = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(complementarySelector.build()).withTreatment(tb.build()).forTable(forTableId);
        if (fwd.permanent()) {
            rule.makePermanent();
        } else {
            rule.makeTemporary(fwd.timeout());
        }
        flowRuleCollection.add(rule.build());
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    // XXX retrying flows may be necessary due to bug CORD-554
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    return processEthTypeSpecificInternal(fwd, true, ACL_TABLE);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(pwaasConfigFactory);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(pwaasConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    log.info("Stopped");
}
#end_block

#method_before
Boolean isSeenLinkUp(Link link) {
    return seenLinks.get(link);
}
#method_after
private Boolean isSeenLinkUp(Link link) {
    return seenLinks.get(link);
}
#end_block

#method_before
public boolean isBidirectional(Link link) {
    Link reverseLink = linkService.getLink(link.dst(), link.src());
    if (reverseLink == null) {
        return false;
    }
    Boolean result = isSeenLinkUp(reverseLink);
    if (result == null) {
        return false;
    }
    return result.booleanValue();
}
#method_after
boolean isBidirectional(Link link) {
    Link reverseLink = linkService.getLink(link.dst(), link.src());
    if (reverseLink == null) {
        return false;
    }
    Boolean result = isSeenLinkUp(reverseLink);
    if (result == null) {
        return false;
    }
    return result.booleanValue();
}
#end_block

#method_before
public boolean avoidLink(Link link) {
    // XXX currently only avoids all pair-links. In the future can be
    // extended to avoid any generic link
    DeviceId src = link.src().deviceId();
    PortNumber srcPort = link.src().port();
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(src)) {
        log.warn("Device {} not configured..cannot avoid link {}", src, link);
        return false;
    }
    DeviceId pairDev;
    PortNumber pairLocalPort, pairRemotePort = null;
    try {
        pairDev = deviceConfiguration.getPairDeviceId(src);
        pairLocalPort = deviceConfiguration.getPairLocalPort(src);
        if (pairDev != null) {
            pairRemotePort = deviceConfiguration.getPairLocalPort(pairDev);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn("Pair dev for dev {} not configured..cannot avoid link {}", src, link);
        return false;
    }
    if (srcPort.equals(pairLocalPort) && link.dst().deviceId().equals(pairDev) && link.dst().port().equals(pairRemotePort)) {
        return true;
    }
    return false;
}
#method_after
boolean avoidLink(Link link) {
    // XXX currently only avoids all pair-links. In the future can be
    // extended to avoid any generic link
    DeviceId src = link.src().deviceId();
    PortNumber srcPort = link.src().port();
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(src)) {
        log.warn("Device {} not configured..cannot avoid link {}", src, link);
        return false;
    }
    DeviceId pairDev;
    PortNumber pairLocalPort, pairRemotePort = null;
    try {
        pairDev = deviceConfiguration.getPairDeviceId(src);
        pairLocalPort = deviceConfiguration.getPairLocalPort(src);
        if (pairDev != null) {
            pairRemotePort = deviceConfiguration.getPairLocalPort(pairDev);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn("Pair dev for dev {} not configured..cannot avoid link {}", src, link);
        return false;
    }
    return srcPort.equals(pairLocalPort) && link.dst().deviceId().equals(pairDev) && link.dst().port().equals(pairRemotePort);
}
#end_block

#method_before
private boolean isLinkValid(Link link) {
    if (link.type() != Link.Type.DIRECT) {
        // NOTE: A DIRECT link might be transiently marked as INDIRECT
        // if BDDP is received before LLDP. We can safely ignore that
        // until the LLDP is received and the link is marked as DIRECT.
        log.info("Ignore link {}->{}. Link type is {} instead of DIRECT.", link.src(), link.dst(), link.type());
        return false;
    }
    DeviceId srcId = link.src().deviceId();
    DeviceId dstId = link.dst().deviceId();
    if (srcId.equals(dstId)) {
        log.warn("Links between ports on the same switch are not " + "allowed .. ignoring link {}", link);
        return false;
    }
    try {
        if (!deviceConfiguration.isEdgeDevice(srcId) && !deviceConfiguration.isEdgeDevice(dstId)) {
            // ignore links between spines
            // XXX revisit when handling multi-stage fabrics
            log.warn("Links between spines not allowed...ignoring " + "link {}", link);
            return false;
        }
        if (deviceConfiguration.isEdgeDevice(srcId) && deviceConfiguration.isEdgeDevice(dstId)) {
            // one pair-link
            if (deviceConfiguration.getPairDeviceId(srcId).equals(dstId) && deviceConfiguration.getPairLocalPort(srcId).equals(link.src().port()) && deviceConfiguration.getPairLocalPort(dstId).equals(link.dst().port())) {
                // found pair link - allow it
                return true;
            } else {
                log.warn("Links between leaves other than pair-links are " + "not allowed...ignoring link {}", link);
                return false;
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn("Could not check validity of link {} as subtending devices " + "are not yet configured", link);
    }
    return true;
}
#method_after
private boolean isLinkValid(Link link) {
    if (link.type() != Link.Type.DIRECT) {
        // NOTE: A DIRECT link might be transiently marked as INDIRECT
        // if BDDP is received before LLDP. We can safely ignore that
        // until the LLDP is received and the link is marked as DIRECT.
        log.info("Ignore link {}->{}. Link type is {} instead of DIRECT.", link.src(), link.dst(), link.type());
        return false;
    }
    DeviceId srcId = link.src().deviceId();
    DeviceId dstId = link.dst().deviceId();
    if (srcId.equals(dstId)) {
        log.warn("Links between ports on the same switch are not " + "allowed .. ignoring link {}", link);
        return false;
    }
    try {
        if (!deviceConfiguration.isEdgeDevice(srcId) && !deviceConfiguration.isEdgeDevice(dstId)) {
            // ignore links between spines
            // XXX revisit when handling multi-stage fabrics
            log.warn("Links between spines not allowed...ignoring " + "link {}", link);
            return false;
        }
        if (deviceConfiguration.isEdgeDevice(srcId) && deviceConfiguration.isEdgeDevice(dstId)) {
            // one pair-link
            if (deviceConfiguration.getPairDeviceId(srcId).equals(dstId) && deviceConfiguration.getPairLocalPort(srcId).equals(link.src().port()) && deviceConfiguration.getPairLocalPort(dstId).equals(link.dst().port())) {
                // found pair link - allow it
                return true;
            } else {
                log.warn("Links between leaves other than pair-links are " + "not allowed...ignoring link {}", link);
                return false;
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        // We still want to count the links in seenLinks even though there
        // is no config. So we let it return true
        log.warn("Could not check validity of link {} as subtending devices " + "are not yet configured", link);
    }
    return true;
}
#end_block

#method_before
private void processDeviceRemoved(Device device) {
    dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> {
        dsNextObjStore.remove(entry.getKey());
    });
    vlanNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> vlanNextObjStore.remove(entry.getKey()));
    portNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> portNextObjStore.remove(entry.getKey()));
    seenLinks.keySet().removeIf(key -> key.src().deviceId().equals(device.id()) || key.dst().deviceId().equals(device.id()));
    DefaultGroupHandler gh = groupHandlerMap.remove(device.id());
    if (gh != null) {
        gh.shutdown();
    }
    defaultRoutingHandler.purgeEcmpGraph(device.id());
    // Note that a switch going down is associated with all of its links
    // going down as well, but it is treated as a single switch down event
    // while the link-downs are ignored.
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, null, device.id());
    mcastHandler.removeDevice(device.id());
    xConnectHandler.removeDevice(device.id());
}
#method_after
private void processDeviceRemoved(Device device) {
    dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> dsNextObjStore.remove(entry.getKey()));
    vlanNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> vlanNextObjStore.remove(entry.getKey()));
    portNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> portNextObjStore.remove(entry.getKey()));
    seenLinks.keySet().removeIf(key -> key.src().deviceId().equals(device.id()) || key.dst().deviceId().equals(device.id()));
    DefaultGroupHandler gh = groupHandlerMap.remove(device.id());
    if (gh != null) {
        gh.shutdown();
    }
    defaultRoutingHandler.purgeEcmpGraph(device.id());
    // Note that a switch going down is associated with all of its links
    // going down as well, but it is treated as a single switch down event
    // while the link-downs are ignored.
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, null, device.id());
    mcastHandler.removeDevice(device.id());
    xConnectHandler.removeDevice(device.id());
}
#end_block

#method_before
private void processEdgePort(Device device, Port port, VlanId vlanId, boolean popVlan) {
    boolean portUp = port.isEnabled();
    if (portUp) {
        log.info("Device:EdgePort {}:{} is enabled in vlan: {}", device.id(), port.number(), vlanId);
    } else {
        log.info("Device:EdgePort {}:{} is disabled in vlan: {}", device.id(), port.number(), vlanId);
    }
    DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
    if (groupHandler != null) {
        groupHandler.processEdgePort(port.number(), vlanId, popVlan, portUp);
    } else {
        log.warn("Group handler not found for dev:{}. Not handling edge port" + " {} event for port:{}", device.id(), (portUp) ? "UP" : "DOWN", port.number());
    }
}
#method_after
private void processEdgePort(Device device, Port port, VlanId vlanId, boolean popVlan) {
    boolean portUp = port.isEnabled();
    if (portUp) {
        log.info("Device:EdgePort {}:{} is enabled in vlan: {}", device.id(), port.number(), vlanId);
        hostHandler.processPortUp(new ConnectPoint(device.id(), port.number()));
    } else {
        log.info("Device:EdgePort {}:{} is disabled in vlan: {}", device.id(), port.number(), vlanId);
    }
    DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
    if (groupHandler != null) {
        groupHandler.processEdgePort(port.number(), vlanId, popVlan, portUp);
    } else {
        log.warn("Group handler not found for dev:{}. Not handling edge port" + " {} event for port:{}", device.id(), (portUp) ? "UP" : "DOWN", port.number());
    }
}
#end_block

#method_before
public void configureNetwork() {
    createOrUpdateDeviceConfiguration();
    arpHandler = new ArpHandler(srManager);
    icmpHandler = new IcmpHandler(srManager);
    ipHandler = new IpHandler(srManager);
    routingRulePopulator = new RoutingRulePopulator(srManager);
    defaultRoutingHandler = new DefaultRoutingHandler(srManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    // add a small delay to absorb multiple network config added notifications
    if (!programmingScheduled.get()) {
        programmingScheduled.set(true);
        executorService.schedule(new ConfigChange(), PROGRAM_DELAY, TimeUnit.SECONDS);
    }
    mcastHandler.init();
}
#method_after
void configureNetwork() {
    createOrUpdateDeviceConfiguration();
    arpHandler = new ArpHandler(srManager);
    icmpHandler = new IcmpHandler(srManager);
    ipHandler = new IpHandler(srManager);
    routingRulePopulator = new RoutingRulePopulator(srManager);
    defaultRoutingHandler = new DefaultRoutingHandler(srManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    // add a small delay to absorb multiple network config added notifications
    if (!programmingScheduled.get()) {
        programmingScheduled.set(true);
        executorService.schedule(new ConfigChange(), PROGRAM_DELAY, TimeUnit.SECONDS);
    }
    mcastHandler.init();
}
#end_block

#method_before
@Override
public void init(Dpid dpid, OFDescStatsReply desc, OFVersion ofv) {
    this.dpid = dpid;
    this.desc = desc;
    this.ofVersion = ofv;
}
#method_after
@Override
public void init(Dpid dpid, OFDescStatsReply desc, OFVersion ofv) {
    this.dpid = dpid;
    this.desc = desc;
}
#end_block

#method_before
@Override
public final void setOFVersion(OFVersion ofV) {
    this.ofVersion = ofV;
    this.ofFactory = OFFactories.getFactory(ofV);
}
#method_after
@Override
public final void setOFVersion(OFVersion ofV) {
    this.ofFactory = OFFactories.getFactory(ofV);
}
#end_block

#method_before
@Override
public void setFeaturesReply(OFFeaturesReply featuresReply) {
    this.features = featuresReply;
}
#method_after
@Override
public void setFeaturesReply(OFFeaturesReply featuresReply) {
    this.features = featuresReply;
    if (featuresReply.getVersion().compareTo(OFVersion.OF_13) < 0) {
        // before OF 1.3, feature reply contains OFPortDescs
        replacePortDescsWith(featuresReply.getPorts());
    }
}
#end_block

#method_before
// ************************
// Message handling
// ************************
@Override
public final void handleMessage(OFMessage m) {
    if (this.role == RoleState.MASTER || m instanceof OFPortStatus) {
        try {
            this.agent.processMessage(dpid, m);
        } catch (Exception e) {
            log.warn("Unhandled exception processing {}@{}", m, dpid, e);
        }
    } else {
        log.trace("Dropping received message {}, was not MASTER", m);
    }
}
#method_after
// ************************
// Message handling
// ************************
@Override
public final void handleMessage(OFMessage m) {
    if (this.role == RoleState.MASTER || m instanceof OFPortStatus) {
        try {
            // also ignore role state.
            if (m.getType() == OFType.PORT_STATUS) {
                OFPortStatus portStatus = (OFPortStatus) m;
                if (portStatus.getReason() == OFPortReason.DELETE) {
                    portDescs.remove(portStatus.getDesc().getPortNo());
                } else {
                    portDescs.put(portStatus.getDesc().getPortNo(), portStatus.getDesc());
                }
            }
            this.agent.processMessage(dpid, m);
        } catch (Exception e) {
            log.warn("Unhandled exception processing {}@{}", m, dpid, e);
        }
    } else {
        log.trace("Dropping received message {}, was not MASTER", m);
    }
}
#end_block

#method_before
@Override
public void setPortDescReply(OFPortDescStatsReply portDescReply) {
    this.ports.add(portDescReply);
}
#method_after
@Override
public void setPortDescReply(OFPortDescStatsReply portDescReply) {
    portDescReply.getEntries().forEach(pd -> portDescs.put(pd.getPortNo(), pd));
    // maintaining only for backward compatibility, to be removed
    this.ports.add(portDescReply);
}
#end_block

#method_before
@Override
public void setPortDescReplies(List<OFPortDescStatsReply> portDescReplies) {
    this.ports.addAll(portDescReplies);
}
#method_after
@Override
public void setPortDescReplies(List<OFPortDescStatsReply> portDescReplies) {
    replacePortDescsWith(portDescReplies.stream().map(OFPortDescStatsReply::getEntries).flatMap(List::stream).collect(Collectors.toList()));
    // maintaining only for backward compatibility, to be removed
    this.ports.addAll(portDescReplies);
}
#end_block

#method_before
@Override
public List<OFPortDesc> getPorts() {
    return this.ports.stream().flatMap(portReply -> portReply.getEntries().stream()).collect(Collectors.toList());
}
#method_after
@Override
public List<OFPortDesc> getPorts() {
    return ImmutableList.copyOf(portDescs.values());
}
#end_block

#method_before
private void createCollector(OpenFlowSwitch sw) {
    if (sw == null) {
        return;
    }
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Constructor
        NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(driverService, sw, flowPollFrequency);
        stopCollectorIfNeeded(afsCollectors.put(new Dpid(sw.getId()), fsc));
        fsc.start();
    } else {
        FlowStatsCollector fsc = new FlowStatsCollector(timer, sw, flowPollFrequency);
        stopCollectorIfNeeded(simpleCollectors.put(new Dpid(sw.getId()), fsc));
        fsc.start();
    }
    if (sw.getFeatures().getCapabilities().contains(OFCapabilities.TABLE_STATS)) {
        TableStatisticsCollector tsc = new TableStatisticsCollector(timer, sw, flowPollFrequency);
        stopCollectorIfNeeded(tableStatsCollectors.put(new Dpid(sw.getId()), tsc));
        tsc.start();
    }
}
#method_after
private void createCollector(OpenFlowSwitch sw) {
    if (sw == null) {
        return;
    }
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Constructor
        NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(driverService, sw, flowPollFrequency);
        stopCollectorIfNeeded(afsCollectors.put(new Dpid(sw.getId()), fsc));
        fsc.start();
    } else {
        FlowStatsCollector fsc = new FlowStatsCollector(timer, sw, flowPollFrequency);
        stopCollectorIfNeeded(simpleCollectors.put(new Dpid(sw.getId()), fsc));
        fsc.start();
    }
    if (sw.features().getCapabilities().contains(OFCapabilities.TABLE_STATS)) {
        TableStatisticsCollector tsc = new TableStatisticsCollector(timer, sw, flowPollFrequency);
        stopCollectorIfNeeded(tableStatsCollectors.put(new Dpid(sw.getId()), tsc));
        tsc.start();
    }
}
#end_block

#method_before
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(piCounterId1, sameAsPiCounterId1).addEqualityGroup(piCounterId2).testEquals();
}
#method_after
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(PI_COUNTER_ID_1, SAME_AS_PI_COUNTER_ID_1).addEqualityGroup(PI_COUNTER_ID_2).testEquals();
}
#end_block

#method_before
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(piPipelineModel1, sameAsPiPipelineModel1).addEqualityGroup(piPipelineModel2).testEquals();
}
#method_after
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(P4_PIPELINE_MODEL_1, SAME_AS_P4_PIPELINE_MODEL_1).addEqualityGroup(P4_PIPELINE_MODEL_2).testEquals();
}
#end_block

#method_before
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(piCounterCellData1, sameAsPiCounterCellData1).addEqualityGroup(piCounterCellData2).testEquals();
}
#method_after
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(PI_COUNTER_CELL_DATA_1, SAME_AS_PI_COUNTER_CELL_DATA_1).addEqualityGroup(PI_COUNTER_CELL_DATA_2).testEquals();
}
#end_block

#method_before
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(p4MatchFieldModel1, sameAsP4MatchFieldModel1).addEqualityGroup(p4MatchFieldModel2).testEquals();
}
#method_after
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(P4_MATCH_FIELD_MODEL_1, SAME_AS_P4_MATCH_FIELD_MODEL_1).addEqualityGroup(P4_MATCH_FIELD_MODEL_2).testEquals();
}
#end_block

#method_before
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(p4PacketOperationModel1, sameAsP4PacketOperationModel1).addEqualityGroup(p4PacketOperationModel2).addEqualityGroup(p4PacketOperationModel3).testEquals();
}
#method_after
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(P4_PACKET_OPERATION_MODEL_1, SAME_AS_P4_PACKET_OPERATION_MODEL_1).addEqualityGroup(P4_PACKET_OPERATION_MODEL_2).addEqualityGroup(P4_PACKET_OPERATION_MODEL_3).testEquals();
}
#end_block

#method_before
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(p4MeterModel1, sameAsP4MeterModel1).addEqualityGroup(p4MeterModel2).addEqualityGroup(p4MeterModel3).testEquals();
}
#method_after
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(P4_METER_MODEL_1, SAME_AS_P4_METER_MODEL_1).addEqualityGroup(P4_METER_MODEL_2).addEqualityGroup(P4_METER_MODEL_3).testEquals();
}
#end_block

#method_before
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(p4TableModel1, sameAsP4TableModel1).addEqualityGroup(p4TableModel2).testEquals();
}
#method_after
@Test
public void testEquals() {
    new EqualsTester().addEqualityGroup(P4_TABLE_MODEL_1, SAME_AS_P4_TABLE_MODEL_1).addEqualityGroup(P4_TABLE_MODEL_2).testEquals();
}
#end_block

#method_before
@Test
public void testConstructorWithNullDeviceId() {
    try {
        new DefaultPacketIn(nullDeviceId, packetOperation);
        fail("Exception was expected for null input");
    } catch (NullPointerException e) {
    }
}
#method_after
@Test(expected = NullPointerException.class)
public void testConstructorWithNullDeviceId() {
    new DefaultPacketIn(nullDeviceId, packetOperation);
}
#end_block

#method_before
@Test
public void testConstructorWithNullPacketOperation() {
    try {
        new DefaultPacketIn(deviceId, nullPacketOperation);
        fail("Exception was expected for null input");
    } catch (NullPointerException e) {
    }
}
#method_after
@Test(expected = NullPointerException.class)
public void testConstructorWithNullPacketOperation() {
    new DefaultPacketIn(deviceId, nullPacketOperation);
}
#end_block

#method_before
@Test
public void deviceId() throws Exception {
    new EqualsTester().addEqualityGroup(deviceId, packetIn.deviceId(), sameAsPacketIn.deviceId()).addEqualityGroup(packetIn2).testEquals();
}
#method_after
@Test
public void deviceId() {
    new EqualsTester().addEqualityGroup(deviceId, packetIn.deviceId(), sameAsPacketIn.deviceId()).addEqualityGroup(packetIn2).testEquals();
}
#end_block

#method_before
@Test
public void packetOperation() throws Exception {
    new EqualsTester().addEqualityGroup(packetOperation, packetIn.packetOperation()).addEqualityGroup(packetIn3.packetOperation()).testEquals();
}
#method_after
@Test
public void packetOperation() {
    new EqualsTester().addEqualityGroup(packetOperation, packetIn.packetOperation()).addEqualityGroup(packetIn3.packetOperation()).testEquals();
}
#end_block

#method_before
private boolean changePortState(PortNumber number, String state) {
    log.debug("changing the port {} on device {} state to {}", number, deviceId, state);
    String uri = genUri(PORT_STATE_URI, number);
    String request = genPortStateRequest(state);
    boolean response = putNoReply(uri, request);
    if (!response) {
        log.error("unable to change port {} on device {} state to {}", number, deviceId, state);
    }
    // 5 tries with 2 sec delay
    long timePeriod = 2000;
    int iterations = 5;
    return pollPortState(timePeriod, iterations, number, state);
}
#method_after
private boolean changePortState(PortNumber number, String state) {
    log.debug("changing the port {} on device {} state to {}", number, deviceId, state);
    String uri = genUri(PORT_STATE_URI, number);
    String request = genPortStateRequest(state);
    boolean response = putNoReply(uri, request);
    if (!response) {
        log.error("unable to change port {} on device {} state to {}", number, deviceId, state);
    }
    // 5 tries with 2 sec delay
    long timePeriod = 2000;
    int iterations = 5;
    return confirmPortState(timePeriod, iterations, number, state);
}
#end_block

#method_before
@Override
public ObjectNode runGetOperationOnDataResource(URI uri) throws RestconfException {
    DataResourceLocator rl = new DataResourceLocator.Builder(uri).build();
    // TODO: define Filter (if there is any requirement).
    Filter filter = Filter.builder().build();
    DataNode dataNode;
    try {
        if (!dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            return null;
        }
        dataNode = dynamicConfigService.readNode(rl.ridForDynConfig(), filter);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
    ObjectNode rootNode = convertDataNodeToJson(rl.ridForYangRuntime(), dataNode);
    return rootNode;
}
#method_after
@Override
public ObjectNode runGetOperationOnDataResource(URI uri) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    // TODO: define Filter (if there is any requirement).
    Filter filter = Filter.builder().build();
    DataNode dataNode;
    try {
        if (!dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            return null;
        }
        dataNode = dynamicConfigService.readNode(rl.ridForDynConfig(), filter);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
    ObjectNode rootNode = convertDataNodeToJson(rl.ridForYangRuntime(), dataNode);
    return rootNode;
}
#end_block

#method_before
@Override
public void runPostOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = new DataResourceLocator.Builder(uri).build();
    ResourceData receivedData = convertJsonToDataNode(rl.uriForYangRuntime(), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.createNode(rl.ridForDynConfig(), dataNode);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runPostOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rl.uriForYangRuntime(), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.createNode(rl.ridForDynConfig(), dataNode);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Override
public void runPutOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = new DataResourceLocator.Builder(uri).build();
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    try {
        /*
             * If the data node already exists, then replace it.
             * Otherwise, create it.
             */
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.replaceNode(parentOf(rl.ridForDynConfig()), dataNode);
        } else {
            dynamicConfigService.createNode(parentOf(rl.ridForDynConfig()), dataNode);
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runPutOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    try {
        /*
             * If the data node already exists, then replace it.
             * Otherwise, create it.
             */
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.replaceNode(parentOf(rl.ridForDynConfig()), dataNode);
        } else {
            dynamicConfigService.createNode(parentOf(rl.ridForDynConfig()), dataNode);
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Override
public void runDeleteOperationOnDataResource(URI uri) throws RestconfException {
    DataResourceLocator rl = new DataResourceLocator.Builder(uri).build();
    try {
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.deleteNode(rl.ridForDynConfig());
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runDeleteOperationOnDataResource(URI uri) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    try {
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.deleteNode(rl.ridForDynConfig());
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Override
public void runPatchOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = new DataResourceLocator.Builder(uri).build();
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.updateNode(parentOf(rl.ridForDynConfig()), dataNode);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runPatchOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.updateNode(parentOf(rl.ridForDynConfig()), dataNode);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
public URI uriForYangRuntime() {
    return uriForYangRuntime;
}
#method_after
private static URI uriForYangRuntime(URI uriForRestconf) {
    return isDeviceResource(uriForRestconf) ? removeDeviceProxyPrefix(uriForRestconf) : uriForRestconf;
}
#end_block

#method_before
public ResourceId ridForYangRuntime() {
    return yrtResourceId;
}
#method_after
private static ResourceId ridForYangRuntime(URI uriForYangRuntime) {
    ResourceId yrtResourceId = convertUriToRid(uriForYangRuntime);
    if (yrtResourceId == null) {
        yrtResourceId = ResourceId.builder().addBranchPointSchema("/", null).build();
    }
    return yrtResourceId;
}
#end_block

#method_before
public void checkIntentsPurge() {
    // check intents to be purge
    if (!toBePurgedIntentKeys.isEmpty()) {
        Set<Key> removeKeys = new HashSet<>();
        for (Key key : toBePurgedIntentKeys) {
            if (!intentService.isLocal(key)) {
                removeKeys.add(key);
                continue;
            }
            Intent intentToPurge = intentService.getIntent(key);
            if (intentToPurge == null) {
                log.info("purged intent: key={}", key);
                removeKeys.add(key);
            } else {
                switch(intentService.getIntentState(key)) {
                    // case FAILED:  // not auto removed
                    case WITHDRAWN:
                        log.info("try to purge intent: key={}", key);
                        intentService.purge(intentToPurge);
                        break;
                    case INSTALL_REQ:
                    case INSTALLED:
                    case INSTALLING:
                    case RECOMPILING:
                    case COMPILING:
                        log.warn("not to purge for active intent: key={}", key);
                        removeKeys.add(key);
                        break;
                    case WITHDRAW_REQ:
                    case WITHDRAWING:
                    case PURGE_REQ:
                    case CORRUPT:
                    default:
                        // no action
                        break;
                }
            }
        }
        toBePurgedIntentKeys.removeAll(removeKeys);
    }
}
#method_after
private void checkIntentsPurge() {
    // check intents to be purge
    if (!toBePurgedIntentKeys.isEmpty()) {
        Set<Key> removeKeys = new HashSet<>();
        for (Key key : toBePurgedIntentKeys) {
            if (!intentService.isLocal(key)) {
                removeKeys.add(key);
                continue;
            }
            Intent intentToPurge = intentService.getIntent(key);
            if (intentToPurge == null) {
                log.info("purged intent: key={}", key);
                removeKeys.add(key);
            } else {
                switch(intentService.getIntentState(key)) {
                    // case FAILED:  // not auto removed
                    case WITHDRAWN:
                        log.info("try to purge intent: key={}", key);
                        intentService.purge(intentToPurge);
                        break;
                    case INSTALL_REQ:
                    case INSTALLED:
                    case INSTALLING:
                    case RECOMPILING:
                    case COMPILING:
                        log.warn("not to purge for active intent: key={}", key);
                        removeKeys.add(key);
                        break;
                    case WITHDRAW_REQ:
                    case WITHDRAWING:
                    case PURGE_REQ:
                    case CORRUPT:
                    default:
                        // no action
                        break;
                }
            }
        }
        toBePurgedIntentKeys.removeAll(removeKeys);
    }
}
#end_block

#method_before
public static L2Network of(L2Network l2Network) {
    Objects.requireNonNull(l2Network);
    L2Network l2NetworkCopy = new L2Network(l2Network.name(), l2Network.encapsulation());
    l2NetworkCopy.addInterfaceNames(l2Network.interfaceNames());
    l2NetworkCopy.setEncapsulation(l2Network.encapsulation());
    l2NetworkCopy.setL2Forward((SimpleFabricService.ALLOW_ETH_ADDRESS_SELECTOR) ? l2Network.l2Forward() : false);
    l2NetworkCopy.addInterfaces(l2Network.interfaces());
    l2NetworkCopy.setDirty(l2Network.dirty());
    return l2NetworkCopy;
}
#method_after
public static L2Network of(L2Network l2Network) {
    Objects.requireNonNull(l2Network);
    L2Network l2NetworkCopy = new L2Network(l2Network.name(), l2Network.encapsulation());
    l2NetworkCopy.interfaceNames.addAll(l2Network.interfaceNames());
    l2NetworkCopy.l2Forward = (SimpleFabricService.ALLOW_ETH_ADDRESS_SELECTOR) ? l2Network.l2Forward() : false;
    l2NetworkCopy.interfaces.addAll(l2Network.interfaces());
    l2NetworkCopy.hostIds.addAll(l2Network.hostIds());
    l2NetworkCopy.setDirty(l2Network.dirty());
    return l2NetworkCopy;
}
#end_block

#method_before
public void refresh() {
    log.debug("simple fabric l2forward refresh");
    Map<Key, SinglePointToMultiPointIntent> newBctIntentsMap = Maps.newConcurrentMap();
    Map<Key, MultiPointToSinglePointIntent> newUniIntentsMap = Maps.newConcurrentMap();
    for (L2Network l2Network : simpleFabric.getL2Networks()) {
        // if l2Network.l2Forward == false or number of interfaces() < 2, no Intents generated
        for (SinglePointToMultiPointIntent intent : buildBrcIntents(l2Network)) {
            newBctIntentsMap.put(intent.key(), intent);
        }
        for (MultiPointToSinglePointIntent intent : buildUniIntents(l2Network, hostsFromL2Network(l2Network))) {
            newUniIntentsMap.put(intent.key(), intent);
        }
        if (l2Network.dirty()) {
            l2Network.setDirty(false);
        }
    }
    boolean bctUpdated = false;
    for (SinglePointToMultiPointIntent intent : bctIntentsMap.values()) {
        SinglePointToMultiPointIntent newIntent = newBctIntentsMap.get(intent.key());
        if (newIntent == null) {
            log.info("simple fabric l2forward withdraw broadcast intent: {}", intent.key().toString());
            toBePurgedIntentKeys.add(intent.key());
            intentService.withdraw(intent);
            bctUpdated = true;
        }
    }
    for (SinglePointToMultiPointIntent intent : newBctIntentsMap.values()) {
        SinglePointToMultiPointIntent oldIntent = bctIntentsMap.get(intent.key());
        if (oldIntent == null || !oldIntent.filteredEgressPoints().equals(intent.filteredEgressPoints()) || !oldIntent.filteredIngressPoint().equals(intent.filteredIngressPoint()) || !oldIntent.selector().equals(intent.selector()) || !oldIntent.treatment().equals(intent.treatment()) || !oldIntent.constraints().equals(intent.constraints())) {
            log.info("simple fabric l2forward submit broadcast intent: {}", intent.key().toString());
            toBePurgedIntentKeys.remove(intent.key());
            intentService.submit(intent);
            bctUpdated = true;
        }
    }
    boolean uniUpdated = false;
    for (MultiPointToSinglePointIntent intent : uniIntentsMap.values()) {
        MultiPointToSinglePointIntent newIntent = newUniIntentsMap.get(intent.key());
        if (newIntent == null) {
            log.info("simple fabric l2forward withdraw unicast intent: {}", intent.key().toString());
            toBePurgedIntentKeys.add(intent.key());
            intentService.withdraw(intent);
            uniUpdated = true;
        }
    }
    for (MultiPointToSinglePointIntent intent : newUniIntentsMap.values()) {
        MultiPointToSinglePointIntent oldIntent = uniIntentsMap.get(intent.key());
        if (oldIntent == null || !oldIntent.filteredEgressPoint().equals(intent.filteredEgressPoint()) || !oldIntent.filteredIngressPoints().equals(intent.filteredIngressPoints()) || !oldIntent.selector().equals(intent.selector()) || !oldIntent.treatment().equals(intent.treatment()) || !oldIntent.constraints().equals(intent.constraints())) {
            log.info("simple fabric l2forward submit unicast intent: {}", intent.key().toString());
            toBePurgedIntentKeys.remove(intent.key());
            intentService.submit(intent);
            uniUpdated = true;
        }
    }
    if (bctUpdated) {
        bctIntentsMap = newBctIntentsMap;
    }
    if (uniUpdated) {
        uniIntentsMap = newUniIntentsMap;
    }
}
#method_after
private void refresh() {
    log.debug("simple fabric l2forward refresh");
    Map<Key, SinglePointToMultiPointIntent> newBctIntentsMap = Maps.newConcurrentMap();
    Map<Key, MultiPointToSinglePointIntent> newUniIntentsMap = Maps.newConcurrentMap();
    for (L2Network l2Network : simpleFabric.getL2Networks()) {
        // if l2Network.l2Forward == false or number of interfaces() < 2, no Intents generated
        for (SinglePointToMultiPointIntent intent : buildBrcIntents(l2Network)) {
            newBctIntentsMap.put(intent.key(), intent);
        }
        for (MultiPointToSinglePointIntent intent : buildUniIntents(l2Network, hostsFromL2Network(l2Network))) {
            newUniIntentsMap.put(intent.key(), intent);
        }
        if (l2Network.dirty()) {
            l2Network.setDirty(false);
        }
    }
    boolean bctUpdated = false;
    for (SinglePointToMultiPointIntent intent : bctIntentsMap.values()) {
        SinglePointToMultiPointIntent newIntent = newBctIntentsMap.get(intent.key());
        if (newIntent == null) {
            log.info("simple fabric l2forward withdraw broadcast intent: {}", intent.key().toString());
            toBePurgedIntentKeys.add(intent.key());
            intentService.withdraw(intent);
            bctUpdated = true;
        }
    }
    for (SinglePointToMultiPointIntent intent : newBctIntentsMap.values()) {
        SinglePointToMultiPointIntent oldIntent = bctIntentsMap.get(intent.key());
        if (oldIntent == null || !oldIntent.filteredEgressPoints().equals(intent.filteredEgressPoints()) || !oldIntent.filteredIngressPoint().equals(intent.filteredIngressPoint()) || !oldIntent.selector().equals(intent.selector()) || !oldIntent.treatment().equals(intent.treatment()) || !oldIntent.constraints().equals(intent.constraints())) {
            log.info("simple fabric l2forward submit broadcast intent: {}", intent.key().toString());
            toBePurgedIntentKeys.remove(intent.key());
            intentService.submit(intent);
            bctUpdated = true;
        }
    }
    boolean uniUpdated = false;
    for (MultiPointToSinglePointIntent intent : uniIntentsMap.values()) {
        MultiPointToSinglePointIntent newIntent = newUniIntentsMap.get(intent.key());
        if (newIntent == null) {
            log.info("simple fabric l2forward withdraw unicast intent: {}", intent.key().toString());
            toBePurgedIntentKeys.add(intent.key());
            intentService.withdraw(intent);
            uniUpdated = true;
        }
    }
    for (MultiPointToSinglePointIntent intent : newUniIntentsMap.values()) {
        MultiPointToSinglePointIntent oldIntent = uniIntentsMap.get(intent.key());
        if (oldIntent == null || !oldIntent.filteredEgressPoint().equals(intent.filteredEgressPoint()) || !oldIntent.filteredIngressPoints().equals(intent.filteredIngressPoints()) || !oldIntent.selector().equals(intent.selector()) || !oldIntent.treatment().equals(intent.treatment()) || !oldIntent.constraints().equals(intent.constraints())) {
            log.info("simple fabric l2forward submit unicast intent: {}", intent.key().toString());
            toBePurgedIntentKeys.remove(intent.key());
            intentService.submit(intent);
            uniUpdated = true;
        }
    }
    if (bctUpdated) {
        bctIntentsMap = newBctIntentsMap;
    }
    if (uniUpdated) {
        uniIntentsMap = newUniIntentsMap;
    }
}
#end_block

#method_before
public void checkIntentsPurge() {
    // check intents to be purge
    if (!toBePurgedIntentKeys.isEmpty()) {
        Set<Key> purgedKeys = new HashSet<>();
        for (Key key : toBePurgedIntentKeys) {
            Intent intentToPurge = intentService.getIntent(key);
            if (intentToPurge == null) {
                log.info("simple fabric l2forward purged intent: key={}", key.toString());
                purgedKeys.add(key);
            } else {
                switch(intentService.getIntentState(key)) {
                    case FAILED:
                    case WITHDRAWN:
                        log.info("simple fabric l2forward try to purge intent: key={}", key.toString());
                        intentService.purge(intentToPurge);
                        break;
                    case INSTALL_REQ:
                    case INSTALLED:
                    case INSTALLING:
                    case RECOMPILING:
                    case COMPILING:
                        log.warn("simple fabric l2forward withdraw intent to purge: key={}", key);
                        intentService.withdraw(intentToPurge);
                        break;
                    case WITHDRAW_REQ:
                    case WITHDRAWING:
                    case PURGE_REQ:
                    case CORRUPT:
                    default:
                        // no action
                        break;
                }
            }
        }
        toBePurgedIntentKeys.removeAll(purgedKeys);
    }
}
#method_after
private void checkIntentsPurge() {
    // check intents to be purge
    if (!toBePurgedIntentKeys.isEmpty()) {
        Set<Key> purgedKeys = new HashSet<>();
        for (Key key : toBePurgedIntentKeys) {
            Intent intentToPurge = intentService.getIntent(key);
            if (intentToPurge == null) {
                log.info("simple fabric l2forward purged intent: key={}", key.toString());
                purgedKeys.add(key);
            } else {
                switch(intentService.getIntentState(key)) {
                    case FAILED:
                    case WITHDRAWN:
                        log.info("simple fabric l2forward try to purge intent: key={}", key.toString());
                        intentService.purge(intentToPurge);
                        break;
                    case INSTALL_REQ:
                    case INSTALLED:
                    case INSTALLING:
                    case RECOMPILING:
                    case COMPILING:
                        log.warn("simple fabric l2forward withdraw intent to purge: key={}", key);
                        intentService.withdraw(intentToPurge);
                        break;
                    case WITHDRAW_REQ:
                    case WITHDRAWING:
                    case PURGE_REQ:
                    case CORRUPT:
                    default:
                        // no action
                        break;
                }
            }
        }
        toBePurgedIntentKeys.removeAll(purgedKeys);
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(ipPrefix);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(ipPrefix, gatewayIp, gatewayMac, encapsulation, l2NetworkName);
}
#end_block

#method_before
public DataNode buildDnForAnydata() {
    dBlr = initializeDataNode(context);
    value = null;
    // Adding container c1
    dBlr = addDataNode(dBlr, "c1", TANY_NS, value, null);
    // Adding anydata container
    dBlr = addDataNode(dBlr, "mydata2", TANY_NS, value, null);
    context.getRegistry().registerAnydataSchema(Mydata2.class, Node.class);
    context.getRegistry().registerAnydataSchema(Mydata2.class, Link.class);
    // Adding list inside anydata container
    dBlr = addDataNode(dBlr, "link", NW_TOPO_NAME_SPACE, value, null);
    value = "link-id";
    dBlr = addDataNode(dBlr, "link-id", NW_TOPO_NAME_SPACE, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "source", NW_TOPO_NAME_SPACE, value, null);
    value = "source-node";
    dBlr = addDataNode(dBlr, "source-node", NW_TOPO_NAME_SPACE, value, null);
    dBlr = exitDataNode(dBlr);
    // exit source
    dBlr = exitDataNode(dBlr);
    // exit link
    dBlr = exitDataNode(dBlr);
    // Adding list inside anydata container
    value = null;
    dBlr = addDataNode(dBlr, "node", IETFNS, value, null);
    // Adding key element node-id
    value = "node1";
    dBlr = addDataNode(dBlr, "node-id", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    // Adding list inside list
    dBlr = addDataNode(dBlr, "supporting-node", null, value, null);
    // Adding key element network-ref
    value = "network3";
    dBlr = addDataNode(dBlr, "network-ref", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "network4";
    // Adding key element node-ref
    dBlr = addDataNode(dBlr, "node-ref", null, value, null);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    return dBlr.build();
}
#method_after
public DataNode buildDnForAnydata() {
    dBlr = initializeDataNode(context);
    value = null;
    // Adding container c1
    dBlr = addDataNode(dBlr, "c1", TANY_NS, value, null);
    // Adding anydata container
    dBlr = addDataNode(dBlr, "mydata2", TANY_NS, value, null);
    context.getRegistry().registerAnydataSchema(Mydata2.class, Node.class);
    context.getRegistry().registerAnydataSchema(Mydata2.class, DefaultLink.class);
    context.getRegistry().registerAnydataSchema(Mydata2.class, SupportingTerminationPoint.class);
    // Adding list inside anydata container
    dBlr = addDataNode(dBlr, "link", NW_TOPO_NAME_SPACE, value, null);
    value = "link-id";
    dBlr = addDataNode(dBlr, "link-id", NW_TOPO_NAME_SPACE, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    dBlr = addDataNode(dBlr, "source", NW_TOPO_NAME_SPACE, value, null);
    value = "source-node";
    dBlr = addDataNode(dBlr, "source-node", NW_TOPO_NAME_SPACE, value, null);
    dBlr = exitDataNode(dBlr);
    // exit source
    dBlr = exitDataNode(dBlr);
    // exit link
    dBlr = exitDataNode(dBlr);
    // Adding list inside anydata container
    value = null;
    dBlr = addDataNode(dBlr, "node", IETFNS, value, null);
    // Adding key element node-id
    value = "node1";
    dBlr = addDataNode(dBlr, "node-id", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = null;
    // Adding list inside list
    dBlr = addDataNode(dBlr, "supporting-node", null, value, null);
    // Adding key element network-ref
    value = "network3";
    dBlr = addDataNode(dBlr, "network-ref", null, value, null);
    dBlr = exitDataNode(dBlr);
    value = "network4";
    // Adding key element node-ref
    dBlr = addDataNode(dBlr, "node-ref", null, value, null);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    dBlr = exitDataNode(dBlr);
    return dBlr.build();
}
#end_block

#method_before
@Test
public void addToData2Test() {
    boolean isExpOccurred = false;
    context.getContext();
    try {
        context.getRegistry().registerAnydataSchema(Mydata.class, ListAnydataOpParam.class);
    } catch (IllegalArgumentException e) {
        isExpOccurred = true;
        assertEquals(e.getMessage(), String.format(E_NVALID, ListAnydataOpParam.class));
    }
    assertEquals(isExpOccurred, true);
}
#method_after
@Test
public void addToData2Test() {
    boolean isExpOccurred = false;
    context.getContext();
    try {
        context.getRegistry().registerAnydataSchema(Mydata.class, ListAnydataOpParam.class);
    } catch (IllegalArgumentException e) {
        isExpOccurred = true;
        assertEquals(e.getMessage(), String.format(INVAL_ANYDATA, ListAnydataOpParam.class));
    }
    assertEquals(isExpOccurred, true);
}
#end_block

#method_before
@Test
public void addToData3Test() {
    boolean isExpOccurred = false;
    context.getContext();
    try {
        context.getRegistry().registerAnydataSchema(Mydata.class, ListAnydata.class);
    } catch (IllegalArgumentException e) {
        isExpOccurred = true;
        assertEquals(e.getMessage(), String.format(E_NVALID, ListAnydata.class));
    }
    assertEquals(isExpOccurred, true);
}
#method_after
@Test
public void addToData3Test() {
    boolean isExpOccurred = false;
    context.getContext();
    try {
        context.getRegistry().registerAnydataSchema(Mydata.class, ListAnydata.class);
    } catch (IllegalArgumentException e) {
        isExpOccurred = true;
        assertEquals(e.getMessage(), String.format(INVAL_ANYDATA, ListAnydata.class));
    }
    assertEquals(isExpOccurred, true);
}
#end_block

#method_before
@Test
public void addToData4Test() {
    boolean isExpOccurred = false;
    context.getContext();
    try {
        context.getRegistry().registerAnydataSchema(Mydata.class, List52Keys.class);
    } catch (IllegalArgumentException e) {
        isExpOccurred = true;
        assertEquals(e.getMessage(), String.format(FMT_INV, List52Keys.class));
    }
    assertEquals(isExpOccurred, true);
}
#method_after
@Test
public void addToData4Test() {
    boolean isExpOccurred = false;
    context.getContext();
    try {
        context.getRegistry().registerAnydataSchema(Mydata.class, List52Keys.class);
    } catch (IllegalArgumentException e) {
        isExpOccurred = true;
        assertEquals(e.getMessage(), String.format(INVAL_ANYDATA, List52Keys.class.getCanonicalName()));
    }
    assertEquals(isExpOccurred, true);
}
#end_block

#method_before
private YangNode cloneDeviatedModuleNode(YangNode targetNode, YangDeviation deviation) throws DataModelException {
    // get Root node of target schema
    while (targetNode.getParent() != null) {
        targetNode = targetNode.getParent();
    }
    YangNode srcNode = targetNode;
    YangNode dstNode = deviation.getParent();
    if (((YangDeviationHolder) dstNode).isDeviatedNodeCloned()) {
        // Target Node is already cloned, no need to clone again
        return dstNode;
    }
    // clone leaf and leaf-list of root level
    YangLeavesHolder destLeafHolder = (YangLeavesHolder) dstNode;
    YangLeavesHolder srcLeafHolder = (YangLeavesHolder) srcNode;
    if (srcLeafHolder.getListOfLeaf() != null) {
        for (YangLeaf leaf : srcLeafHolder.getListOfLeaf()) {
            YangLeaf clonedLeaf;
            try {
                ((CollisionDetector) dstNode).detectCollidingChild(leaf.getName(), LEAF_DATA);
                clonedLeaf = leaf.cloneForDeviation();
                clonedLeaf.setReferredLeaf(leaf);
            } catch (CloneNotSupportedException | DataModelException e) {
                throw new DataModelException(e.getMessage());
            }
            clonedLeaf.setContainedIn(destLeafHolder);
            destLeafHolder.addLeaf(clonedLeaf);
        }
    }
    if (srcLeafHolder.getListOfLeafList() != null) {
        for (YangLeafList leafList : srcLeafHolder.getListOfLeafList()) {
            YangLeafList clonedLeafList;
            try {
                ((CollisionDetector) destLeafHolder).detectCollidingChild(leafList.getName(), LEAF_LIST_DATA);
                clonedLeafList = leafList.cloneForDeviation();
                clonedLeafList.setReferredSchemaLeafList(leafList);
            } catch (CloneNotSupportedException | DataModelException e) {
                throw new DataModelException(e.getMessage());
            }
            clonedLeafList.setContainedIn(destLeafHolder);
            destLeafHolder.addLeafList(clonedLeafList);
        }
    }
    // clone subtree
    cloneSubTree(srcNode, dstNode, null, true, false);
    /*
         * Cloning of deviated module is done, set isDeviatedNodeCloned
         * flag as true.
         */
    ((YangDeviationHolder) dstNode).setDeviatedNodeCloned(true);
    return dstNode;
}
#method_after
private YangNode cloneDeviatedModuleNode(YangNode targetNode, YangDeviation deviation) throws DataModelException {
    // get Root node of target schema
    while (targetNode.getParent() != null) {
        targetNode = targetNode.getParent();
    }
    YangNode srcNode = targetNode;
    YangNode dstNode = deviation.getParent();
    if (((YangDeviationHolder) dstNode).isDeviatedNodeCloned()) {
        // Target Node is already cloned, no need to clone again
        return dstNode;
    }
    // clone leaf and leaf-list of root level
    YangLeavesHolder destLeafHolder = (YangLeavesHolder) dstNode;
    YangLeavesHolder srcLeafHolder = (YangLeavesHolder) srcNode;
    if (srcLeafHolder.getListOfLeaf() != null) {
        for (YangLeaf leaf : srcLeafHolder.getListOfLeaf()) {
            YangLeaf clonedLeaf;
            try {
                ((CollisionDetector) dstNode).detectCollidingChild(leaf.getName(), LEAF_DATA);
                clonedLeaf = leaf.cloneForDeviation();
                clonedLeaf.setReferredLeaf(leaf);
            } catch (CloneNotSupportedException | DataModelException e) {
                throw new DataModelException(e.getMessage());
            }
            clonedLeaf.setContainedIn(destLeafHolder);
            destLeafHolder.addLeaf(clonedLeaf);
        }
    }
    if (srcLeafHolder.getListOfLeafList() != null) {
        for (YangLeafList leafList : srcLeafHolder.getListOfLeafList()) {
            YangLeafList clonedLeafList;
            try {
                ((CollisionDetector) destLeafHolder).detectCollidingChild(leafList.getName(), LEAF_LIST_DATA);
                clonedLeafList = leafList.cloneForDeviation();
                clonedLeafList.setReferredSchemaLeafList(leafList);
            } catch (CloneNotSupportedException | DataModelException e) {
                throw new DataModelException(e.getMessage());
            }
            clonedLeafList.setContainedIn(destLeafHolder);
            destLeafHolder.addLeafList(clonedLeafList);
        }
    }
    // clone subtree
    cloneGroupingTree(srcNode, dstNode, null, true);
    /*
         * Cloning of deviated module is done, set isDeviatedNodeCloned
         * flag as true.
         */
    ((YangDeviationHolder) dstNode).setDeviatedNodeCloned(true);
    return dstNode;
}
#end_block

#method_before
public static void cloneListOfLeaf(YangLeavesHolder clonedNode, YangUses yangUses, boolean isDeviation, boolean isAnydata) throws CloneNotSupportedException, DataModelException {
    List<YangLeaf> leaves = clonedNode.getListOfLeaf();
    if (nonEmpty(leaves)) {
        List<YangLeaf> clonedLeaves = new LinkedList<>();
        for (YangLeaf leaf : leaves) {
            YangLeaf clonedLeaf;
            if (!isDeviation) {
                clonedLeaf = leaf.clone();
                addUnresolvedType(yangUses, clonedLeaf, (YangNode) clonedNode);
            } else {
                clonedLeaf = leaf.cloneForDeviation();
            }
            clonedLeaf.setReferredLeaf(leaf);
            clonedLeaf.setContainedIn(clonedNode);
            clonedLeaves.add(clonedLeaf);
            /*
                 * If its anydata linking, then fill the information of the
                 * cloned leafs in the ysnContextInfo map of current node as
                 * which will be further used by the serializer helper to find
                 * the child under current node.
                 */
            if (isAnydata) {
                YangSchemaNodeContextInfo info = ((YangNode) clonedNode).getYsnContextInfoMap().get(clonedLeaf.getYangSchemaNodeIdentifier());
                info.setSchemaNode(clonedLeaf);
                clonedLeaf.setParentContext((SchemaContext) clonedNode);
            }
        }
        clonedNode.setListOfLeaf(clonedLeaves);
    }
}
#method_after
public static void cloneListOfLeaf(YangLeavesHolder clonedNode, YangUses yangUses, boolean isDeviation) throws CloneNotSupportedException, DataModelException {
    List<YangLeaf> leaves = clonedNode.getListOfLeaf();
    if (nonEmpty(leaves)) {
        List<YangLeaf> clonedLeaves = new LinkedList<>();
        for (YangLeaf leaf : leaves) {
            YangLeaf clonedLeaf;
            if (!isDeviation) {
                clonedLeaf = leaf.clone();
                addUnresolvedType(yangUses, clonedLeaf, (YangNode) clonedNode);
            } else {
                clonedLeaf = leaf.cloneForDeviation();
            }
            clonedLeaf.setReferredLeaf(leaf);
            clonedLeaf.setContainedIn(clonedNode);
            clonedLeaves.add(clonedLeaf);
        }
        clonedNode.setListOfLeaf(clonedLeaves);
    }
}
#end_block

#method_before
public static void cloneListOfLeafList(YangLeavesHolder clonedNode, YangUses yangUses, boolean isDeviation, boolean isAnydata) throws CloneNotSupportedException, DataModelException {
    List<YangLeafList> listOfLeafList = clonedNode.getListOfLeafList();
    if (nonEmpty(listOfLeafList)) {
        List<YangLeafList> clonedList = new LinkedList<>();
        for (YangLeafList leafList : listOfLeafList) {
            YangLeafList clonedLeafList;
            if (!isDeviation) {
                clonedLeafList = leafList.clone();
                addUnresolvedType(yangUses, clonedLeafList, (YangNode) clonedNode);
            } else {
                clonedLeafList = leafList.cloneForDeviation();
            }
            clonedLeafList.setReferredSchemaLeafList(leafList);
            clonedLeafList.setContainedIn(clonedNode);
            clonedList.add(clonedLeafList);
            /*
                 * If its anydata linking, then fill the information of the
                 * cloned leaf-lists in the ysnContextInfo map of current node
                 * as which will be further used by the serializer helper to
                 * find the child under current node.
                 */
            if (isAnydata) {
                YangSchemaNodeContextInfo info = ((YangNode) clonedList).getYsnContextInfoMap().get(clonedLeafList.getYangSchemaNodeIdentifier());
                info.setSchemaNode(clonedLeafList);
                clonedLeafList.setParentContext((SchemaContext) clonedNode);
            }
        }
        clonedNode.setListOfLeafList(clonedList);
    }
}
#method_after
public static void cloneListOfLeafList(YangLeavesHolder clonedNode, YangUses yangUses, boolean isDeviation) throws CloneNotSupportedException, DataModelException {
    List<YangLeafList> listOfLeafList = clonedNode.getListOfLeafList();
    if (nonEmpty(listOfLeafList)) {
        List<YangLeafList> clonedList = new LinkedList<>();
        for (YangLeafList leafList : listOfLeafList) {
            YangLeafList clonedLeafList;
            if (!isDeviation) {
                clonedLeafList = leafList.clone();
                addUnresolvedType(yangUses, clonedLeafList, (YangNode) clonedNode);
            } else {
                clonedLeafList = leafList.cloneForDeviation();
            }
            clonedLeafList.setReferredSchemaLeafList(leafList);
            clonedLeafList.setContainedIn(clonedNode);
            clonedList.add(clonedLeafList);
        }
        clonedNode.setListOfLeafList(clonedList);
    }
}
#end_block

#method_before
public YangNode clone(YangUses yangUses, boolean isDeviation, boolean isAnydata) throws CloneNotSupportedException {
    YangNode clonedNode = (YangNode) super.clone();
    if (isAnydata) {
        Iterator<YangSchemaNodeContextInfo> it = ysnContextInfoMap.values().iterator();
        while (it.hasNext()) {
            YangSchemaNodeContextInfo info = it.next();
            clonedNode.ysnContextInfoMap.put(info.getSchemaNode().getYangSchemaNodeIdentifier(), info.clone());
        }
    }
    if (clonedNode instanceof YangLeavesHolder) {
        try {
            cloneListOfLeaf((YangLeavesHolder) clonedNode, yangUses, isDeviation, isAnydata);
            cloneListOfLeafList((YangLeavesHolder) clonedNode, yangUses, isDeviation, isAnydata);
        } catch (DataModelException e) {
            throw new CloneNotSupportedException(e.getMessage());
        }
    }
    clonedNode.setParent(null);
    clonedNode.setChild(null);
    clonedNode.setNextSibling(null);
    clonedNode.setPreviousSibling(null);
    if (!isDeviation && !isAnydata) {
        clonedNode.yangSchemaNodeIdentifier = clonedNode.yangSchemaNodeIdentifier.clone();
        clonedNode.ysnContextInfoMap = new HashMap<>();
        clonedNode.referredSchemaNode = this;
    }
    if (clonedNode instanceof YangAugmentableNode) {
        ((YangAugmentableNode) clonedNode).cloneAugmentInfo();
    }
    return clonedNode;
}
#method_after
public YangNode clone(YangUses yangUses, boolean isDeviation) throws CloneNotSupportedException {
    YangNode clonedNode = (YangNode) super.clone();
    if (clonedNode instanceof YangLeavesHolder) {
        try {
            cloneListOfLeaf((YangLeavesHolder) clonedNode, yangUses, isDeviation);
            cloneListOfLeafList((YangLeavesHolder) clonedNode, yangUses, isDeviation);
        } catch (DataModelException e) {
            throw new CloneNotSupportedException(e.getMessage());
        }
    }
    clonedNode.setParent(null);
    clonedNode.setChild(null);
    clonedNode.setNextSibling(null);
    clonedNode.setPreviousSibling(null);
    if (!isDeviation) {
        clonedNode.yangSchemaNodeIdentifier = clonedNode.yangSchemaNodeIdentifier.clone();
        clonedNode.ysnContextInfoMap = new HashMap<>();
        clonedNode.referredSchemaNode = this;
    }
    if (clonedNode instanceof YangAugmentableNode) {
        ((YangAugmentableNode) clonedNode).cloneAugmentInfo();
    }
    return clonedNode;
}
#end_block

#method_before
public static void cloneSubTree(YangNode srcRootNode, YangNode dstRootNode, YangUses yangUses, boolean isDeviation, boolean isAnydata) throws DataModelException {
    YangNode nextNodeToClone = srcRootNode;
    TraversalType curTraversal;
    YangNode clonedTreeCurNode = dstRootNode;
    YangNode newNode = null;
    nextNodeToClone = nextNodeToClone.getChild();
    if (nextNodeToClone == null) {
        return;
    } else {
        /*
             * Root level cloning is taken care in the caller.
             */
        curTraversal = CHILD;
    }
    /*
         * Caller ensures the cloning of the root nodes
         */
    try {
        while (nextNodeToClone != srcRootNode) {
            if (nextNodeToClone == null) {
                throw new DataModelException("Internal error: Cloning " + "failed, source " + "tree null pointer " + "reached " + nextNodeToClone.getName() + " in " + nextNodeToClone.getLineNumber() + " at " + nextNodeToClone.getCharPosition() + " in " + nextNodeToClone.getFileName() + "\"");
            }
            if (curTraversal != PARENT) {
                newNode = nextNodeToClone.clone(yangUses, isDeviation, isAnydata);
                if (newNode instanceof YangUses) {
                    ((YangUses) newNode).setCloned(true);
                }
                detectCollisionWhileCloning(clonedTreeCurNode, newNode, curTraversal);
            }
            if (curTraversal == CHILD) {
                /*
                     * add the new node to the cloned tree.
                     */
                clonedTreeCurNode.addChild(newNode);
                if (isAnydata) {
                    YangSchemaNodeContextInfo info = clonedTreeCurNode.ysnContextInfoMap.get(newNode.yangSchemaNodeIdentifier);
                    info.setSchemaNode(newNode);
                    newNode.setParentContext(clonedTreeCurNode);
                }
                /*
                     * update the cloned tree's traversal current node as the
                     * new node.
                     */
                clonedTreeCurNode = newNode;
            } else if (curTraversal == SIBLING) {
                clonedTreeCurNode.addNextSibling(newNode);
                clonedTreeCurNode = newNode;
            } else {
                if (clonedTreeCurNode instanceof YangLeavesHolder) {
                    updateClonedLeavesUnionEnumRef((YangLeavesHolder) clonedTreeCurNode);
                }
                clonedTreeCurNode = clonedTreeCurNode.getParent();
            }
            if (curTraversal != PARENT && clonedTreeCurNode instanceof YangAugment && (clonedTreeCurNode.getParent() instanceof YangUses)) {
                YangAugment augment = (YangAugment) clonedTreeCurNode;
                addUnresolvedAugment(yangUses, augment);
            }
            if (curTraversal != PARENT && nextNodeToClone.getChild() != null) {
                curTraversal = CHILD;
                /*
                     * update the traversal's current node.
                     */
                nextNodeToClone = nextNodeToClone.getChild();
            } else if (nextNodeToClone.getNextSibling() != null) {
                curTraversal = SIBLING;
                nextNodeToClone = nextNodeToClone.getNextSibling();
            } else {
                curTraversal = PARENT;
                nextNodeToClone = nextNodeToClone.getParent();
            }
        }
    } catch (CloneNotSupportedException e) {
        throw new DataModelException("Failed to clone the tree " + nextNodeToClone.getName() + " in " + nextNodeToClone.getLineNumber() + " at " + nextNodeToClone.getCharPosition() + " in " + nextNodeToClone.getFileName() + "\"");
    }
}
#method_after
public static void cloneSubTree(YangNode srcRootNode, YangNode dstRootNode, YangUses yangUses, boolean isDeviation, YangNode childToClone) throws DataModelException {
    YangNode nextNodeToClone;
    TraversalType curTraversal;
    YangNode clonedTreeCurNode = dstRootNode;
    YangNode newNode = null;
    if (childToClone != null) {
        nextNodeToClone = childToClone;
    } else {
        nextNodeToClone = srcRootNode.getChild();
    }
    if (nextNodeToClone == null) {
        return;
    } else {
        /*
             * Root level cloning is taken care in the caller.
             */
        curTraversal = CHILD;
    }
    /*
         * Caller ensures the cloning of the root nodes
         */
    try {
        while (nextNodeToClone != srcRootNode) {
            if (nextNodeToClone == null) {
                throw new DataModelException("Internal error: Cloning " + "failed, source " + "tree null pointer " + "reached " + nextNodeToClone.getName() + " in " + nextNodeToClone.getLineNumber() + " at " + nextNodeToClone.getCharPosition() + " in " + nextNodeToClone.getFileName() + "\"");
            }
            if (curTraversal != PARENT) {
                newNode = nextNodeToClone.clone(yangUses, isDeviation);
                if (newNode instanceof YangUses) {
                    ((YangUses) newNode).setCloned(true);
                }
                detectCollisionWhileCloning(clonedTreeCurNode, newNode, curTraversal);
            }
            if (curTraversal == CHILD) {
                /*
                     * add the new node to the cloned tree.
                     */
                clonedTreeCurNode.addChild(newNode);
                /*
                     * update the cloned tree's traversal current node as the
                     * new node.
                     */
                clonedTreeCurNode = newNode;
            } else if (curTraversal == SIBLING) {
                clonedTreeCurNode.addNextSibling(newNode);
                clonedTreeCurNode = newNode;
            } else {
                if (clonedTreeCurNode instanceof YangLeavesHolder) {
                    updateClonedLeavesUnionEnumRef((YangLeavesHolder) clonedTreeCurNode);
                }
                clonedTreeCurNode = clonedTreeCurNode.getParent();
            }
            if (curTraversal != PARENT && clonedTreeCurNode instanceof YangAugment && (clonedTreeCurNode.getParent() instanceof YangUses)) {
                YangAugment augment = (YangAugment) clonedTreeCurNode;
                addUnresolvedAugment(yangUses, augment);
            }
            if (curTraversal != PARENT && nextNodeToClone.getChild() != null) {
                curTraversal = CHILD;
                /*
                     * update the traversal's current node.
                     */
                nextNodeToClone = nextNodeToClone.getChild();
            } else if (nextNodeToClone.getNextSibling() != null) {
                if (childToClone != null && nextNodeToClone.getNextSibling().getParent() == srcRootNode) {
                    curTraversal = PARENT;
                    nextNodeToClone = nextNodeToClone.getParent();
                } else {
                    curTraversal = SIBLING;
                    nextNodeToClone = nextNodeToClone.getNextSibling();
                }
            } else {
                curTraversal = PARENT;
                nextNodeToClone = nextNodeToClone.getParent();
            }
        }
    } catch (CloneNotSupportedException e) {
        throw new DataModelException("Failed to clone the tree " + nextNodeToClone.getName() + " in " + nextNodeToClone.getLineNumber() + " at " + nextNodeToClone.getCharPosition() + " in " + nextNodeToClone.getFileName() + "\"");
    }
}
#end_block

#method_before
public void setNameSpaceAndAddToParentSchemaMap() {
    // Get parent namespace.
    if (getParent() != null) {
        // Get parent namespace and set namespace for self node.
        setNameSpace(getParent().getNameSpace());
        // Process addition of leaf to the child schema map of parent.
        processAdditionOfSchemaNodeToParentMap(getName(), getNameSpace());
    } else {
        // Module/Sub-module
        setNameSpace((YangNamespace) this);
    }
    /*
         * Check if node contains leaf/leaf-list, if yes add namespace for leaf
         * and leaf list.
         */
    if (this instanceof YangLeavesHolder) {
        ((YangLeavesHolder) this).setLeafNameSpaceAndAddToParentSchemaMap();
    }
}
#method_after
public void setNameSpaceAndAddToParentSchemaMap() {
    // Get parent namespace.
    if (getParent() != null && getParent().getNodeType() != ANYDATA_NODE) {
        // Get parent namespace and set namespace for self node.
        setNameSpace(getParent().getNameSpace());
        // Process addition of leaf to the child schema map of parent.
        processAdditionOfSchemaNodeToParentMap(getName(), getNameSpace());
    } else if (getParent() != null && getParent().getNodeType() == ANYDATA_NODE) {
        processAdditionOfSchemaNodeToParentMap(getName(), getNameSpace());
    } else {
        // Module/Sub-module
        setNameSpace((YangNamespace) this);
    }
    /*
         * Check if node contains leaf/leaf-list, if yes add namespace for leaf
         * and leaf list.
         */
    if (this instanceof YangLeavesHolder) {
        ((YangLeavesHolder) this).setLeafNameSpaceAndAddToParentSchemaMap();
    }
}
#end_block

#method_before
public void setParentContext() {
    if (this instanceof SchemaDataNode) {
        parentContext = getParentSchemaContext(this.getParent());
        // As rpc and anydata node is not leaf holder
        if (nodeType != RPC_NODE && nodeType != ANYDATA_NODE) {
            ((YangLeavesHolder) this).setLeafParentContext();
        }
        // setting the schema Id
        schemaId = new SchemaId(getName(), getNameSpace().getModuleNamespace());
    } else if (this instanceof YangCase || this instanceof YangAugment) {
        ((YangLeavesHolder) this).setLeafParentContext();
    }
}
#method_after
public void setParentContext() {
    if (this instanceof SchemaDataNode) {
        SchemaContext t = getParentSchemaContext(this.getParent());
        if (t != null) {
            parentContext = t;
        }
        // As rpc and anydata node is not leaf holder
        if (nodeType != RPC_NODE && nodeType != ANYDATA_NODE) {
            ((YangLeavesHolder) this).setLeafParentContext();
        }
        // setting the schema Id
        schemaId = new SchemaId(getName(), getNameSpace().getModuleNamespace());
    } else if (this instanceof YangCase || this instanceof YangAugment) {
        ((YangLeavesHolder) this).setLeafParentContext();
    }
}
#end_block

#method_before
private YangSchemaNodeContextInfo getTargetNode(int maxLen, YangNode s) {
    YangSchemaNodeContextInfo info;
    // skipping the revision part in class path
    int i = index + 1;
    info = getNodeInfo(s.getYsnContextInfoMap(), i);
    while (i < maxLen) {
        if (info != null) {
            info = getNodeInfo(((YangNode) info.getSchemaNode()).getYsnContextInfoMap(), ++i);
        } else {
            break;
        }
    }
    return info;
}
#method_after
private static YangSchemaNode getTargetNode(String cn, String[] paths, YangSchemaNode s, int index) throws IllegalArgumentException {
    int i = index;
    YangSchemaNodeContextInfo info;
    YangSchemaNode schema = s;
    while (i < paths.length) {
        Iterator<YangSchemaNodeContextInfo> it = schema.getYsnContextInfoMap().values().iterator();
        boolean isSuccess = false;
        while (it.hasNext()) {
            info = it.next();
            schema = info.getSchemaNode();
            if (schema instanceof SchemaDataNode) {
                if (schema.getJavaAttributeName().equalsIgnoreCase(paths[i])) {
                    isSuccess = true;
                    break;
                }
            }
        }
        if (!isSuccess) {
            // above iteration.
            if (i == index && i < paths.length - 1) {
                AugmentedSchemaInfo in = ((YangModule) s).getAugmentedSchemaInfo(cn);
                i = in.getPosition();
                schema = in.getSchemaNode();
            } else {
                throw new IllegalArgumentException(errorMsg(INVAL_ANYDATA, cn));
            }
        }
        i++;
    }
    return schema;
}
#end_block

#method_before
Object getParentObject(DefaultYangModelRegistry reg, YangSchemaNode schemaNode) {
    YangSchemaNodeIdentifier targetNode = schemaNode.getYangSchemaNodeIdentifier();
    YobWorkBench curWorkBench = this;
    YangSchemaNode nonSchemaHolder = null;
    do {
        // Current Schema node context
        YangSchemaNodeContextInfo schemaContext;
        YangSchemaNode parentSchema = null;
        try {
            // Find the new schema context node.
            parentSchema = curWorkBench.schemaNode();
            schemaContext = parentSchema.getChildSchema(targetNode);
        } catch (DataModelException e) {
            throw new ModelConverterException(parentSchema.getName() + E_HAS_NO_CHILD + targetNode.getName(), e);
        }
        nonSchemaHolder = schemaContext.getContextSwitchedNode();
        // If the descendant schema node is in switched context
        if (nonSchemaHolder != null) {
            YangSchemaNodeIdentifier nonSchemaIdentifier = nonSchemaHolder.getYangSchemaNodeIdentifier();
            // check if the descendant builder container is already available
            YobWorkBench childWorkBench = curWorkBench.attributeMap.get(nonSchemaIdentifier);
            if (childWorkBench == null) {
                YobWorkBench newWorkBench = getNewChildWorkBench(schemaContext, targetNode, curWorkBench, reg);
                curWorkBench.attributeMap.put(nonSchemaIdentifier, newWorkBench);
                curWorkBench = newWorkBench;
            } else {
                curWorkBench = childWorkBench;
            }
        }
    } while (nonSchemaHolder != null);
    return curWorkBench.getBuiltObject();
}
#method_after
Object getParentObject(DefaultYangModelRegistry reg, YangSchemaNode schemaNode) {
    YangSchemaNodeIdentifier targetNode = schemaNode.getYangSchemaNodeIdentifier();
    YobWorkBench curWorkBench = this;
    YangSchemaNode nonSchemaHolder;
    do {
        // Current Schema node context
        YangSchemaNodeContextInfo schemaContext;
        YangSchemaNode parentSchema = null;
        try {
            // Find the new schema context node.
            parentSchema = curWorkBench.schemaNode();
            schemaContext = parentSchema.getChildSchema(targetNode);
        } catch (DataModelException e) {
            throw new ModelConverterException(parentSchema.getName() + E_HAS_NO_CHILD + targetNode.getName(), e);
        }
        nonSchemaHolder = schemaContext.getContextSwitchedNode();
        // If the descendant schema node is in switched context
        if (nonSchemaHolder != null) {
            YangSchemaNodeIdentifier nonSchemaIdentifier = nonSchemaHolder.getYangSchemaNodeIdentifier();
            // check if the descendant builder container is already available
            YobWorkBench childWorkBench = curWorkBench.attributeMap.get(nonSchemaIdentifier);
            if (childWorkBench == null) {
                YobWorkBench newWorkBench = getNewChildWorkBench(schemaContext, targetNode, curWorkBench, reg);
                curWorkBench.attributeMap.put(nonSchemaIdentifier, newWorkBench);
                curWorkBench = newWorkBench;
            } else {
                curWorkBench = childWorkBench;
            }
        }
    } while (nonSchemaHolder != null);
    return curWorkBench.getBuiltObject();
}
#end_block

#method_before
@Override
public Object resolve() throws DataModelException {
    YangGrouping referredGrouping = getRefGroup();
    if (referredGrouping == null) {
        throw new DataModelException("YANG uses linker error, cannot resolve" + " uses " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    } else {
        /*
             * if referredGrouping has uses which is not resolved then set the status
             * as Intra file resolved and return
             */
        if (checkIsUnresolvedRecursiveUsesInGrouping(referredGrouping)) {
            return null;
        }
    }
    YangNode usesParentNode = getParentNodeInGenCode(this);
    if (!(usesParentNode instanceof YangLeavesHolder) || !(usesParentNode instanceof CollisionDetector)) {
        throw new DataModelException("YANG uses holder construct is wrong " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    }
    YangLeavesHolder usesParent = (YangLeavesHolder) usesParentNode;
    if (referredGrouping.getListOfLeaf() != null) {
        for (YangLeaf leaf : referredGrouping.getListOfLeaf()) {
            YangLeaf clonedLeaf;
            try {
                ((CollisionDetector) usesParent).detectCollidingChild(leaf.getName(), LEAF_DATA);
                clonedLeaf = leaf.clone();
                clonedLeaf.setReferredLeaf(leaf);
                addUnresolvedType(this, clonedLeaf, (YangNode) usesParent);
            } catch (CloneNotSupportedException | DataModelException e) {
                throw new DataModelException(e.getMessage());
            }
            clonedLeaf.setContainedIn(usesParent);
            usesParent.addLeaf(clonedLeaf);
            if (usesParent instanceof YangList) {
                Set<String> keys = ((YangList) usesParent).getKeyLeaf();
                if (keys.contains(clonedLeaf.getName())) {
                    clonedLeaf.setKeyLeaf(true);
                }
            }
        }
    }
    if (referredGrouping.getListOfLeafList() != null) {
        for (YangLeafList leafList : referredGrouping.getListOfLeafList()) {
            YangLeafList clonedLeafList;
            try {
                ((CollisionDetector) usesParent).detectCollidingChild(leafList.getName(), LEAF_LIST_DATA);
                clonedLeafList = leafList.clone();
                clonedLeafList.setReferredSchemaLeafList(leafList);
                addUnresolvedType(this, clonedLeafList, (YangNode) usesParent);
            } catch (CloneNotSupportedException | DataModelException e) {
                throw new DataModelException(e.getMessage());
            }
            clonedLeafList.setContainedIn(usesParent);
            usesParent.addLeafList(clonedLeafList);
        }
    }
    try {
        cloneSubTree(referredGrouping, usesParentNode, this, false, false);
    } catch (DataModelException e) {
        throw new DataModelException(e.getMessage());
    }
    updateClonedLeavesUnionEnumRef(usesParent);
    return unmodifiableList(entityToResolveInfoList);
}
#method_after
@Override
public Object resolve() throws DataModelException {
    YangGrouping referredGrouping = getRefGroup();
    if (referredGrouping == null) {
        throw new DataModelException("YANG uses linker error, cannot resolve" + " uses " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    } else {
        /*
             * if referredGrouping has uses which is not resolved then set the status
             * as Intra file resolved and return
             */
        if (checkIsUnresolvedRecursiveUsesInGrouping(referredGrouping)) {
            return null;
        }
    }
    YangNode usesParentNode = getParentNodeInGenCode(this);
    if (!(usesParentNode instanceof YangLeavesHolder) || !(usesParentNode instanceof CollisionDetector)) {
        throw new DataModelException("YANG uses holder construct is wrong " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + "\"");
    }
    YangLeavesHolder usesParent = (YangLeavesHolder) usesParentNode;
    if (referredGrouping.getListOfLeaf() != null) {
        for (YangLeaf leaf : referredGrouping.getListOfLeaf()) {
            YangLeaf clonedLeaf;
            try {
                ((CollisionDetector) usesParent).detectCollidingChild(leaf.getName(), LEAF_DATA);
                clonedLeaf = leaf.clone();
                clonedLeaf.setReferredLeaf(leaf);
                addUnresolvedType(this, clonedLeaf, (YangNode) usesParent);
            } catch (CloneNotSupportedException | DataModelException e) {
                throw new DataModelException(e.getMessage());
            }
            clonedLeaf.setContainedIn(usesParent);
            usesParent.addLeaf(clonedLeaf);
            if (usesParent instanceof YangList) {
                Set<String> keys = ((YangList) usesParent).getKeyLeaf();
                if (keys.contains(clonedLeaf.getName())) {
                    clonedLeaf.setKeyLeaf(true);
                }
            }
        }
    }
    if (referredGrouping.getListOfLeafList() != null) {
        for (YangLeafList leafList : referredGrouping.getListOfLeafList()) {
            YangLeafList clonedLeafList;
            try {
                ((CollisionDetector) usesParent).detectCollidingChild(leafList.getName(), LEAF_LIST_DATA);
                clonedLeafList = leafList.clone();
                clonedLeafList.setReferredSchemaLeafList(leafList);
                addUnresolvedType(this, clonedLeafList, (YangNode) usesParent);
            } catch (CloneNotSupportedException | DataModelException e) {
                throw new DataModelException(e.getMessage());
            }
            clonedLeafList.setContainedIn(usesParent);
            usesParent.addLeafList(clonedLeafList);
        }
    }
    try {
        cloneGroupingTree(referredGrouping, usesParentNode, this, false);
    } catch (DataModelException e) {
        throw new DataModelException(e.getMessage());
    }
    updateClonedLeavesUnionEnumRef(usesParent);
    return unmodifiableList(entityToResolveInfoList);
}
#end_block

#method_before
@Override
public YangNode clone(YangUses node, boolean isDeviation, boolean isAnydata) throws CloneNotSupportedException {
    YangNode clnNode = (YangNode) super.clone();
    clnNode.setParent(null);
    clnNode.setChild(null);
    clnNode.setNextSibling(null);
    clnNode.setPreviousSibling(null);
    return clnNode;
}
#method_after
@Override
public YangNode clone(YangUses node, boolean isDeviation) throws CloneNotSupportedException {
    YangNode clnNode = (YangNode) super.clone();
    clnNode.setParent(null);
    clnNode.setChild(null);
    clnNode.setNextSibling(null);
    clnNode.setPreviousSibling(null);
    return clnNode;
}
#end_block

#method_before
@Override
public void registerAnydataSchema(Class c, Class c1) throws IllegalArgumentException {
    AnydataHandler h = new AnydataHandler(this);
    YangSchemaNodeContextInfo in = h.getContextInfoFromClass(c);
    if (in != null && (in.getSchemaNode().getYangSchemaNodeType() == YANG_ANYDATA_NODE)) {
        YangNode anySchema = ((YangNode) in.getSchemaNode());
        Map<YangSchemaNodeIdentifier, YangSchemaNodeContextInfo> m = null;
        YangSchemaNodeContextInfo info;
        boolean isFirstChild = false;
        if (anySchema != null) {
            m = anySchema.getYsnContextInfoMap();
            if (m.isEmpty()) {
                isFirstChild = true;
            }
        }
        YangNode preNode;
        info = h.getContextInfoFromClass(c1);
        if (info != null) {
            try {
                YangNode n = (YangNode) info.getSchemaNode();
                YangNode cn = n.clone(null, false, true);
                try {
                    cloneSubTree(n, cn, null, false, true);
                } catch (DataModelException e) {
                    e.printStackTrace();
                }
                cn.setParent(n.getParent());
                cn.setParentContext(anySchema);
                cn.isAnydataParent = true;
                YangSchemaNodeContextInfo info1 = info.clone();
                info1.setSchemaNode(cn);
                if (n.getParent().getNodeType() == AUGMENT_NODE) {
                    info1.setContextSwitchedNode(null);
                }
                if (isFirstChild) {
                    anySchema.setChild(cn);
                } else {
                    List<Map.Entry<YangSchemaNodeIdentifier, YangSchemaNodeContextInfo>> entryList = new ArrayList<>(m.entrySet());
                    Map.Entry<YangSchemaNodeIdentifier, YangSchemaNodeContextInfo> lastEntry = entryList.get(entryList.size() - 1);
                    preNode = (YangNode) lastEntry.getValue().getSchemaNode();
                    preNode.setNextSibling(cn);
                    cn.setPreviousSibling(preNode);
                }
                m.put(cn.getYangSchemaNodeIdentifier(), info1);
                ((YangAnydata) anySchema).addChildNode(c1, cn);
            } catch (CloneNotSupportedException e) {
                throw new IllegalArgumentException(errorMsg(E_NCLONE, c1));
            }
        } else {
            throw new IllegalArgumentException(errorMsg(FMT_INV, c1));
        }
    } else {
        throw new IllegalArgumentException(errorMsg(FMT_INV, c));
    }
}
#method_after
@Override
public void registerAnydataSchema(Class ac, Class cc) throws IllegalArgumentException {
    YangSchemaNode anySchema = getSchemaNode(ac, this);
    if (anySchema != null && anySchema.getYangSchemaNodeType() == YANG_ANYDATA_NODE) {
        YangSchemaNode cSchema = getSchemaNode(cc, this);
        if (cSchema != null) {
            YangSchemaNode clonedNode = anySchema.addSchema(cSchema);
            updateTreeContext(clonedNode, null, false, false);
        } else {
            throw new IllegalArgumentException(errorMsg(FMT_INV, cc));
        }
    } else {
        throw new IllegalArgumentException(errorMsg(FMT_INV, ac));
    }
}
#end_block

#method_before
YobWorkBench createObject(YangSchemaNode schemaNode, DefaultYangModelRegistry reg) {
    YangSchemaNode node = schemaNode;
    while (node.getReferredSchema() != null) {
        node = node.getReferredSchema();
    }
    String setterName;
    String qualName = getQualifiedDefaultClass(node);
    ClassLoader classLoader = getClassLoader(node, reg);
    /**
     * if current node parent is anydata then it need to be added into
     * anydata map, so in setter for same in parent will be addAnydata
     */
    if (((YangNode) node).isAnydataParent) {
        setterName = ANYDATA_SETTER;
    } else {
        setterName = schemaNode.getJavaAttributeName();
    }
    Object builtObject = getInstanceOfClass(classLoader, qualName);
    return new YobWorkBench(classLoader, builtObject, setterName, schemaNode);
}
#method_after
YobWorkBench createObject(YangSchemaNode schemaNode, DefaultYangModelRegistry reg) {
    YangSchemaNode node = schemaNode;
    String setterName;
    YangNode n = (YangNode) node;
    /**
     * if current node parent is anydata then it need to be added into
     * anydata map, so in setter for same in parent will be addAnydata
     */
    if (n.getParent() != null && (n.getParent().getNodeType() == ANYDATA_NODE)) {
        setterName = ANYDATA_SETTER;
    } else {
        setterName = schemaNode.getJavaAttributeName();
    }
    while (node.getReferredSchema() != null) {
        node = node.getReferredSchema();
    }
    String qualName = getQualifiedDefaultClass(node);
    ClassLoader classLoader = getClassLoader(node, reg);
    Object builtObject = getInstanceOfClass(classLoader, qualName);
    return new YobWorkBench(classLoader, builtObject, setterName, schemaNode);
}
#end_block

#method_before
private YangNode getParentSchemaNode(YangNode curNode) {
    if (curNode.isAnydataParent) {
        return (YangNode) curNode.getParentContext();
    }
    if (curNode instanceof YangAugment) {
        /*
             * If curNode is augment, either next augment or augmented node
             * has to be processed. So traversal type is changed to parent,
             * but node is not changed.
             */
        return curNode;
    }
    if (!curNode.equals(rootSchema)) {
        return curNode.getParent();
    }
    return curNode;
}
#method_after
private YangNode getParentSchemaNode(YangNode curNode) {
    if (curNode instanceof YangAugment) {
        /*
             * If curNode is augment, either next augment or augmented node
             * has to be processed. So traversal type is changed to parent,
             * but node is not changed.
             */
        return curNode;
    }
    if (!curNode.equals(rootSchema)) {
        return curNode.getParent();
    }
    return curNode;
}
#end_block

#method_before
Object getChildObject(YangNode curNode, DataTreeNodeInfo parentNodeInfo) {
    if (curNode.isAnydataParent) {
        return getAnydataChildObject(curNode, parentNodeInfo);
    }
    String nodeJavaName = curNode.getJavaAttributeName();
    Object parentObj = getParentObjectOfNode(parentNodeInfo, curNode.getParent());
    try {
        return getAttributeOfObject(parentObj, nodeJavaName);
    } catch (NoSuchMethodException e) {
        throw new ModelConverterException(e);
    }
}
#method_after
Object getChildObject(YangNode curNode, DataTreeNodeInfo parentNodeInfo) {
    // check current node parent linking status if current node
    if (curNode.getParent() != null && curNode.getParent().getNodeType() == ANYDATA_NODE) {
        return getAnydataChildObject(curNode, parentNodeInfo);
    }
    String nodeJavaName = curNode.getJavaAttributeName();
    Object parentObj = getParentObjectOfNode(parentNodeInfo, curNode.getParent());
    try {
        return getAttributeOfObject(parentObj, nodeJavaName);
    } catch (NoSuchMethodException e) {
        throw new ModelConverterException(e);
    }
}
#end_block

#method_before
private Object getAnydataChildObject(YangNode curNode, DataTreeNodeInfo info) {
    Object parentObj = getParentObjectOfNode(info, (YangNode) curNode.getParentContext());
    List<Object> objs = new ArrayList<>();
    YangSchemaNode node = reg.getForNameSpace(curNode.getNameSpace().getModuleNamespace(), false);
    Class<?> moduleClass = reg.getRegisteredClass(node);
    if (moduleClass == null) {
        throw new ModelConverterException(E_FAIL_TO_LOAD_CLASS + node.getJavaClassNameOrBuiltInType());
    }
    String className = curNode.getJavaPackage() + PERIOD + DEFAULT_CAPS + getCapitalCase(curNode.getJavaAttributeName());
    Class childClass;
    try {
        childClass = moduleClass.getClassLoader().loadClass(className);
    } catch (ClassNotFoundException e) {
        throw new ModelConverterException(E_FAIL_TO_LOAD_CLASS + className);
    }
    objs.add(((Anydata) parentObj).anydata(childClass));
    return objs;
}
#method_after
private Object getAnydataChildObject(YangNode curNode, DataTreeNodeInfo info) {
    // Getting the curNode anydata parent object
    Anydata parentObj = (Anydata) getParentObjectOfNode(info, curNode.getParent());
    List<Object> objs = new ArrayList<>();
    YangSchemaNode node = reg.getForNameSpace(curNode.getNameSpace().getModuleNamespace(), false);
    // Getting the module class
    Class<?> moduleClass = reg.getRegisteredClass(node);
    if (moduleClass == null) {
        throw new ModelConverterException(E_FAIL_TO_LOAD_CLASS + node.getJavaClassNameOrBuiltInType());
    }
    // Forming the default class name for the curNode object creation.
    String className = curNode.getJavaPackage() + PERIOD + DEFAULT_CAPS + getCapitalCase(curNode.getJavaAttributeName());
    Class childClass;
    try {
        childClass = moduleClass.getClassLoader().loadClass(className);
    } catch (ClassNotFoundException e) {
        throw new ModelConverterException(E_FAIL_TO_LOAD_CLASS + className);
    }
    objs.add(parentObj.anydata(childClass));
    return objs;
}
#end_block

#method_before
private ModelConverterTraversalInfo getProcessableInfo(YangNode curNode) {
    if (curNode.getNextSibling() != null) {
        YangNode sibling = curNode.getNextSibling();
        while (isNonProcessableNode(sibling)) {
            sibling = sibling.getNextSibling();
        }
        if (sibling != null) {
            return new ModelConverterTraversalInfo(sibling, SIBLING);
        }
    }
    YangNode parent = curNode.getParent();
    if (curNode.isAnydataParent) {
        parent = (YangNode) curNode.getParentContext();
    } else {
        parent = curNode.getParent();
    }
    if (!(parent instanceof RpcNotificationContainer)) {
        return new ModelConverterTraversalInfo(parent, PARENT);
    }
    return new ModelConverterTraversalInfo((YangNode) exitBuilderSchema, PARENT);
}
#method_after
private ModelConverterTraversalInfo getProcessableInfo(YangNode curNode) {
    if (curNode.getNextSibling() != null) {
        YangNode sibling = curNode.getNextSibling();
        while (isNonProcessableNode(sibling)) {
            sibling = sibling.getNextSibling();
        }
        if (sibling != null) {
            return new ModelConverterTraversalInfo(sibling, SIBLING);
        }
    }
    YangNode parent = curNode.getParent();
    if (!(parent instanceof RpcNotificationContainer)) {
        return new ModelConverterTraversalInfo(curNode.getParent(), PARENT);
    }
    return new ModelConverterTraversalInfo((YangNode) exitBuilderSchema, PARENT);
}
#end_block

#method_before
@Override
public RpcService getRpcService(Class<? extends RpcService> intfc) {
    return handlerRegistry.get(intfc.getSimpleName());
}
#method_after
@Override
public RpcService getRpcService(Class<? extends RpcService> intfc) {
    return handlerRegistry.get(intfc.getName());
}
#end_block

#method_before
@Override
public void registerRpcService(RpcService handler) {
    for (Class<?> intfc : handler.getClass().getInterfaces()) {
        if (RpcService.class.isAssignableFrom(intfc)) {
            handlerRegistry.put(intfc.getSimpleName(), handler);
        }
    }
}
#method_after
@Override
public void registerRpcService(RpcService handler) {
    for (Class<?> intfc : handler.getClass().getInterfaces()) {
        if (RpcService.class.isAssignableFrom(intfc)) {
            handlerRegistry.put(intfc.getName(), handler);
        }
    }
}
#end_block

#method_before
@Override
public void unregisterRpcService(RpcService handler) {
    for (Class<?> intfc : handler.getClass().getInterfaces()) {
        if (RpcService.class.isAssignableFrom(intfc)) {
            String key = intfc.getSimpleName();
            if (handlerRegistry.get(key) == null) {
                throw new FailedException("No registered handler found, cannot unregister");
            }
            handlerRegistry.remove(key);
        }
    }
}
#method_after
@Override
public void unregisterRpcService(RpcService handler) {
    for (Class<?> intfc : handler.getClass().getInterfaces()) {
        if (RpcService.class.isAssignableFrom(intfc)) {
            String key = intfc.getName();
            if (handlerRegistry.get(key) == null) {
                throw new FailedException("No registered handler found, cannot unregister");
            }
            handlerRegistry.remove(key);
        }
    }
}
#end_block

#method_before
private int getSvcId(RpcService handler, String srvc) {
    Class<?>[] intfcs = handler.getClass().getInterfaces();
    for (int i = 0; i < intfcs.length; i++) {
        if (intfcs[i].getSimpleName().compareTo(srvc) == 0) {
            return i;
        }
    }
    throw new FailedException("No handler found, cannot invoke");
}
#method_after
private int getSvcId(RpcService handler, String srvc) {
    Class<?>[] intfcs = handler.getClass().getInterfaces();
    for (int i = 0; i < intfcs.length; i++) {
        if (intfcs[i].getName().compareTo(srvc) == 0) {
            return i;
        }
    }
    throw new FailedException("No handler found, cannot invoke");
}
#end_block

#method_before
@Override
public CompletableFuture<RpcOutput> invokeRpc(ResourceId id, RpcInput input) {
    RpcContext context = contextProvider.getRpcContext(id);
    String srvcIntf = context.serviceIntf().getSimpleName();
    RpcService handler = handlerRegistry.get(srvcIntf);
    if (handler == null) {
        throw new FailedException("No registered handler found, cannot invoke");
    }
    return CompletableFuture.supplyAsync(new RpcExecutor(handler, getSvcId(handler, srvcIntf), context.rpcName(), RpcMessageId.generate(), input), Executors.newSingleThreadExecutor());
}
#method_after
@Override
public CompletableFuture<RpcOutput> invokeRpc(ResourceId id, RpcInput input) {
    RpcContext context = contextProvider.getRpcContext(id);
    String srvcIntf = context.serviceIntf().getName();
    RpcService handler = handlerRegistry.get(srvcIntf);
    if (handler == null) {
        throw new FailedException("No registered handler found, cannot invoke");
    }
    return CompletableFuture.supplyAsync(new RpcExecutor(handler, getSvcId(handler, srvcIntf), context.rpcName(), RpcMessageId.generate(), input));
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    eventHandlingExecutor.execute(() -> {
        try {
            Device device = event.subject();
            if (device == null) {
                return;
            }
            Driver driver = driverService.getDriver(device.id());
            if (driver == null) {
                return;
            }
            if (!Boolean.parseBoolean(driver.getProperty(SUPPORT_PACKET_REQUEST_PROPERTY))) {
                return;
            }
            if (!deviceService.isAvailable(event.subject().id())) {
                return;
            }
            pushRulesToDevice(device);
        } catch (Exception e) {
            log.warn("Failed to process {}", event, e);
        }
    });
}
#method_after
@Override
public void event(DeviceEvent event) {
    eventHandlingExecutor.execute(() -> {
        try {
            if (driverService == null) {
                // Event came in after the driver service shut down, nothing to be done
                return;
            }
            Device device = event.subject();
            Driver driver = driverService.getDriver(device.id());
            if (driver == null) {
                return;
            }
            if (!Boolean.parseBoolean(driver.getProperty(SUPPORT_PACKET_REQUEST_PROPERTY))) {
                return;
            }
            if (!deviceService.isAvailable(event.subject().id())) {
                return;
            }
            pushRulesToDevice(device);
        } catch (Exception e) {
            log.warn("Failed to process {}", event, e);
        }
    });
}
#end_block

#method_before
@Override
protected void execute() {
    Set<OFController> ctrls = Sets.newHashSet();
    for (String strCtrl : strCtrls) {
        if (!isValidController(strCtrl)) {
            print("Invalid controller %s, ignores it.", strCtrl);
            continue;
        }
        String[] temp = strCtrl.split(":");
        ctrls.add(DefaultOFController.of(IpAddress.valueOf(temp[0]), TpPort.tpPort(Integer.valueOf(temp[1]))));
    }
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    OFAgent ofAgent = DefaultOFAgent.builder().networkId(NetworkId.networkId(networkId)).tenantId(TenantId.tenantId(tenantId)).controllers(ctrls).state(OFAgent.State.STOPPED).build();
    adminService.createAgent(ofAgent);
    print("Successfully created OFAgent for network %s, tenant %s", networkId, tenantId);
}
#method_after
@Override
protected void execute() {
    Set<OFController> ctrls = Sets.newHashSet();
    for (String strCtrl : strCtrls) {
        if (!isValidController(strCtrl)) {
            print("Invalid controller %s, ignores it.", strCtrl);
            continue;
        }
        String[] temp = strCtrl.split(":");
        ctrls.add(DefaultOFController.of(IpAddress.valueOf(temp[0]), TpPort.tpPort(Integer.valueOf(temp[1]))));
    }
    VirtualNetworkService virtualNetworkService = get(VirtualNetworkService.class);
    TenantId tenantId = virtualNetworkService.getTenantId(NetworkId.networkId(networkId));
    checkNotNull(tenantId, "Virtual network %s does not have tenant.", networkId);
    OFAgentAdminService adminService = get(OFAgentAdminService.class);
    OFAgent ofAgent = DefaultOFAgent.builder().networkId(NetworkId.networkId(networkId)).tenantId(tenantId).controllers(ctrls).state(OFAgent.State.STOPPED).build();
    adminService.createAgent(ofAgent);
    print("Successfully created OFAgent for network %s, tenant %s", networkId, tenantId);
}
#end_block

#method_before
@Override
public TenantId getTenantId(NetworkId networkId) {
    VirtualNetwork virtualNetwork = getVirtualNetwork(networkId);
    checkNotNull(virtualNetwork);
    return virtualNetwork.tenantId();
}
#method_after
@Override
public TenantId getTenantId(NetworkId networkId) {
    VirtualNetwork virtualNetwork = getVirtualNetwork(networkId);
    checkNotNull(virtualNetwork, "The network does not exist.");
    return virtualNetwork.tenantId();
}
#end_block

#method_before
@Override
public boolean sendMsg(Iterable<OFMessage> msgs) {
    if (channel.isActive()) {
        log.debug("Sending messages for switch {} via openflow channel: {}", getSwitchInfoString(), msgs);
        channel.writeAndFlush(msgs, channel.voidPromise());
        return true;
    } else {
        log.warn("Dropping messages for switch {} because channel is not connected: {}", getSwitchInfoString(), msgs);
        return false;
    }
}
#method_after
@Override
public boolean sendMsg(Iterable<OFMessage> msgs) {
    if (channel.isActive()) {
        if (log.isTraceEnabled()) {
            log.trace("Sending messages for switch {} via openflow channel: {}", getSwitchInfoString(), msgs);
        }
        channel.writeAndFlush(msgs, channel.voidPromise());
        return true;
    } else {
        log.warn("Dropping messages for switch {} because channel is not connected: {}", getSwitchInfoString(), msgs);
        return false;
    }
}
#end_block

#method_before
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = this.getSwitch(dpid);
    log.debug("Processing message from switch {} via openflow: {}", dpid, msg);
    // Check if someone is waiting for this message
    ConcurrentMap<Long, CompletableFuture<OFMessage>> xids = responses.get(dpid);
    if (xids != null) {
        CompletableFuture<OFMessage> future = xids.remove(msg.getXid());
        if (future != null) {
            future.complete(msg);
        }
    }
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            if (sw == null) {
                log.error("Ignoring PACKET_IN, switch {} is not found", dpid);
                break;
            }
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(sw, (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
            executorMsgs.execute(new OFMessageHandler(dpid, msg));
            break;
        case ERROR:
            log.debug("Received error message from {}: {}", dpid, msg);
            errorMsgs.putIfAbsent(msg.getXid(), true);
            executorErrorMsgs.execute(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            processStatsReply(dpid, (OFStatsReply) msg);
            break;
        case BARRIER_REPLY:
            if (errorMsgs.containsKey(msg.getXid())) {
                // To make oferror msg handling and corresponding barrier reply serialized,
                // executorErrorMsgs is used for both transaction
                errorMsgs.remove(msg.getXid());
                executorErrorMsgs.execute(new OFMessageHandler(dpid, msg));
            } else {
                executorBarrier.execute(new OFMessageHandler(dpid, msg));
            }
            break;
        case EXPERIMENTER:
            if (sw == null) {
                log.error("Switch {} is not found", dpid);
                break;
            }
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = sw.factory().buildPortStatus();
                OFPortDesc.Builder portDesc = sw.factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#method_after
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = this.getSwitch(dpid);
    if (log.isTraceEnabled()) {
        log.trace("Processing message from switch {} via openflow: {}", dpid, msg);
    }
    // Check if someone is waiting for this message
    ConcurrentMap<Long, CompletableFuture<OFMessage>> xids = responses.get(dpid);
    if (xids != null) {
        CompletableFuture<OFMessage> future = xids.remove(msg.getXid());
        if (future != null) {
            future.complete(msg);
        }
    }
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            if (sw == null) {
                log.error("Ignoring PACKET_IN, switch {} is not found", dpid);
                break;
            }
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(sw, (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
            executorMsgs.execute(new OFMessageHandler(dpid, msg));
            break;
        case ERROR:
            log.debug("Received error message from {}: {}", dpid, msg);
            errorMsgs.putIfAbsent(msg.getXid(), true);
            executorErrorMsgs.execute(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            processStatsReply(dpid, (OFStatsReply) msg);
            break;
        case BARRIER_REPLY:
            if (errorMsgs.containsKey(msg.getXid())) {
                // To make oferror msg handling and corresponding barrier reply serialized,
                // executorErrorMsgs is used for both transaction
                errorMsgs.remove(msg.getXid());
                executorErrorMsgs.execute(new OFMessageHandler(dpid, msg));
            } else {
                executorBarrier.execute(new OFMessageHandler(dpid, msg));
            }
            break;
        case EXPERIMENTER:
            if (sw == null) {
                log.error("Switch {} is not found", dpid);
                break;
            }
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = sw.factory().buildPortStatus();
                OFPortDesc.Builder portDesc = sw.factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(DeviceEvent event) {
    return event.subject().type() != CONTROLLER && event.type() == DEVICE_REMOVED;
}
#method_after
@Override
public boolean isRelevant(DeviceEvent event) {
    return event.subject().type() != CONTROLLER && event.type() == DEVICE_REMOVED && event.subject().id().uri().getScheme().equals(SCHEME);
}
#end_block

#method_before
private void mastershipCheck() {
    log.debug("Checking mastership");
    for (Device device : getDevices()) {
        final DeviceId deviceId = device.id();
        MastershipRole myRole = mastershipService.getLocalRole(deviceId);
        log.trace("Checking device {}. Current role is {}", deviceId, myRole);
        if (!isReachable(deviceId)) {
            if (myRole != NONE) {
                // can't be master if device is not reachable
                try {
                    if (myRole == MASTER) {
                        post(store.markOffline(deviceId));
                    }
                    // relinquish master role and ability to be backup.
                    mastershipService.relinquishMastership(deviceId).get();
                } catch (InterruptedException e) {
                    log.warn("Interrupted while reliquishing role for {}", deviceId);
                    Thread.currentThread().interrupt();
                } catch (ExecutionException e) {
                    log.error("Exception thrown while relinquishing role for {}", deviceId, e);
                }
            } else {
                // check if the device has master, if not, mark it offline
                // only the nodes which has mastership role can mark any device offline.
                CompletableFuture<MastershipRole> roleFuture = mastershipService.requestRoleFor(deviceId);
                roleFuture.thenAccept(role -> {
                    MastershipTerm term = termService.getMastershipTerm(deviceId);
                    if (term != null && localNodeId.equals(term.master())) {
                        log.info("Marking unreachable device {} offline", deviceId);
                        post(store.markOffline(deviceId));
                    } else {
                        log.info("Failed marking {} offline. {}", deviceId, role);
                    }
                    mastershipService.relinquishMastership(deviceId);
                });
            }
            continue;
        }
        if (myRole != NONE) {
            continue;
        }
        log.info("{} is reachable but did not have a valid role, reasserting", deviceId);
        // isReachable but was not MASTER or STANDBY, get a role and apply
        // Note: NONE triggers request to MastershipService
        reassertRole(deviceId, mastershipService.getLocalRole(deviceId));
    }
}
#method_after
private void mastershipCheck() {
    log.debug("Checking mastership");
    for (Device device : getDevices()) {
        final DeviceId deviceId = device.id();
        MastershipRole myRole = mastershipService.getLocalRole(deviceId);
        log.trace("Checking device {}. Current role is {}", deviceId, myRole);
        if (!isReachable(deviceId)) {
            if (myRole != NONE) {
                // can't be master if device is not reachable
                try {
                    if (myRole == MASTER) {
                        post(store.markOffline(deviceId));
                    }
                    // relinquish master role and ability to be backup.
                    mastershipService.relinquishMastership(deviceId).get();
                } catch (InterruptedException e) {
                    log.warn("Interrupted while reliquishing role for {}", deviceId);
                    Thread.currentThread().interrupt();
                } catch (ExecutionException e) {
                    log.error("Exception thrown while relinquishing role for {}", deviceId, e);
                }
            } else {
                // check if the device has master, if not, mark it offline
                // only the nodes which has mastership role can mark any device offline.
                CompletableFuture<MastershipRole> roleFuture = mastershipService.requestRoleFor(deviceId);
                roleFuture.thenAccept(role -> {
                    MastershipTerm term = termService.getMastershipTerm(deviceId);
                    if (term != null && localNodeId.equals(term.master())) {
                        log.info("Marking unreachable device {} offline", deviceId);
                        post(store.markOffline(deviceId));
                    } else {
                        log.info("Failed marking {} offline. {}", deviceId, role);
                    }
                    mastershipService.relinquishMastership(deviceId);
                });
            }
            continue;
        }
        if (myRole != NONE) {
            continue;
        }
        log.info("{} is reachable but did not have a valid role, reasserting", deviceId);
        // isReachable but was not MASTER or STANDBY, get a role and apply
        // Note: NONE triggers request to MastershipService
        reassertRole(deviceId, NONE);
    }
}
#end_block

#method_before
private void reassertRole(final DeviceId did, final MastershipRole nextRole) {
    switch(nextRole) {
        case MASTER:
            final Device device = getDevice(did);
            if ((device != null) && !isAvailable(did)) {
                store.markOnline(did);
            }
            // TODO: should apply role only if there is mismatch
            log.debug("Applying role {} to {}", nextRole, did);
            if (!applyRoleAndProbe(did, MASTER)) {
                log.warn("Unsuccessful applying role {} to {}", nextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case STANDBY:
            log.debug("Applying role {} to {}", nextRole, did);
            if (!applyRoleAndProbe(did, STANDBY)) {
                log.warn("Unsuccessful applying role {} to {}", nextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case NONE:
            break;
        default:
            // should never reach here
            log.error("You didn't see anything. I did not exist.");
            break;
    }
}
#method_after
private void reassertRole(final DeviceId did, final MastershipRole nextRole) {
    MastershipRole myNextRole = nextRole;
    if (myNextRole == NONE && upgradeService.isLocalActive()) {
        try {
            mastershipService.requestRoleFor(did).get();
            MastershipTerm term = termService.getMastershipTerm(did);
            if (term != null && localNodeId.equals(term.master())) {
                myNextRole = MASTER;
            } else {
                myNextRole = STANDBY;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Interrupted waiting for Mastership", e);
        } catch (ExecutionException e) {
            log.error("Encountered an error waiting for Mastership", e);
        }
    }
    switch(myNextRole) {
        case MASTER:
            final Device device = getDevice(did);
            if ((device != null) && !isAvailable(did)) {
                store.markOnline(did);
            }
            // TODO: should apply role only if there is mismatch
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, MASTER)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case STANDBY:
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, STANDBY)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case NONE:
            break;
        default:
            // should never reach here
            log.error("You didn't see anything. I did not exist.");
            break;
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    DeviceEvent de = null;
    if (event.configClass().equals(BasicDeviceConfig.class)) {
        log.debug("Detected device network config event {}", event.type());
        DeviceId did = (DeviceId) event.subject();
        DeviceProvider dp = getProvider(did);
        BasicDeviceConfig cfg = networkConfigService.getConfig(did, BasicDeviceConfig.class);
        if (!isAllowed(cfg)) {
            kickOutBadDevice(did);
        } else {
            Device dev = getDevice(did);
            DeviceDescription desc = (dev == null) ? null : BasicDeviceOperator.descriptionOf(dev);
            desc = BasicDeviceOperator.combine(cfg, desc);
            if (desc != null && dp != null) {
                de = store.createOrUpdateDevice(dp.id(), did, desc);
            }
        }
    } else if (event.configClass().equals(PortDescriptionsConfig.class)) {
        DeviceId did = (DeviceId) event.subject();
        DeviceProvider dp = getProvider(did);
        if (!event.config().isPresent() || getDevice(did) == null || dp == null) {
            // sanity check failed, ignore
            return;
        }
        PortDescriptionsConfig portConfig = (PortDescriptionsConfig) event.config().get();
        // updating the ports if configuration exists
        List<PortDescription> complete = store.getPortDescriptions(dp.id(), did).collect(Collectors.toList());
        complete.addAll(portConfig.portDescriptions());
        store.updatePorts(dp.id(), did, complete);
    } else if (event.configClass().equals(DeviceAnnotationConfig.class)) {
        DeviceId did = (DeviceId) event.subject();
        DeviceProvider dp = getProvider(did);
        Device dev = getDevice(did);
        DeviceDescription desc = (dev == null) ? null : BasicDeviceOperator.descriptionOf(dev);
        desc = deviceAnnotationOp.combine(did, desc);
        if (desc != null && dp != null) {
            de = store.createOrUpdateDevice(dp.id(), did, desc);
        }
    } else if (portOpsIndex.containsKey(event.configClass())) {
        ConnectPoint cpt = (ConnectPoint) event.subject();
        DeviceId did = cpt.deviceId();
        DeviceProvider dp = getProvider(did);
        // Note: assuming PortOperator can modify existing port,
        // but cannot add new port purely from Config.
        de = Optional.ofNullable(dp).map(provider -> store.getPortDescription(provider.id(), did, cpt.port())).map(desc -> applyAllPortOps(cpt, desc)).map(desc -> store.updatePortStatus(dp.id(), did, desc)).orElse(null);
    }
    if (de != null) {
        post(de);
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    DeviceEvent de = null;
    if (event.configClass().equals(BasicDeviceConfig.class)) {
        log.debug("Detected device network config event {}", event.type());
        DeviceId did = (DeviceId) event.subject();
        DeviceProvider dp = getProvider(did);
        BasicDeviceConfig cfg = networkConfigService.getConfig(did, BasicDeviceConfig.class);
        if (!isAllowed(cfg)) {
            kickOutBadDevice(did);
        } else {
            Device dev = getDevice(did);
            DeviceDescription desc = (dev == null) ? null : BasicDeviceOperator.descriptionOf(dev);
            desc = BasicDeviceOperator.combine(cfg, desc);
            if (desc != null && dp != null) {
                de = store.createOrUpdateDevice(dp.id(), did, desc);
            }
        }
    } else if (event.configClass().equals(PortDescriptionsConfig.class)) {
        DeviceId did = (DeviceId) event.subject();
        DeviceProvider dp = getProvider(did);
        if (!event.config().isPresent() || getDevice(did) == null || dp == null) {
            // sanity check failed, ignore
            return;
        }
        PortDescriptionsConfig portConfig = (PortDescriptionsConfig) event.config().get();
        // updating the ports if configuration exists
        List<PortDescription> complete = store.getPortDescriptions(dp.id(), did).collect(Collectors.toList());
        complete.addAll(portConfig.portDescriptions());
        store.updatePorts(dp.id(), did, complete);
    } else if (event.configClass().equals(DeviceAnnotationConfig.class)) {
        DeviceId did = (DeviceId) event.subject();
        DeviceProvider dp = getProvider(did);
        Device dev = getDevice(did);
        DeviceDescription desc = (dev == null) ? null : BasicDeviceOperator.descriptionOf(dev);
        Optional<Config> prevConfig = event.prevConfig();
        desc = deviceAnnotationOp.combine(did, desc, prevConfig);
        if (desc != null && dp != null) {
            de = store.createOrUpdateDevice(dp.id(), did, desc);
        }
    } else if (portOpsIndex.containsKey(event.configClass())) {
        ConnectPoint cpt = (ConnectPoint) event.subject();
        DeviceId did = cpt.deviceId();
        DeviceProvider dp = getProvider(did);
        // Note: assuming PortOperator can modify existing port,
        // but cannot add new port purely from Config.
        de = Optional.ofNullable(dp).map(provider -> store.getPortDescription(provider.id(), did, cpt.port())).map(desc -> applyAllPortOps(cpt, desc)).map(desc -> store.updatePortStatus(dp.id(), did, desc)).orElse(null);
    }
    if (de != null) {
        post(de);
    }
}
#end_block

#method_before
@Override
protected void execute() {
    NetworkConfigService netcfgService = get(NetworkConfigService.class);
    DeviceId deviceId = DeviceId.deviceId(uri);
    if (key == null) {
        print("[ERROR] Annotation key not specified.");
        return;
    }
    DeviceAnnotationConfig cfg = netcfgService.addConfig(deviceId, DeviceAnnotationConfig.class);
    cfg.annotation(key, value);
    cfg.apply();
}
#method_after
@Override
protected void execute() {
    NetworkConfigService netcfgService = get(NetworkConfigService.class);
    DeviceId deviceId = DeviceId.deviceId(uri);
    if (key == null) {
        print("[ERROR] Annotation key not specified.");
        return;
    }
    DeviceAnnotationConfig cfg = netcfgService.getConfig(deviceId, DeviceAnnotationConfig.class);
    if (cfg == null) {
        cfg = new DeviceAnnotationConfig(deviceId);
    }
    if (removeCfg) {
        // remove config about entry
        cfg.annotation(key);
    } else {
        // add remove request config
        cfg.annotation(key, value);
    }
    netcfgService.applyConfig(deviceId, DeviceAnnotationConfig.class, cfg.node());
}
#end_block

#method_before
@Override
public DeviceDescription combine(DeviceId deviceId, DeviceDescription descr) {
    DeviceAnnotationConfig cfg = lookupConfig(deviceId);
    if (cfg == null) {
        return descr;
    }
    Map<String, String> annotations = cfg.annotations();
    if (annotations.isEmpty()) {
        return descr;
    }
    Builder builder = DefaultAnnotations.builder();
    builder.putAll(descr.annotations());
    builder.putAll(annotations);
    return DefaultDeviceDescription.copyReplacingAnnotation(descr, builder.build());
}
#method_after
@Override
public DeviceDescription combine(DeviceId deviceId, DeviceDescription descr, Optional<Config> prevConfig) {
    DeviceAnnotationConfig cfg = lookupConfig(deviceId);
    if (cfg == null) {
        return descr;
    }
    Map<String, String> annotations = cfg.annotations();
    Builder builder = DefaultAnnotations.builder();
    builder.putAll(descr.annotations());
    if (prevConfig.isPresent()) {
        DeviceAnnotationConfig prevDeviceAnnotationConfig = (DeviceAnnotationConfig) prevConfig.get();
        for (String key : prevDeviceAnnotationConfig.annotations().keySet()) {
            if (!annotations.containsKey(key)) {
                builder.remove(key);
            }
        }
    }
    builder.putAll(annotations);
    return DefaultDeviceDescription.copyReplacingAnnotation(descr, builder.build());
}
#end_block

#method_before
/*
     * In Next block, we need to implement these actions:
     * output
     * set_vlan_output
     * l3_routing
     * mpls_routing_v4
     *
     * Unsupported, using PiAction directly:
     * set_next_type
     *
     * Unsupported, need to find a way to implement it
     * mpls_routing_v6
     */
public static PiAction mapNextTreatment(TrafficTreatment treatment) throws PiInterpreterException {
    List<Instruction> insts = treatment.allInstructions();
    OutputInstruction outInst = null;
    ModEtherInstruction modEthDstInst = null;
    ModEtherInstruction modEthSrcInst = null;
    ModVlanIdInstruction modVlanIdInst = null;
    ModMplsLabelInstruction modMplsInst = null;
    // TODO: add NextFunctionType (like ForwardingFunctionType)
    for (Instruction inst : insts) {
        switch(inst.type()) {
            case L2MODIFICATION:
                L2ModificationInstruction l2Inst = (L2ModificationInstruction) inst;
                if (l2Inst.subtype() == ETH_SRC) {
                    modEthSrcInst = (ModEtherInstruction) l2Inst;
                } else if (l2Inst.subtype() == ETH_DST) {
                    modEthDstInst = (ModEtherInstruction) l2Inst;
                } else if (l2Inst.subtype() == VLAN_ID) {
                    modVlanIdInst = (ModVlanIdInstruction) l2Inst;
                } else if (l2Inst.subtype() == MPLS_LABEL) {
                    modMplsInst = (ModMplsLabelInstruction) l2Inst;
                }
                // TODO: support TTL_OUT instruction
                break;
            case OUTPUT:
                outInst = (OutputInstruction) inst;
                break;
            default:
                break;
        }
    }
    if (outInst == null) {
        throw new PiInterpreterException(format(INVALID_TREATMENT, "next", treatment));
    }
    short portNum = (short) outInst.port().toLong();
    PiActionParam portNumParam = new PiActionParam(FabricConstants.ACT_PRM_PORT_NUM_ID, ImmutableByteSequence.copyFrom(portNum));
    if (modEthDstInst == null && modEthSrcInst == null) {
        if (modVlanIdInst != null) {
            VlanId vlanId = modVlanIdInst.vlanId();
            PiActionParam vlanParam = new PiActionParam(FabricConstants.ACT_PRM_NEW_VLAN_ID_ID, ImmutableByteSequence.copyFrom(vlanId.toShort()));
            // set_vlan_output
            return PiAction.builder().withId(FabricConstants.ACT_SET_VLAN_OUTPUT_ID).withParameters(ImmutableList.of(portNumParam, vlanParam)).build();
        } else {
            // output
            return PiAction.builder().withId(FabricConstants.ACT_OUTPUT_ID).withParameter(portNumParam).build();
        }
    }
    if (modEthDstInst != null && modEthSrcInst != null) {
        MacAddress srcMac = modEthSrcInst.mac();
        MacAddress dstMac = modEthDstInst.mac();
        PiActionParam srcMacParam = new PiActionParam(FabricConstants.ACT_PRM_SMAC_ID, ImmutableByteSequence.copyFrom(srcMac.toBytes()));
        PiActionParam dstMacParam = new PiActionParam(FabricConstants.ACT_PRM_DMAC_ID, ImmutableByteSequence.copyFrom(dstMac.toBytes()));
        if (modMplsInst != null) {
            // MPLS routing
            MplsLabel mplsLabel = modMplsInst.label();
            try {
                ImmutableByteSequence mplsValue = ImmutableByteSequence.fit(ImmutableByteSequence.copyFrom(mplsLabel.toInt()), 20);
                PiActionParam mplsParam = new PiActionParam(FabricConstants.ACT_PRM_LABEL_ID, mplsValue);
                return PiAction.builder().withId(FabricConstants.ACT_MPLS_ROUTING_V4_ID).withParameters(ImmutableList.of(portNumParam, srcMacParam, dstMacParam, mplsParam)).build();
            } catch (ImmutableByteSequence.ByteSequenceTrimException e) {
                // size of mpls value to 20 bits (0xFFFFF)
                throw new PiInterpreterException(format(INVALID_TREATMENT, "next", treatment));
            }
        }
        // L3 routing
        return PiAction.builder().withId(FabricConstants.ACT_L3_ROUTING_ID).withParameters(ImmutableList.of(portNumParam, srcMacParam, dstMacParam)).build();
    }
    throw new PiInterpreterException(format(INVALID_TREATMENT, "next", treatment));
}
#method_after
/*
     * In Next block, we need to implement these actions:
     * output
     * set_vlan_output
     * l3_routing
     * mpls_routing_v4
     *
     * Unsupported, using PiAction directly:
     * set_next_type
     *
     * Unsupported, need to find a way to implement it
     * mpls_routing_v6
     */
public static PiAction mapNextTreatment(TrafficTreatment treatment) throws PiInterpreterException {
    List<Instruction> insts = treatment.allInstructions();
    OutputInstruction outInst = null;
    ModEtherInstruction modEthDstInst = null;
    ModEtherInstruction modEthSrcInst = null;
    ModVlanIdInstruction modVlanIdInst = null;
    ModMplsLabelInstruction modMplsInst = null;
    // TODO: add NextFunctionType (like ForwardingFunctionType)
    for (Instruction inst : insts) {
        switch(inst.type()) {
            case L2MODIFICATION:
                L2ModificationInstruction l2Inst = (L2ModificationInstruction) inst;
                switch(l2Inst.subtype()) {
                    case ETH_SRC:
                        modEthSrcInst = (ModEtherInstruction) l2Inst;
                        break;
                    case ETH_DST:
                        modEthDstInst = (ModEtherInstruction) l2Inst;
                        break;
                    case VLAN_ID:
                        modVlanIdInst = (ModVlanIdInstruction) l2Inst;
                        break;
                    case MPLS_LABEL:
                        modMplsInst = (ModMplsLabelInstruction) l2Inst;
                        break;
                    default:
                        log.warn("Unsupported l2 instruction sub type: {}", l2Inst.subtype());
                        break;
                }
                break;
            case OUTPUT:
                outInst = (OutputInstruction) inst;
                break;
            default:
                log.warn("Unsupported instruction sub type: {}", inst.type());
                break;
        }
    }
    if (outInst == null) {
        throw new PiInterpreterException(format(INVALID_TREATMENT, "next", treatment));
    }
    short portNum = (short) outInst.port().toLong();
    PiActionParam portNumParam = new PiActionParam(FabricConstants.ACT_PRM_PORT_NUM_ID, ImmutableByteSequence.copyFrom(portNum));
    if (modEthDstInst == null && modEthSrcInst == null) {
        if (modVlanIdInst != null) {
            VlanId vlanId = modVlanIdInst.vlanId();
            PiActionParam vlanParam = new PiActionParam(FabricConstants.ACT_PRM_NEW_VLAN_ID_ID, ImmutableByteSequence.copyFrom(vlanId.toShort()));
            // set_vlan_output
            return PiAction.builder().withId(FabricConstants.ACT_SET_VLAN_OUTPUT_ID).withParameters(ImmutableList.of(portNumParam, vlanParam)).build();
        } else {
            // output
            return PiAction.builder().withId(FabricConstants.ACT_OUTPUT_ID).withParameter(portNumParam).build();
        }
    }
    if (modEthDstInst != null && modEthSrcInst != null) {
        MacAddress srcMac = modEthSrcInst.mac();
        MacAddress dstMac = modEthDstInst.mac();
        PiActionParam srcMacParam = new PiActionParam(FabricConstants.ACT_PRM_SMAC_ID, ImmutableByteSequence.copyFrom(srcMac.toBytes()));
        PiActionParam dstMacParam = new PiActionParam(FabricConstants.ACT_PRM_DMAC_ID, ImmutableByteSequence.copyFrom(dstMac.toBytes()));
        if (modMplsInst != null) {
            // MPLS routing
            MplsLabel mplsLabel = modMplsInst.label();
            try {
                ImmutableByteSequence mplsValue = ImmutableByteSequence.fit(ImmutableByteSequence.copyFrom(mplsLabel.toInt()), 20);
                PiActionParam mplsParam = new PiActionParam(FabricConstants.ACT_PRM_LABEL_ID, mplsValue);
                return PiAction.builder().withId(FabricConstants.ACT_MPLS_ROUTING_V4_ID).withParameters(ImmutableList.of(portNumParam, srcMacParam, dstMacParam, mplsParam)).build();
            } catch (ImmutableByteSequence.ByteSequenceTrimException e) {
                // size of mpls value to 20 bits (0xFFFFF)
                throw new PiInterpreterException(format(INVALID_TREATMENT, "next", treatment));
            }
        }
        // L3 routing
        return PiAction.builder().withId(FabricConstants.ACT_L3_ROUTING_ID).withParameters(ImmutableList.of(portNumParam, srcMacParam, dstMacParam)).build();
    }
    throw new PiInterpreterException(format(INVALID_TREATMENT, "next", treatment));
}
#end_block

#method_before
private boolean installGroups(Objective objective, Collection<GroupDescription> groups) {
    if (groups.isEmpty()) {
        return true;
    }
    Collection<Integer> groupIds = groups.stream().map(GroupDescription::givenGroupId).collect(Collectors.toSet());
    int numGroupsToBeInstalled = groups.size();
    CompletableFuture<Boolean> groupInstallFuture = new CompletableFuture<>();
    AtomicInteger numGroupsInstalled = new AtomicInteger(0);
    GroupListener listener = new GroupListener() {

        @Override
        public void event(GroupEvent event) {
            log.info("Receive group event for group {}", event.subject());
            int currentNumGroupInstalled = numGroupsInstalled.incrementAndGet();
            if (currentNumGroupInstalled == numGroupsToBeInstalled) {
                // install completed
                groupService.removeListener(this);
                groupInstallFuture.complete(true);
            }
        }

        @Override
        public boolean isRelevant(GroupEvent event) {
            Group group = event.subject();
            return groupIds.contains(group.givenGroupId());
        }
    };
    groupService.addListener(listener);
    switch(objective.op()) {
        case ADD:
            groups.forEach(groupService::addGroup);
            break;
        case REMOVE:
            groups.forEach(group -> groupService.removeGroup(deviceId, group.appCookie(), objective.appId()));
            break;
        case ADD_TO_EXISTING:
            groups.forEach(group -> {
                groupService.addBucketsToGroup(deviceId, group.appCookie(), group.buckets(), group.appCookie(), group.appId());
            });
            break;
        case REMOVE_FROM_EXISTING:
            groups.forEach(group -> {
                groupService.removeBucketsFromGroup(deviceId, group.appCookie(), group.buckets(), group.appCookie(), group.appId());
            });
            break;
        default:
            log.warn("Unsupported objective operation {}", objective.op());
            groupService.removeListener(listener);
    }
    try {
        return groupInstallFuture.get(DEFAULT_INSTALLATION_TIME_OUT, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        groupService.removeListener(listener);
        log.warn("Got exception while installing groups: {}", e.getMessage());
        return false;
    }
}
#method_after
private boolean installGroups(Objective objective, Collection<GroupDescription> groups) {
    if (groups.isEmpty()) {
        return true;
    }
    Collection<Integer> groupIds = groups.stream().map(GroupDescription::givenGroupId).collect(Collectors.toSet());
    int numGroupsToBeInstalled = groups.size();
    CompletableFuture<Boolean> groupInstallFuture = new CompletableFuture<>();
    AtomicInteger numGroupsInstalled = new AtomicInteger(0);
    GroupListener listener = new GroupListener() {

        @Override
        public void event(GroupEvent event) {
            log.debug("Receive group event for group {}", event.subject());
            int currentNumGroupInstalled = numGroupsInstalled.incrementAndGet();
            if (currentNumGroupInstalled == numGroupsToBeInstalled) {
                // install completed
                groupService.removeListener(this);
                groupInstallFuture.complete(true);
            }
        }

        @Override
        public boolean isRelevant(GroupEvent event) {
            Group group = event.subject();
            return groupIds.contains(group.givenGroupId());
        }
    };
    groupService.addListener(listener);
    switch(objective.op()) {
        case ADD:
            groups.forEach(groupService::addGroup);
            break;
        case REMOVE:
            groups.forEach(group -> groupService.removeGroup(deviceId, group.appCookie(), objective.appId()));
            break;
        case ADD_TO_EXISTING:
            groups.forEach(group -> {
                groupService.addBucketsToGroup(deviceId, group.appCookie(), group.buckets(), group.appCookie(), group.appId());
            });
            break;
        case REMOVE_FROM_EXISTING:
            groups.forEach(group -> {
                groupService.removeBucketsFromGroup(deviceId, group.appCookie(), group.buckets(), group.appCookie(), group.appId());
            });
            break;
        default:
            log.warn("Unsupported objective operation {}", objective.op());
            groupService.removeListener(listener);
    }
    try {
        return groupInstallFuture.get(DEFAULT_INSTALLATION_TIME_OUT, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        groupService.removeListener(listener);
        log.warn("Got exception while installing groups: {}", e.getMessage());
        return false;
    }
}
#end_block

#method_before
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription, boolean discovered) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        log.debug("Device {} has not been added to store, since it's not reachable", deviceId);
        return;
    }
    boolean isReachable = isReachable(deviceId);
    if (!isReachable && deviceService.isAvailable(deviceId)) {
        providerService.deviceDisconnected(deviceId);
    } else if (discovered) {
        updateDeviceDescription(deviceId, deviceDescription, device);
    }
    if (isReachable && deviceService.isAvailable(deviceId) && mastershipService.isLocalMaster(deviceId)) {
        // if ports are not discovered, retry the discovery
        if (deviceService.getPorts(deviceId).isEmpty() && retriedPortDiscoveryMap.get(deviceId).getAndIncrement() < maxRetries) {
            discoverPorts(deviceId);
        }
        updatePortStatistics(device);
    }
}
#method_after
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription, boolean newlyConnected) {
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        log.debug("Device {} has not been added to store, since it's not reachable", deviceId);
        return;
    }
    boolean isReachable = isReachable(deviceId);
    if (!isReachable && deviceService.isAvailable(deviceId)) {
        providerService.deviceDisconnected(deviceId);
        return;
    } else if (newlyConnected) {
        updateDeviceDescription(deviceId, deviceDescription, device);
    }
    if (isReachable && deviceService.isAvailable(deviceId) && mastershipService.isLocalMaster(deviceId)) {
        // if ports are not discovered, retry the discovery
        if (deviceService.getPorts(deviceId).isEmpty() && retriedPortDiscoveryMap.get(deviceId).getAndIncrement() < maxRetries) {
            discoverPorts(deviceId);
        }
        updatePortStatistics(device);
    }
}
#end_block

#method_before
@Override
public Type piEntityType() {
    return Type.TABLE_ENTRY;
}
#method_after
@Override
public PiEntityType piEntityType() {
    return PiEntityType.TABLE_ENTRY;
}
#end_block

#method_before
public final PiEntity.Type entityType() {
    return type;
}
#method_after
public final PiEntityType entityType() {
    return type;
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(PiTranslatedEntityKey.class).register(PiTranslatedEntity.class);
    translatedEntities = storageService.<PiTranslatedEntityKey, PiTranslatedEntity>eventuallyConsistentMapBuilder().withName("onos-pi-translated-entities-map").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    translatedEntities.addListener(entityMapListener);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    translatedEntities = storageService.<PiTranslatedEntityKey, PiTranslatedEntity>eventuallyConsistentMapBuilder().withName(DIST_MAP_NAME).withSerializer(KryoNamespace.newBuilder().register(KryoNamespaces.API).register(PiTranslatedEntityKey.class).build()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    translatedEntities.addListener(entityMapListener);
    log.info("Started");
}
#end_block

#method_before
@Override
public void event(EventuallyConsistentMapEvent<PiTranslatedEntityKey, PiTranslatedEntity> event) {
    final PiTranslationEvent.Type type;
    switch(event.type()) {
        case PUT:
            type = PiTranslationEvent.Type.LEARN;
            break;
        case REMOVE:
            type = PiTranslationEvent.Type.FORGET;
            break;
        default:
            throw new IllegalArgumentException("Unknown event type " + event.type().name());
    }
    notifyDelegate(new PiTranslationEvent(type, event.value()));
}
#method_after
@Override
public void event(EventuallyConsistentMapEvent<PiTranslatedEntityKey, PiTranslatedEntity> event) {
    final PiTranslationEvent.Type type;
    switch(event.type()) {
        case PUT:
            type = PiTranslationEvent.Type.LEARNED;
            break;
        case REMOVE:
            type = PiTranslationEvent.Type.FORGOT;
            break;
        default:
            throw new IllegalArgumentException("Unknown event type " + event.type().name());
    }
    notifyDelegate(new PiTranslationEvent(type, event.value()));
}
#end_block

#method_before
@Override
public Type piEntityType() {
    return Type.GROUP;
}
#method_after
@Override
public PiEntityType piEntityType() {
    return PiEntityType.GROUP;
}
#end_block

#method_before
@Override
protected void execute() {
    FpmInfoService fpmInfo = get(FpmInfoService.class);
    if (fpmInfo.isPushRouteToQuaggaEnabled()) {
        print("Push routes to Quagga is enabled.");
    }
    fpmInfo.peers().entrySet().stream().sorted(Comparator.<Map.Entry<FpmPeer, FpmPeerInfo>, IpAddress>comparing(e -> e.getKey().address()).thenComparing(e -> e.getKey().port())).map(Map.Entry::getValue).forEach(this::print);
}
#method_after
@Override
protected void execute() {
    FpmInfoService fpmInfo = get(FpmInfoService.class);
    if (fpmInfo.isPdPushEnabled()) {
        print("PD Pushing is enabled/disbled.");
    }
    fpmInfo.peers().entrySet().stream().sorted(Comparator.<Map.Entry<FpmPeer, FpmPeerInfo>, IpAddress>comparing(e -> e.getKey().address()).thenComparing(e -> e.getKey().port())).map(Map.Entry::getValue).forEach(this::print);
}
#end_block

#method_before
@Before
public void setup() {
    manager = new DhcpRelayManager();
    manager.cfgService = createNiceMock(NetworkConfigRegistry.class);
    expect(manager.cfgService.getConfig(APP_ID, DefaultDhcpRelayConfig.class)).andReturn(CONFIG).anyTimes();
    expect(manager.cfgService.getConfig(APP_ID, IndirectDhcpRelayConfig.class)).andReturn(CONFIG_INDIRECT).anyTimes();
    manager.coreService = createNiceMock(CoreService.class);
    expect(manager.coreService.registerApplication(anyString())).andReturn(APP_ID).anyTimes();
    manager.hostService = createNiceMock(HostService.class);
    expect(manager.hostService.getHostsByIp(OUTER_RELAY_IP_V6)).andReturn(ImmutableSet.of(OUTER_RELAY_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(SERVER_IP)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(SERVER_IP_V6)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(GATEWAY_IP)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(GATEWAY_IP_V6)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(CLIENT_LL_IP_V6)).andReturn(ImmutableSet.of(EXISTS_HOST)).anyTimes();
    expect(manager.hostService.getHost(OUTER_RELAY_HOST_ID)).andReturn(OUTER_RELAY_HOST).anyTimes();
    packetService = new MockPacketService();
    manager.packetService = packetService;
    manager.compCfgService = createNiceMock(ComponentConfigService.class);
    deviceService = createNiceMock(DeviceService.class);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(deviceService.getDevice(DEV_2_ID)).andReturn(device).anyTimes();
    replay(deviceService, device);
    mockRouteStore = new MockRouteStore();
    mockDhcpRelayStore = new MockDhcpRelayStore();
    manager.dhcpRelayStore = mockDhcpRelayStore;
    manager.deviceService = deviceService;
    mockDhcpFpmPrefixStore = new MockDhcpFpmPrefixStore();
    // manager.distributedFpmPrefixStore = mockFpmPrefixStore;
    manager.interfaceService = new MockInterfaceService();
    flowObjectiveService = EasyMock.niceMock(FlowObjectiveService.class);
    mockHostProviderService = createNiceMock(HostProviderService.class);
    v4Handler = new Dhcp4HandlerImpl();
    v4Handler.providerService = mockHostProviderService;
    v4Handler.dhcpRelayStore = mockDhcpRelayStore;
    v4Handler.hostService = manager.hostService;
    v4Handler.interfaceService = manager.interfaceService;
    v4Handler.packetService = manager.packetService;
    v4Handler.routeStore = mockRouteStore;
    v4Handler.coreService = createNiceMock(CoreService.class);
    v4Handler.flowObjectiveService = flowObjectiveService;
    v4Handler.appId = TestApplicationId.create(Dhcp4HandlerImpl.DHCP_V4_RELAY_APP);
    v4Handler.deviceService = deviceService;
    manager.v4Handler = v4Handler;
    v6Handler = new Dhcp6HandlerImpl();
    v6Handler.dhcpRelayStore = mockDhcpRelayStore;
    v6Handler.hostService = manager.hostService;
    v6Handler.interfaceService = manager.interfaceService;
    v6Handler.packetService = manager.packetService;
    v6Handler.routeStore = mockRouteStore;
    v6Handler.providerService = mockHostProviderService;
    v6Handler.dhcpFpmPrefixStore = mockDhcpFpmPrefixStore;
    v6Handler.coreService = createNiceMock(CoreService.class);
    v6Handler.flowObjectiveService = flowObjectiveService;
    v6Handler.appId = TestApplicationId.create(Dhcp6HandlerImpl.DHCP_V6_RELAY_APP);
    v6Handler.deviceService = deviceService;
    manager.v6Handler = v6Handler;
    // properties
    Dictionary<String, Object> dictionary = createNiceMock(Dictionary.class);
    expect(dictionary.get("arpEnabled")).andReturn(true).anyTimes();
    ComponentContext context = createNiceMock(ComponentContext.class);
    expect(context.getProperties()).andReturn(dictionary).anyTimes();
    replay(manager.cfgService, manager.coreService, manager.hostService, manager.compCfgService, dictionary, context);
    manager.activate(context);
}
#method_after
@Before
public void setup() {
    manager = new DhcpRelayManager();
    manager.cfgService = createNiceMock(NetworkConfigRegistry.class);
    expect(manager.cfgService.getConfig(APP_ID, DefaultDhcpRelayConfig.class)).andReturn(CONFIG).anyTimes();
    expect(manager.cfgService.getConfig(APP_ID, IndirectDhcpRelayConfig.class)).andReturn(CONFIG_INDIRECT).anyTimes();
    manager.coreService = createNiceMock(CoreService.class);
    expect(manager.coreService.registerApplication(anyString())).andReturn(APP_ID).anyTimes();
    manager.hostService = createNiceMock(HostService.class);
    expect(manager.hostService.getHostsByIp(OUTER_RELAY_IP_V6)).andReturn(ImmutableSet.of(OUTER_RELAY_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(SERVER_IP)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(SERVER_IP_V6)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(GATEWAY_IP)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(GATEWAY_IP_V6)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(CLIENT_LL_IP_V6)).andReturn(ImmutableSet.of(EXISTS_HOST)).anyTimes();
    expect(manager.hostService.getHost(OUTER_RELAY_HOST_ID)).andReturn(OUTER_RELAY_HOST).anyTimes();
    packetService = new MockPacketService();
    manager.packetService = packetService;
    manager.compCfgService = createNiceMock(ComponentConfigService.class);
    deviceService = createNiceMock(DeviceService.class);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(deviceService.getDevice(DEV_2_ID)).andReturn(device).anyTimes();
    replay(deviceService, device);
    mockRouteStore = new MockRouteStore();
    mockDhcpRelayStore = new MockDhcpRelayStore();
    manager.dhcpRelayStore = mockDhcpRelayStore;
    manager.deviceService = deviceService;
    manager.interfaceService = new MockInterfaceService();
    flowObjectiveService = EasyMock.niceMock(FlowObjectiveService.class);
    mockHostProviderService = createNiceMock(HostProviderService.class);
    v4Handler = new Dhcp4HandlerImpl();
    v4Handler.providerService = mockHostProviderService;
    v4Handler.dhcpRelayStore = mockDhcpRelayStore;
    v4Handler.hostService = manager.hostService;
    v4Handler.interfaceService = manager.interfaceService;
    v4Handler.packetService = manager.packetService;
    v4Handler.routeStore = mockRouteStore;
    v4Handler.coreService = createNiceMock(CoreService.class);
    v4Handler.flowObjectiveService = flowObjectiveService;
    v4Handler.appId = TestApplicationId.create(Dhcp4HandlerImpl.DHCP_V4_RELAY_APP);
    v4Handler.deviceService = deviceService;
    manager.v4Handler = v4Handler;
    v6Handler = new Dhcp6HandlerImpl();
    v6Handler.dhcpRelayStore = mockDhcpRelayStore;
    v6Handler.hostService = manager.hostService;
    v6Handler.interfaceService = manager.interfaceService;
    v6Handler.packetService = manager.packetService;
    v6Handler.routeStore = mockRouteStore;
    v6Handler.providerService = mockHostProviderService;
    v6Handler.coreService = createNiceMock(CoreService.class);
    v6Handler.flowObjectiveService = flowObjectiveService;
    v6Handler.appId = TestApplicationId.create(Dhcp6HandlerImpl.DHCP_V6_RELAY_APP);
    v6Handler.deviceService = deviceService;
    manager.v6Handler = v6Handler;
    // properties
    Dictionary<String, Object> dictionary = createNiceMock(Dictionary.class);
    expect(dictionary.get("arpEnabled")).andReturn(true).anyTimes();
    ComponentContext context = createNiceMock(ComponentContext.class);
    expect(context.getProperties()).andReturn(dictionary).anyTimes();
    replay(manager.cfgService, manager.coreService, manager.hostService, manager.compCfgService, dictionary, context);
    manager.activate(context);
}
#end_block

#method_before
@Override
public Optional<Ip4Address> getRelayAgentIp4() {
    return Optional.ofNullable(relayAgentIp);
}
#method_after
@Override
public Optional<Ip4Address> getRelayAgentIp4(DeviceId deviceId) {
    return Optional.ofNullable(this.relayAgentIps.get(deviceId).getLeft());
}
#end_block

#method_before
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Interface serverInterface = directConnFlag ? getServerInterface() : getIndirectServerInterface();
    if (serverInterface == null) {
        log.warn("Can't get {} server interface, ignore", directConnFlag ? "direct" : "indirect");
        return null;
    }
    Ip6Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP v6 address for server Interface {}", serverInterface);
        return null;
    }
    Ethernet etherReply = clientPacket.duplicate();
    etherReply.setSourceMACAddress(macFacingServer);
    if ((directConnFlag && this.dhcpConnectMac == null) || !directConnFlag && this.indirectDhcpConnectMac == null && this.dhcpConnectMac == null) {
        log.warn("Packet received from {} connected client.", directConnFlag ? "directly" : "indirectly");
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP packet processing from client on port: {}", (this.dhcpGatewayIp == null) ? "server IP " + this.dhcpServerIp : "gateway IP " + this.dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (this.dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point direct {} directConn {} indirectConn {} is not set up yet", directConnFlag, this.dhcpServerConnectPoint, this.indirectDhcpServerConnectPoint);
        return null;
    }
    etherReply.setDestinationMACAddress(this.dhcpConnectMac);
    etherReply.setVlanID(this.dhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(ipFacingServer.toOctets());
    ipv6Packet.setDestinationAddress(this.dhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    removeHostOrRoute(directConnFlag, dhcp6Packet, clientPacket, clientIpv6, clientInterface);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (this.indirectDhcpServerIp == null) {
            log.warn("indirect DhcpServerIp not available, use default DhcpServerIp {}", HexString.toHexString(this.dhcpServerIp.toOctets()));
        } else {
            // Check if mac is obtained for valid server ip
            if (this.indirectDhcpConnectMac == null) {
                log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.indirectDhcpGatewayIp == null) ? "server IP " + this.indirectDhcpServerIp : "gateway IP " + this.indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
                return null;
            }
            etherReply.setDestinationMACAddress(this.indirectDhcpConnectMac);
            etherReply.setVlanID(this.indirectDhcpConnectVlan.toShort());
            ipv6Packet.setDestinationAddress(this.indirectDhcpServerIp.toOctets());
        }
        if (this.indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.warn("indirect connection: relayAgentIp NOT availale from config file! Use dynamic. {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(this.indirectRelayAgentIpFromCfg.toOctets());
            log.debug("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(this.indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // peer address:  address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<Dhcp6Option>();
    // directly connected case, hop count is zero. otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString() + ":";
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (clientPacket.getVlanID() & 0xff);
    vlanIdBytes[1] = (byte) ((clientPacket.getVlanID() >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    log.debug("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} vlan {}", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length, vlanIdBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    ipv6Packet.setHopLimit((byte) 64);
    etherReply.setPayload(ipv6Packet);
    if (directConnFlag) {
        return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
    } else {
        if (this.indirectDhcpServerIp == null) {
            return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
        } else {
            return new InternalPacket(etherReply, this.indirectDhcpServerConnectPoint);
        }
    }
}
#method_after
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    DhcpServerInfo serverInfo;
    Ip6Address dhcpServerIp = null;
    ConnectPoint dhcpServerConnectPoint = null;
    MacAddress dhcpConnectMac = null;
    VlanId dhcpConnectVlan = null;
    Ip6Address dhcpGatewayIp = null;
    Ip6Address indirectDhcpServerIp = null;
    ConnectPoint indirectDhcpServerConnectPoint = null;
    MacAddress indirectDhcpConnectMac = null;
    VlanId indirectDhcpConnectVlan = null;
    Ip6Address indirectDhcpGatewayIp = null;
    Ip6Address indirectRelayAgentIpFromCfg = null;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        indirectDhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        indirectRelayAgentIpFromCfg = serverInfo.getRelayAgentIp6(receivedFromDevice).orElse(null);
    }
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Interface serverInterface = directConnFlag ? getServerInterface() : getIndirectServerInterface();
    if (serverInterface == null) {
        log.warn("Can't get {} server interface, ignore", directConnFlag ? "direct" : "indirect");
        return null;
    }
    Ip6Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP v6 address for server Interface {}", serverInterface);
        return null;
    }
    Ethernet etherReply = clientPacket.duplicate();
    etherReply.setSourceMACAddress(macFacingServer);
    if ((directConnFlag && dhcpConnectMac == null) || !directConnFlag && indirectDhcpConnectMac == null && dhcpConnectMac == null) {
        log.warn("Packet received from {} connected client.", directConnFlag ? "directly" : "indirectly");
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP packet processing from client on port: {}", (dhcpGatewayIp == null) ? "server IP " + dhcpServerIp : "gateway IP " + dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point direct {} directConn {} indirectConn {} is not set up yet", directConnFlag, dhcpServerConnectPoint, indirectDhcpServerConnectPoint);
        return null;
    }
    etherReply.setDestinationMACAddress(dhcpConnectMac);
    etherReply.setVlanID(dhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(ipFacingServer.toOctets());
    ipv6Packet.setDestinationAddress(dhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    removeHostOrRoute(directConnFlag, dhcp6Packet, clientPacket, clientIpv6, clientInterface);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (indirectDhcpServerIp == null) {
            log.warn("indirect DhcpServerIp not available, use default DhcpServerIp {}", HexString.toHexString(dhcpServerIp.toOctets()));
        } else {
            // Check if mac is obtained for valid server ip
            if (indirectDhcpConnectMac == null) {
                log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (indirectDhcpGatewayIp == null) ? "server IP " + indirectDhcpServerIp : "gateway IP " + indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
                return null;
            }
            etherReply.setDestinationMACAddress(indirectDhcpConnectMac);
            etherReply.setVlanID(indirectDhcpConnectVlan.toShort());
            ipv6Packet.setDestinationAddress(indirectDhcpServerIp.toOctets());
        }
        if (indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.warn("indirect connection: relayAgentIp NOT availale from config file! Use dynamic. {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(indirectRelayAgentIpFromCfg.toOctets());
            log.debug("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // peer address: address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<>();
    // directly connected case, hop count is zero; otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString() + ":";
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (clientPacket.getVlanID() & 0xff);
    vlanIdBytes[1] = (byte) ((clientPacket.getVlanID() >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    log.debug("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} vlan {}", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length, vlanIdBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    ipv6Packet.setHopLimit((byte) 64);
    etherReply.setPayload(ipv6Packet);
    if (directConnFlag || indirectDhcpServerIp == null) {
        return new InternalPacket(etherReply, dhcpServerConnectPoint);
    } else {
        return new InternalPacket(etherReply, indirectDhcpServerConnectPoint);
    }
}
#end_block

#method_before
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    // get dhcp6 header.
    Ethernet etherReply = receivedPacket.duplicate();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = directlyConnected(dhcp6Relay);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if ((directConnFlag || (!directConnFlag && this.indirectDhcpServerIp == null)) && !inPort.equals(this.dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for direct or indirect-null", inPort, this.dhcpServerConnectPoint);
        return null;
    }
    if (!directConnFlag && this.indirectDhcpServerIp != null && !inPort.equals(this.indirectDhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for indirect", inPort, this.indirectDhcpServerConnectPoint);
        return null;
    }
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId vlanIdInUse = VlanId.vlanId(interfaceIdOption.getVlanId());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot get client interface for from packet, abort... vlan {}", vlanIdInUse.toString());
        return null;
    }
    MacAddress relayAgentMac = clientInterface.mac();
    if (relayAgentMac == null) {
        log.warn("Can not get interface mac, abort packet..");
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac = null;
    Ip6Address peerAddress = Ip6Address.valueOf(dhcp6Relay.getPeerAddress());
    Set<Host> clients = hostService.getHostsByIp(peerAddress);
    if (clients.isEmpty()) {
        log.warn("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.warn("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            return null;
        }
        log.warn("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    // add host or route
    addHostOrRoute(directConnFlag, dhcp6Relay, embeddedDhcp6, clientMac, clientInterface);
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#method_after
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    // TODO: refactor
    DhcpServerInfo serverInfo;
    Ip6Address dhcpServerIp = null;
    ConnectPoint dhcpServerConnectPoint = null;
    MacAddress dhcpConnectMac = null;
    VlanId dhcpConnectVlan = null;
    Ip6Address dhcpGatewayIp = null;
    Ip6Address indirectDhcpServerIp = null;
    ConnectPoint indirectDhcpServerConnectPoint = null;
    MacAddress indirectDhcpConnectMac = null;
    VlanId indirectDhcpConnectVlan = null;
    Ip6Address indirectDhcpGatewayIp = null;
    Ip6Address indirectRelayAgentIpFromCfg = null;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        indirectDhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        indirectRelayAgentIpFromCfg = serverInfo.getRelayAgentIp6(receivedFromDevice).orElse(null);
    }
    // get dhcp6 header.
    Ethernet etherReply = receivedPacket.duplicate();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = directlyConnected(dhcp6Relay);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if ((directConnFlag || (!directConnFlag && indirectDhcpServerIp == null)) && !inPort.equals(dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for direct or indirect-null", inPort, dhcpServerConnectPoint);
        return null;
    }
    if (!directConnFlag && indirectDhcpServerIp != null && !inPort.equals(indirectDhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for indirect", inPort, indirectDhcpServerConnectPoint);
        return null;
    }
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId vlanIdInUse = VlanId.vlanId(interfaceIdOption.getVlanId());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot get client interface for from packet, abort... vlan {}", vlanIdInUse.toString());
        return null;
    }
    MacAddress relayAgentMac = clientInterface.mac();
    if (relayAgentMac == null) {
        log.warn("Can not get interface mac, abort packet..");
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac = null;
    Ip6Address peerAddress = Ip6Address.valueOf(dhcp6Relay.getPeerAddress());
    Set<Host> clients = hostService.getHostsByIp(peerAddress);
    if (clients.isEmpty()) {
        log.warn("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.warn("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            return null;
        }
        log.warn("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    // add host or route
    addHostOrRoute(directConnFlag, dhcp6Relay, embeddedDhcp6, clientMac, clientInterface);
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#end_block

#method_before
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    setDhcpServerConfigs(configs, defaultServerInfoList);
    reloadServerSettings();
}
#method_after
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    setDhcpServerConfigs(configs, defaultServerInfoList);
}
#end_block

#method_before
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    setDhcpServerConfigs(configs, indirectServerInfoList);
    reloadServerSettings();
}
#method_after
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    setDhcpServerConfigs(configs, indirectServerInfoList);
}
#end_block

#method_before
private void hostUpdated(Host host) {
    hostUpdated(host, defaultServerInfoList);
    hostUpdated(host, indirectServerInfoList);
    reloadServerSettings();
}
#method_after
private void hostUpdated(Host host) {
    hostUpdated(host, defaultServerInfoList);
    hostUpdated(host, indirectServerInfoList);
}
#end_block

#method_before
private void hostRemoved(Host host) {
    hostRemoved(host, defaultServerInfoList);
    hostRemoved(host, indirectServerInfoList);
    reloadServerSettings();
}
#method_after
private void hostRemoved(Host host) {
    hostRemoved(host, defaultServerInfoList);
    hostRemoved(host, indirectServerInfoList);
}
#end_block

#method_before
private Interface getServerInterface() {
    if (dhcpServerConnectPoint == null || dhcpConnectVlan == null) {
        return null;
    }
    return interfaceService.getInterfacesByPort(dhcpServerConnectPoint).stream().filter(iface -> interfaceContainsVlan(iface, dhcpConnectVlan)).findFirst().orElse(null);
}
#method_after
private Interface getServerInterface() {
    DhcpServerInfo serverInfo;
    ConnectPoint dhcpServerConnectPoint;
    VlanId dhcpConnectVlan;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    } else {
        return null;
    }
    if (dhcpServerConnectPoint == null || dhcpConnectVlan == null) {
        log.info("Default DHCP server {} not resolve yet", serverInfo.getDhcpGatewayIp6());
        return null;
    }
    return interfaceService.getInterfacesByPort(dhcpServerConnectPoint).stream().filter(iface -> interfaceContainsVlan(iface, dhcpConnectVlan)).findFirst().orElse(null);
}
#end_block

#method_before
private Interface getIndirectServerInterface() {
    if (indirectDhcpServerConnectPoint == null || indirectDhcpConnectVlan == null) {
        return getServerInterface();
    }
    return interfaceService.getInterfacesByPort(indirectDhcpServerConnectPoint).stream().filter(iface -> interfaceContainsVlan(iface, indirectDhcpConnectVlan)).findFirst().orElse(null);
}
#method_after
private Interface getIndirectServerInterface() {
    DhcpServerInfo serverInfo;
    ConnectPoint indirectDhcpServerConnectPoint;
    VlanId indirectDhcpConnectVlan;
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    } else {
        return getServerInterface();
    }
    if (indirectDhcpServerConnectPoint == null || indirectDhcpConnectVlan == null) {
        log.info("Indirect DHCP server {} not resolve yet", serverInfo.getDhcpGatewayIp6());
        return null;
    }
    return interfaceService.getInterfacesByPort(indirectDhcpServerConnectPoint).stream().filter(iface -> interfaceContainsVlan(iface, indirectDhcpConnectVlan)).findFirst().orElse(null);
}
#end_block

#method_before
/**
 * * Add a dhcp fpm entry.
 * *
 * * @param prefix the route prefix in the advertisement
 * * @param fpmRecord the route for fpm
 */
public void addFpmRecord(IpPrefix prefix, FpmRecord fpmRecord) {
    checkNotNull(prefix, "Prefix can't be null");
    checkNotNull(fpmRecord, "Fpm record can't be null");
    dhcpFpmRecords.put(prefix, fpmRecord);
}
#method_after
public void addFpmRecord(IpPrefix prefix, FpmRecord fpmRecord) {
    checkNotNull(prefix, "Prefix can't be null");
    checkNotNull(fpmRecord, "Fpm record can't be null");
    dhcpFpmRecords.put(prefix, fpmRecord);
}
#end_block

#method_before
/**
 * * Remove a dhcp fpm entry.
 * *
 * * @param prefix the route prefix in the advertisement
 * * @return none
 */
public Optional<FpmRecord> removeFpmRecord(IpPrefix prefix) {
    checkNotNull(prefix, "Prefix can't be null");
    return Optional.ofNullable(dhcpFpmRecords.remove(prefix));
}
#method_after
public Optional<FpmRecord> removeFpmRecord(IpPrefix prefix) {
    checkNotNull(prefix, "Prefix can't be null");
    return Optional.ofNullable(dhcpFpmRecords.remove(prefix));
}
#end_block

#method_before
@Modified
protected void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    if (properties == null) {
        return;
    }
    String strClearRoutes = Tools.get(properties, "clearRoutes");
    if (strClearRoutes != null) {
        clearRoutes = Boolean.parseBoolean(strClearRoutes);
        log.info("clearRoutes set to {}", clearRoutes);
    }
    String strPushRouteToQuaggaEnabled = Tools.get(properties, "pushRouteToQuaggaEnabled");
    if (strPushRouteToQuaggaEnabled != null) {
        boolean oldValue = pushRouteToQuaggaEnabled;
        pushRouteToQuaggaEnabled = Boolean.parseBoolean(strPushRouteToQuaggaEnabled);
        if (pushRouteToQuaggaEnabled && !oldValue) {
            log.info("PD pushing to Quagga is enabled.");
            processStaticRoutes();
        }
        if (!pushRouteToQuaggaEnabled && oldValue) {
            log.info("PD pushing to Quagga is disabled.");
        }
    }
}
#method_after
@Modified
protected void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    if (properties == null) {
        return;
    }
    String strClearRoutes = Tools.get(properties, "clearRoutes");
    if (strClearRoutes != null) {
        clearRoutes = Boolean.parseBoolean(strClearRoutes);
        log.info("clearRoutes is {}", clearRoutes);
    }
    String strPdPushEnabled = Tools.get(properties, "pdPushEnabled");
    if (strPdPushEnabled != null) {
        boolean oldValue = pdPushEnabled;
        pdPushEnabled = Boolean.parseBoolean(strPdPushEnabled);
        if (pdPushEnabled) {
            pdPushNextHopIPv4 = null;
            pdPushNextHopIPv6 = null;
            String strPdPushNextHopIPv4 = Tools.get(properties, "pdPushNextHopIPv4");
            if (strPdPushNextHopIPv4 != null) {
                pdPushNextHopIPv4 = Ip4Address.valueOf(strPdPushNextHopIPv4);
            }
            String strPdPushNextHopIPv6 = Tools.get(properties, "pdPushNextHopIPv6");
            if (strPdPushNextHopIPv6 != null) {
                pdPushNextHopIPv6 = Ip6Address.valueOf(strPdPushNextHopIPv6);
            }
            if (pdPushNextHopIPv4 == null) {
                pdPushNextHopIPv4 = interfaceService.getInterfaces().stream().filter(iface -> iface.name().contains("RUR")).map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
            }
            if (pdPushNextHopIPv6 == null) {
                pdPushNextHopIPv6 = interfaceService.getInterfaces().stream().filter(iface -> iface.name().contains("RUR")).map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp6).map(IpAddress::getIp6Address).findFirst().orElse(null);
            }
            log.info("PD pushing is enabled.");
            if (pdPushNextHopIPv4 != null) {
                log.info("ipv4 next-hop {}", pdPushNextHopIPv4.toString());
            } else {
                log.info("ipv4 next-hop is null");
            }
            if (pdPushNextHopIPv6 != null) {
                log.info("ipv6 next-hop={}", pdPushNextHopIPv6.toString());
            } else {
                log.info("ipv6 next-hop is null");
            }
            if (!oldValue) {
                processStaticRoutes();
            }
        } else {
            log.info("PD pushing is disabled.");
        }
    }
}
#end_block

#method_before
private void processRipStaticRoutes(Channel ch) {
    /* Get RIP static routes. */
    if (ripStore != null) {
        Collection<FpmRecord> ripRecords = ripStore.getFpmRecords();
        log.info("RIP store size is {}", ripRecords.size());
        ripRecords.forEach(record -> sendRouteUpdateToChannel(true, record.ipPrefix(), record.nextHop(), ch));
    }
}
#method_after
private void processRipStaticRoutes(Channel ch) {
    /* Get RIP static routes. */
    if (ripStore != null) {
        Collection<FpmRecord> ripRecords = ripStore.getFpmRecords();
        log.info("RIP store size is {}", ripRecords.size());
        ripRecords.forEach(record -> sendRouteUpdateToChannel(true, record.ipPrefix(), ch));
    }
}
#end_block

#method_before
private void processDhcpStaticRoutes(Channel ch) {
    /* Get Dhcp static routes. */
    if (dhcpStore != null) {
        Collection<FpmRecord> dhcpRecords = dhcpStore.getFpmRecords();
        log.info("Dhcp store size is {}", dhcpRecords.size());
        dhcpRecords.forEach(record -> sendRouteUpdateToChannel(true, record.ipPrefix(), record.nextHop(), ch));
    }
}
#method_after
private void processDhcpStaticRoutes(Channel ch) {
    /* Get Dhcp static routes. */
    if (dhcpStore != null) {
        Collection<FpmRecord> dhcpRecords = dhcpStore.getFpmRecords();
        log.info("Dhcp store size is {}", dhcpRecords.size());
        dhcpRecords.forEach(record -> sendRouteUpdateToChannel(true, record.ipPrefix(), ch));
    }
}
#end_block

#method_before
private void sendRouteUpdateToChannel(boolean isAdd, IpPrefix prefix, IpAddress nextHop, Channel ch) {
    int netLinkLength;
    short addrFamily;
    if (!pushRouteToQuaggaEnabled) {
        log.trace("Push static route to Quagga is disabled.");
        return;
    }
    try {
        // Construct list of route attributes.
        List<RouteAttribute> attributes = new ArrayList<>();
        if (prefix.isIp4()) {
            netLinkLength = Ip4Address.BYTE_LENGTH + RouteAttribute.ROUTE_ATTRIBUTE_HEADER_LENGTH;
            addrFamily = RtNetlink.RT_ADDRESS_FAMILY_INET;
        } else {
            netLinkLength = Ip6Address.BYTE_LENGTH + RouteAttribute.ROUTE_ATTRIBUTE_HEADER_LENGTH;
            addrFamily = RtNetlink.RT_ADDRESS_FAMILY_INET6;
        }
        RouteAttributeDst raDst = new RouteAttributeDst(netLinkLength, RouteAttribute.RTA_DST, prefix.address());
        attributes.add(raDst);
        RouteAttributeGateway raGateway = new RouteAttributeGateway(netLinkLength, RouteAttribute.RTA_GATEWAY, nextHop);
        attributes.add(raGateway);
        // Add RtNetlink header.
        int srcLength = 0;
        short tos = 0;
        short table = 0;
        short scope = 0;
        long rtFlags = 0;
        int messageLength = raDst.length() + raGateway.length() + RtNetlink.RT_NETLINK_LENGTH;
        RtNetlink rtNetlink = new RtNetlink(addrFamily, prefix.prefixLength(), srcLength, tos, table, RtProtocol.ZEBRA, scope, FpmHeader.FPM_TYPE_NETLINK, rtFlags, attributes);
        // Add Netlink header.
        NetlinkMessageType nlMsgType;
        if (isAdd) {
            nlMsgType = NetlinkMessageType.RTM_NEWROUTE;
        } else {
            nlMsgType = NetlinkMessageType.RTM_DELROUTE;
        }
        int flags = Netlink.NETLINK_REQUEST | Netlink.NETLINK_CREATE;
        long sequence = 0;
        long processPortId = 0;
        messageLength += Netlink.NETLINK_HEADER_LENGTH;
        Netlink netLink = new Netlink(messageLength, nlMsgType, flags, sequence, processPortId, rtNetlink);
        messageLength += FpmHeader.FPM_HEADER_LENGTH;
        // Add FpmHeader.
        FpmHeader fpmMessage = new FpmHeader(FpmHeader.FPM_VERSION_1, FpmHeader.FPM_TYPE_NETLINK, messageLength, netLink);
        // Encode message in a channel buffer and transmit.
        ch.write(fpmMessage.encode());
    } catch (RuntimeException e) {
        log.info("Route not sent over fpm connection.");
    }
}
#method_after
private void sendRouteUpdateToChannel(boolean isAdd, IpPrefix prefix, Channel ch) {
    int netLinkLength;
    short addrFamily;
    IpAddress pdPushNextHop;
    if (!pdPushEnabled) {
        return;
    }
    try {
        // Construct list of route attributes.
        List<RouteAttribute> attributes = new ArrayList<>();
        if (prefix.isIp4()) {
            if (pdPushNextHopIPv4 == null) {
                log.info("Prefix not pushed because ipv4 next-hop is null.");
                return;
            }
            pdPushNextHop = pdPushNextHopIPv4;
            netLinkLength = Ip4Address.BYTE_LENGTH + RouteAttribute.ROUTE_ATTRIBUTE_HEADER_LENGTH;
            addrFamily = RtNetlink.RT_ADDRESS_FAMILY_INET;
        } else {
            if (pdPushNextHopIPv6 == null) {
                log.info("Prefix not pushed because ipv6 next-hop is null.");
                return;
            }
            pdPushNextHop = pdPushNextHopIPv6;
            netLinkLength = Ip6Address.BYTE_LENGTH + RouteAttribute.ROUTE_ATTRIBUTE_HEADER_LENGTH;
            addrFamily = RtNetlink.RT_ADDRESS_FAMILY_INET6;
        }
        RouteAttributeDst raDst = new RouteAttributeDst(netLinkLength, RouteAttribute.RTA_DST, prefix.address());
        attributes.add(raDst);
        RouteAttributeGateway raGateway = new RouteAttributeGateway(netLinkLength, RouteAttribute.RTA_GATEWAY, pdPushNextHop);
        attributes.add(raGateway);
        // Add RtNetlink header.
        int srcLength = 0;
        short tos = 0;
        short table = 0;
        short scope = 0;
        long rtFlags = 0;
        int messageLength = raDst.length() + raGateway.length() + RtNetlink.RT_NETLINK_LENGTH;
        RtNetlink rtNetlink = new RtNetlink(addrFamily, prefix.prefixLength(), srcLength, tos, table, RtProtocol.ZEBRA, scope, FpmHeader.FPM_TYPE_NETLINK, rtFlags, attributes);
        // Add Netlink header.
        NetlinkMessageType nlMsgType;
        if (isAdd) {
            nlMsgType = NetlinkMessageType.RTM_NEWROUTE;
        } else {
            nlMsgType = NetlinkMessageType.RTM_DELROUTE;
        }
        int flags = Netlink.NETLINK_REQUEST | Netlink.NETLINK_CREATE;
        long sequence = 0;
        long processPortId = 0;
        messageLength += Netlink.NETLINK_HEADER_LENGTH;
        Netlink netLink = new Netlink(messageLength, nlMsgType, flags, sequence, processPortId, rtNetlink);
        messageLength += FpmHeader.FPM_HEADER_LENGTH;
        // Add FpmHeader.
        FpmHeader fpmMessage = new FpmHeader(FpmHeader.FPM_VERSION_1, FpmHeader.FPM_TYPE_NETLINK, messageLength, netLink);
        // Encode message in a channel buffer and transmit.
        ch.write(fpmMessage.encode());
    } catch (RuntimeException e) {
        log.info("Route not sent over fpm connection.");
    }
}
#end_block

#method_before
private void sendRouteUpdate(boolean isAdd, IpPrefix prefix, IpAddress nextHop) {
    for (Channel ch : allChannels) {
        sendRouteUpdateToChannel(isAdd, prefix, nextHop, ch);
    }
}
#method_after
private void sendRouteUpdate(boolean isAdd, IpPrefix prefix) {
    for (Channel ch : allChannels) {
        sendRouteUpdateToChannel(isAdd, prefix, ch);
    }
}
#end_block

#method_before
@Override
public void notify(FpmPrefixStoreEvent e) {
    log.trace("FpmPrefixStoreEvent notify");
    FpmRecord record = e.subject();
    switch(e.type()) {
        case ADD:
            sendRouteUpdate(true, record.ipPrefix(), record.nextHop());
            break;
        case REMOVE:
            sendRouteUpdate(false, record.ipPrefix(), record.nextHop());
            break;
        default:
            log.warn("unsupported store event type", e.type());
            return;
    }
}
#method_after
@Override
public void notify(FpmPrefixStoreEvent e) {
    log.trace("FpmPrefixStoreEvent notify");
    FpmRecord record = e.subject();
    switch(e.type()) {
        case ADD:
            sendRouteUpdate(true, record.ipPrefix());
            break;
        case REMOVE:
            sendRouteUpdate(false, record.ipPrefix());
            break;
        default:
            log.warn("unsupported store event type", e.type());
            return;
    }
}
#end_block

#method_before
private Ethernet processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = ethernetPacket.duplicate();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    VlanId dhcpConnectVlan = null;
    MacAddress dhcpConnectMac = null;
    Ip4Address dhcpServerIp = null;
    Ip4Address relayAgentIp = null;
    VlanId indirectDhcpConnectVlan = null;
    MacAddress indirectDhcpConnectMac = null;
    Ip4Address indirectDhcpServerIp = null;
    Ip4Address indirectRelayAgentIp = null;
    if (!defaultServerInfoList.isEmpty()) {
        DhcpServerInfo serverInfo = defaultServerInfoList.get(0);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp4().orElse(null);
        relayAgentIp = serverInfo.getRelayAgentIp4().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        DhcpServerInfo indirectServerInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectVlan = indirectServerInfo.getDhcpConnectVlan().orElse(null);
        indirectDhcpConnectMac = indirectServerInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpServerIp = indirectServerInfo.getDhcpServerIp4().orElse(null);
        indirectRelayAgentIp = indirectServerInfo.getRelayAgentIp4().orElse(null);
    }
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    boolean isDirectlyConnected = directlyConnected(dhcpPacket);
    Interface serverInterface = isDirectlyConnected ? getDefaultServerInterface() : getIndirectServerInterface();
    if (serverInterface == null) {
        log.warn("Can't get {} server interface, ignore", isDirectlyConnected ? "direct" : "indirect");
        return null;
    }
    Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP address for server Interface {}", serverInterface);
        return null;
    }
    if (dhcpConnectMac == null) {
        log.warn("DHCP Server/Gateway IP not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", context.inPacket().receivedFrom());
        return null;
    }
    etherReply.setSourceMACAddress(macFacingServer);
    ipv4Packet.setSourceAddress(ipFacingServer.toInt());
    if (isDirectlyConnected) {
        etherReply.setDestinationMACAddress(dhcpConnectMac);
        etherReply.setVlanID(dhcpConnectVlan.toShort());
        ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
        ConnectPoint inPort = context.inPacket().receivedFrom();
        VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
        // add connected in port and vlan
        CircuitId cid = new CircuitId(inPort.toString(), vlanId);
        byte[] circuitId = cid.serialize();
        DhcpOption circuitIdSubOpt = new DhcpOption();
        circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
        DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
        newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
        newRelayAgentOpt.addSubOption(circuitIdSubOpt);
        // Removes END option first
        List<DhcpOption> options = dhcpPacket.getOptions().stream().filter(opt -> opt.getCode() != OptionCode_END.getValue()).collect(Collectors.toList());
        // push relay agent option
        options.add(newRelayAgentOpt);
        // make sure option 255(End) is the last option
        DhcpOption endOption = new DhcpOption();
        endOption.setCode(OptionCode_END.getValue());
        options.add(endOption);
        dhcpPacket.setOptions(options);
        // Sets relay agent IP
        int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
        dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
    } else {
        if (indirectDhcpServerIp != null) {
            // Use indirect server config for indirect packets if configured
            etherReply.setDestinationMACAddress(indirectDhcpConnectMac);
            etherReply.setVlanID(indirectDhcpConnectVlan.toShort());
            ipv4Packet.setDestinationAddress(indirectDhcpServerIp.toInt());
            // Set giaddr if indirect relay agent IP is configured
            if (indirectRelayAgentIp != null) {
                dhcpPacket.setGatewayIPAddress(indirectRelayAgentIp.toInt());
            }
        } else {
            // Otherwise, use default server config for indirect packets
            etherReply.setDestinationMACAddress(dhcpConnectMac);
            etherReply.setVlanID(dhcpConnectVlan.toShort());
            ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
            // Set giaddr if direct relay agent IP is configured
            if (relayAgentIp != null) {
                dhcpPacket.setGatewayIPAddress(relayAgentIp.toInt());
            }
        }
    }
    // Remove broadcast flag
    dhcpPacket.setFlags((short) 0);
    udpPacket.setPayload(dhcpPacket);
    // As a DHCP relay, the source port should be server port( instead
    // of client port.
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
    ipv4Packet.setPayload(udpPacket);
    ipv4Packet.setTtl((byte) 64);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#method_after
private Ethernet processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    // get dhcp header.
    Ethernet etherReply = ethernetPacket.duplicate();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    // TODO: refactor
    VlanId dhcpConnectVlan = null;
    MacAddress dhcpConnectMac = null;
    Ip4Address dhcpServerIp = null;
    Ip4Address relayAgentIp = null;
    VlanId indirectDhcpConnectVlan = null;
    MacAddress indirectDhcpConnectMac = null;
    Ip4Address indirectDhcpServerIp = null;
    Ip4Address indirectRelayAgentIp = null;
    if (!defaultServerInfoList.isEmpty()) {
        DhcpServerInfo serverInfo = defaultServerInfoList.get(0);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp4().orElse(null);
        relayAgentIp = serverInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        DhcpServerInfo indirectServerInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectVlan = indirectServerInfo.getDhcpConnectVlan().orElse(null);
        indirectDhcpConnectMac = indirectServerInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpServerIp = indirectServerInfo.getDhcpServerIp4().orElse(null);
        indirectRelayAgentIp = indirectServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
    }
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    boolean isDirectlyConnected = directlyConnected(dhcpPacket);
    Interface serverInterface = isDirectlyConnected ? getDefaultServerInterface() : getIndirectServerInterface();
    if (serverInterface == null) {
        log.warn("Can't get {} server interface, ignore", isDirectlyConnected ? "direct" : "indirect");
        return null;
    }
    Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP address for server Interface {}", serverInterface);
        return null;
    }
    if (dhcpConnectMac == null) {
        log.warn("DHCP Server/Gateway IP not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", context.inPacket().receivedFrom());
        return null;
    }
    etherReply.setSourceMACAddress(macFacingServer);
    ipv4Packet.setSourceAddress(ipFacingServer.toInt());
    if (isDirectlyConnected) {
        etherReply.setDestinationMACAddress(dhcpConnectMac);
        etherReply.setVlanID(dhcpConnectVlan.toShort());
        ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
        ConnectPoint inPort = context.inPacket().receivedFrom();
        VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
        // add connected in port and vlan
        CircuitId cid = new CircuitId(inPort.toString(), vlanId);
        byte[] circuitId = cid.serialize();
        DhcpOption circuitIdSubOpt = new DhcpOption();
        circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
        DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
        newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
        newRelayAgentOpt.addSubOption(circuitIdSubOpt);
        // Removes END option first
        List<DhcpOption> options = dhcpPacket.getOptions().stream().filter(opt -> opt.getCode() != OptionCode_END.getValue()).collect(Collectors.toList());
        // push relay agent option
        options.add(newRelayAgentOpt);
        // make sure option 255(End) is the last option
        DhcpOption endOption = new DhcpOption();
        endOption.setCode(OptionCode_END.getValue());
        options.add(endOption);
        dhcpPacket.setOptions(options);
        // Sets relay agent IP
        int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
        dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
    } else {
        if (indirectDhcpServerIp != null) {
            // Use indirect server config for indirect packets if configured
            etherReply.setDestinationMACAddress(indirectDhcpConnectMac);
            etherReply.setVlanID(indirectDhcpConnectVlan.toShort());
            ipv4Packet.setDestinationAddress(indirectDhcpServerIp.toInt());
            // Set giaddr if indirect relay agent IP is configured
            if (indirectRelayAgentIp != null) {
                dhcpPacket.setGatewayIPAddress(indirectRelayAgentIp.toInt());
            }
        } else {
            // Otherwise, use default server config for indirect packets
            etherReply.setDestinationMACAddress(dhcpConnectMac);
            etherReply.setVlanID(dhcpConnectVlan.toShort());
            ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
            // Set giaddr if direct relay agent IP is configured
            if (relayAgentIp != null) {
                dhcpPacket.setGatewayIPAddress(relayAgentIp.toInt());
            }
        }
    }
    // Remove broadcast flag
    dhcpPacket.setFlags((short) 0);
    udpPacket.setPayload(dhcpPacket);
    // As a DHCP relay, the source port should be server port( instead
    // of client port.
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
    ipv4Packet.setPayload(udpPacket);
    ipv4Packet.setTtl((byte) 64);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#end_block

#method_before
/*@Argument(index = 0, name = "type",
            description = "Type of learned routes",
            required = true, multiValued = true)
    String type = null;*/
@Override
protected void execute() {
    /*if (type.equals("v4") || type.equals("[v4]")) {
            type = "v4";
        } else if (type.equals("v6") || type.equals("[v6]")) {
            type = "v6";
        } else if (type.equals("all") || type.equals("[all]")) {
            type = "all";
        } else {
            print("Invalid type entered %s\n", type);
            print("Available options are [v4|v6|all]]");
            return;
        }

        if (type.equals("v4")) {
            print("v4 FPM not supported yet");
            return;
        }

        if (type.equals("v6") || type.equals("all")) { */
    print("Dhcp Fpm Feature is %s !", DHCP_RELAY_SERVICE.isDhcpFpmEnabled() ? "enabled" : "disabled");
    print("\n");
    Collection<FpmRecord> records = DHCP_RELAY_SERVICE.getFpmRecords();
    if (records.isEmpty()) {
        print(NO_RECORDS);
        return;
    }
    print(HEADER);
    records.forEach(record -> print(ROUTE, record.ipPrefix(), record.nextHop()));
// }
}
#method_after
@Override
protected void execute() {
    print("Dhcp Fpm Feature is %s !", DHCP_RELAY_SERVICE.isDhcpFpmEnabled() ? "enabled" : "disabled");
    print("\n");
    Collection<FpmRecord> records = DHCP_RELAY_SERVICE.getFpmRecords();
    if (records.isEmpty()) {
        print(NO_RECORDS);
        return;
    }
    print(HEADER);
    records.forEach(record -> print(ROUTE, record.ipPrefix(), record.nextHop()));
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    // Basic application registrations.
    appId = coreService.registerApplication(APP_NAME);
    componentConfigService.registerProperties(getClass());
    // Packet processor for handling Router Solicitations
    processor = new InternalPacketProcessor();
    packetService.addProcessor(processor, PacketProcessor.director(3));
    // Setup global prefix loading components
    networkConfigRegistry.addListener(networkConfigListener);
    networkConfigRegistry.registerConfigFactory(deviceConfigFactory);
    loadGlobalPrefixConfig();
    // Setup pool and worker threads for existing interfaces
    setupPoolAndTxWorkers();
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    // Basic application registrations.
    appId = coreService.registerApplication(APP_NAME);
    componentConfigService.registerProperties(getClass());
    // Packet processor for handling Router Solicitations
    processor = new InternalPacketProcessor();
    packetService.addProcessor(processor, PacketProcessor.director(3));
    // Setup global prefix loading components
    networkConfigRegistry.addListener(networkConfigListener);
    networkConfigRegistry.registerConfigFactory(deviceConfigFactory);
    loadGlobalPrefixConfig();
    // Dynamic device updates handling
    deviceService.addListener(internalDeviceListener);
    // Setup pool and worker threads for existing interfaces
    setupPoolAndTxWorkers();
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    // Unregister resources.
    componentConfigService.unregisterProperties(getClass(), false);
    interfaceService.removeListener(interfaceListener);
    networkConfigRegistry.removeListener(networkConfigListener);
    networkConfigRegistry.unregisterConfigFactory(deviceConfigFactory);
    packetService.removeProcessor(processor);
    // Clear pool & threads
    clearPoolAndTxWorkers();
}
#method_after
@Deactivate
protected void deactivate() {
    // Unregister resources.
    componentConfigService.unregisterProperties(getClass(), false);
    interfaceService.removeListener(interfaceListener);
    networkConfigRegistry.removeListener(networkConfigListener);
    networkConfigRegistry.unregisterConfigFactory(deviceConfigFactory);
    packetService.removeProcessor(processor);
    deviceService.removeListener(internalDeviceListener);
    // Clear pool & threads
    clearPoolAndTxWorkers();
}
#end_block

#method_before
public void run() {
    // Router Advertisement header filling. Please refer RFC-2461.
    RouterAdvertisement ra = new RouterAdvertisement();
    ra.setCurrentHopLimit(RA_HOP_LIMIT);
    ra.setMFlag((byte) (raFlagMbitStatus ? 0x01 : 0x00));
    ra.setOFlag((byte) (raFlagObitStatus ? 0x01 : 0x00));
    ra.setRouterLifetime(RA_ROUTER_LIFETIME);
    ra.setReachableTime(0);
    ra.setRetransmitTimer(retransmitPeriod + RA_RETRANSMIT_CALIBRATION_PERIOD);
    // Option : Source link-layer address.
    byte[] optionBuffer = new byte[RA_OPTIONS_BUFFER_SIZE];
    ByteBuffer option = ByteBuffer.wrap(optionBuffer);
    Optional<MacAddress> macAddress = interfaceService.getInterfacesByPort(connectPoint).stream().map(Interface::mac).findFirst();
    if (!macAddress.isPresent()) {
        log.warn("Unable to retrieve interface {} MAC address. Terminating RA transmission.", connectPoint);
        return;
    }
    option.put(macAddress.get().toBytes());
    ra.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, Arrays.copyOfRange(option.array(), 0, option.position()));
    // Option : MTU.
    option.rewind();
    option.putShort((short) 0);
    option.putInt(RA_OPTION_MTU_VALUE);
    ra.addOption(NeighborDiscoveryOptions.TYPE_MTU, Arrays.copyOfRange(option.array(), 0, option.position()));
    // Option : Prefix information.
    if (raOptionPrefixStatus) {
        ipAddresses.stream().filter(i -> i.ipAddress().version().equals(IpAddress.Version.INET6)).forEach(i -> {
            option.rewind();
            option.put((byte) i.subnetAddress().prefixLength());
            // Enable "onlink" option only.
            option.put((byte) 0x80);
            option.putInt(RA_OPTION_PREFIX_VALID_LIFETIME);
            option.putInt(RA_OPTION_PREFIX_PREFERRED_LIFETIME);
            // Clear reserved fields
            option.putInt(0x00000000);
            option.put(IpAddress.makeMaskedAddress(i.ipAddress(), i.subnetAddress().prefixLength()).toOctets());
            ra.addOption(NeighborDiscoveryOptions.TYPE_PREFIX_INFORMATION, Arrays.copyOfRange(option.array(), 0, option.position()));
        });
    }
    // ICMPv6 header filling.
    ICMP6 icmpv6 = new ICMP6();
    icmpv6.setIcmpType(ICMP6.ROUTER_ADVERTISEMENT);
    icmpv6.setIcmpCode((byte) 0);
    icmpv6.setPayload(ra);
    // IPv6 header filling.
    byte[] ip6AllNodesAddress = Ip6Address.valueOf("ff02::1").toOctets();
    IPv6 ipv6 = new IPv6();
    ipv6.setDestinationAddress((solicitHostAddress == null) ? ip6AllNodesAddress : solicitHostAddress);
    /* RA packet L2 source address created from port MAC address.
             * Note : As per RFC-4861 RAs should be sent from link-local address.
             */
    ipv6.setSourceAddress(IPv6.getLinkLocalAddress(macAddress.get().toBytes()));
    ipv6.setNextHeader(IPv6.PROTOCOL_ICMP6);
    ipv6.setHopLimit(RA_HOP_LIMIT);
    ipv6.setTrafficClass((byte) 0xe0);
    ipv6.setPayload(icmpv6);
    // Ethernet header filling.
    Ethernet ethernet = new Ethernet();
    /* Ethernet IPv6 multicast address creation.
             * Refer : RFC 2624 section 7.
             */
    byte[] l2Ipv6MulticastAddress = MacAddress.IPV6_MULTICAST.toBytes();
    IntStream.range(1, 4).forEach(i -> l2Ipv6MulticastAddress[l2Ipv6MulticastAddress.length - i] = ip6AllNodesAddress[ip6AllNodesAddress.length - i]);
    // Provide unicast address for Solicit RA replays
    ethernet.setDestinationMACAddress((solicitHostMac == null) ? MacAddress.valueOf(l2Ipv6MulticastAddress) : solicitHostMac);
    ethernet.setSourceMACAddress(macAddress.get().toBytes());
    ethernet.setEtherType(EthType.EtherType.IPV6.ethType().toShort());
    ethernet.setVlanID(Ethernet.VLAN_UNTAGGED);
    ethernet.setPayload(ipv6);
    ethernet.setPad(false);
    // Flush out PACKET_OUT.
    ByteBuffer stream = ByteBuffer.wrap(ethernet.serialize());
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(connectPoint.port()).build();
    OutboundPacket packet = new DefaultOutboundPacket(connectPoint.deviceId(), treatment, stream);
    packetService.emit(packet);
}
#method_after
public void run() {
    // Router Advertisement header filling. Please refer RFC-2461.
    RouterAdvertisement ra = new RouterAdvertisement();
    ra.setCurrentHopLimit(RA_HOP_LIMIT);
    ra.setMFlag((byte) (raFlagMbitStatus ? 0x01 : 0x00));
    ra.setOFlag((byte) (raFlagObitStatus ? 0x01 : 0x00));
    ra.setRouterLifetime(RA_ROUTER_LIFETIME);
    ra.setReachableTime(0);
    ra.setRetransmitTimer(retransmitPeriod + RA_RETRANSMIT_CALIBRATION_PERIOD);
    // Option : Source link-layer address.
    byte[] optionBuffer = new byte[RA_OPTIONS_BUFFER_SIZE];
    ByteBuffer option = ByteBuffer.wrap(optionBuffer);
    Optional<MacAddress> macAddress = interfaceService.getInterfacesByPort(connectPoint).stream().map(Interface::mac).findFirst();
    if (!macAddress.isPresent()) {
        log.warn("Unable to retrieve interface {} MAC address. Terminating RA transmission.", connectPoint);
        return;
    }
    option.put(macAddress.get().toBytes());
    ra.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, Arrays.copyOfRange(option.array(), 0, option.position()));
    // Option : MTU.
    option.rewind();
    option.putShort((short) 0);
    option.putInt(RA_OPTION_MTU_VALUE);
    ra.addOption(NeighborDiscoveryOptions.TYPE_MTU, Arrays.copyOfRange(option.array(), 0, option.position()));
    // Option : Prefix information.
    if (raOptionPrefixStatus) {
        ipAddresses.stream().filter(i -> i.ipAddress().version().equals(IpAddress.Version.INET6)).forEach(i -> {
            option.rewind();
            option.put((byte) i.subnetAddress().prefixLength());
            // Enable "onlink" option only.
            option.put((byte) 0x80);
            option.putInt(RA_OPTION_PREFIX_VALID_LIFETIME);
            option.putInt(RA_OPTION_PREFIX_PREFERRED_LIFETIME);
            // Clear reserved fields
            option.putInt(0x00000000);
            option.put(IpAddress.makeMaskedAddress(i.ipAddress(), i.subnetAddress().prefixLength()).toOctets());
            ra.addOption(NeighborDiscoveryOptions.TYPE_PREFIX_INFORMATION, Arrays.copyOfRange(option.array(), 0, option.position()));
        });
    }
    // ICMPv6 header filling.
    ICMP6 icmpv6 = new ICMP6();
    icmpv6.setIcmpType(ICMP6.ROUTER_ADVERTISEMENT);
    icmpv6.setIcmpCode((byte) 0);
    icmpv6.setPayload(ra);
    // IPv6 header filling.
    byte[] ip6AllNodesAddress = Ip6Address.valueOf("ff02::1").toOctets();
    IPv6 ipv6 = new IPv6();
    ipv6.setDestinationAddress((solicitHostAddress == null) ? ip6AllNodesAddress : solicitHostAddress);
    /* RA packet L2 source address created from port MAC address.
             * Note : As per RFC-4861 RAs should be sent from link-local address.
             */
    ipv6.setSourceAddress(IPv6.getLinkLocalAddress(macAddress.get().toBytes()));
    ipv6.setNextHeader(IPv6.PROTOCOL_ICMP6);
    ipv6.setHopLimit(RA_HOP_LIMIT);
    ipv6.setTrafficClass((byte) 0xe0);
    ipv6.setPayload(icmpv6);
    // Ethernet header filling.
    Ethernet ethernet = new Ethernet();
    /* Ethernet IPv6 multicast address creation.
             * Refer : RFC 2624 section 7.
             */
    byte[] l2Ipv6MulticastAddress = MacAddress.IPV6_MULTICAST.toBytes();
    IntStream.range(1, 4).forEach(i -> l2Ipv6MulticastAddress[l2Ipv6MulticastAddress.length - i] = ip6AllNodesAddress[ip6AllNodesAddress.length - i]);
    // Provide unicast address for Solicit RA replays
    ethernet.setDestinationMACAddress((solicitHostMac == null) ? MacAddress.valueOf(l2Ipv6MulticastAddress) : solicitHostMac);
    ethernet.setSourceMACAddress(macAddress.get().toBytes());
    ethernet.setEtherType(EthType.EtherType.IPV6.ethType().toShort());
    ethernet.setVlanID(Ethernet.VLAN_UNTAGGED);
    ethernet.setPayload(ipv6);
    ethernet.setPad(false);
    // Flush out PACKET_OUT.
    ByteBuffer stream = ByteBuffer.wrap(ethernet.serialize());
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(connectPoint.port()).build();
    OutboundPacket packet = new DefaultOutboundPacket(connectPoint.deviceId(), treatment, stream);
    packetService.emit(packet);
    log.trace("Transmitted Unsolicited Router Advertisement on {}", connectPoint);
}
#end_block

#method_before
@Override
public void run() {
    // TODO : Validate Router Solicitation
    // Pause already running unsolicited RA threads in received connect point
    ConnectPoint connectPoint = packet.receivedFrom();
    List<InterfaceIpAddress> addresses = deactivateRouterAdvertisement(connectPoint);
    // Respond to Router Solicitation asynchronously and restore unsolicited RA
    try {
        Ethernet ethernet = packet.parsed();
        IPv6 ipv6 = (IPv6) ethernet.getPayload();
        RAWorkerThread worker = new RAWorkerThread(connectPoint, addresses, raThreadDelay, ethernet.getSourceMAC(), ipv6.getSourceAddress());
        CompletableFuture<Void> sraHandlerFuture = CompletableFuture.runAsync(worker, executors);
        CompletableFuture<Void> raRestoreFuture = sraHandlerFuture.thenRun(() -> activateRouterAdvertisement(connectPoint, addresses));
        raRestoreFuture.get();
    } catch (Exception e) {
        log.error("Failed to respond to router solicitation. {}", e);
    }
}
#method_after
@Override
public void run() {
    // TODO : Validate Router Solicitation
    // Pause already running unsolicited RA threads in received connect point
    ConnectPoint connectPoint = packet.receivedFrom();
    List<InterfaceIpAddress> addresses = deactivateRouterAdvertisement(connectPoint);
    /* Multicast RA(ie. Unsolicited RA) TX time is not preciously tracked so to make sure that
             * Unicast RA(ie. Router Solicitation Response) is TXed before Mulicast RA
             * logic adapted here is disable Mulicast RA, TX Unicast RA and then restore Multicast RA.
             */
    log.trace("Processing Router Solicitations from {}", connectPoint);
    try {
        Ethernet ethernet = packet.parsed();
        IPv6 ipv6 = (IPv6) ethernet.getPayload();
        RAWorkerThread worker = new RAWorkerThread(connectPoint, addresses, raThreadDelay, ethernet.getSourceMAC(), ipv6.getSourceAddress());
        // TODO : Estimate TX time as in RFC 4861, Section 6.2.6 and schedule TX based on it
        CompletableFuture<Void> sraHandlerFuture = CompletableFuture.runAsync(worker, executors);
        sraHandlerFuture.get();
    } catch (Exception e) {
        log.error("Failed to respond to router solicitation. {}", e);
    } finally {
        activateRouterAdvertisement(connectPoint, addresses);
        log.trace("Restored Unsolicited Router Advertisements on {}", connectPoint);
    }
}
#end_block

#method_before
public void forward(ForwardingObjective forwardObjective) {
    if (forwardObjective.flag() == ForwardingObjective.Flag.VERSATILE) {
        processVersatileFwd(forwardObjective);
    } else {
        processSpecificFwd(forwardObjective);
    }
}
#method_after
public PipelinerTranslationResult forward(ForwardingObjective forwardObjective) {
    PipelinerTranslationResult.Builder resultBuilder = PipelinerTranslationResult.builder();
    if (forwardObjective.flag() == ForwardingObjective.Flag.VERSATILE) {
        processVersatileFwd(forwardObjective, resultBuilder);
    } else {
        processSpecificFwd(forwardObjective, resultBuilder);
    }
    return resultBuilder.build();
}
#end_block

#method_before
private void processVersatileFwd(ForwardingObjective fwd) {
    // program ACL table only
    FlowRule flowRule = DefaultFlowRule.builder().withSelector(fwd.selector()).withTreatment(fwd.treatment()).forTable(FabricConstants.TBL_ACL_ID).withPriority(fwd.priority()).forDevice(deviceId).makePermanent().fromApp(fwd.appId()).build();
    flowRuleService.apply(buildFlowRuleOps(fwd, ImmutableList.of(flowRule)));
}
#method_after
private void processVersatileFwd(ForwardingObjective fwd, PipelinerTranslationResult.Builder resultBuilder) {
    // program ACL table only
    FlowRule flowRule = DefaultFlowRule.builder().withSelector(fwd.selector()).withTreatment(fwd.treatment()).forTable(FabricConstants.TBL_ACL_ID).withPriority(fwd.priority()).forDevice(deviceId).makePermanent().fromApp(fwd.appId()).build();
    resultBuilder.addFlowRule(flowRule);
}
#end_block

#method_before
private void processSpecificFwd(ForwardingObjective fwd) {
    // TODO:
    // L2 Broadcast
    // L3 Unicast
    // L3 Multicast
    // MPLS
    int criterionCombinationMatrix = 0;
    TrafficSelector selector = fwd.selector();
    Set<Criterion> criterions = selector.criteria();
    VlanIdCriterion vlanIdCriterion = null;
    EthCriterion ethDstCriterion = null;
    for (Criterion criterion : criterions) {
        switch(criterion.type()) {
            case ETH_DST:
                ethDstCriterion = (EthCriterion) criterion;
                criterionCombinationMatrix |= MTX_ETH_DST;
                break;
            case VLAN_VID:
                vlanIdCriterion = (VlanIdCriterion) criterion;
                criterionCombinationMatrix |= MTX_VLAN_ID;
                break;
            default:
                log.warn("Unsupported criterion {} to fwd", criterion);
                break;
        }
    }
    switch(criterionCombinationMatrix) {
        case MTX_BRIDGING_UNI:
            processL2UnicastRule(vlanIdCriterion, ethDstCriterion, fwd);
            break;
        default:
            log.warn("Unknown criterion combination {}", criterionCombinationMatrix);
            fail(fwd, ObjectiveError.UNSUPPORTED);
            break;
    }
}
#method_after
private void processSpecificFwd(ForwardingObjective fwd, PipelinerTranslationResult.Builder resultBuilder) {
    TrafficSelector selector = fwd.selector();
    TrafficSelector meta = fwd.meta();
    ImmutableSet.Builder<Criterion> criterionSetBuilder = ImmutableSet.builder();
    criterionSetBuilder.addAll(selector.criteria());
    if (meta != null) {
        criterionSetBuilder.addAll(meta.criteria());
    }
    Set<Criterion> criteria = criterionSetBuilder.build();
    VlanIdCriterion vlanIdCriterion = null;
    EthCriterion ethDstCriterion = null;
    for (Criterion criterion : criteria) {
        switch(criterion.type()) {
            case ETH_DST:
                ethDstCriterion = (EthCriterion) criterion;
                break;
            case VLAN_VID:
                vlanIdCriterion = (VlanIdCriterion) criterion;
                break;
            default:
                log.warn("Unsupported criterion {}", criterion);
                break;
        }
    }
    ForwardingFunctionType forwardingFunctionType = ForwardingFunctionType.getForwardingFunctionType(fwd);
    switch(forwardingFunctionType) {
        case L2_UNICAST:
            processL2UnicastRule(vlanIdCriterion, ethDstCriterion, fwd, resultBuilder);
            break;
        case L2_BROADCAST:
            processL2BroadcastRule(vlanIdCriterion, fwd, resultBuilder);
            break;
        case IPV4_UNICAST:
        case IPV4_MULTICAST:
        case IPV6_UNICAST:
        case IPV6_MULTICAST:
        case MPLS:
        default:
            log.warn("Unsupported forwarding function type {}", criteria);
            resultBuilder.setError(ObjectiveError.UNSUPPORTED);
            break;
    }
}
#end_block

#method_before
private void processL2UnicastRule(VlanIdCriterion vlanIdCriterion, EthCriterion ethDstCriterion, ForwardingObjective fwd) {
    if (fwd.nextId() == null) {
        fail(fwd, ObjectiveError.BADPARAMS);
        return;
    }
    VlanId vlanId = vlanIdCriterion.vlanId();
    MacAddress ethDst = ethDstCriterion.mac();
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(vlanId).matchEthDst(ethDst).build();
    TrafficTreatment treatment = buildSetNextIdTreatment(fwd.nextId());
    FlowRule flowRule = DefaultFlowRule.builder().withSelector(selector).withTreatment(treatment).fromApp(fwd.appId()).withPriority(fwd.priority()).makePermanent().forDevice(deviceId).forTable(FabricConstants.TBL_BRIDGING_ID).build();
    flowRuleService.apply(buildFlowRuleOps(fwd, ImmutableList.of(flowRule)));
}
#method_after
private void processL2UnicastRule(VlanIdCriterion vlanIdCriterion, EthCriterion ethDstCriterion, ForwardingObjective fwd, PipelinerTranslationResult.Builder resultBuilder) {
    checkNotNull(vlanIdCriterion, "VlanId criterion should not be null");
    checkNotNull(ethDstCriterion, "EthDst criterion should not be null");
    if (fwd.nextId() == null) {
        log.warn("Forwarding objective for L2 unicast should contains next id");
        resultBuilder.setError(ObjectiveError.BADPARAMS);
        return;
    }
    VlanId vlanId = vlanIdCriterion.vlanId();
    MacAddress ethDst = ethDstCriterion.mac();
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(vlanId).matchEthDst(ethDst).build();
    TrafficTreatment treatment = buildSetNextIdTreatment(fwd.nextId());
    FlowRule flowRule = DefaultFlowRule.builder().withSelector(selector).withTreatment(treatment).fromApp(fwd.appId()).withPriority(fwd.priority()).makePermanent().forDevice(deviceId).forTable(FabricConstants.TBL_BRIDGING_ID).build();
    resultBuilder.addFlowRule(flowRule);
}
#end_block

#method_before
@Before
public void setup() {
    flowRuleService = createNiceMock(FlowRuleService.class);
    groupService = createNiceMock(GroupService.class);
    flowObjectiveStore = createNiceMock(FlowObjectiveStore.class);
    pipeliner = new FabricPipeliner();
    ServiceDirectory serviceDirectory = createNiceMock(ServiceDirectory.class);
    expect(serviceDirectory.get(FlowRuleService.class)).andReturn(flowRuleService).anyTimes();
    expect(serviceDirectory.get(GroupService.class)).andReturn(groupService).anyTimes();
    expect(serviceDirectory.get(FlowObjectiveStore.class)).andReturn(flowObjectiveStore).anyTimes();
    PipelinerContext pipelinerContext = createNiceMock(PipelinerContext.class);
    expect(pipelinerContext.directory()).andReturn(serviceDirectory).anyTimes();
    replay(serviceDirectory, pipelinerContext);
    pipeliner.init(DEVICE_ID, pipelinerContext);
}
#method_after
@Before
public void setup() {
    pipeliner = new FabricPipeliner();
    ServiceDirectory serviceDirectory = createNiceMock(ServiceDirectory.class);
    PipelinerContext pipelinerContext = createNiceMock(PipelinerContext.class);
    expect(pipelinerContext.directory()).andReturn(serviceDirectory).anyTimes();
    replay(serviceDirectory, pipelinerContext);
    pipeliner.init(DEVICE_ID, pipelinerContext);
}
#end_block

#method_before
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.deviceId = deviceId;
    this.flowRuleService = context.directory().get(FlowRuleService.class);
    this.groupService = context.directory().get(GroupService.class);
    this.flowObjectiveStore = context.directory().get(FlowObjectiveStore.class);
    this.pipelinerFilter = new FabricFilteringPipeliner(deviceId, flowRuleService);
    this.pipelinerForward = new FabricForwardingPipeliner(deviceId, flowRuleService);
    this.pipelinerNext = new FabricNextPipeliner(deviceId, flowRuleService, flowObjectiveStore);
}
#method_after
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.deviceId = deviceId;
    this.flowRuleService = context.directory().get(FlowRuleService.class);
    this.groupService = context.directory().get(GroupService.class);
    this.flowObjectiveStore = context.directory().get(FlowObjectiveStore.class);
    this.pipelinerFilter = new FabricFilteringPipeliner(deviceId);
    this.pipelinerForward = new FabricForwardingPipeliner(deviceId);
    this.pipelinerNext = new FabricNextPipeliner(deviceId);
}
#end_block

#method_before
@Override
public void filter(FilteringObjective filterObjective) {
    pipelinerFilter.filter(filterObjective);
}
#method_after
@Override
public void filter(FilteringObjective filterObjective) {
    PipelinerTranslationResult result = pipelinerFilter.filter(filterObjective);
    if (result.error().isPresent()) {
        fail(filterObjective, result.error().get());
        return;
    }
    applyTranslationResult(filterObjective, result, success -> {
        if (success) {
            success(filterObjective);
        } else {
            fail(filterObjective, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    });
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective forwardObjective) {
    pipelinerForward.forward(forwardObjective);
}
#method_after
@Override
public void forward(ForwardingObjective forwardObjective) {
    PipelinerTranslationResult result = pipelinerForward.forward(forwardObjective);
    if (result.error().isPresent()) {
        fail(forwardObjective, result.error().get());
        return;
    }
    applyTranslationResult(forwardObjective, result, success -> {
        if (success) {
            success(forwardObjective);
        } else {
            fail(forwardObjective, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    });
}
#end_block

#method_before
@Override
public void next(NextObjective nextObjective) {
    pipelinerNext.next(nextObjective);
}
#method_after
@Override
public void next(NextObjective nextObjective) {
    PipelinerTranslationResult result = pipelinerNext.next(nextObjective);
    if (result.error().isPresent()) {
        fail(nextObjective, result.error().get());
        return;
    }
    applyTranslationResult(nextObjective, result, success -> {
        if (!success) {
            fail(nextObjective, ObjectiveError.GROUPINSTALLATIONFAILED);
            return;
        }
        // Success, put next group to objective store
        List<PortNumber> portNumbers = Lists.newArrayList();
        nextObjective.next().forEach(treatment -> {
            Instructions.OutputInstruction outputInst = treatment.allInstructions().stream().filter(inst -> inst.type() == Instruction.Type.OUTPUT).map(inst -> (Instructions.OutputInstruction) inst).findFirst().orElse(null);
            if (outputInst != null) {
                portNumbers.add(outputInst.port());
            }
        });
        FabricNextGroup nextGroup = new FabricNextGroup(nextObjective.type(), portNumbers);
        flowObjectiveStore.putNextGroup(nextObjective.id(), nextGroup);
        success(nextObjective);
    });
}
#end_block

#method_before
@Test
public void testAclArp() {
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().wipeDeferred().punt().build();
    // ARP
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_ARP).build();
    ForwardingObjective fwd = DefaultForwardingObjective.builder().withSelector(selector).withPriority(PRIORITY).fromApp(APP_ID).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withTreatment(treatment).add();
    Capture<FlowRuleOperations> captured = newCapture(CaptureType.ALL);
    flowRuleService.apply(capture(captured));
    expectLastCall().anyTimes();
    replay(flowRuleService);
    pipeliner.forward(fwd);
    verify(flowRuleService);
    List<FlowRuleOperations> capturedOpsList = captured.getValues();
    List<FlowRule> flowRulesInstalled = verifyFlowRuleOpsListAndGet(capturedOpsList, 1, 1);
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).forTable(FabricConstants.TBL_ACL_ID).withPriority(PRIORITY).makePermanent().withSelector(selector).withTreatment(treatment).fromApp(APP_ID).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
}
#method_after
@Test
public void testAclArp() {
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().wipeDeferred().punt().build();
    // ARP
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_ARP).build();
    ForwardingObjective fwd = DefaultForwardingObjective.builder().withSelector(selector).withPriority(PRIORITY).fromApp(APP_ID).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withTreatment(treatment).add();
    PipelinerTranslationResult result = pipeliner.pipelinerForward.forward(fwd);
    List<FlowRule> flowRulesInstalled = (List<FlowRule>) result.flowRules();
    List<GroupDescription> groupsInstalled = (List<GroupDescription>) result.groups();
    assertEquals(1, flowRulesInstalled.size());
    assertTrue(groupsInstalled.isEmpty());
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).forTable(FabricConstants.TBL_ACL_ID).withPriority(PRIORITY).makePermanent().withSelector(selector).withTreatment(treatment).fromApp(APP_ID).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
}
#end_block

#method_before
@Test
public void testAclDhcp() {
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().wipeDeferred().punt().build();
    // DHCP
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpSrc(TpPort.tpPort(UDP.DHCP_CLIENT_PORT)).matchUdpDst(TpPort.tpPort(UDP.DHCP_SERVER_PORT)).build();
    ForwardingObjective fwd = DefaultForwardingObjective.builder().withSelector(selector).withPriority(PRIORITY).fromApp(APP_ID).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withTreatment(treatment).add();
    Capture<FlowRuleOperations> captured = newCapture(CaptureType.ALL);
    flowRuleService.apply(capture(captured));
    expectLastCall().anyTimes();
    replay(flowRuleService);
    pipeliner.forward(fwd);
    verify(flowRuleService);
    List<FlowRuleOperations> capturedOpsList = captured.getValues();
    List<FlowRule> flowRulesInstalled = verifyFlowRuleOpsListAndGet(capturedOpsList, 1, 1);
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).forTable(FabricConstants.TBL_ACL_ID).withPriority(PRIORITY).makePermanent().withSelector(selector).withTreatment(treatment).fromApp(APP_ID).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
}
#method_after
@Test
public void testAclDhcp() {
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().wipeDeferred().punt().build();
    // DHCP
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpSrc(TpPort.tpPort(UDP.DHCP_CLIENT_PORT)).matchUdpDst(TpPort.tpPort(UDP.DHCP_SERVER_PORT)).build();
    ForwardingObjective fwd = DefaultForwardingObjective.builder().withSelector(selector).withPriority(PRIORITY).fromApp(APP_ID).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withTreatment(treatment).add();
    PipelinerTranslationResult result = pipeliner.pipelinerForward.forward(fwd);
    List<FlowRule> flowRulesInstalled = (List<FlowRule>) result.flowRules();
    List<GroupDescription> groupsInstalled = (List<GroupDescription>) result.groups();
    assertEquals(1, flowRulesInstalled.size());
    assertTrue(groupsInstalled.isEmpty());
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).forTable(FabricConstants.TBL_ACL_ID).withPriority(PRIORITY).makePermanent().withSelector(selector).withTreatment(treatment).fromApp(APP_ID).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
}
#end_block

#method_before
@Test
public void testL2Unicast() {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(VLAN_100).matchEthDst(HOST_MAC).build();
    ForwardingObjective fwd = DefaultForwardingObjective.builder().withSelector(selector).withPriority(PRIORITY).fromApp(APP_ID).makePermanent().withFlag(ForwardingObjective.Flag.SPECIFIC).nextStep(NEXT_ID_1).add();
    Capture<FlowRuleOperations> captured = newCapture(CaptureType.ALL);
    flowRuleService.apply(capture(captured));
    expectLastCall().anyTimes();
    replay(flowRuleService);
    pipeliner.forward(fwd);
    verify(flowRuleService);
    List<FlowRuleOperations> capturedOpsList = captured.getValues();
    List<FlowRule> flowRulesInstalled = verifyFlowRuleOpsListAndGet(capturedOpsList, 1, 1);
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    PiActionParam nextIdParam = new PiActionParam(FabricConstants.ACT_PRM_NEXT_ID_ID, ImmutableByteSequence.copyFrom(NEXT_ID_1.byteValue()));
    PiAction setNextIdAction = PiAction.builder().withId(FabricConstants.ACT_SET_NEXT_ID_ID).withParameter(nextIdParam).build();
    TrafficTreatment setNextIdTreatment = DefaultTrafficTreatment.builder().piTableAction(setNextIdAction).build();
    FlowRule expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).forTable(FabricConstants.TBL_BRIDGING_ID).withPriority(PRIORITY).makePermanent().withSelector(selector).withTreatment(setNextIdTreatment).fromApp(APP_ID).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
}
#method_after
@Test
public void testL2Unicast() {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(VLAN_100).matchEthDst(HOST_MAC).build();
    testSpecificForward(FabricConstants.TBL_BRIDGING_ID, selector, selector, NEXT_ID_1);
}
#end_block

#method_before
@Test
@Ignore
public void testL2Broadcast() {
}
#method_after
@Test
public void testL2Broadcast() {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchVlanId(VLAN_100).build();
    testSpecificForward(FabricConstants.TBL_BRIDGING_ID, selector, selector, NEXT_ID_1);
}
#end_block

#method_before
@Test
public void testRouterMacAndVlanFilter() {
    FilteringObjective filteringObjective = buildFilteringObjective(ROUTER_MAC);
    Capture<FlowRuleOperations> captured = newCapture(CaptureType.ALL);
    flowRuleService.apply(capture(captured));
    expectLastCall().anyTimes();
    replay(flowRuleService);
    pipeliner.filter(filteringObjective);
    verify(flowRuleService);
    List<FlowRuleOperations> capturedOpsList = captured.getValues();
    List<FlowRule> flowRulesInstalled = verifyFlowRuleOpsListAndGet(capturedOpsList, 1, 4);
    // in port vlan flow rule
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule flowRuleExpected = buildExpectedVlanInPortRule(PORT_1, VlanId.NONE, VLAN_100, FabricConstants.TBL_INGRESS_PORT_VLAN_ID);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier ipv4
    actualFlowRule = flowRulesInstalled.get(1);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, ROUTER_MAC, Ethernet.TYPE_IPV4, FWD_IPV4_UNICAST);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier ipv6
    actualFlowRule = flowRulesInstalled.get(2);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, ROUTER_MAC, Ethernet.TYPE_IPV6, FWD_IPV6_UNICAST);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier mpls
    actualFlowRule = flowRulesInstalled.get(3);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, ROUTER_MAC, Ethernet.MPLS_UNICAST, FWD_MPLS);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
}
#method_after
@Test
public void testRouterMacAndVlanFilter() {
    FilteringObjective filteringObjective = buildFilteringObjective(ROUTER_MAC);
    PipelinerTranslationResult result = pipeliner.pipelinerFilter.filter(filteringObjective);
    List<FlowRule> flowRulesInstalled = (List<FlowRule>) result.flowRules();
    List<GroupDescription> groupsInstalled = (List<GroupDescription>) result.groups();
    assertTrue(groupsInstalled.isEmpty());
    // in port vlan flow rule
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule flowRuleExpected = buildExpectedVlanInPortRule(PORT_1, VlanId.NONE, VLAN_100, FabricConstants.TBL_INGRESS_PORT_VLAN_ID);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier ipv4
    actualFlowRule = flowRulesInstalled.get(1);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, ROUTER_MAC, Ethernet.TYPE_IPV4, FWD_IPV4_UNICAST);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier ipv6
    actualFlowRule = flowRulesInstalled.get(2);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, ROUTER_MAC, Ethernet.TYPE_IPV6, FWD_IPV6_UNICAST);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier mpls
    actualFlowRule = flowRulesInstalled.get(3);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, ROUTER_MAC, Ethernet.MPLS_UNICAST, FWD_MPLS);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
}
#end_block

#method_before
@Test
public void testIpv4MulticastFwdClass() {
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VLAN_100).build();
    FilteringObjective filteringObjective = DefaultFilteringObjective.builder().permit().withPriority(PRIORITY).withKey(Criteria.matchInPort(PORT_1)).addCondition(Criteria.matchEthDst(MacAddress.IPV4_MULTICAST)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withMeta(treatment).fromApp(APP_ID).makePermanent().add();
    Capture<FlowRuleOperations> captured = newCapture(CaptureType.ALL);
    flowRuleService.apply(capture(captured));
    expectLastCall().anyTimes();
    replay(flowRuleService);
    pipeliner.filter(filteringObjective);
    verify(flowRuleService);
    List<FlowRuleOperations> capturedOpsList = captured.getValues();
    List<FlowRule> flowRulesInstalled = verifyFlowRuleOpsListAndGet(capturedOpsList, 1, 2);
    // in port vlan flow rule
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule flowRuleExpected = buildExpectedVlanInPortRule(PORT_1, VlanId.NONE, VLAN_100, FabricConstants.TBL_INGRESS_PORT_VLAN_ID);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier
    actualFlowRule = flowRulesInstalled.get(1);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, MacAddress.IPV4_MULTICAST, Ethernet.TYPE_IPV4, FWD_IPV4_MULTICAST);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
}
#method_after
@Test
public void testIpv4MulticastFwdClass() {
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VLAN_100).build();
    FilteringObjective filteringObjective = DefaultFilteringObjective.builder().permit().withPriority(PRIORITY).withKey(Criteria.matchInPort(PORT_1)).addCondition(Criteria.matchEthDst(MacAddress.IPV4_MULTICAST)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withMeta(treatment).fromApp(APP_ID).makePermanent().add();
    PipelinerTranslationResult result = pipeliner.pipelinerFilter.filter(filteringObjective);
    List<FlowRule> flowRulesInstalled = (List<FlowRule>) result.flowRules();
    List<GroupDescription> groupsInstalled = (List<GroupDescription>) result.groups();
    assertTrue(groupsInstalled.isEmpty());
    // in port vlan flow rule
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule flowRuleExpected = buildExpectedVlanInPortRule(PORT_1, VlanId.NONE, VLAN_100, FabricConstants.TBL_INGRESS_PORT_VLAN_ID);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier
    actualFlowRule = flowRulesInstalled.get(1);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, MacAddress.IPV4_MULTICAST, Ethernet.TYPE_IPV4, FWD_IPV4_MULTICAST);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
}
#end_block

#method_before
@Test
public void testIpv6MulticastFwdClass() {
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VLAN_100).build();
    FilteringObjective filteringObjective = DefaultFilteringObjective.builder().permit().withPriority(PRIORITY).withKey(Criteria.matchInPort(PORT_1)).addCondition(Criteria.matchEthDst(MacAddress.IPV6_MULTICAST)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withMeta(treatment).fromApp(APP_ID).makePermanent().add();
    Capture<FlowRuleOperations> captured = newCapture(CaptureType.ALL);
    flowRuleService.apply(capture(captured));
    expectLastCall().anyTimes();
    replay(flowRuleService);
    pipeliner.filter(filteringObjective);
    verify(flowRuleService);
    List<FlowRuleOperations> capturedOpsList = captured.getValues();
    List<FlowRule> flowRulesInstalled = verifyFlowRuleOpsListAndGet(capturedOpsList, 1, 2);
    // in port vlan flow rule
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule flowRuleExpected = buildExpectedVlanInPortRule(PORT_1, VlanId.NONE, VLAN_100, FabricConstants.TBL_INGRESS_PORT_VLAN_ID);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier
    actualFlowRule = flowRulesInstalled.get(1);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, MacAddress.IPV6_MULTICAST, Ethernet.TYPE_IPV6, FWD_IPV6_MULTICAST);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
}
#method_after
@Test
public void testIpv6MulticastFwdClass() {
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(VLAN_100).build();
    FilteringObjective filteringObjective = DefaultFilteringObjective.builder().permit().withPriority(PRIORITY).withKey(Criteria.matchInPort(PORT_1)).addCondition(Criteria.matchEthDst(MacAddress.IPV6_MULTICAST)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withMeta(treatment).fromApp(APP_ID).makePermanent().add();
    PipelinerTranslationResult result = pipeliner.pipelinerFilter.filter(filteringObjective);
    List<FlowRule> flowRulesInstalled = (List<FlowRule>) result.flowRules();
    List<GroupDescription> groupsInstalled = (List<GroupDescription>) result.groups();
    assertTrue(groupsInstalled.isEmpty());
    // in port vlan flow rule
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule flowRuleExpected = buildExpectedVlanInPortRule(PORT_1, VlanId.NONE, VLAN_100, FabricConstants.TBL_INGRESS_PORT_VLAN_ID);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
    // forwarding classifier
    actualFlowRule = flowRulesInstalled.get(1);
    flowRuleExpected = buildExpectedFwdClassifierRule(PORT_1, MacAddress.IPV6_MULTICAST, Ethernet.TYPE_IPV6, FWD_IPV6_MULTICAST);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
}
#end_block

#method_before
@Test
public void testFwdBridging() {
    FilteringObjective filteringObjective = buildFilteringObjective(null);
    Capture<FlowRuleOperations> captured = newCapture(CaptureType.ALL);
    flowRuleService.apply(capture(captured));
    expectLastCall().anyTimes();
    replay(flowRuleService);
    pipeliner.filter(filteringObjective);
    verify(flowRuleService);
    List<FlowRuleOperations> capturedOpsList = captured.getValues();
    List<FlowRule> flowRulesInstalled = verifyFlowRuleOpsListAndGet(capturedOpsList, 1, 1);
    // in port vlan flow rule
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule flowRuleExpected = buildExpectedVlanInPortRule(PORT_1, VlanId.NONE, VLAN_100, FabricConstants.TBL_INGRESS_PORT_VLAN_ID);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
// No rules in forwarding classifier, will do default action: set fwd type to bridging
}
#method_after
@Test
public void testFwdBridging() {
    FilteringObjective filteringObjective = buildFilteringObjective(null);
    PipelinerTranslationResult result = pipeliner.pipelinerFilter.filter(filteringObjective);
    List<FlowRule> flowRulesInstalled = (List<FlowRule>) result.flowRules();
    List<GroupDescription> groupsInstalled = (List<GroupDescription>) result.groups();
    assertTrue(groupsInstalled.isEmpty());
    // in port vlan flow rule
    FlowRule actualFlowRule = flowRulesInstalled.get(0);
    FlowRule flowRuleExpected = buildExpectedVlanInPortRule(PORT_1, VlanId.NONE, VLAN_100, FabricConstants.TBL_INGRESS_PORT_VLAN_ID);
    assertTrue(flowRuleExpected.exactMatch(actualFlowRule));
// No rules in forwarding classifier, will do default action: set fwd type to bridging
}
#end_block

#method_before
@Test
public void testUnsupportedObjective() {
    ObjectiveContext ctx = createNiceMock(ObjectiveContext.class);
    FilteringObjective filteringObjective = DefaultFilteringObjective.builder().deny().withKey(Criteria.matchInPort(PORT_1)).addCondition(Criteria.matchVlanId(VLAN_100)).fromApp(APP_ID).makePermanent().add(ctx);
    Capture<ObjectiveError> errorCaptured = newCapture();
    ctx.onError(eq(filteringObjective), capture(errorCaptured));
    replay(flowRuleService, ctx);
    pipeliner.filter(filteringObjective);
    verify(flowRuleService, ctx);
    ObjectiveError error = errorCaptured.getValue();
    assertEquals(ObjectiveError.UNSUPPORTED, error);
}
#method_after
@Test
public void testUnsupportedObjective() {
    FilteringObjective filteringObjective = DefaultFilteringObjective.builder().deny().withKey(Criteria.matchInPort(PORT_1)).addCondition(Criteria.matchVlanId(VLAN_100)).fromApp(APP_ID).makePermanent().add();
    PipelinerTranslationResult result = pipeliner.pipelinerFilter.filter(filteringObjective);
    pipeliner.pipelinerFilter.filter(filteringObjective);
    List<FlowRule> flowRulesInstalled = (List<FlowRule>) result.flowRules();
    List<GroupDescription> groupsInstalled = (List<GroupDescription>) result.groups();
    assertTrue(flowRulesInstalled.isEmpty());
    assertTrue(groupsInstalled.isEmpty());
    assertTrue(result.error().isPresent());
    ObjectiveError error = result.error().get();
    assertEquals(ObjectiveError.UNSUPPORTED, error);
}
#end_block

#method_before
@Test
public void badParamTest() {
    // Filtering objective should contains filtering key
    ObjectiveContext ctx = createNiceMock(ObjectiveContext.class);
    FilteringObjective filteringObjective = DefaultFilteringObjective.builder().permit().addCondition(Criteria.matchVlanId(VLAN_100)).fromApp(APP_ID).makePermanent().add(ctx);
    Capture<ObjectiveError> errorCaptured = newCapture();
    ctx.onError(eq(filteringObjective), capture(errorCaptured));
    replay(flowRuleService, ctx);
    pipeliner.filter(filteringObjective);
    verify(flowRuleService, ctx);
    ObjectiveError error = errorCaptured.getValue();
    assertEquals(ObjectiveError.BADPARAMS, error);
    // Filtering objective should use in_port as key
    reset(flowRuleService, ctx);
    filteringObjective = DefaultFilteringObjective.builder().permit().withKey(Criteria.matchEthDst(ROUTER_MAC)).addCondition(Criteria.matchVlanId(VLAN_100)).withMeta(DefaultTrafficTreatment.emptyTreatment()).fromApp(APP_ID).makePermanent().add(ctx);
    errorCaptured = newCapture();
    ctx.onError(eq(filteringObjective), capture(errorCaptured));
    replay(flowRuleService, ctx);
    pipeliner.filter(filteringObjective);
    verify(flowRuleService, ctx);
    error = errorCaptured.getValue();
    assertEquals(ObjectiveError.BADPARAMS, error);
}
#method_after
@Test
public void badParamTest() {
    // Filtering objective should contains filtering key
    FilteringObjective filteringObjective = DefaultFilteringObjective.builder().permit().addCondition(Criteria.matchVlanId(VLAN_100)).fromApp(APP_ID).makePermanent().add();
    PipelinerTranslationResult result = pipeliner.pipelinerFilter.filter(filteringObjective);
    pipeliner.pipelinerFilter.filter(filteringObjective);
    assertTrue(result.error().isPresent());
    ObjectiveError error = result.error().get();
    assertEquals(ObjectiveError.BADPARAMS, error);
    // Filtering objective should use in_port as key
    filteringObjective = DefaultFilteringObjective.builder().permit().withKey(Criteria.matchEthDst(ROUTER_MAC)).addCondition(Criteria.matchVlanId(VLAN_100)).withMeta(DefaultTrafficTreatment.emptyTreatment()).fromApp(APP_ID).makePermanent().add();
    result = pipeliner.pipelinerFilter.filter(filteringObjective);
    pipeliner.pipelinerFilter.filter(filteringObjective);
    assertTrue(result.error().isPresent());
    error = result.error().get();
    assertEquals(ObjectiveError.BADPARAMS, error);
}
#end_block

#method_before
public void filter(FilteringObjective filterObjective) {
    if (filterObjective.type() == FilteringObjective.Type.DENY) {
        log.warn("Unsupported filtering objective type {}", filterObjective.type());
        fail(filterObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    if (filterObjective.key() == null || filterObjective.key().type() != Criterion.Type.IN_PORT) {
        log.warn("Unsupported filter key {}", filterObjective.key());
        fail(filterObjective, ObjectiveError.BADPARAMS);
        return;
    }
    PortCriterion inPortCriterion = (PortCriterion) filterObjective.key();
    VlanIdCriterion vlanCriterion = filterObjective.conditions().stream().filter(criterion -> criterion.type() == Criterion.Type.VLAN_VID).map(criterion -> (VlanIdCriterion) criterion).findFirst().orElse(null);
    EthCriterion ethDstCriterion = filterObjective.conditions().stream().filter(criterion -> criterion.type() == Criterion.Type.ETH_DST).map(criterion -> (EthCriterion) criterion).findFirst().orElse(null);
    FlowRule inportVlanTableRule = createInPortVlanTable(inPortCriterion, vlanCriterion, filterObjective);
    Collection<FlowRule> fwdClassifierRules = createFwdClassifierRules(inPortCriterion, ethDstCriterion, filterObjective);
    Collection<FlowRule> flowRulesToApply = Lists.newArrayList();
    flowRulesToApply.add(inportVlanTableRule);
    flowRulesToApply.addAll(fwdClassifierRules);
    flowRuleService.apply(buildFlowRuleOps(filterObjective, flowRulesToApply));
}
#method_after
public PipelinerTranslationResult filter(FilteringObjective filterObjective) {
    PipelinerTranslationResult.Builder resultBuilder = PipelinerTranslationResult.builder();
    if (filterObjective.type() == FilteringObjective.Type.DENY) {
        log.warn("Unsupported filtering objective type {}", filterObjective.type());
        resultBuilder.setError(ObjectiveError.UNSUPPORTED);
        return resultBuilder.build();
    }
    if (filterObjective.key() == null || filterObjective.key().type() != Criterion.Type.IN_PORT) {
        log.warn("Unsupported filter key {}", filterObjective.key());
        resultBuilder.setError(ObjectiveError.BADPARAMS);
        return resultBuilder.build();
    }
    PortCriterion inPortCriterion = (PortCriterion) filterObjective.key();
    VlanIdCriterion vlanCriterion = filterObjective.conditions().stream().filter(criterion -> criterion.type() == Criterion.Type.VLAN_VID).map(criterion -> (VlanIdCriterion) criterion).findFirst().orElse(null);
    EthCriterion ethDstCriterion = filterObjective.conditions().stream().filter(criterion -> criterion.type() == Criterion.Type.ETH_DST).map(criterion -> (EthCriterion) criterion).findFirst().orElse(null);
    FlowRule inPortVlanTableRule = createInPortVlanTable(inPortCriterion, vlanCriterion, filterObjective);
    Collection<FlowRule> fwdClassifierRules = createFwdClassifierRules(inPortCriterion, ethDstCriterion, filterObjective);
    resultBuilder.addFlowRule(inPortVlanTableRule);
    fwdClassifierRules.forEach(resultBuilder::addFlowRule);
    return resultBuilder.build();
}
#end_block

#method_before
private void testSimple(TrafficTreatment treatment) {
    ObjectiveContext ctx = createNiceMock(ObjectiveContext.class);
    NextObjective nextObjective = DefaultNextObjective.builder().withId(NEXT_ID_1).withPriority(PRIORITY).addTreatment(treatment).withType(NextObjective.Type.SIMPLE).makePermanent().fromApp(APP_ID).add(ctx);
    Capture<FlowRuleOperations> captured = newCapture(CaptureType.ALL);
    flowRuleService.apply(capture(captured));
    expectLastCall().anyTimes();
    ctx.onSuccess(eq(nextObjective));
    expectLastCall().once();
    replay(flowRuleService, ctx);
    pipeliner.next(nextObjective);
    verify(flowRuleService);
    List<FlowRuleOperations> capturedOpsList = captured.getValues();
    List<FlowRule> flowRulesInstalled = verifyFlowRuleOpsListAndGet(capturedOpsList, 1, 2);
    verify(ctx);
    FlowRule actualFlowRule;
    FlowRule expectedFlowRule;
    // Next id mapping table
    actualFlowRule = flowRulesInstalled.get(0);
    byte[] nextIdVal = new byte[] { NEXT_ID_1.byteValue() };
    PiCriterion nextIdCriterion = PiCriterion.builder().matchExact(FabricConstants.HF_FABRIC_METADATA_NEXT_ID_ID, nextIdVal).build();
    TrafficSelector nextIdSelector = DefaultTrafficSelector.builder().matchPi(nextIdCriterion).build();
    PiActionParam setNextToSimpleParam = new PiActionParam(FabricConstants.ACT_PRM_NEXT_TYPE_ID, ImmutableByteSequence.copyFrom(NEXT_TYPE_SIMPLE));
    PiAction setNextToSimpleAction = PiAction.builder().withId(FabricConstants.ACT_SET_NEXT_TYPE_ID).withParameter(setNextToSimpleParam).build();
    TrafficTreatment setNextTypeTreatment = DefaultTrafficTreatment.builder().piTableAction(setNextToSimpleAction).build();
    expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).fromApp(APP_ID).makePermanent().withPriority(0).forTable(FabricConstants.TBL_NEXT_ID_MAPPING_ID).withSelector(nextIdSelector).withTreatment(setNextTypeTreatment).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
    // Simple table
    actualFlowRule = flowRulesInstalled.get(1);
    expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).fromApp(APP_ID).makePermanent().withPriority(0).forTable(FabricConstants.TBL_SIMPLE_ID).withSelector(nextIdSelector).withTreatment(treatment).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
}
#method_after
private void testSimple(TrafficTreatment treatment) {
    NextObjective nextObjective = DefaultNextObjective.builder().withId(NEXT_ID_1).withPriority(PRIORITY).addTreatment(treatment).withType(NextObjective.Type.SIMPLE).makePermanent().fromApp(APP_ID).add();
    PipelinerTranslationResult result = pipeliner.pipelinerNext.next(nextObjective);
    List<FlowRule> flowRulesInstalled = (List<FlowRule>) result.flowRules();
    List<GroupDescription> groupsInstalled = (List<GroupDescription>) result.groups();
    assertEquals(2, flowRulesInstalled.size());
    assertTrue(groupsInstalled.isEmpty());
    FlowRule actualFlowRule;
    FlowRule expectedFlowRule;
    // Next id mapping table
    actualFlowRule = flowRulesInstalled.get(0);
    byte[] nextIdVal = new byte[] { NEXT_ID_1.byteValue() };
    PiCriterion nextIdCriterion = PiCriterion.builder().matchExact(FabricConstants.HF_FABRIC_METADATA_NEXT_ID_ID, nextIdVal).build();
    TrafficSelector nextIdSelector = DefaultTrafficSelector.builder().matchPi(nextIdCriterion).build();
    PiActionParam setNextToSimpleParam = new PiActionParam(FabricConstants.ACT_PRM_NEXT_TYPE_ID, ImmutableByteSequence.copyFrom(NEXT_TYPE_SIMPLE));
    PiAction setNextToSimpleAction = PiAction.builder().withId(FabricConstants.ACT_SET_NEXT_TYPE_ID).withParameter(setNextToSimpleParam).build();
    TrafficTreatment setNextTypeTreatment = DefaultTrafficTreatment.builder().piTableAction(setNextToSimpleAction).build();
    expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).fromApp(APP_ID).makePermanent().withPriority(0).forTable(FabricConstants.TBL_NEXT_ID_MAPPING_ID).withSelector(nextIdSelector).withTreatment(setNextTypeTreatment).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
    // Simple table
    actualFlowRule = flowRulesInstalled.get(1);
    expectedFlowRule = DefaultFlowRule.builder().forDevice(DEVICE_ID).fromApp(APP_ID).makePermanent().withPriority(0).forTable(FabricConstants.TBL_SIMPLE_ID).withSelector(nextIdSelector).withTreatment(treatment).build();
    assertTrue(expectedFlowRule.exactMatch(actualFlowRule));
}
#end_block

#method_before
public void next(NextObjective nextObjective) {
    FlowRule nextIdMappingRule = processNextIdMapping(nextObjective);
    FlowRule nextRule = null;
    switch(nextObjective.type()) {
        case SIMPLE:
            nextRule = processSimpleNext(nextObjective);
            break;
        default:
            log.warn("Unsupported next type {}", nextObjective);
            fail(nextObjective, ObjectiveError.UNSUPPORTED);
            break;
    }
    if (nextIdMappingRule != null && nextRule != null) {
        FlowRuleOperationsContext ctx = buildContext(nextObjective);
        flowRuleService.apply(buildFlowRuleOps(nextObjective, ImmutableList.of(nextIdMappingRule, nextRule), ctx));
    }
}
#method_after
public PipelinerTranslationResult next(NextObjective nextObjective) {
    PipelinerTranslationResult.Builder resultBuilder = PipelinerTranslationResult.builder();
    FlowRule nextIdMappingRule = processNextIdMapping(nextObjective);
    FlowRule nextRule = null;
    switch(nextObjective.type()) {
        case SIMPLE:
            nextRule = processSimpleNext(nextObjective);
            break;
        default:
            log.warn("Unsupported next type {}", nextObjective);
            resultBuilder.setError(ObjectiveError.UNSUPPORTED);
            break;
    }
    if (nextIdMappingRule != null && nextRule != null) {
        resultBuilder.addFlowRule(nextIdMappingRule);
        resultBuilder.addFlowRule(nextRule);
    }
    return resultBuilder.build();
}
#end_block

#method_before
private Interface getServerInterface() {
    DhcpServerInfo serverInfo;
    ConnectPoint dhcpServerConnectPoint;
    VlanId dhcpConnectVlan;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    } else {
        return null;
    }
    if (dhcpServerConnectPoint == null || dhcpConnectVlan == null) {
        log.info("DHCP server {} not resolve yet", serverInfo.getDhcpGatewayIp6());
        return null;
    }
    return interfaceService.getInterfacesByPort(dhcpServerConnectPoint).stream().filter(iface -> interfaceContainsVlan(iface, dhcpConnectVlan)).findFirst().orElse(null);
}
#method_after
private Interface getServerInterface() {
    DhcpServerInfo serverInfo;
    ConnectPoint dhcpServerConnectPoint;
    VlanId dhcpConnectVlan;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    } else {
        return null;
    }
    if (dhcpServerConnectPoint == null || dhcpConnectVlan == null) {
        log.info("Default DHCP server {} not resolve yet", serverInfo.getDhcpGatewayIp6());
        return null;
    }
    return interfaceService.getInterfacesByPort(dhcpServerConnectPoint).stream().filter(iface -> interfaceContainsVlan(iface, dhcpConnectVlan)).findFirst().orElse(null);
}
#end_block

#method_before
private PiControlMetadata createPacketMetadata(long portNumber) throws PiInterpreterException {
    try {
        return PiControlMetadata.builder().withId(FabricConstants.CTRL_META_EGRESS_PORT_ID).withValue(fit(copyFrom(portNumber), PORT_BITWIDTH)).build();
    } catch (ImmutableByteSequence.ByteSequenceTrimException e) {
        throw new PiInterpreterException(format("Port number %d too big, %s", portNumber, e.getMessage()));
    }
}
#method_after
private PiControlMetadata createPacketMetadata(long portNumber) throws PiInterpreterException {
    try {
        return PiControlMetadata.builder().withId(FabricConstants.CTRL_META_EGRESS_PORT_ID).withValue(fit(copyFrom(portNumber), FabricConstants.PORT_BITWIDTH)).build();
    } catch (ImmutableByteSequence.ByteSequenceTrimException e) {
        throw new PiInterpreterException(format("Port number %d too big, %s", portNumber, e.getMessage()));
    }
}
#end_block

#method_before
public ElectionState cleanup(String topic, RaftSession session, Supplier<Long> termCounter) {
    Optional<Registration> registration = registrations.stream().filter(r -> r.sessionId() == session.sessionId().id()).findFirst();
    if (registration.isPresent()) {
        List<Registration> updatedRegistrations = registrations.stream().filter(r -> r.sessionId() != session.sessionId().id()).collect(Collectors.toList());
        if (leader.sessionId() == session.sessionId().id()) {
            if (!updatedRegistrations.isEmpty()) {
                updatedRegistrations.sort((a, b) -> {
                    long aCount = elections.entrySet().stream().filter(entry -> !entry.getKey().equals(topic) && entry.getValue().leader != null && entry.getValue().leader.nodeId.id().equals(sessions().getSession(a.sessionId).memberId().id())).count();
                    long bCount = elections.entrySet().stream().filter(entry -> !entry.getKey().equals(topic) && entry.getValue().leader != null && entry.getValue().leader.nodeId.id().equals(sessions().getSession(b.sessionId).memberId().id())).count();
                    return ComparisonChain.start().compare(aCount, bCount).compare(a.sessionId, b.sessionId).result();
                });
                return new ElectionState(updatedRegistrations, updatedRegistrations.get(0), termCounter.get(), System.currentTimeMillis(), elections);
            } else {
                return new ElectionState(updatedRegistrations, null, term, termStartTime, elections);
            }
        } else {
            return new ElectionState(updatedRegistrations, leader, term, termStartTime, elections);
        }
    } else {
        return this;
    }
}
#method_after
public ElectionState cleanup(String topic, RaftSession session, Supplier<Long> termCounter) {
    Optional<Registration> registration = registrations.stream().filter(r -> r.sessionId() == session.sessionId().id()).findFirst();
    if (registration.isPresent()) {
        List<Registration> updatedRegistrations = registrations.stream().filter(r -> r.sessionId() != session.sessionId().id()).collect(Collectors.toList());
        if (leader.sessionId() == session.sessionId().id()) {
            if (!updatedRegistrations.isEmpty()) {
                sortRegistrations(topic, updatedRegistrations);
                return new ElectionState(updatedRegistrations, updatedRegistrations.get(0), termCounter.get(), System.currentTimeMillis(), elections);
            } else {
                return new ElectionState(updatedRegistrations, null, term, termStartTime, elections);
            }
        } else {
            return new ElectionState(updatedRegistrations, leader, term, termStartTime, elections);
        }
    } else {
        return this;
    }
}
#end_block

#method_before
public ElectionState addRegistration(String topic, Registration registration, Supplier<Long> termCounter) {
    if (!registrations.stream().anyMatch(r -> r.sessionId() == registration.sessionId())) {
        List<Registration> updatedRegistrations = new LinkedList<>(registrations);
        updatedRegistrations.add(registration);
        updatedRegistrations.sort((a, b) -> {
            long aCount = elections.entrySet().stream().filter(entry -> !entry.getKey().equals(topic) && entry.getValue().leader != null && entry.getValue().leader.nodeId.id().equals(sessions().getSession(a.sessionId).memberId().id())).count();
            long bCount = elections.entrySet().stream().filter(entry -> !entry.getKey().equals(topic) && entry.getValue().leader != null && entry.getValue().leader.nodeId.id().equals(sessions().getSession(b.sessionId).memberId().id())).count();
            return ComparisonChain.start().compare(aCount, bCount).compare(a.sessionId, b.sessionId).result();
        });
        Registration firstRegistration = updatedRegistrations.get(0);
        Registration leader = this.leader;
        long term = this.term;
        long termStartTime = this.termStartTime;
        if (leader == null || !leader.equals(firstRegistration)) {
            leader = firstRegistration;
            term = termCounter.get();
            termStartTime = System.currentTimeMillis();
        }
        return new ElectionState(updatedRegistrations, leader, term, termStartTime, elections);
    }
    return this;
}
#method_after
public ElectionState addRegistration(String topic, Registration registration, Supplier<Long> termCounter) {
    if (!registrations.stream().anyMatch(r -> r.sessionId() == registration.sessionId())) {
        List<Registration> updatedRegistrations = new LinkedList<>(registrations);
        updatedRegistrations.add(registration);
        sortRegistrations(topic, updatedRegistrations);
        Registration firstRegistration = updatedRegistrations.get(0);
        Registration leader = this.leader;
        long term = this.term;
        long termStartTime = this.termStartTime;
        if (leader == null || !leader.equals(firstRegistration)) {
            leader = firstRegistration;
            term = termCounter.get();
            termStartTime = System.currentTimeMillis();
        }
        return new ElectionState(updatedRegistrations, leader, term, termStartTime, elections);
    }
    return this;
}
#end_block

#method_before
@Override
public void registerAnydataSchema(Class id, List<Class> ids) {
// TODO implemention
}
#method_after
@Override
public void registerAnydataSchema(Class id, Class id1) throws IllegalArgumentException {
// TODO implemention
}
#end_block

#method_before
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    DhcpServerConfig serverConfig = configs.iterator().next();
    if (!serverConfig.getDhcpServerIp6().isPresent()) {
        // not a DHCPv6 config
        return;
    }
    if (!serverInfoList.isEmpty()) {
        // remove old server info
        DhcpServerInfo oldServerInfo = serverInfoList.remove(0);
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp6().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp6().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    // Create new server info according to the config
    DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V6);
    checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
    checkState(newServerInfo.getDhcpServerIp6().isPresent(), "IP of DHCP server not exists");
    log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
    log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp6().orElse(null));
    Ip6Address serverIp = newServerInfo.getDhcpServerIp6().get();
    Ip6Address ipToProbe;
    if (newServerInfo.getDhcpGatewayIp6().isPresent()) {
        ipToProbe = newServerInfo.getDhcpGatewayIp6().get();
    } else {
        ipToProbe = newServerInfo.getDhcpServerIp6().orElse(null);
    }
    String hostToProbe = newServerInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
    log.debug("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
    hostService.startMonitoringIp(ipToProbe);
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (!hosts.isEmpty()) {
        Host host = hosts.iterator().next();
        newServerInfo.setDhcpConnectVlan(host.vlan());
        newServerInfo.setDhcpConnectMac(host.mac());
    }
    // Add new server info
    serverInfoList.add(0, newServerInfo);
    // Remove duplicated server info
    Set<DhcpServerInfo> nonDupServerInfoList = Sets.newLinkedHashSet();
    nonDupServerInfoList.addAll(serverInfoList);
    serverInfoList.clear();
    serverInfoList.addAll(nonDupServerInfoList);
    requestDhcpPacket(serverIp);
}
#method_after
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    DhcpServerConfig serverConfig = configs.iterator().next();
    if (!serverConfig.getDhcpServerIp6().isPresent()) {
        // not a DHCPv6 config
        return;
    }
    if (!serverInfoList.isEmpty()) {
        // remove old server info
        DhcpServerInfo oldServerInfo = serverInfoList.remove(0);
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp6().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp6().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    // Create new server info according to the config
    DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V6);
    checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
    checkState(newServerInfo.getDhcpServerIp6().isPresent(), "IP of DHCP server not exists");
    log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
    log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp6().orElse(null));
    Ip6Address serverIp = newServerInfo.getDhcpServerIp6().get();
    Ip6Address ipToProbe;
    if (newServerInfo.getDhcpGatewayIp6().isPresent()) {
        ipToProbe = newServerInfo.getDhcpGatewayIp6().get();
    } else {
        ipToProbe = newServerInfo.getDhcpServerIp6().orElse(null);
    }
    String hostToProbe = newServerInfo.getDhcpGatewayIp6().map(ip -> "gateway").orElse("server");
    log.debug("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
    hostService.startMonitoringIp(ipToProbe);
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (!hosts.isEmpty()) {
        Host host = hosts.iterator().next();
        newServerInfo.setDhcpConnectVlan(host.vlan());
        newServerInfo.setDhcpConnectMac(host.mac());
    }
    // Add new server info
    synchronized (this) {
        serverInfoList.clear();
        serverInfoList.add(0, newServerInfo);
    }
    requestDhcpPacket(serverIp);
}
#end_block

#method_before
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    DhcpServerConfig serverConfig = configs.iterator().next();
    if (!serverConfig.getDhcpServerIp4().isPresent()) {
        // not a DHCPv4 config
        return;
    }
    if (!serverInfoList.isEmpty()) {
        // remove old server info
        DhcpServerInfo oldServerInfo = serverInfoList.remove(0);
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp4().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp4().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    // Create new server info according to the config
    DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V4);
    checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
    checkState(newServerInfo.getDhcpServerIp4().isPresent(), "IP of DHCP server not exists");
    log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
    log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp4().orElse(null));
    Ip4Address serverIp = newServerInfo.getDhcpServerIp4().get();
    Ip4Address ipToProbe;
    if (newServerInfo.getDhcpGatewayIp4().isPresent()) {
        ipToProbe = newServerInfo.getDhcpGatewayIp4().get();
    } else {
        ipToProbe = newServerInfo.getDhcpServerIp4().orElse(null);
    }
    String hostToProbe = newServerInfo.getDhcpGatewayIp4().map(ip -> "gateway").orElse("server");
    log.debug("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
    hostService.startMonitoringIp(ipToProbe);
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (!hosts.isEmpty()) {
        Host host = hosts.iterator().next();
        newServerInfo.setDhcpConnectVlan(host.vlan());
        newServerInfo.setDhcpConnectMac(host.mac());
    }
    // Add new server info
    serverInfoList.add(0, newServerInfo);
    // Remove duplicated server info
    Set<DhcpServerInfo> nonDupServerInfoList = Sets.newLinkedHashSet();
    nonDupServerInfoList.addAll(serverInfoList);
    serverInfoList.clear();
    serverInfoList.addAll(nonDupServerInfoList);
    requestDhcpPacket(serverIp);
}
#method_after
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    DhcpServerConfig serverConfig = configs.iterator().next();
    if (!serverConfig.getDhcpServerIp4().isPresent()) {
        // not a DHCPv4 config
        return;
    }
    if (!serverInfoList.isEmpty()) {
        // remove old server info
        DhcpServerInfo oldServerInfo = serverInfoList.remove(0);
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp4().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp4().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    // Create new server info according to the config
    DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V4);
    checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
    checkState(newServerInfo.getDhcpServerIp4().isPresent(), "IP of DHCP server not exists");
    log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
    log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp4().orElse(null));
    Ip4Address serverIp = newServerInfo.getDhcpServerIp4().get();
    Ip4Address ipToProbe;
    if (newServerInfo.getDhcpGatewayIp4().isPresent()) {
        ipToProbe = newServerInfo.getDhcpGatewayIp4().get();
    } else {
        ipToProbe = newServerInfo.getDhcpServerIp4().orElse(null);
    }
    String hostToProbe = newServerInfo.getDhcpGatewayIp4().map(ip -> "gateway").orElse("server");
    log.debug("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
    hostService.startMonitoringIp(ipToProbe);
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (!hosts.isEmpty()) {
        Host host = hosts.iterator().next();
        newServerInfo.setDhcpConnectVlan(host.vlan());
        newServerInfo.setDhcpConnectMac(host.mac());
    }
    // Add new server info
    synchronized (this) {
        serverInfoList.clear();
        serverInfoList.add(0, newServerInfo);
    }
    requestDhcpPacket(serverIp);
}
#end_block

#method_before
@Modified
protected void modified(ComponentContext context) {
    int newRaPoolSize, newRaThreadDelay;
    // Loading configured properties.
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        try {
            // Handle change in pool size
            String s = get(properties, PROP_RA_THREADS_POOL);
            newRaPoolSize = isNullOrEmpty(s) ? DEFAULT_RA_THREADS_POOL_SIZE : Integer.parseInt(s.trim());
            if (newRaPoolSize != raPoolSize) {
                raPoolSize = newRaPoolSize;
                clearPoolAndTxWorkers();
                setupPoolAndTxWorkers();
                log.info("Thread pool size updated to " + raPoolSize);
            }
            // Handle change in thread delay
            s = get(properties, PROP_RA_THREADS_DELAY);
            newRaThreadDelay = isNullOrEmpty(s) ? DEFAULT_RA_THREADS_DELAY : Integer.parseInt(s.trim());
            if (newRaThreadDelay != raThreadDelay) {
                raThreadDelay = newRaThreadDelay;
                clearTxWorkers();
                setupTxWorkers();
                log.info("Thread delay updated to " + raThreadDelay);
            }
            // Handle M-flag changes
            s = get(properties, PROP_RA_FLAG_MBIT_STATUS);
            if (!isNullOrEmpty(s)) {
                raFlagMbitStatus = Boolean.parseBoolean(s.trim());
                log.info("RA M-flag set " + s);
            }
            // Handle O-flag changes
            s = get(properties, PROP_RA_FLAG_OBIT_STATUS);
            if (!isNullOrEmpty(s)) {
                raFlagObitStatus = Boolean.parseBoolean(s.trim());
                log.info("RA O-flag set " + s);
            }
            // Handle prefix option configuration
            s = get(properties, PROP_RA_OPTION_PREFIX_STATUS);
            if (!isNullOrEmpty(s)) {
                raOptionPrefixStatus = Boolean.parseBoolean(s.trim());
                String status = raOptionPrefixStatus ? "enabled" : "disabled";
                log.info("RA prefix option " + status);
            }
            s = get(properties, PROP_RA_GLOBAL_PREFIX_CONF_STATUS);
            if (!isNullOrEmpty(s)) {
                raGlobalConfigStatus = Boolean.parseBoolean(s.trim());
                clearTxWorkers();
                setupTxWorkers();
                String status = raOptionPrefixStatus ? "enabled" : "disabled";
                log.info("RA global configuration file loading " + status);
            }
        } catch (NumberFormatException e) {
            log.warn("Component configuration had invalid value, aborting changes loading.", e);
        }
    }
}
#method_after
@Modified
protected void modified(ComponentContext context) {
    int newRaPoolSize, newRaThreadDelay;
    // Loading configured properties.
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        try {
            // Handle change in pool size
            String s = get(properties, PROP_RA_THREADS_POOL);
            newRaPoolSize = isNullOrEmpty(s) ? DEFAULT_RA_THREADS_POOL_SIZE : Integer.parseInt(s.trim());
            if (newRaPoolSize != raPoolSize) {
                raPoolSize = newRaPoolSize;
                clearPoolAndTxWorkers();
                setupPoolAndTxWorkers();
                log.info("Thread pool size updated to {}", raPoolSize);
            }
            // Handle change in thread delay
            s = get(properties, PROP_RA_THREADS_DELAY);
            newRaThreadDelay = isNullOrEmpty(s) ? DEFAULT_RA_THREADS_DELAY : Integer.parseInt(s.trim());
            if (newRaThreadDelay != raThreadDelay) {
                raThreadDelay = newRaThreadDelay;
                clearTxWorkers();
                setupTxWorkers();
                log.info("Thread delay updated to {}", raThreadDelay);
            }
            // Handle M-flag changes
            s = get(properties, PROP_RA_FLAG_MBIT_STATUS);
            if (!isNullOrEmpty(s)) {
                raFlagMbitStatus = Boolean.parseBoolean(s.trim());
                log.info("RA M-flag set {}", s);
            }
            // Handle O-flag changes
            s = get(properties, PROP_RA_FLAG_OBIT_STATUS);
            if (!isNullOrEmpty(s)) {
                raFlagObitStatus = Boolean.parseBoolean(s.trim());
                log.info("RA O-flag set {}", s);
            }
            // Handle prefix option configuration
            s = get(properties, PROP_RA_OPTION_PREFIX_STATUS);
            if (!isNullOrEmpty(s)) {
                raOptionPrefixStatus = Boolean.parseBoolean(s.trim());
                String status = raOptionPrefixStatus ? "enabled" : "disabled";
                log.info("RA prefix option {}", status);
            }
            s = get(properties, PROP_RA_GLOBAL_PREFIX_CONF_STATUS);
            if (!isNullOrEmpty(s)) {
                raGlobalConfigStatus = Boolean.parseBoolean(s.trim());
                clearTxWorkers();
                setupTxWorkers();
                String status = raOptionPrefixStatus ? "enabled" : "disabled";
                log.info("RA global configuration file loading {}", status);
            }
        } catch (NumberFormatException e) {
            log.warn("Component configuration had invalid value, aborting changes loading.", e);
        }
    }
}
#end_block

#method_before
@Override
public boolean isValid() {
    return true;
}
#method_after
@Override
public boolean isValid() {
    return hasOnlyFields(PREFIXES) && prefixes() != null;
}
#end_block

#method_before
public FlowEntry build(FlowEntryState... state) {
    FlowRule.Builder builder;
    try {
        switch(this.type) {
            case STAT:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).withIdleTimeout(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
                if (stat.getVersion() != OFVersion.OF_10) {
                    builder.forTable(stat.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(stat.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(stat.getDurationSec()) + stat.getDurationNsec(), NANOSECONDS, liveType, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                }
            case REMOVED:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).withIdleTimeout(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue()).withReason(FlowRule.FlowRemoveReason.parseShort((short) removed.getReason().ordinal()));
                if (removed.getVersion() != OFVersion.OF_10) {
                    builder.forTable(removed.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(removed.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(removed.getDurationSec()) + removed.getDurationNsec(), NANOSECONDS, liveType, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                }
            case MOD:
                FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).withIdleTimeout(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue());
                if (flowMod.getVersion() != OFVersion.OF_10) {
                    builder.forTable(flowMod.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = FlowEntry.FlowLiveType.IMMEDIATE;
                    return new DefaultFlowEntry(builder.build(), flowState, 0, liveType, 0, 0);
                } else {
                    return new DefaultFlowEntry(builder.build(), flowState, 0, 0, 0);
                }
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#method_after
public FlowEntry build(FlowEntryState... state) {
    try {
        switch(this.type) {
            case STAT:
                return createFlowEntryFromStat();
            case LIGHTWEIGHT_STAT:
                return createFlowEntryFromLightweightStat();
            case REMOVED:
                return createFlowEntryForFlowRemoved();
            case MOD:
                return createFlowEntryForFlowMod(state);
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#end_block

#method_before
private TrafficTreatment buildTreatment() {
    TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
    for (OFInstruction in : instructions) {
        switch(in.getType()) {
            case GOTO_TABLE:
                builder.transition(((int) ((OFInstructionGotoTable) in).getTableId().getValue()));
                break;
            case WRITE_METADATA:
                OFInstructionWriteMetadata m = (OFInstructionWriteMetadata) in;
                builder.writeMetadata(m.getMetadata().getValue(), m.getMetadataMask().getValue());
                break;
            case WRITE_ACTIONS:
                builder.deferred();
                buildActions(((OFInstructionWriteActions) in).getActions(), builder);
                break;
            case APPLY_ACTIONS:
                builder.immediate();
                buildActions(((OFInstructionApplyActions) in).getActions(), builder);
                break;
            case CLEAR_ACTIONS:
                builder.wipeDeferred();
                break;
            case EXPERIMENTER:
                break;
            case METER:
                break;
            default:
                log.warn("Unknown instructions type {}", in.getType());
        }
    }
    return builder.build();
}
#method_after
private TrafficTreatment buildTreatment() {
    TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
    for (OFInstruction in : instructions) {
        switch(in.getType()) {
            case GOTO_TABLE:
                builder.transition(((int) ((OFInstructionGotoTable) in).getTableId().getValue()));
                break;
            case WRITE_METADATA:
                OFInstructionWriteMetadata m = (OFInstructionWriteMetadata) in;
                builder.writeMetadata(m.getMetadata().getValue(), m.getMetadataMask().getValue());
                break;
            case WRITE_ACTIONS:
                builder.deferred();
                buildActions(((OFInstructionWriteActions) in).getActions(), builder);
                break;
            case APPLY_ACTIONS:
                builder.immediate();
                buildActions(((OFInstructionApplyActions) in).getActions(), builder);
                break;
            case CLEAR_ACTIONS:
                builder.wipeDeferred();
                break;
            case STAT_TRIGGER:
                OFInstructionStatTrigger statTrigger = (OFInstructionStatTrigger) in;
                buildStatTrigger(statTrigger.getThresholds(), statTrigger.getFlags(), builder);
                break;
            case EXPERIMENTER:
                break;
            case METER:
                break;
            default:
                log.warn("Unknown instructions type {}", in.getType());
        }
    }
    return builder.build();
}
#end_block

#method_before
public static TrafficTreatment.Builder configureTreatmentBuilder(List<OFAction> actions, TrafficTreatment.Builder builder, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter interpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        interpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        interpreter = null;
    }
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanPcp(pcp.getVlanPcp().getValue());
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06 || exp.getExperimenter() == 0x748771) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    CircuitSignalID circuitSignalID = ((OFOxmOchSigid) ct.getField()).getValue();
                    builder.add(Instructions.modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
                } else if (interpreter != null) {
                    builder.extension(interpreter.mapAction(exp), deviceId);
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                OFActionSetField setField = (OFActionSetField) act;
                handleSetField(builder, setField, driverHandler, deviceId);
                break;
            case POP_MPLS:
                OFActionPopMpls popMpls = (OFActionPopMpls) act;
                builder.popMpls(new EthType(popMpls.getEthertype().getValue()));
                break;
            case PUSH_MPLS:
                builder.pushMpls();
                break;
            case COPY_TTL_IN:
                builder.copyTtlIn();
                break;
            case COPY_TTL_OUT:
                builder.copyTtlOut();
                break;
            case DEC_MPLS_TTL:
                builder.decMplsTtl();
                break;
            case DEC_NW_TTL:
                builder.decNwTtl();
                break;
            case GROUP:
                OFActionGroup group = (OFActionGroup) act;
                builder.group(new GroupId(group.getGroup().getGroupNumber()));
                break;
            case SET_QUEUE:
                OFActionSetQueue setQueue = (OFActionSetQueue) act;
                builder.setQueue(setQueue.getQueueId());
                break;
            case ENQUEUE:
                OFActionEnqueue enqueue = (OFActionEnqueue) act;
                builder.setQueue(enqueue.getQueueId(), PortNumber.portNumber(enqueue.getPort().getPortNumber()));
                break;
            case STRIP_VLAN:
            case POP_VLAN:
                builder.popVlan();
                break;
            case PUSH_VLAN:
                OFActionPushVlan pushVlan = (OFActionPushVlan) act;
                builder.pushVlan(new EthType((short) pushVlan.getEthertype().getValue()));
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_PBB:
            case PUSH_PBB:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder;
}
#method_after
public static TrafficTreatment.Builder configureTreatmentBuilder(List<OFAction> actions, TrafficTreatment.Builder builder, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter interpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        interpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        interpreter = null;
    }
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanPcp(pcp.getVlanPcp().getValue());
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06 || exp.getExperimenter() == 0x748771) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    CircuitSignalID circuitSignalID = ((OFOxmOchSigid) ct.getField()).getValue();
                    builder.add(Instructions.modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
                } else if (interpreter != null) {
                    builder.extension(interpreter.mapAction(exp), deviceId);
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                OFActionSetField setField = (OFActionSetField) act;
                handleSetField(builder, setField, driverHandler, deviceId);
                break;
            case POP_MPLS:
                OFActionPopMpls popMpls = (OFActionPopMpls) act;
                builder.popMpls(new EthType(popMpls.getEthertype().getValue()));
                break;
            case PUSH_MPLS:
                builder.pushMpls();
                break;
            case COPY_TTL_IN:
                builder.copyTtlIn();
                break;
            case COPY_TTL_OUT:
                builder.copyTtlOut();
                break;
            case DEC_MPLS_TTL:
                builder.decMplsTtl();
                break;
            case DEC_NW_TTL:
                builder.decNwTtl();
                break;
            case GROUP:
                OFActionGroup group = (OFActionGroup) act;
                builder.group(new GroupId(group.getGroup().getGroupNumber()));
                break;
            case SET_QUEUE:
                OFActionSetQueue setQueue = (OFActionSetQueue) act;
                builder.setQueue(setQueue.getQueueId());
                break;
            case ENQUEUE:
                OFActionEnqueue enqueue = (OFActionEnqueue) act;
                builder.setQueue(enqueue.getQueueId(), PortNumber.portNumber(enqueue.getPort().getPortNumber()));
                break;
            case STRIP_VLAN:
            case POP_VLAN:
                builder.popVlan();
                break;
            case PUSH_VLAN:
                OFActionPushVlan pushVlan = (OFActionPushVlan) act;
                builder.pushVlan(new EthType((short) pushVlan.getEthertype().getValue()));
                break;
            case METER:
                OFActionMeter actionMeter = (OFActionMeter) act;
                builder.meter(MeterId.meterId(actionMeter.getMeterId()));
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_PBB:
            case PUSH_PBB:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder;
}
#end_block

#method_before
private static DriverHandler getDriver(DeviceId devId, DriverService driverService) {
    Driver driver = driverService.getDriver(devId);
    DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, devId));
    return handler;
}
#method_after
protected static DriverHandler getDriver(DeviceId deviceId, DriverService driverService) {
    Driver driver = driverService.getDriver(deviceId);
    DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
    return handler;
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(Dpid.uri(dpid));
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(deviceId, removed, getDriver(deviceId)).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg, getDriver(deviceId));
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.TABLE) {
                pushTableStatistics(dpid, (OFTableStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            handleErrorMsg(deviceId, msg);
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(Dpid.uri(dpid));
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(deviceId, removed, getDriver(deviceId)).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg, getDriver(deviceId));
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.TABLE) {
                pushTableStatistics(dpid, (OFTableStatsReply) msg);
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW_LIGHTWEIGHT) {
                pushFlowLightWeightMetrics(dpid, (OFFlowLightweightStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            handleErrorMsg(deviceId, msg);
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
private void dispatchMessage(OFMessage m) {
    if (dispatchBacklog.isEmpty()) {
        if (!dispatchQueue.offer(m)) {
            // queue full
            channel.config().setAutoRead(false);
            // put it on the head of backlog
            dispatchBacklog.addFirst(m);
            return;
        }
    } else {
        dispatchBacklog.addLast(m);
    }
    while (!dispatchBacklog.isEmpty()) {
        OFMessage msg = dispatchBacklog.pop();
        if (!dispatchQueue.offer(msg)) {
            // queue full
            channel.config().setAutoRead(false);
            // put it back to the head of backlog
            dispatchBacklog.addFirst(msg);
            return;
        }
    }
    if (dispatcherHandle.isDone()) {
        // dispatcher terminated for some reason, restart
        dispatcherHandle = dispatcher.submit(() -> {
            try {
                List<OFMessage> msgs = new ArrayList<>();
                for (; ; ) {
                    // wait for new message
                    OFMessage msg = dispatchQueue.take();
                    sw.handleMessage(msg);
                    while (dispatchQueue.drainTo(msgs, MSG_READ_BUFFER) > 0) {
                        if (!channel.config().isAutoRead()) {
                            channel.config().setAutoRead(true);
                        }
                        msgs.forEach(sw::handleMessage);
                        msgs.clear();
                    }
                    if (!channel.config().isAutoRead()) {
                        channel.config().setAutoRead(true);
                    }
                    if (Thread.currentThread().isInterrupted()) {
                        return;
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                // interrupted. gracefully shutting down
                return;
            }
        });
    }
}
#method_after
private void dispatchMessage(OFMessage m) {
    if (dispatchBacklog.isEmpty()) {
        if (!dispatchQueue.offer(m)) {
            // queue full
            channel.config().setAutoRead(false);
            // put it on the head of backlog
            dispatchBacklog.addFirst(m);
            return;
        }
    } else {
        dispatchBacklog.addLast(m);
    }
    while (!dispatchBacklog.isEmpty()) {
        OFMessage msg = dispatchBacklog.pop();
        if (!dispatchQueue.offer(msg)) {
            // queue full
            channel.config().setAutoRead(false);
            // put it back to the head of backlog
            dispatchBacklog.addFirst(msg);
            return;
        }
    }
    if (dispatcherHandle.isDone()) {
        // dispatcher terminated for some reason, restart
        dispatcherHandle = dispatcher.submit(() -> {
            try {
                List<OFMessage> msgs = new ArrayList<>();
                for (; ; ) {
                    // wait for new message
                    OFMessage msg = dispatchQueue.take();
                    sw.handleMessage(msg);
                    while (dispatchQueue.drainTo(msgs, MSG_READ_BUFFER) > 0) {
                        if (!channel.config().isAutoRead()) {
                            channel.config().setAutoRead(true);
                        }
                        msgs.forEach(sw::handleMessage);
                        msgs.clear();
                    }
                    if (!channel.config().isAutoRead()) {
                        channel.config().setAutoRead(true);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                // interrupted. gracefully shutting down
                return;
            }
        });
    }
}
#end_block

#method_before
private void removeHostOrRoute(boolean directConnFlag, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("extractPrefix  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    MacAddress clientMac = clientPacket.getSourceMAC();
    log.debug("client mac {} client vlan {}", HexString.toHexString(clientMac.toBytes(), ":"), vlanId);
    // add host or route
    if (isDhcp6Release(dhcp6Packet)) {
        IpAddress ip = null;
        if (directConnFlag) {
            // Add to host store if it is connected to network directly
            ip = extractIpAddress(dhcp6Packet);
            if (ip != null) {
                HostId hostId = HostId.hostId(clientMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                // Remove host's ip of  when dhcp release msg is received
                providerService.removeIpFromHost(hostId, ip);
            } else {
                log.debug("ipAddress not found. Do not add Host for directly connected.");
            }
        } else {
            // Remove from route store if it is not connected to network directly
            IpAddress nextHopIp = null;
            // pick out the first ip address
            HostId gwHostId = HostId.hostId(clientMac, vlanId);
            Host gwHost = hostService.getHost(gwHostId);
            if (gwHost == null) {
                log.warn("Can't find gateway host for hostId {}", gwHostId);
                return;
            }
            nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp6).filter(ip6 -> ip6.isLinkLocal()).map(IpAddress::getIp6Address).findFirst().orElse(null);
            if (nextHopIp == null) {
                log.warn("Can't find link-local IP address of gateway {}", gwHost);
                return;
            }
            DHCP6 leafDhcp = getDhcp6Leaf(dhcp6Packet);
            ip = extractIpAddress(leafDhcp);
            if (ip == null) {
                log.debug("ip is null");
            } else {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ip.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
            IpPrefix ipPrefix = extractPrefix(leafDhcp);
            if (ipPrefix == null) {
                log.debug("ipPrefix is null ");
            } else {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(ipPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
            }
        }
    }
}
#method_after
private void removeHostOrRoute(boolean directConnFlag, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("extractPrefix  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    MacAddress clientMac = clientPacket.getSourceMAC();
    log.debug("client mac {} client vlan {}", HexString.toHexString(clientMac.toBytes(), ":"), vlanId);
    // add host or route
    if (isDhcp6Release(dhcp6Packet)) {
        IpAddress ip = null;
        if (directConnFlag) {
            // Add to host store if it is connected to network directly
            ip = extractIpAddress(dhcp6Packet);
            if (ip != null) {
                HostId hostId = HostId.hostId(clientMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                // Remove host's ip of  when dhcp release msg is received
                providerService.removeIpFromHost(hostId, ip);
            } else {
                log.debug("ipAddress not found. Do not add Host for directly connected.");
            }
        } else {
            // Remove from route store if it is not connected to network directly
            // pick out the first link-local ip address
            IpAddress nextHopIp = getFirstIpByHost(clientMac, vlanId);
            if (nextHopIp == null) {
                log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", clientMac, vlanId);
                return;
            }
            DHCP6 leafDhcp = getDhcp6Leaf(dhcp6Packet);
            ip = extractIpAddress(leafDhcp);
            if (ip == null) {
                log.debug("ip is null");
            } else {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ip.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
            IpPrefix ipPrefix = extractPrefix(leafDhcp);
            if (ipPrefix == null) {
                log.debug("ipPrefix is null ");
            } else {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(ipPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
            }
        }
    }
}
#end_block

#method_before
private void addHostOrRoute(boolean directConnFlag, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress clientMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    // add host or route
    if (isDhcp6Reply(dhcp6Relay)) {
        IpAddress ip = null;
        if (directConnFlag) {
            // Add to host store if it connect to network directly
            ip = extractIpAddress(embeddedDhcp6);
            if (ip != null) {
                Set<IpAddress> ips = Sets.newHashSet(ip);
                // FIXME: we should use vlan id from original packet (solicit, request)
                HostId hostId = HostId.hostId(clientMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(clientMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(clientMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            } else {
                log.warn("ipAddress not found. Do not add Host for directly connected.");
            }
        } else {
            // Add to route store if it does not connect to network directly
            IpAddress nextHopIp = null;
            // pick out the first ip address
            HostId gwHostId = HostId.hostId(clientMac, vlanId);
            Host gwHost = hostService.getHost(gwHostId);
            if (gwHost == null) {
                log.warn("Can't find gateway host for hostId {}", gwHostId);
                return;
            }
            nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp6).filter(ip6 -> ip6.isLinkLocal()).map(IpAddress::getIp6Address).findFirst().orElse(null);
            if (nextHopIp == null) {
                log.warn("Can't find link-local IP address of gateway {}", gwHost);
                return;
            }
            DHCP6 leafDhcp = getDhcp6Leaf(embeddedDhcp6);
            ip = extractIpAddress(leafDhcp);
            if (ip == null) {
                log.warn("ip is null");
            } else {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.warn("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
            IpPrefix ipPrefix = extractPrefix(leafDhcp);
            if (ipPrefix == null) {
                log.warn("ipPrefix is null ");
            } else {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.warn("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
            }
        }
    }
}
#method_after
private void addHostOrRoute(boolean directConnFlag, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress clientMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    // add host or route
    if (isDhcp6Reply(dhcp6Relay)) {
        IpAddress ip = null;
        if (directConnFlag) {
            // Add to host store if it connect to network directly
            ip = extractIpAddress(embeddedDhcp6);
            if (ip != null) {
                Set<IpAddress> ips = Sets.newHashSet(ip);
                // FIXME: we should use vlan id from original packet (solicit, request)
                HostId hostId = HostId.hostId(clientMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(clientMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(clientMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            } else {
                log.warn("ipAddress not found. Do not add Host for directly connected.");
            }
        } else {
            // Add to route store if it does not connect to network directly
            // pick out the first link-local ip address
            IpAddress nextHopIp = getFirstIpByHost(clientMac, vlanId);
            if (nextHopIp == null) {
                log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", clientMac, vlanId);
                return;
            }
            DHCP6 leafDhcp = getDhcp6Leaf(embeddedDhcp6);
            ip = extractIpAddress(leafDhcp);
            if (ip == null) {
                log.warn("ip is null");
            } else {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.warn("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
            IpPrefix ipPrefix = extractPrefix(leafDhcp);
            if (ipPrefix == null) {
                log.warn("ipPrefix is null ");
            } else {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.warn("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
            }
        }
    }
}
#end_block

#method_before
@Before
public void setup() {
    manager = new DhcpRelayManager();
    manager.cfgService = createNiceMock(NetworkConfigRegistry.class);
    expect(manager.cfgService.getConfig(APP_ID, DefaultDhcpRelayConfig.class)).andReturn(CONFIG).anyTimes();
    expect(manager.cfgService.getConfig(APP_ID, IndirectDhcpRelayConfig.class)).andReturn(CONFIG_INDIRECT).anyTimes();
    manager.coreService = createNiceMock(CoreService.class);
    expect(manager.coreService.registerApplication(anyString())).andReturn(APP_ID).anyTimes();
    manager.hostService = createNiceMock(HostService.class);
    expect(manager.hostService.getHostsByIp(anyObject())).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHost(OUTER_RELAY_HOST_ID)).andReturn(OUTER_RELAY_HOST).anyTimes();
    packetService = new MockPacketService();
    manager.packetService = packetService;
    manager.compCfgService = createNiceMock(ComponentConfigService.class);
    deviceService = createNiceMock(DeviceService.class);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(deviceService.getDevice(DEV_2_ID)).andReturn(device).anyTimes();
    replay(deviceService, device);
    mockRouteStore = new MockRouteStore();
    mockDhcpRelayStore = new MockDhcpRelayStore();
    manager.dhcpRelayStore = mockDhcpRelayStore;
    manager.deviceService = deviceService;
    manager.interfaceService = new MockInterfaceService();
    flowObjectiveService = EasyMock.niceMock(FlowObjectiveService.class);
    mockHostProviderService = createNiceMock(HostProviderService.class);
    v4Handler = new Dhcp4HandlerImpl();
    v4Handler.providerService = mockHostProviderService;
    v4Handler.dhcpRelayStore = mockDhcpRelayStore;
    v4Handler.hostService = manager.hostService;
    v4Handler.interfaceService = manager.interfaceService;
    v4Handler.packetService = manager.packetService;
    v4Handler.routeStore = mockRouteStore;
    v4Handler.coreService = createNiceMock(CoreService.class);
    v4Handler.flowObjectiveService = flowObjectiveService;
    v4Handler.appId = TestApplicationId.create(Dhcp4HandlerImpl.DHCP_V4_RELAY_APP);
    v4Handler.deviceService = deviceService;
    manager.v4Handler = v4Handler;
    v6Handler = new Dhcp6HandlerImpl();
    v6Handler.dhcpRelayStore = mockDhcpRelayStore;
    v6Handler.hostService = manager.hostService;
    v6Handler.interfaceService = manager.interfaceService;
    v6Handler.packetService = manager.packetService;
    v6Handler.routeStore = mockRouteStore;
    v6Handler.providerService = mockHostProviderService;
    v6Handler.coreService = createNiceMock(CoreService.class);
    v6Handler.flowObjectiveService = flowObjectiveService;
    v6Handler.appId = TestApplicationId.create(Dhcp6HandlerImpl.DHCP_V6_RELAY_APP);
    v6Handler.deviceService = deviceService;
    manager.v6Handler = v6Handler;
    // properties
    Dictionary<String, Object> dictionary = createNiceMock(Dictionary.class);
    expect(dictionary.get("arpEnabled")).andReturn(true).anyTimes();
    ComponentContext context = createNiceMock(ComponentContext.class);
    expect(context.getProperties()).andReturn(dictionary).anyTimes();
    replay(manager.cfgService, manager.coreService, manager.hostService, manager.compCfgService, dictionary, context);
    manager.activate(context);
}
#method_after
@Before
public void setup() {
    manager = new DhcpRelayManager();
    manager.cfgService = createNiceMock(NetworkConfigRegistry.class);
    expect(manager.cfgService.getConfig(APP_ID, DefaultDhcpRelayConfig.class)).andReturn(CONFIG).anyTimes();
    expect(manager.cfgService.getConfig(APP_ID, IndirectDhcpRelayConfig.class)).andReturn(CONFIG_INDIRECT).anyTimes();
    manager.coreService = createNiceMock(CoreService.class);
    expect(manager.coreService.registerApplication(anyString())).andReturn(APP_ID).anyTimes();
    manager.hostService = createNiceMock(HostService.class);
    expect(manager.hostService.getHostsByIp(OUTER_RELAY_IP_V6)).andReturn(ImmutableSet.of(OUTER_RELAY_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(SERVER_IP)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(SERVER_IP_V6)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(GATEWAY_IP)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(GATEWAY_IP_V6)).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHostsByIp(CLIENT_LL_IP_V6)).andReturn(ImmutableSet.of(EXISTS_HOST)).anyTimes();
    expect(manager.hostService.getHost(OUTER_RELAY_HOST_ID)).andReturn(OUTER_RELAY_HOST).anyTimes();
    packetService = new MockPacketService();
    manager.packetService = packetService;
    manager.compCfgService = createNiceMock(ComponentConfigService.class);
    deviceService = createNiceMock(DeviceService.class);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(deviceService.getDevice(DEV_2_ID)).andReturn(device).anyTimes();
    replay(deviceService, device);
    mockRouteStore = new MockRouteStore();
    mockDhcpRelayStore = new MockDhcpRelayStore();
    manager.dhcpRelayStore = mockDhcpRelayStore;
    manager.deviceService = deviceService;
    manager.interfaceService = new MockInterfaceService();
    flowObjectiveService = EasyMock.niceMock(FlowObjectiveService.class);
    mockHostProviderService = createNiceMock(HostProviderService.class);
    v4Handler = new Dhcp4HandlerImpl();
    v4Handler.providerService = mockHostProviderService;
    v4Handler.dhcpRelayStore = mockDhcpRelayStore;
    v4Handler.hostService = manager.hostService;
    v4Handler.interfaceService = manager.interfaceService;
    v4Handler.packetService = manager.packetService;
    v4Handler.routeStore = mockRouteStore;
    v4Handler.coreService = createNiceMock(CoreService.class);
    v4Handler.flowObjectiveService = flowObjectiveService;
    v4Handler.appId = TestApplicationId.create(Dhcp4HandlerImpl.DHCP_V4_RELAY_APP);
    v4Handler.deviceService = deviceService;
    manager.v4Handler = v4Handler;
    v6Handler = new Dhcp6HandlerImpl();
    v6Handler.dhcpRelayStore = mockDhcpRelayStore;
    v6Handler.hostService = manager.hostService;
    v6Handler.interfaceService = manager.interfaceService;
    v6Handler.packetService = manager.packetService;
    v6Handler.routeStore = mockRouteStore;
    v6Handler.providerService = mockHostProviderService;
    v6Handler.coreService = createNiceMock(CoreService.class);
    v6Handler.flowObjectiveService = flowObjectiveService;
    v6Handler.appId = TestApplicationId.create(Dhcp6HandlerImpl.DHCP_V6_RELAY_APP);
    v6Handler.deviceService = deviceService;
    manager.v6Handler = v6Handler;
    // properties
    Dictionary<String, Object> dictionary = createNiceMock(Dictionary.class);
    expect(dictionary.get("arpEnabled")).andReturn(true).anyTimes();
    ComponentContext context = createNiceMock(ComponentContext.class);
    expect(context.getProperties()).andReturn(dictionary).anyTimes();
    replay(manager.cfgService, manager.coreService, manager.hostService, manager.compCfgService, dictionary, context);
    manager.activate(context);
}
#end_block

#method_before
@Test
public void relayDhcp6WithoutAgentInfo() {
    replay(mockHostProviderService);
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.REQUEST.value(), CLIENT_MAC, CLIENT_VLAN, CLIENT_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    assertEquals(0, mockRouteStore.routes.size());
    Capture<HostDescription> capturedHostDesc = newCapture();
    mockHostProviderService.hostDetected(eq(HostId.hostId(CLIENT_MAC, CLIENT_VLAN)), capture(capturedHostDesc), eq(false));
    replay(mockHostProviderService);
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT_CP, CLIENT_MAC, CLIENT_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    verify(mockHostProviderService);
    assertEquals(0, mockRouteStore.routes.size());
    HostDescription host = capturedHostDesc.getValue();
    assertEquals(CLIENT_VLAN, host.vlan());
    assertEquals(CLIENT_CP.deviceId(), host.location().elementId());
    assertEquals(CLIENT_CP.port(), host.location().port());
    assertEquals(1, host.ipAddress().size());
    assertEquals(IP_FOR_CLIENT_V6, host.ipAddress().iterator().next());
    // send release
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.RELEASE.value(), CLIENT_MAC, CLIENT_VLAN, CLIENT_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    assertEquals(null, manager.hostService.getHost(HostId.hostId(CLIENT_MAC, CLIENT_VLAN)));
}
#method_after
@Test
public void relayDhcp6WithoutAgentInfo() {
    replay(mockHostProviderService);
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.REQUEST.value(), CLIENT_MAC, CLIENT_VLAN, CLIENT_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    assertEquals(0, mockRouteStore.routes.size());
    Capture<HostDescription> capturedHostDesc = newCapture();
    mockHostProviderService.hostDetected(eq(HostId.hostId(CLIENT_MAC, CLIENT_VLAN)), capture(capturedHostDesc), eq(false));
    replay(mockHostProviderService);
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT_CP, CLIENT_MAC, CLIENT_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0, false, CLIENT_VLAN));
    verify(mockHostProviderService);
    assertEquals(0, mockRouteStore.routes.size());
    HostDescription host = capturedHostDesc.getValue();
    assertEquals(CLIENT_VLAN, host.vlan());
    assertEquals(CLIENT_CP.deviceId(), host.location().elementId());
    assertEquals(CLIENT_CP.port(), host.location().port());
    assertEquals(1, host.ipAddress().size());
    assertEquals(IP_FOR_CLIENT_V6, host.ipAddress().iterator().next());
    // send release
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.RELEASE.value(), CLIENT_MAC, CLIENT_VLAN, CLIENT_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    assertEquals(null, manager.hostService.getHost(HostId.hostId(CLIENT_MAC, CLIENT_VLAN)));
}
#end_block

#method_before
@Test
public void relayDhcp6WithAgentInfo() {
    replay(mockHostProviderService);
    // Assume outer dhcp6 relay agent exists in store already
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.REQUEST.value(), CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, OUTER_RELAY_IP_V6, 1));
    assertEquals(0, mockRouteStore.routes.size());
    // To add a host entry, send reply for gw
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT2_CP, CLIENT2_MAC, CLIENT2_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT2_CP, CLIENT2_MAC, CLIENT2_VLAN, OUTER_RELAY_IP_V6, 1));
    // won't trigger the host provider service
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    // ipAddress and prefix real(2)
    assertEquals(0, mockRouteStore.routes.size());
    Route aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(IP_FOR_CLIENT_V6)).findFirst().orElse(null);
    // real notEquals
    assertEquals(null, aRoute);
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(PREFIX_FOR_CLIENT_V6)).findFirst().orElse(null);
    // real notEquals
    assertEquals(null, aRoute);
    // send release msg
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.RELEASE.value(), CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, OUTER_RELAY_IP_V6, 1));
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(IP_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertEquals(null, aRoute);
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(PREFIX_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertEquals(null, aRoute);
    assertEquals(0, mockRouteStore.routes.size());
}
#method_after
@Test
public void relayDhcp6WithAgentInfo() {
    replay(mockHostProviderService);
    // Assume outer dhcp6 relay agent exists in store already
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.REQUEST.value(), CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, OUTER_RELAY_IP_V6, 1));
    assertEquals(0, mockRouteStore.routes.size());
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT2_CP, CLIENT2_MAC, CLIENT2_VLAN, OUTER_RELAY_IP_V6, 1, false, CLIENT2_VLAN));
    // won't trigger the host provider service
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    // ipAddress and prefix
    assertEquals(2, mockRouteStore.routes.size());
    Route aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(IP_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertNotEquals(null, aRoute);
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(PREFIX_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertNotEquals(null, aRoute);
    // send release msg
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.RELEASE.value(), CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, OUTER_RELAY_IP_V6, 1));
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(IP_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertEquals(null, aRoute);
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(PREFIX_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertEquals(null, aRoute);
    assertEquals(0, mockRouteStore.routes.size());
}
#end_block

#method_before
@Test
public void relayDhcp6WithAgentInfoWrongVlan() {
    replay(mockHostProviderService);
    // Assume outer dhcp6 relay agent exists in store already
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.REQUEST.value(), CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 1));
    assertEquals(0, mockRouteStore.routes.size());
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT2_CP, CLIENT2_MAC, // mismatch
    CLIENT_BOGUS_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 1));
    // won't trigger the host provider service
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    // ipAddress and prefix
    assertEquals(0, mockRouteStore.routes.size());
}
#method_after
@Test
public void relayDhcp6WithAgentInfoWrongVlan() {
    replay(mockHostProviderService);
    // Assume outer dhcp6 relay agent exists in store already
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.REQUEST.value(), CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 1));
    assertEquals(0, mockRouteStore.routes.size());
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT2_CP, CLIENT2_MAC, CLIENT2_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 1, true, // mismatch
    CLIENT_BOGUS_VLAN));
    // won't trigger the host provider service
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    // ipAddress and prefix
    assertEquals(0, mockRouteStore.routes.size());
}
#end_block

#method_before
@Test
public void testDhcp6DualHome() {
    PacketContext packetContext = new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT_DH_CP, CLIENT_MAC, CLIENT_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0);
    reset(manager.hostService);
    expect(manager.hostService.getHostsByIp(CLIENT_LL_IP_V6)).andReturn(ImmutableSet.of(EXISTS_HOST)).anyTimes();
    // FIXME: currently DHCPv6 has a bug, we can't get correct vlan of client......
    // XXX: The vlan relied from DHCP6 handler might be wrong, do hack here
    HostId hostId = HostId.hostId(CLIENT_MAC, VlanId.NONE);
    expect(manager.hostService.getHost(hostId)).andReturn(EXISTS_HOST).anyTimes();
    // XXX: sometimes this will work, sometimes not
    expect(manager.hostService.getHost(CLIENT_HOST_ID)).andReturn(EXISTS_HOST).anyTimes();
    Capture<HostDescription> capturedHostDesc = newCapture();
    // XXX: also a hack here
    mockHostProviderService.hostDetected(eq(hostId), capture(capturedHostDesc), eq(false));
    expectLastCall().anyTimes();
    mockHostProviderService.hostDetected(eq(CLIENT_HOST_ID), capture(capturedHostDesc), eq(false));
    expectLastCall().anyTimes();
    replay(mockHostProviderService, manager.hostService);
    packetService.processPacket(packetContext);
    verify(mockHostProviderService);
    HostDescription hostDesc = capturedHostDesc.getValue();
    Set<HostLocation> hostLocations = hostDesc.locations();
    assertEquals(2, hostLocations.size());
    assertTrue(hostLocations.contains(CLIENT_LOCATION));
    assertTrue(hostLocations.contains(CLIENT_DH_LOCATION));
}
#method_after
@Test
public void testDhcp6DualHome() {
    PacketContext packetContext = new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT_DH_CP, CLIENT_MAC, CLIENT_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0, false, CLIENT_VLAN);
    reset(manager.hostService);
    expect(manager.hostService.getHostsByIp(CLIENT_LL_IP_V6)).andReturn(ImmutableSet.of(EXISTS_HOST)).anyTimes();
    // FIXME: currently DHCPv6 has a bug, we can't get correct vlan of client......
    // XXX: The vlan relied from DHCP6 handler might be wrong, do hack here
    HostId hostId = HostId.hostId(CLIENT_MAC, VlanId.NONE);
    expect(manager.hostService.getHost(hostId)).andReturn(EXISTS_HOST).anyTimes();
    // XXX: sometimes this will work, sometimes not
    expect(manager.hostService.getHost(CLIENT_HOST_ID)).andReturn(EXISTS_HOST).anyTimes();
    Capture<HostDescription> capturedHostDesc = newCapture();
    // XXX: also a hack here
    mockHostProviderService.hostDetected(eq(hostId), capture(capturedHostDesc), eq(false));
    expectLastCall().anyTimes();
    mockHostProviderService.hostDetected(eq(CLIENT_HOST_ID), capture(capturedHostDesc), eq(false));
    expectLastCall().anyTimes();
    replay(mockHostProviderService, manager.hostService);
    packetService.processPacket(packetContext);
    verify(mockHostProviderService);
    HostDescription hostDesc = capturedHostDesc.getValue();
    Set<HostLocation> hostLocations = hostDesc.locations();
    assertEquals(2, hostLocations.size());
    assertTrue(hostLocations.contains(CLIENT_LOCATION));
    assertTrue(hostLocations.contains(CLIENT_DH_LOCATION));
}
#end_block

#method_before
public void delete() {
    try {
        Files.delete(partition.getDataFolder().toPath());
    } catch (IOException e) {
        log.error("Failed to delete partition: {}", e);
    }
}
#method_after
public void delete() {
    try {
        Files.walkFileTree(partition.getDataFolder().toPath(), new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                Files.delete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    } catch (IOException e) {
        log.error("Failed to delete partition: {}", e);
    }
}
#end_block

#method_before
public CompletableFuture<Void> fork(Partition fromPartition) {
    log.info("Forking server for partition {} ({}->{})", partition.getId(), partition.getVersion(), fromPartition.getVersion());
    RaftServer.Builder builder = RaftServer.newBuilder(localMemberId).withName(fromPartition.getName()).withType(RaftMember.Type.PASSIVE).withProtocol(new RaftServerCommunicator(fromPartition.getName(), Serializer.using(StorageNamespaces.RAFT_PROTOCOL), clusterCommunicator)).withElectionTimeout(Duration.ofMillis(ELECTION_TIMEOUT_MILLIS)).withHeartbeatInterval(Duration.ofMillis(HEARTBEAT_INTERVAL_MILLIS)).withStorage(RaftStorage.newBuilder().withStorageLevel(StorageLevel.MAPPED).withSerializer(new AtomixSerializerAdapter(Serializer.using(StorageNamespaces.RAFT_STORAGE))).withDirectory(partition.getDataFolder()).withMaxSegmentSize(MAX_SEGMENT_SIZE).build());
    StoragePartition.RAFT_SERVICES.forEach(builder::addService);
    RaftServer server = builder.build();
    return server.join(fromPartition.getMembers().stream().map(id -> MemberId.from(id.id())).collect(Collectors.toList())).thenCompose(v -> server.shutdown()).thenCompose(v -> {
        // Delete the cluster configuration file from the forked partition.
        try {
            Files.delete(new File(partition.getDataFolder(), "atomix.conf").toPath());
        } catch (IOException e) {
            log.error("Failed to delete partition configuration: {}", e);
        }
        // Build and bootstrap a new server.
        this.server = buildServer();
        return this.server.bootstrap();
    }).whenComplete((r, e) -> {
        if (e == null) {
            log.info("Successfully forked server for partition {} ({}->{})", partition.getId(), fromPartition.getVersion(), partition.getVersion());
        } else {
            log.info("Failed to fork server for partition {} ({}->{})", partition.getId(), fromPartition.getVersion(), partition.getVersion(), e);
        }
    }).thenApply(v -> null);
}
#method_after
public CompletableFuture<Void> fork(Partition fromPartition) {
    log.info("Forking server for partition {} ({}->{})", partition.getId(), fromPartition.getVersion(), partition.getVersion());
    RaftServer.Builder builder = RaftServer.newBuilder(localMemberId).withName(String.format("partition-%s", fromPartition.getId())).withProtocol(new RaftServerCommunicator(String.format("partition-%s-%s", fromPartition.getId(), fromPartition.getVersion()), Serializer.using(StorageNamespaces.RAFT_PROTOCOL), clusterCommunicator)).withElectionTimeout(Duration.ofMillis(ELECTION_TIMEOUT_MILLIS)).withHeartbeatInterval(Duration.ofMillis(HEARTBEAT_INTERVAL_MILLIS)).withStorage(RaftStorage.newBuilder().withPrefix(String.format("partition-%s", partition.getId())).withStorageLevel(StorageLevel.MAPPED).withSerializer(new AtomixSerializerAdapter(Serializer.using(StorageNamespaces.RAFT_STORAGE))).withDirectory(partition.getDataFolder()).withMaxSegmentSize(MAX_SEGMENT_SIZE).build());
    StoragePartition.RAFT_SERVICES.forEach(builder::addService);
    RaftServer server = builder.build();
    // Create a collection of members currently in the source partition.
    Collection<MemberId> members = fromPartition.getMembers().stream().map(id -> MemberId.from(id.id())).collect(Collectors.toList());
    // If this node is a member of the partition, join the partition. Otherwise, listen to the partition.
    CompletableFuture<RaftServer> future = members.contains(localMemberId) ? server.bootstrap(members) : server.listen(members);
    // files when a node leaves the cluster so we can't do that here.
    return future.thenCompose(v -> server.shutdown()).thenCompose(v -> {
        // Delete the cluster configuration file from the forked partition.
        try {
            Files.delete(new File(partition.getDataFolder(), String.format("partition-%s.conf", partition.getId())).toPath());
        } catch (IOException e) {
            log.error("Failed to delete partition configuration: {}", e);
        }
        // Build and bootstrap a new server.
        this.server = buildServer();
        return this.server.bootstrap();
    }).whenComplete((r, e) -> {
        if (e == null) {
            log.info("Successfully forked server for partition {} ({}->{})", partition.getId(), fromPartition.getVersion(), partition.getVersion());
        } else {
            log.info("Failed to fork server for partition {} ({}->{})", partition.getId(), fromPartition.getVersion(), partition.getVersion(), e);
        }
    }).thenApply(v -> null);
}
#end_block

#method_before
private RaftServer buildServer() {
    RaftServer.Builder builder = RaftServer.newBuilder(localMemberId).withName(partition.getName()).withProtocol(new RaftServerCommunicator(partition.getName(), Serializer.using(StorageNamespaces.RAFT_PROTOCOL), clusterCommunicator)).withElectionTimeout(Duration.ofMillis(ELECTION_TIMEOUT_MILLIS)).withHeartbeatInterval(Duration.ofMillis(HEARTBEAT_INTERVAL_MILLIS)).withStorage(RaftStorage.newBuilder().withStorageLevel(StorageLevel.MAPPED).withSerializer(new AtomixSerializerAdapter(Serializer.using(StorageNamespaces.RAFT_STORAGE))).withDirectory(partition.getDataFolder()).withMaxSegmentSize(MAX_SEGMENT_SIZE).build());
    StoragePartition.RAFT_SERVICES.forEach(builder::addService);
    return builder.build();
}
#method_after
private RaftServer buildServer() {
    RaftServer.Builder builder = RaftServer.newBuilder(localMemberId).withName(String.format("partition-%s", partition.getId())).withProtocol(new RaftServerCommunicator(String.format("partition-%s-%s", partition.getId(), partition.getVersion()), Serializer.using(StorageNamespaces.RAFT_PROTOCOL), clusterCommunicator)).withElectionTimeout(Duration.ofMillis(ELECTION_TIMEOUT_MILLIS)).withHeartbeatInterval(Duration.ofMillis(HEARTBEAT_INTERVAL_MILLIS)).withStorage(RaftStorage.newBuilder().withPrefix(String.format("partition-%s", partition.getId())).withStorageLevel(StorageLevel.MAPPED).withSerializer(new AtomixSerializerAdapter(Serializer.using(StorageNamespaces.RAFT_STORAGE))).withDirectory(partition.getDataFolder()).withMaxSegmentSize(MAX_SEGMENT_SIZE).build());
    StoragePartition.RAFT_SERVICES.forEach(builder::addService);
    return builder.build();
}
#end_block

#method_before
@Activate
public void activate() {
    eventDispatcher.addSink(PartitionEvent.class, listenerRegistry);
    currentClusterMetadata.set(metadataService.getClusterMetadata());
    clusterService.addListener(clusterListener);
    upgradeService.addListener(upgradeListener);
    metadataService.addListener(metadataListener);
    // If an upgrade is currently in progress and this node is an upgraded node, initialize upgrade partitions.
    CompletableFuture<Void> openFuture;
    if (upgradeService.isUpgrading() && upgradeService.isLocalUpgraded()) {
        currentClusterMetadata.get().getPartitions().forEach(partition -> {
            // Create a default partition and assign it to inactive partitions. This node will join
            // inactive partitions to participate in consensus for fault tolerance, but the partitions
            // won't be accessible via client proxies.
            inactivePartitions.put(partition.getId(), new DefaultStoragePartition(partition, clusterCommunicator, clusterService));
            // Create a forked partition and assign it to active partitions. These partitions will be
            // forked from commit logs for previous version partitions.
            Partition forkedPartition = computeInitialPartition(partition, upgradeService.getState().target(), getSortedNodes());
            activePartitions.put(partition.getId(), new ForkedStoragePartition(forkedPartition, partition, clusterCommunicator, clusterService));
        });
        // We have to fork existing partitions before we can start inactive partition servers to
        // avoid duplicate message handlers when both servers are running.
        openFuture = CompletableFuture.allOf(activePartitions.values().stream().map(StoragePartition::open).toArray(CompletableFuture[]::new)).thenCompose(v -> CompletableFuture.allOf(inactivePartitions.values().stream().map(StoragePartition::open).toArray(CompletableFuture[]::new)));
    } else {
        currentClusterMetadata.get().getPartitions().forEach(partition -> activePartitions.put(partition.getId(), new DefaultStoragePartition(partition, clusterCommunicator, clusterService)));
        openFuture = CompletableFuture.allOf(activePartitions.values().stream().map(StoragePartition::open).toArray(CompletableFuture[]::new));
    }
    openFuture.join();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    eventDispatcher.addSink(PartitionEvent.class, listenerRegistry);
    currentClusterMetadata.set(metadataService.getClusterMetadata());
    clusterService.addListener(clusterListener);
    upgradeService.addListener(upgradeListener);
    metadataService.addListener(metadataListener);
    // If an upgrade is currently in progress and this node is an upgraded node, initialize upgrade partitions.
    CompletableFuture<Void> openFuture;
    if (upgradeService.isUpgrading() && upgradeService.isLocalUpgraded()) {
        currentClusterMetadata.get().getPartitions().forEach(partition -> {
            // Create a default partition and assign it to inactive partitions. This node will join
            // inactive partitions to participate in consensus for fault tolerance, but the partitions
            // won't be accessible via client proxies.
            inactivePartitions.put(partition.getId(), new InactiveStoragePartition(partition, clusterCommunicator, clusterService));
            // Create a forked partition and assign it to active partitions. These partitions will be
            // forked from commit logs for previous version partitions.
            Partition forkedPartition = computeInitialPartition(partition, upgradeService.getState().target(), getLocalNodes());
            activePartitions.put(partition.getId(), new ForkedStoragePartition(forkedPartition, partition, clusterCommunicator, clusterService));
        });
        // We have to fork existing partitions before we can start inactive partition servers to
        // avoid duplicate message handlers when both servers are running.
        openFuture = CompletableFuture.allOf(activePartitions.values().stream().map(StoragePartition::open).toArray(CompletableFuture[]::new)).thenCompose(v -> CompletableFuture.allOf(inactivePartitions.values().stream().map(StoragePartition::open).toArray(CompletableFuture[]::new)));
    } else {
        currentClusterMetadata.get().getPartitions().forEach(partition -> activePartitions.put(partition.getId(), new ActiveStoragePartition(partition, clusterCommunicator, clusterService)));
        openFuture = CompletableFuture.allOf(activePartitions.values().stream().map(StoragePartition::open).toArray(CompletableFuture[]::new));
    }
    openFuture.join();
    log.info("Started");
}
#end_block

#method_before
private void processInstanceReady(NodeId nodeId) {
    if (upgradeService.isUpgrading()) {
        for (StoragePartition partition : activePartitions.values()) {
            Partition newPartition = computeFinalPartition(partition.partition, upgradeService.getState().target(), getSortedNodes());
            partition.onUpdate(newPartition);
        }
    }
}
#method_after
private void processInstanceReady(NodeId nodeId) {
    if (upgradeService.isUpgrading() && upgradeService.isLocalUpgraded()) {
        currentClusterMetadata.get().getPartitions().forEach(partition -> {
            StoragePartition activePartition = activePartitions.get(partition.getId());
            if (activePartition != null) {
                Partition newPartition = computeFinalPartition(partition, upgradeService.getState().target(), getLocalNodes());
                log.info("Updating storage partition {}: {}", partition, newPartition);
                activePartition.onUpdate(newPartition);
            }
        });
    }
}
#end_block

#method_before
private void processUpgradeComplete(Upgrade upgrade) {
    if (!inactivePartitions.isEmpty()) {
        Collection<CompletableFuture<Void>> closeFutures = inactivePartitions.values().stream().map(StoragePartition::delete).collect(Collectors.toList());
        CompletableFuture.allOf(closeFutures.toArray(new CompletableFuture[closeFutures.size()])).join();
    }
}
#method_after
private void processUpgradeComplete(Upgrade upgrade) {
    if (!inactivePartitions.isEmpty()) {
        List<CompletableFuture<Void>> futures = inactivePartitions.values().stream().map(StoragePartition::delete).collect(Collectors.toList());
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()])).thenRun(() -> {
            try {
                Files.delete(new File(InactiveStoragePartition.INACTIVE_DIR).toPath());
            } catch (IOException e) {
                log.error("Failed to delete partition archive");
            }
        });
        inactivePartitions.clear();
    }
}
#end_block

#method_before
private CompletableFuture<StoragePartitionClient> openClient() {
    client = new StoragePartitionClient(this, MemberId.from(localNodeId.id()), new RaftClientCommunicator(partition.getName(), Serializer.using(StorageNamespaces.RAFT_PROTOCOL), clusterCommunicator));
    return client.open().thenApply(v -> client);
}
#method_after
private CompletableFuture<StoragePartitionClient> openClient() {
    client = new StoragePartitionClient(this, MemberId.from(localNodeId.id()), new RaftClientCommunicator(String.format("partition-%s-%s", partition.getId(), partition.getVersion()), Serializer.using(StorageNamespaces.RAFT_PROTOCOL), clusterCommunicator));
    return client.open().thenApply(v -> client);
}
#end_block

#method_before
public CompletableFuture<Void> leaveCluster() {
    return server != null ? server.closeAndExit() : CompletableFuture.completedFuture(null);
}
#method_after
public CompletableFuture<Void> leaveCluster() {
    return server != null ? server.closeAndExit().thenRun(() -> server.delete()) : CompletableFuture.completedFuture(null);
}
#end_block

#method_before
void onUpdate(Partition newValue) {
    boolean wasPresent = partition.getMembers().contains(localNodeId);
    boolean isPresent = newValue.getMembers().contains(localNodeId);
    this.partition = newValue;
    if ((wasPresent && isPresent) || (!wasPresent && !isPresent)) {
        // no action needed
        return;
    }
    // only need to do action if our membership changed
    if (wasPresent) {
        leaveCluster();
    } else if (isPresent) {
        joinCluster();
    }
}
#method_after
void onUpdate(Partition newValue) {
    boolean wasPresent = partition.getMembers().contains(localNodeId);
    boolean isPresent = newValue.getMembers().contains(localNodeId);
    this.partition = newValue;
    if ((wasPresent && isPresent) || (!wasPresent && !isPresent)) {
        // no action needed
        return;
    }
    // Only need to do action if our membership changed
    if (wasPresent) {
        leaveCluster();
    } else if (isPresent) {
        joinCluster();
    }
}
#end_block

#method_before
@Activate
public void activate() {
    partition = new DefaultStoragePartition(new DefaultPartition(PartitionId.SHARED, null, clusterService.getNodes().stream().map(ControllerNode::id).collect(Collectors.toSet())), clusterCommunicator, clusterService);
    partition.open().join();
    primitiveCreator = partition.client();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    partition = new ActiveStoragePartition(new DefaultPartition(PartitionId.SHARED, null, clusterService.getNodes().stream().map(ControllerNode::id).collect(Collectors.toSet())), clusterCommunicator, clusterService);
    partition.open().join();
    primitiveCreator = partition.client();
    log.info("Started");
}
#end_block

#method_before
@Override
public <K, V> EventuallyConsistentMapBuilder<K, V> eventuallyConsistentMapBuilder() {
    checkPermission(STORAGE_WRITE);
    return new EventuallyConsistentMapBuilderImpl<>(clusterService, clusterCommunicator, persistenceService);
}
#method_after
@Override
public <K, V> EventuallyConsistentMapBuilder<K, V> eventuallyConsistentMapBuilder() {
    checkPermission(STORAGE_WRITE);
    final NodeId localNodeId = clusterService.getLocalNode().id();
    Supplier<List<NodeId>> peersSupplier = () -> clusterService.getNodes().stream().map(ControllerNode::id).filter(nodeId -> !nodeId.equals(localNodeId)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
    Supplier<List<NodeId>> bootstrapPeersSupplier = () -> clusterService.getNodes().stream().map(ControllerNode::id).filter(id -> !localNodeId.equals(id)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
    return new EventuallyConsistentMapBuilderImpl<>(localNodeId, clusterCommunicator, persistenceService, peersSupplier, bootstrapPeersSupplier);
}
#end_block

#method_before
@Override
public <E> DistributedSetBuilder<E> setBuilder() {
    checkPermission(STORAGE_WRITE);
    return new DefaultDistributedSetBuilder<>(() -> this.<E, Boolean>consistentMapBuilder());
}
#method_after
@Override
public <E> DistributedSetBuilder<E> setBuilder() {
    checkPermission(STORAGE_WRITE);
    return new DefaultDistributedSetBuilder<>(this::<E, Boolean>consistentMapBuilder);
}
#end_block

#method_before
@Override
public <K, V> EventuallyConsistentMapBuilder<K, V> eventuallyConsistentMapBuilder() {
    checkPermission(STORAGE_WRITE);
    return new EventuallyConsistentMapBuilderImpl<>(clusterService, clusterCommunicator, persistenceService, membershipService);
}
#method_after
@Override
public <K, V> EventuallyConsistentMapBuilder<K, V> eventuallyConsistentMapBuilder() {
    checkPermission(STORAGE_WRITE);
    final NodeId localNodeId = clusterService.getLocalNode().id();
    Supplier<List<NodeId>> peersSupplier = () -> membershipService.getMembers().stream().map(Member::nodeId).filter(nodeId -> !nodeId.equals(localNodeId)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
    Supplier<List<NodeId>> bootstrapPeersSupplier = () -> {
        if (membershipService.getMembers().size() == 1) {
            return clusterService.getNodes().stream().map(ControllerNode::id).filter(id -> !localNodeId.equals(id)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
        } else {
            return membershipService.getMembers().stream().map(Member::nodeId).filter(id -> !localNodeId.equals(id)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
        }
    };
    return new EventuallyConsistentMapBuilderImpl<>(localNodeId, clusterCommunicator, persistenceService, peersSupplier, bootstrapPeersSupplier);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    clusterService = createMock(ClusterService.class);
    membershipService = createMock(MembershipService.class);
    expect(clusterService.getLocalNode()).andReturn(self).anyTimes();
    expect(clusterService.getNodes()).andReturn(ImmutableSet.of(self)).anyTimes();
    replay(clusterService);
    clusterCommunicator = createMock(ClusterCommunicationService.class);
    persistenceService = new TestPersistenceService();
    // Add expectation for adding cluster message subscribers which
    // delegate to our ClusterCommunicationService implementation. This
    // allows us to get a reference to the map's internal cluster message
    // handlers so we can induce events coming in from a peer.
    clusterCommunicator.<Object, Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Function.class), anyObject(Function.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    clusterCommunicator.<Object, Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Function.class), anyObject(Function.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    clusterCommunicator.<Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Consumer.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    clusterCommunicator.<Object, Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Function.class), anyObject(Function.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    clusterCommunicator.<Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Consumer.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    replay(clusterCommunicator);
    clockService = new SequentialClockService<>();
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(TestTimestamp.class);
    ecMap = new EventuallyConsistentMapBuilderImpl<String, String>(clusterService, clusterCommunicator, persistenceService, membershipService).withName(MAP_NAME).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp(k, v)).withCommunicationExecutor(MoreExecutors.newDirectExecutorService()).withPersistence().withVersionIsolation(false).build();
    // Reset ready for tests to add their own expectations
    reset(clusterCommunicator);
}
#method_after
@Before
public void setUp() throws Exception {
    clusterCommunicator = createMock(ClusterCommunicationService.class);
    persistenceService = new TestPersistenceService();
    // Add expectation for adding cluster message subscribers which
    // delegate to our ClusterCommunicationService implementation. This
    // allows us to get a reference to the map's internal cluster message
    // handlers so we can induce events coming in from a peer.
    clusterCommunicator.<Object, Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Function.class), anyObject(Function.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    clusterCommunicator.<Object, Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Function.class), anyObject(Function.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    clusterCommunicator.<Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Consumer.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    clusterCommunicator.<Object, Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Function.class), anyObject(Function.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    clusterCommunicator.<Object>addSubscriber(anyObject(MessageSubject.class), anyObject(Function.class), anyObject(Consumer.class), anyObject(Executor.class));
    expectLastCall().andDelegateTo(new TestClusterCommunicationService()).times(1);
    replay(clusterCommunicator);
    clockService = new SequentialClockService<>();
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(TestTimestamp.class);
    ecMap = new EventuallyConsistentMapBuilderImpl<String, String>(NodeId.nodeId("0"), clusterCommunicator, persistenceService, peersHandler, peersHandler).withName(MAP_NAME).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp(k, v)).withCommunicationExecutor(MoreExecutors.newDirectExecutorService()).withPersistence().build();
    // Reset ready for tests to add their own expectations
    reset(clusterCommunicator);
}
#end_block

#method_before
private void queueUpdate(UpdateEntry<K, V> event, Collection<NodeId> peers) {
    if (peers == null) {
        // we have no friends :(
        return;
    }
    if (versionIsolated) {
        membershipService.getMembers().stream().filter(member -> peers.contains(member.nodeId())).forEach(member -> senderPending.computeIfAbsent(member.nodeId(), unusedKey -> new EventAccumulator(member.nodeId())).add(event));
    } else {
        peers.forEach(node -> senderPending.computeIfAbsent(node, unusedKey -> new EventAccumulator(node)).add(event));
    }
}
#method_after
private void queueUpdate(UpdateEntry<K, V> event, Collection<NodeId> peers) {
    if (peers == null) {
        // we have no friends :(
        return;
    }
    peers.forEach(node -> senderPending.computeIfAbsent(node, unusedKey -> new EventAccumulator(node)).add(event));
}
#end_block

#method_before
private Optional<NodeId> pickRandomActivePeer() {
    List<NodeId> activePeers;
    if (versionIsolated) {
        activePeers = clusterService.getNodes().stream().map(ControllerNode::id).filter(id -> !localNodeId.equals(id)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
    } else {
        activePeers = membershipService.getMembers().stream().map(Member::nodeId).filter(id -> !localNodeId.equals(id)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
    }
    Collections.shuffle(activePeers);
    return activePeers.stream().findFirst();
}
#method_after
private Optional<NodeId> pickRandomActivePeer() {
    List<NodeId> activePeers = peersSupplier.get();
    Collections.shuffle(activePeers);
    return activePeers.stream().findFirst();
}
#end_block

#method_before
private List<EventuallyConsistentMapEvent<K, V>> antiEntropyCheckLocalItems(AntiEntropyAdvertisement<K> ad) {
    final List<EventuallyConsistentMapEvent<K, V>> externalEvents = Lists.newLinkedList();
    final NodeId sender = ad.sender();
    // ignore advertisments from other version nodes.
    if (versionIsolated && membershipService.getMembers().stream().noneMatch(k -> k.nodeId().equals(sender))) {
        return externalEvents;
    }
    final List<NodeId> peers = ImmutableList.of(sender);
    Set<K> staleOrMissing = new HashSet<>();
    Set<K> locallyUnknown = new HashSet<>(ad.digest().keySet());
    items.forEach((key, localValue) -> {
        locallyUnknown.remove(key);
        MapValue.Digest remoteValueDigest = ad.digest().get(key);
        if (remoteValueDigest == null || localValue.isNewerThan(remoteValueDigest.timestamp())) {
            // local value is more recent, push to sender
            queueUpdate(new UpdateEntry<>(key, localValue), peers);
        } else if (remoteValueDigest != null && remoteValueDigest.isNewerThan(localValue.digest()) && remoteValueDigest.isTombstone()) {
            // remote value is more recent and a tombstone: update local value
            MapValue<V> tombstone = MapValue.tombstone(remoteValueDigest.timestamp());
            MapValue<V> previousValue = removeInternal(key, Optional.empty(), Optional.of(tombstone));
            if (previousValue != null && previousValue.isAlive()) {
                externalEvents.add(new EventuallyConsistentMapEvent<>(mapName, REMOVE, key, previousValue.get()));
            }
        } else if (remoteValueDigest.isNewerThan(localValue.digest())) {
            // Not a tombstone and remote is newer
            staleOrMissing.add(key);
        }
    });
    // Keys missing in local map
    staleOrMissing.addAll(locallyUnknown);
    // Request updates that we missed out on
    sendUpdateRequestToPeer(sender, staleOrMissing);
    return externalEvents;
}
#method_after
private List<EventuallyConsistentMapEvent<K, V>> antiEntropyCheckLocalItems(AntiEntropyAdvertisement<K> ad) {
    final List<EventuallyConsistentMapEvent<K, V>> externalEvents = Lists.newLinkedList();
    final NodeId sender = ad.sender();
    final List<NodeId> peers = ImmutableList.of(sender);
    Set<K> staleOrMissing = new HashSet<>();
    Set<K> locallyUnknown = new HashSet<>(ad.digest().keySet());
    items.forEach((key, localValue) -> {
        locallyUnknown.remove(key);
        MapValue.Digest remoteValueDigest = ad.digest().get(key);
        if (remoteValueDigest == null || localValue.isNewerThan(remoteValueDigest.timestamp())) {
            // local value is more recent, push to sender
            queueUpdate(new UpdateEntry<>(key, localValue), peers);
        } else if (remoteValueDigest.isNewerThan(localValue.digest()) && remoteValueDigest.isTombstone()) {
            // remote value is more recent and a tombstone: update local value
            MapValue<V> tombstone = MapValue.tombstone(remoteValueDigest.timestamp());
            MapValue<V> previousValue = removeInternal(key, Optional.empty(), Optional.of(tombstone));
            if (previousValue != null && previousValue.isAlive()) {
                externalEvents.add(new EventuallyConsistentMapEvent<>(mapName, REMOVE, key, previousValue.get()));
            }
        } else if (remoteValueDigest.isNewerThan(localValue.digest())) {
            // Not a tombstone and remote is newer
            staleOrMissing.add(key);
        }
    });
    // Keys missing in local map
    staleOrMissing.addAll(locallyUnknown);
    // Request updates that we missed out on
    sendUpdateRequestToPeer(sender, staleOrMissing);
    return externalEvents;
}
#end_block

#method_before
private void handleUpdateRequests(UpdateRequest<K> request) {
    final Set<K> keys = request.keys();
    final NodeId sender = request.sender();
    final List<NodeId> peers = ImmutableList.of(sender);
    // ignore advertisments from other version nodes.
    if (versionIsolated && membershipService.getMembers().stream().noneMatch(k -> k.nodeId().equals(sender))) {
        return;
    }
    keys.forEach(key -> queueUpdate(new UpdateEntry<>(key, items.get(key)), peers));
}
#method_after
private void handleUpdateRequests(UpdateRequest<K> request) {
    final Set<K> keys = request.keys();
    final NodeId sender = request.sender();
    final List<NodeId> peers = ImmutableList.of(sender);
    keys.forEach(key -> queueUpdate(new UpdateEntry<>(key, items.get(key)), peers));
}
#end_block

#method_before
private void purgeTombstones() {
    /*
         * In order to mitigate the resource exhaustion that can ensue due to an ever-growing set
         * of tombstones we employ the following heuristic to purge old tombstones periodically.
         * First, we keep track of the time (local system time) when we were able to have a successful
         * AE exchange with each peer. The smallest (or oldest) such time across *all* peers is regarded
         * as the time before which all tombstones are considered safe to purge.
         */
    long currentSafeTombstonePurgeTime = clusterService.getNodes().stream().map(ControllerNode::id).filter(id -> !id.equals(localNodeId)).map(id -> antiEntropyTimes.getOrDefault(id, 0L)).reduce(Math::min).orElse(0L);
    if (currentSafeTombstonePurgeTime == previousTombstonePurgeTime) {
        return;
    }
    List<Map.Entry<K, MapValue<V>>> tombStonesToDelete = items.entrySet().stream().filter(e -> e.getValue().isTombstone()).filter(e -> e.getValue().creationTime() <= currentSafeTombstonePurgeTime).collect(Collectors.toList());
    previousTombstonePurgeTime = currentSafeTombstonePurgeTime;
    tombStonesToDelete.forEach(entry -> items.remove(entry.getKey(), entry.getValue()));
}
#method_after
private void purgeTombstones() {
    /*
         * In order to mitigate the resource exhaustion that can ensue due to an ever-growing set
         * of tombstones we employ the following heuristic to purge old tombstones periodically.
         * First, we keep track of the time (local system time) when we were able to have a successful
         * AE exchange with each peer. The smallest (or oldest) such time across *all* peers is regarded
         * as the time before which all tombstones are considered safe to purge.
         */
    long currentSafeTombstonePurgeTime = peersSupplier.get().stream().map(id -> antiEntropyTimes.getOrDefault(id, 0L)).reduce(Math::min).orElse(0L);
    if (currentSafeTombstonePurgeTime == previousTombstonePurgeTime) {
        return;
    }
    List<Map.Entry<K, MapValue<V>>> tombStonesToDelete = items.entrySet().stream().filter(e -> e.getValue().isTombstone()).filter(e -> e.getValue().creationTime() <= currentSafeTombstonePurgeTime).collect(Collectors.toList());
    previousTombstonePurgeTime = currentSafeTombstonePurgeTime;
    tombStonesToDelete.forEach(entry -> items.remove(entry.getKey(), entry.getValue()));
}
#end_block

#method_before
private void bootstrap() {
    List<NodeId> activePeers = clusterService.getNodes().stream().map(ControllerNode::id).filter(id -> !localNodeId.equals(id)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
    if (activePeers.isEmpty()) {
        return;
    }
    try {
        requestBootstrapFromPeers(activePeers).get(DistributedPrimitive.DEFAULT_OPERATION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    } catch (ExecutionException | InterruptedException | TimeoutException e) {
        log.debug("Failed to bootstrap ec map {}: {}", mapName, ExceptionUtils.getStackTrace(e));
    }
}
#method_after
private void bootstrap() {
    List<NodeId> activePeers = bootstrapPeersSupplier.get();
    if (activePeers.isEmpty()) {
        return;
    }
    try {
        requestBootstrapFromPeers(activePeers).get(DistributedPrimitive.DEFAULT_OPERATION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
    } catch (ExecutionException | InterruptedException | TimeoutException e) {
        log.debug("Failed to bootstrap ec map {}: {}", mapName, ExceptionUtils.getStackTrace(e));
    }
}
#end_block

#method_before
@Activate
public void activate() {
    partition = new StoragePartition(new DefaultPartition(PartitionId.SHARED, clusterService.getNodes().stream().map(ControllerNode::id).collect(Collectors.toSet())), null, null, clusterCommunicator, clusterService, new File(System.getProperty("karaf.data") + "/partitions/coordination"));
    partition.open().join();
    primitiveCreator = partition.client();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    partition = new StoragePartition(new DefaultPartition(PartitionId.SHARED, clusterService.getNodes().stream().map(ControllerNode::id).collect(Collectors.toSet())), null, null, clusterCommunicator, clusterService, new File(PARTITIONS_DIR + "/coordination"));
    partition.open().join();
    primitiveCreator = partition.client();
    log.info("Started");
}
#end_block

#method_before
@Override
public <K, V> EventuallyConsistentMapBuilder<K, V> eventuallyConsistentMapBuilder() {
    checkPermission(STORAGE_WRITE);
    return new EventuallyConsistentMapBuilderImpl<>(clusterService, clusterCommunicator, persistenceService, membershipService);
}
#method_after
@Override
public <K, V> EventuallyConsistentMapBuilder<K, V> eventuallyConsistentMapBuilder() {
    checkPermission(STORAGE_WRITE);
    final NodeId localNodeId = clusterService.getLocalNode().id();
    Supplier<List<NodeId>> peersSupplier = () -> clusterService.getNodes().stream().map(ControllerNode::id).filter(nodeId -> !nodeId.equals(localNodeId)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
    Supplier<List<NodeId>> bootstrapPeersSupplier = () -> clusterService.getNodes().stream().map(ControllerNode::id).filter(id -> !localNodeId.equals(id)).filter(id -> clusterService.getState(id).isActive()).collect(Collectors.toList());
    return new EventuallyConsistentMapBuilderImpl<>(localNodeId, clusterCommunicator, persistenceService, peersSupplier, bootstrapPeersSupplier);
}
#end_block

#method_before
@Override
public <E> DistributedSetBuilder<E> setBuilder() {
    checkPermission(STORAGE_WRITE);
    return new DefaultDistributedSetBuilder<>(() -> this.<E, Boolean>consistentMapBuilder());
}
#method_after
@Override
public <E> DistributedSetBuilder<E> setBuilder() {
    checkPermission(STORAGE_WRITE);
    return new DefaultDistributedSetBuilder<>(this::<E, Boolean>consistentMapBuilder);
}
#end_block

#method_before
@Override
public EventuallyConsistentMap<K, V> build() {
    checkNotNull(name, "name is a mandatory parameter");
    checkNotNull(timestampProvider, "timestampProvider is a mandatory parameter");
    if (serializer == null && serializerBuilder != null) {
        serializer = serializerBuilder.build(name);
    }
    checkNotNull(serializer, "serializer is a mandatory parameter");
    return new EventuallyConsistentMapImpl<>(name, clusterService, clusterCommunicator, serializer, timestampProvider, peerUpdateFunction, eventExecutor, communicationExecutor, backgroundExecutor, tombstonesDisabled, antiEntropyPeriod, antiEntropyTimeUnit, convergeFaster, persistent, persistenceService, membershipService, versionIsolated);
}
#method_after
@Override
public EventuallyConsistentMap<K, V> build() {
    checkNotNull(name, "name is a mandatory parameter");
    checkNotNull(timestampProvider, "timestampProvider is a mandatory parameter");
    if (serializer == null && serializerBuilder != null) {
        serializer = serializerBuilder.build(name);
    }
    checkNotNull(serializer, "serializer is a mandatory parameter");
    checkNotNull(localNodeId, "local node id cannot be null");
    return new EventuallyConsistentMapImpl<>(localNodeId, name, clusterCommunicator, serializer, timestampProvider, peerUpdateFunction, eventExecutor, communicationExecutor, backgroundExecutor, tombstonesDisabled, antiEntropyPeriod, antiEntropyTimeUnit, convergeFaster, persistent, persistenceService, peersSupplier, bootstrapPeersSupplier);
}
#end_block

#method_before
@Override
public void processMonitorPacket(JSONObject msg) {
    eventDispatcher.post(new ArtemisEvent(ArtemisEvent.Type.BGPUPDATE_ADDED, msg));
}
#method_after
@Override
public void processMonitorPacket(JSONObject msg) {
    // TODO: in future maybe store the BGP Update message and propagate it to the cluster instead of Events
    eventDispatcher.post(new ArtemisEvent(ArtemisEvent.Type.BGPUPDATE_ADDED, msg));
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_REGISTERED:
        case CONFIG_UNREGISTERED:
            {
                break;
            }
        case CONFIG_REMOVED:
            {
                if (event.configClass() == CONFIG_CLASS) {
                    prefixHandlers.forEach(PrefixHandler::stopPrefixMonitors);
                    prefixHandlers.clear();
                }
                break;
            }
        case CONFIG_UPDATED:
        case CONFIG_ADDED:
            {
                if (event.configClass() == CONFIG_CLASS) {
                    event.config().ifPresent(config -> {
                        ArtemisConfig artemisConfig = (ArtemisConfig) config;
                        Set<IpPrefix> ipPrefixes = artemisConfig.prefixesToMonitor();
                        Map<String, Set<String>> monitors = artemisConfig.activeMonitors();
                        prefixHandlers = ipPrefixes.stream().map(prefix -> new PrefixHandler(prefix, monitors, packetProcessor)).collect(Collectors.toSet());
                        prefixHandlers.forEach(PrefixHandler::startPrefixMonitors);
                    });
                }
                break;
            }
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_REGISTERED:
        case CONFIG_UNREGISTERED:
            {
                break;
            }
        case CONFIG_REMOVED:
            {
                if (event.configClass() == CONFIG_CLASS) {
                    prefixHandlers.forEach(PrefixHandler::stopPrefixMonitors);
                    prefixHandlers.clear();
                }
                break;
            }
        case CONFIG_UPDATED:
        case CONFIG_ADDED:
            {
                if (event.configClass() == CONFIG_CLASS) {
                    event.config().ifPresent(config -> {
                        ArtemisConfig artemisConfig = (ArtemisConfig) config;
                        Set<IpPrefix> ipPrefixes = artemisConfig.prefixesToMonitor();
                        Map<String, Set<String>> monitors = artemisConfig.activeMonitors();
                        prefixHandlers.forEach(PrefixHandler::stopPrefixMonitors);
                        prefixHandlers.clear();
                        prefixHandlers = ipPrefixes.stream().map(prefix -> new PrefixHandler(prefix, monitors, packetProcessor)).collect(Collectors.toSet());
                        prefixHandlers.forEach(PrefixHandler::startPrefixMonitors);
                    });
                }
                break;
            }
        default:
            break;
    }
}
#end_block

#method_before
@Activate
public void activate() {
    local = clusterService.getLocalNode().id();
    meters = storageService.<MeterKey, MeterData>consistentMapBuilder().withName(METERSTORE).withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), MeterKey.class, MeterData.class, DefaultMeter.class, DefaultBand.class, Band.Type.class, MeterState.class, Meter.Unit.class, MeterFailReason.class)).build();
    meters.addListener(mapListener);
    meterFeatures = storageService.<MeterFeaturesKey, MeterFeatures>consistentMapBuilder().withName(METERFEATURESSTORE).withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), MeterFeaturesKey.class, MeterFeatures.class, DefaultMeterFeatures.class, Band.Type.class, Meter.Unit.class, MeterFailReason.class)).build();
    availableMeterIds = storageService.<DeviceId, BitSet>consistentMapBuilder().withName(AVAILABLEMETERIDSTORE).withSerializer(Serializer.using(KryoNamespaces.API)).build();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    local = clusterService.getLocalNode().id();
    meters = storageService.<MeterKey, MeterData>consistentMapBuilder().withName(METERSTORE).withSerializer(Serializer.using(KryoNamespaces.API, MeterKey.class, MeterData.class, DefaultMeter.class, DefaultBand.class, Band.Type.class, MeterState.class, Meter.Unit.class, MeterFailReason.class)).build();
    meters.addListener(mapListener);
    meterFeatures = storageService.<MeterFeaturesKey, MeterFeatures>consistentMapBuilder().withName(METERFEATURESSTORE).withSerializer(Serializer.using(KryoNamespaces.API, MeterFeaturesKey.class, MeterFeatures.class, DefaultMeterFeatures.class, Band.Type.class, Meter.Unit.class, MeterFailReason.class)).build();
    // Init the set of the available ids
    availableMeterIds = new DefaultDistributedSet<>(storageService.<MeterKey>setBuilder().withName(AVAILABLEMETERIDSTORE).withSerializer(Serializer.using(KryoNamespaces.API, MeterKey.class)).build(), DistributedPrimitive.DEFAULT_OPERATION_TIMEOUT_MILLIS);
    // Init atomic map counters
    meterIdGenerators = storageService.<DeviceId>atomicCounterMapBuilder().withName(METERIDSTORE).withSerializer(Serializer.using(KryoNamespaces.API)).build();
    log.info("Started");
}
#end_block

#method_before
@Override
public CompletableFuture<MeterStoreResult> storeMeter(Meter meter) {
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    updateMeterIdAvailability(meter.deviceId(), meter.id(), false);
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    try {
        meters.put(key, data);
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#method_after
@Override
public CompletableFuture<MeterStoreResult> storeMeter(Meter meter) {
    // Init steps
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    // Store the future related to the operation
    futures.put(key, future);
    // Store the meter data
    MeterData data = new MeterData(meter, null, local);
    try {
        meters.put(key, data);
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    // Done, return the future
    return future;
}
#end_block

#method_before
@Override
public CompletableFuture<MeterStoreResult> deleteMeter(Meter meter) {
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    // that it has been removed from the dataplane.
    try {
        if (meters.computeIfPresent(key, (k, v) -> data) == null) {
            future.complete(MeterStoreResult.success());
        }
        updateMeterIdAvailability(meter.deviceId(), meter.id(), true);
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#method_after
@Override
public CompletableFuture<MeterStoreResult> deleteMeter(Meter meter) {
    // Init steps
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    // Store the future related to the operation
    futures.put(key, future);
    // Create the meter data
    MeterData data = new MeterData(meter, null, local);
    // that it has been removed from the dataplane.
    try {
        // If it does not exist in the system
        if (meters.computeIfPresent(key, (k, v) -> data) == null) {
            // Complete immediately
            future.complete(MeterStoreResult.success());
        }
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    // Done, return the future
    return future;
}
#end_block

#method_before
@Override
public void deleteMeterNow(Meter m) {
    MeterKey key = MeterKey.key(m.deviceId(), m.id());
    futures.remove(key);
    meters.remove(key);
    notifyDelegate(new MeterEvent(MeterEvent.Type.METER_REMOVED, m));
}
#method_after
@Override
public void deleteMeterNow(Meter m) {
    // Create the key
    MeterKey key = MeterKey.key(m.deviceId(), m.id());
    // Remove the future
    futures.remove(key);
    // Remove the meter
    meters.remove(key);
    // Free the id
    freeMeterId(m.deviceId(), m.id());
    // Finally notify the delegate
    notifyDelegate(new MeterEvent(MeterEvent.Type.METER_REMOVED, m));
}
#end_block

#method_before
private void updateMeterIdAvailability(DeviceId deviceId, MeterId id, boolean available) {
    availableMeterIds.compute(deviceId, (k, v) -> {
        v = v == null ? new BitSet() : v;
        v.set(id.id().intValue(), available);
        return v;
    });
}
#method_after
private boolean updateMeterIdAvailability(DeviceId deviceId, MeterId id, boolean available) {
    // According to available, make available or unavailable a meter key
    return available ? availableMeterIds.add(MeterKey.key(deviceId, id)) : availableMeterIds.remove(MeterKey.key(deviceId, id));
}
#end_block

#method_before
@Override
public MeterId firstReusableMeterId(DeviceId deviceId) {
    Versioned<BitSet> bitSetVersioned = availableMeterIds.get(deviceId);
    if (bitSetVersioned == null) {
        return null;
    }
    BitSet value = bitSetVersioned.value();
    int nextSetBit = value.nextSetBit(1);
    if (nextSetBit < 0) {
        return null;
    }
    return MeterId.meterId(nextSetBit);
}
#method_after
private MeterId firstReusableMeterId(DeviceId deviceId) {
    // Filter key related to device id, and reduce to meter ids
    Set<MeterId> localAvailableMeterIds = availableMeterIds.stream().filter(meterKey -> meterKey.deviceId().equals(deviceId)).map(MeterKey::meterId).collect(Collectors.toSet());
    // Get next available id
    MeterId meterId = getNextAvailableId(localAvailableMeterIds);
    // Iterate until there are items
    while (meterId != null) {
        // If we are able to reserve the id
        if (updateMeterIdAvailability(deviceId, meterId, false)) {
            // Just end
            return meterId;
        }
        // Update the set
        localAvailableMeterIds.remove(meterId);
        // Try another time
        meterId = getNextAvailableId(localAvailableMeterIds);
    }
    // No reusable ids
    return null;
}
#end_block

#method_before
@Override
public Collection<DelayMeasurementEntry> getAllDms(MdId mdName, MaIdShort maName, MepId mepId) throws CfmConfigException, SoamConfigException {
    Collection<DelayMeasurementEntry> dmEntries = new ArrayList<>();
    if (mdName.equals(MDNAME1) && maName.equals(MANAME1) && mepId.equals(MEPID1)) {
        dmEntries.add(dmEntry1);
        return dmEntries;
    }
    return null;
}
#method_after
@Override
public Collection<DelayMeasurementEntry> getAllDms(MdId mdName, MaIdShort maName, MepId mepId) throws CfmConfigException, SoamConfigException {
    Collection<DelayMeasurementEntry> dmEntries = new ArrayList<>();
    if (mdName.equals(MDNAME1) && maName.equals(MANAME1) && mepId.equals(MEPID1)) {
        dmEntries.add(dmEntry1);
        return dmEntries;
    }
    return new ArrayList<>();
}
#end_block

#method_before
private ByteBuffer nameBuffer(PiPipeconf pipeconf) {
    // Length of the name + name.
    String name = pipeconf.id().toString();
    return ByteBuffer.allocate(4 + name.length()).order(ByteOrder.LITTLE_ENDIAN).putInt(name.length()).put(name.getBytes(StandardCharsets.UTF_8));
}
#method_after
private ByteBuffer nameBuffer(PiPipeconf pipeconf) {
    // Length of the name + name.
    String name = pipeconf.id().toString();
    return ByteBuffer.allocate(Integer.BYTES + name.length()).order(ByteOrder.LITTLE_ENDIAN).putInt(name.length()).put(name.getBytes(StandardCharsets.UTF_8));
}
#end_block

#method_before
private ByteBuffer extensionBuffer(PiPipeconf pipeconf, ExtensionType extType) {
    if (!pipeconf.extension(extType).isPresent()) {
        log.warn("Missing extension {} in pipeconf {}", extType, pipeconf.id());
        throw new ExtensionException();
    }
    try {
        byte[] bytes = IOUtils.toByteArray(pipeconf.extension(extType).get());
        // Length of the extension + bytes.
        return ByteBuffer.allocate(4 + bytes.length).order(ByteOrder.LITTLE_ENDIAN).putInt(bytes.length).put(bytes);
    } catch (IOException ex) {
        log.warn("Unable to read extension {} from pipeconf {}: {}", extType, pipeconf.id(), ex.getMessage());
        throw new ExtensionException();
    }
}
#method_after
private ByteBuffer extensionBuffer(PiPipeconf pipeconf, ExtensionType extType) {
    if (!pipeconf.extension(extType).isPresent()) {
        log.warn("Missing extension {} in pipeconf {}", extType, pipeconf.id());
        throw new ExtensionException();
    }
    try {
        byte[] bytes = IOUtils.toByteArray(pipeconf.extension(extType).get());
        // Length of the extension + bytes.
        return ByteBuffer.allocate(Integer.BYTES + bytes.length).order(ByteOrder.LITTLE_ENDIAN).putInt(bytes.length).put(bytes);
    } catch (IOException ex) {
        log.warn("Unable to read extension {} from pipeconf {}: {}", extType, pipeconf.id(), ex.getMessage());
        throw new ExtensionException();
    }
}
#end_block

#method_before
@Override
public Optional<PiPipeconf> getDefaultPipeconf() {
    return Optional.of(PipeconfLoader.DEFAULT_PIPECONF);
}
#method_after
@Override
public Optional<PiPipeconf> getDefaultPipeconf() {
    return Optional.of(PipeconfLoader.BASIC_PIPECONF);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> setPipelineConfig(PiPipeconf pipeconf, ByteBuffer byteBuffer) {
    return supplyInContext(() -> doSetPipelineConfig(pipeconf, byteBuffer), "setPipelineConfig");
}
#method_after
@Override
public CompletableFuture<Boolean> setPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    return supplyInContext(() -> doSetPipelineConfig(pipeconf, deviceData), "setPipelineConfig");
}
#end_block

#method_before
protected void updateConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        IndirectDhcpRelayConfig indirectConfig = (IndirectDhcpRelayConfig) config;
        v4Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
        v6Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        DefaultDhcpRelayConfig defaultConfig = (DefaultDhcpRelayConfig) config;
        v4Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
        v6Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
    }
    if (config instanceof IgnoreDhcpConfig) {
        updateIgnoreVlanRules((IgnoreDhcpConfig) config);
    }
}
#method_after
protected void updateConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        IndirectDhcpRelayConfig indirectConfig = (IndirectDhcpRelayConfig) config;
        v4Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
        v6Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        DefaultDhcpRelayConfig defaultConfig = (DefaultDhcpRelayConfig) config;
        v4Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
        v6Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
    }
    if (config instanceof IgnoreDhcpConfig) {
        v4Handler.updateIgnoreVlanConfig((IgnoreDhcpConfig) config);
        v6Handler.updateIgnoreVlanConfig((IgnoreDhcpConfig) config);
    }
}
#end_block

#method_before
protected void removeConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        v4Handler.setIndirectDhcpServerConfigs(Collections.emptyList());
        v6Handler.setIndirectDhcpServerConfigs(Collections.emptyList());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        v4Handler.setDefaultDhcpServerConfigs(Collections.emptyList());
        v6Handler.setDefaultDhcpServerConfigs(Collections.emptyList());
    }
    if (config instanceof IgnoreDhcpConfig) {
        ignoredVlans.forEach(((deviceId, vlanId) -> {
            processIgnoreVlanRule(deviceId, vlanId, REMOVE);
        }));
    }
}
#method_after
protected void removeConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        v4Handler.setIndirectDhcpServerConfigs(Collections.emptyList());
        v6Handler.setIndirectDhcpServerConfigs(Collections.emptyList());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        v4Handler.setDefaultDhcpServerConfigs(Collections.emptyList());
        v6Handler.setDefaultDhcpServerConfigs(Collections.emptyList());
    }
    if (config instanceof IgnoreDhcpConfig) {
        v4Handler.updateIgnoreVlanConfig(null);
        v6Handler.updateIgnoreVlanConfig(null);
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    switch(event.type()) {
        case DEVICE_ADDED:
            deviceAdd(device.id());
            break;
        case DEVICE_REMOVED:
            ignoredVlans.removeAll(device.id());
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            deviceAvailabilityChanged(device);
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    switch(event.type()) {
        case DEVICE_ADDED:
            updateIgnoreVlanConfigs();
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            deviceAvailabilityChanged(device);
        default:
            break;
    }
}
#end_block

#method_before
private void deviceAvailabilityChanged(Device device) {
    if (deviceService.isAvailable(device.id())) {
        deviceAdd(device.id());
    } else {
        ignoredVlans.removeAll(device.id());
    }
}
#method_after
private void deviceAvailabilityChanged(Device device) {
    if (deviceService.isAvailable(device.id())) {
        updateIgnoreVlanConfigs();
    }
}
#end_block

#method_before
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Interface serverInterface = directConnFlag ? getServerInterface() : getIndirectServerInterface();
    if (serverInterface == null) {
        log.warn("Can't get {} server interface, ignore", directConnFlag ? "direct" : "indirect");
        return null;
    }
    Ip6Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP v6 address for server Interface {}", serverInterface);
        return null;
    }
    Ethernet etherReply = clientPacket.duplicate();
    etherReply.setSourceMACAddress(macFacingServer);
    if ((directConnFlag && this.dhcpConnectMac == null) || !directConnFlag && this.indirectDhcpConnectMac == null && this.dhcpConnectMac == null) {
        log.warn("Packet received from {} connected client.", directConnFlag ? "directly" : "indirectly");
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.dhcpGatewayIp == null) ? "server IP " + this.dhcpServerIp : "gateway IP " + this.dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (this.dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point direct {} directConn {} indirectConn {} is not set up yet", directConnFlag, this.dhcpServerConnectPoint, this.indirectDhcpServerConnectPoint);
        return null;
    }
    etherReply.setDestinationMACAddress(this.dhcpConnectMac);
    etherReply.setVlanID(this.dhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(ipFacingServer.toOctets());
    ipv6Packet.setDestinationAddress(this.dhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    // notify onos and quagga to release PD
    // releasePD(dhcp6Packet);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    removeHostOrRoute(directConnFlag, dhcp6Packet, clientPacket, clientIpv6, clientInterface);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    // is located.
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (this.indirectDhcpServerIp == null) {
            log.warn("indirect DhcpServerIp not available, use default DhcpServerIp {}", HexString.toHexString(this.dhcpServerIp.toOctets()));
        } else {
            // Check if mac is obtained for valid server ip
            if (this.indirectDhcpConnectMac == null) {
                log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.indirectDhcpGatewayIp == null) ? "server IP " + this.indirectDhcpServerIp : "gateway IP " + this.indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
                return null;
            }
            etherReply.setDestinationMACAddress(this.indirectDhcpConnectMac);
            etherReply.setVlanID(this.indirectDhcpConnectVlan.toShort());
            ipv6Packet.setDestinationAddress(this.indirectDhcpServerIp.toOctets());
        }
        if (this.indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.warn("indirect connection: relayAgentIp NOT availale from config file! Use dynamic. {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(this.indirectRelayAgentIpFromCfg.toOctets());
            log.debug("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(this.indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // peer address:  address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<Dhcp6Option>();
    // otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString() + ":";
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (clientPacket.getVlanID() & 0xff);
    vlanIdBytes[1] = (byte) ((clientPacket.getVlanID() >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    log.debug("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} vlan {}", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length, vlanIdBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    ipv6Packet.setHopLimit((byte) 64);
    etherReply.setPayload(ipv6Packet);
    if (directConnFlag) {
        return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
    } else {
        if (this.indirectDhcpServerIp == null) {
            return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
        } else {
            return new InternalPacket(etherReply, this.indirectDhcpServerConnectPoint);
        }
    }
}
#method_after
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Interface serverInterface = directConnFlag ? getServerInterface() : getIndirectServerInterface();
    if (serverInterface == null) {
        log.warn("Can't get {} server interface, ignore", directConnFlag ? "direct" : "indirect");
        return null;
    }
    Ip6Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP v6 address for server Interface {}", serverInterface);
        return null;
    }
    Ethernet etherReply = clientPacket.duplicate();
    etherReply.setSourceMACAddress(macFacingServer);
    if ((directConnFlag && this.dhcpConnectMac == null) || !directConnFlag && this.indirectDhcpConnectMac == null && this.dhcpConnectMac == null) {
        log.warn("Packet received from {} connected client.", directConnFlag ? "directly" : "indirectly");
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP packet processing from client on port: {}", (this.dhcpGatewayIp == null) ? "server IP " + this.dhcpServerIp : "gateway IP " + this.dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (this.dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point direct {} directConn {} indirectConn {} is not set up yet", directConnFlag, this.dhcpServerConnectPoint, this.indirectDhcpServerConnectPoint);
        return null;
    }
    etherReply.setDestinationMACAddress(this.dhcpConnectMac);
    etherReply.setVlanID(this.dhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    Ip6Address peerAddress = null;
    if (directConnFlag) {
        peerAddress = Ip6Address.valueOf(ipv6Packet.getSourceAddress());
    } else {
        MacAddress gwOrClientMac = MacAddress.valueOf(clientPacket.getSourceMACAddress());
        VlanId vlanId = VlanId.vlanId(clientPacket.getVlanID());
        HostId gwOrClientHostId = HostId.hostId(gwOrClientMac, vlanId);
        Host gwOrClientHost = hostService.getHost(gwOrClientHostId);
        if (gwOrClientHost == null) {
            log.warn("Can't find client gateway/server host {}", gwOrClientHostId);
            return null;
        }
        // pick out the first gloabl ip address
        peerAddress = gwOrClientHost.ipAddresses().stream().filter(IpAddress::isIp6).filter(ip6 -> !ip6.isLinkLocal()).map(IpAddress::getIp6Address).findFirst().orElse(null);
        if (peerAddress == null) {
            log.warn("Can't find client gateway/server for mac {} ip {}", gwOrClientMac, HexString.toHexString(ipv6Packet.getSourceAddress()));
            log.warn("Can't find IP address of client gateway/ClienHost address {} for peerAddress", gwOrClientHost);
            return null;
        }
    }
    ipv6Packet.setSourceAddress(ipFacingServer.toOctets());
    ipv6Packet.setDestinationAddress(this.dhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    // notify onos and quagga to release PD
    // releasePD(dhcp6Packet);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    removeHostOrRoute(directConnFlag, dhcp6Packet, clientPacket, clientIpv6, clientInterface);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    // is located.
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (this.indirectDhcpServerIp == null) {
            log.warn("indirect DhcpServerIp not available, use default DhcpServerIp {}", HexString.toHexString(this.dhcpServerIp.toOctets()));
        } else {
            // Check if mac is obtained for valid server ip
            if (this.indirectDhcpConnectMac == null) {
                log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.indirectDhcpGatewayIp == null) ? "server IP " + this.indirectDhcpServerIp : "gateway IP " + this.indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
                return null;
            }
            etherReply.setDestinationMACAddress(this.indirectDhcpConnectMac);
            etherReply.setVlanID(this.indirectDhcpConnectVlan.toShort());
            ipv6Packet.setDestinationAddress(this.indirectDhcpServerIp.toOctets());
        }
        if (this.indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.warn("indirect connection: relayAgentIp NOT availale from config file! Use dynamic. {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(this.indirectRelayAgentIpFromCfg.toOctets());
            log.debug("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(this.indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // peer address:  address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress.toOctets());
    List<Dhcp6Option> options = new ArrayList<Dhcp6Option>();
    // otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString() + ":";
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (clientPacket.getVlanID() & 0xff);
    vlanIdBytes[1] = (byte) ((clientPacket.getVlanID() >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    log.debug("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} vlan {}", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length, vlanIdBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    ipv6Packet.setHopLimit((byte) 64);
    etherReply.setPayload(ipv6Packet);
    if (directConnFlag) {
        return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
    } else {
        if (this.indirectDhcpServerIp == null) {
            return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
        } else {
            return new InternalPacket(etherReply, this.indirectDhcpServerConnectPoint);
        }
    }
}
#end_block

#method_before
@Before
public void setup() {
    manager = new DhcpRelayManager();
    manager.cfgService = createNiceMock(NetworkConfigRegistry.class);
    expect(manager.cfgService.getConfig(APP_ID, DefaultDhcpRelayConfig.class)).andReturn(CONFIG).anyTimes();
    expect(manager.cfgService.getConfig(APP_ID, IndirectDhcpRelayConfig.class)).andReturn(CONFIG_INDIRECT).anyTimes();
    manager.coreService = createNiceMock(CoreService.class);
    expect(manager.coreService.registerApplication(anyString())).andReturn(APP_ID).anyTimes();
    manager.hostService = createNiceMock(HostService.class);
    expect(manager.hostService.getHostsByIp(anyObject())).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHost(OUTER_RELAY_HOST_ID)).andReturn(OUTER_RELAY_HOST).anyTimes();
    packetService = new MockPacketService();
    manager.packetService = packetService;
    manager.compCfgService = createNiceMock(ComponentConfigService.class);
    manager.deviceService = createNiceMock(DeviceService.class);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(manager.deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(manager.deviceService.getDevice(DEV_2_ID)).andReturn(device).anyTimes();
    replay(manager.deviceService, device);
    mockRouteStore = new MockRouteStore();
    mockDhcpRelayStore = new MockDhcpRelayStore();
    manager.dhcpRelayStore = mockDhcpRelayStore;
    manager.interfaceService = new MockInterfaceService();
    manager.flowObjectiveService = EasyMock.niceMock(FlowObjectiveService.class);
    mockHostProviderService = createNiceMock(HostProviderService.class);
    Dhcp4HandlerImpl v4Handler = new Dhcp4HandlerImpl();
    v4Handler.providerService = mockHostProviderService;
    v4Handler.dhcpRelayStore = mockDhcpRelayStore;
    v4Handler.hostService = manager.hostService;
    v4Handler.interfaceService = manager.interfaceService;
    v4Handler.packetService = manager.packetService;
    v4Handler.routeStore = mockRouteStore;
    v4Handler.coreService = createNiceMock(CoreService.class);
    manager.v4Handler = v4Handler;
    Dhcp6HandlerImpl v6Handler = new Dhcp6HandlerImpl();
    v6Handler.dhcpRelayStore = mockDhcpRelayStore;
    v6Handler.hostService = manager.hostService;
    v6Handler.interfaceService = manager.interfaceService;
    v6Handler.packetService = manager.packetService;
    v6Handler.routeStore = mockRouteStore;
    v6Handler.providerService = mockHostProviderService;
    v6Handler.coreService = createNiceMock(CoreService.class);
    manager.v6Handler = v6Handler;
    // properties
    Dictionary<String, Object> dictionary = createNiceMock(Dictionary.class);
    expect(dictionary.get("arpEnabled")).andReturn(true).anyTimes();
    ComponentContext context = createNiceMock(ComponentContext.class);
    expect(context.getProperties()).andReturn(dictionary).anyTimes();
    replay(manager.cfgService, manager.coreService, manager.hostService, manager.compCfgService, dictionary, context);
    manager.activate(context);
}
#method_after
@Before
public void setup() {
    manager = new DhcpRelayManager();
    manager.cfgService = createNiceMock(NetworkConfigRegistry.class);
    expect(manager.cfgService.getConfig(APP_ID, DefaultDhcpRelayConfig.class)).andReturn(CONFIG).anyTimes();
    expect(manager.cfgService.getConfig(APP_ID, IndirectDhcpRelayConfig.class)).andReturn(CONFIG_INDIRECT).anyTimes();
    manager.coreService = createNiceMock(CoreService.class);
    expect(manager.coreService.registerApplication(anyString())).andReturn(APP_ID).anyTimes();
    manager.hostService = createNiceMock(HostService.class);
    expect(manager.hostService.getHostsByIp(anyObject())).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHost(OUTER_RELAY_HOST_ID)).andReturn(OUTER_RELAY_HOST).anyTimes();
    packetService = new MockPacketService();
    manager.packetService = packetService;
    manager.compCfgService = createNiceMock(ComponentConfigService.class);
    deviceService = createNiceMock(DeviceService.class);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(deviceService.getDevice(DEV_2_ID)).andReturn(device).anyTimes();
    replay(deviceService, device);
    mockRouteStore = new MockRouteStore();
    mockDhcpRelayStore = new MockDhcpRelayStore();
    manager.dhcpRelayStore = mockDhcpRelayStore;
    manager.deviceService = deviceService;
    manager.interfaceService = new MockInterfaceService();
    flowObjectiveService = EasyMock.niceMock(FlowObjectiveService.class);
    mockHostProviderService = createNiceMock(HostProviderService.class);
    v4Handler = new Dhcp4HandlerImpl();
    v4Handler.providerService = mockHostProviderService;
    v4Handler.dhcpRelayStore = mockDhcpRelayStore;
    v4Handler.hostService = manager.hostService;
    v4Handler.interfaceService = manager.interfaceService;
    v4Handler.packetService = manager.packetService;
    v4Handler.routeStore = mockRouteStore;
    v4Handler.coreService = createNiceMock(CoreService.class);
    v4Handler.flowObjectiveService = flowObjectiveService;
    v4Handler.appId = TestApplicationId.create(Dhcp4HandlerImpl.DHCP_V4_RELAY_APP);
    v4Handler.deviceService = deviceService;
    manager.v4Handler = v4Handler;
    v6Handler = new Dhcp6HandlerImpl();
    v6Handler.dhcpRelayStore = mockDhcpRelayStore;
    v6Handler.hostService = manager.hostService;
    v6Handler.interfaceService = manager.interfaceService;
    v6Handler.packetService = manager.packetService;
    v6Handler.routeStore = mockRouteStore;
    v6Handler.providerService = mockHostProviderService;
    v6Handler.coreService = createNiceMock(CoreService.class);
    v6Handler.flowObjectiveService = flowObjectiveService;
    v6Handler.appId = TestApplicationId.create(Dhcp6HandlerImpl.DHCP_V6_RELAY_APP);
    v6Handler.deviceService = deviceService;
    manager.v6Handler = v6Handler;
    // properties
    Dictionary<String, Object> dictionary = createNiceMock(Dictionary.class);
    expect(dictionary.get("arpEnabled")).andReturn(true).anyTimes();
    ComponentContext context = createNiceMock(ComponentContext.class);
    expect(context.getProperties()).andReturn(dictionary).anyTimes();
    replay(manager.cfgService, manager.coreService, manager.hostService, manager.compCfgService, dictionary, context);
    manager.activate(context);
}
#end_block

#method_before
@Test
public void testIgnoreVlan() throws Exception {
    ObjectMapper om = new ObjectMapper();
    JsonNode json = om.readTree(Resources.getResource(CONFIG_FILE_PATH));
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    json = json.path("apps").path(DHCP_RELAY_APP).path(IgnoreDhcpConfig.KEY);
    config.init(APP_ID, IgnoreDhcpConfig.KEY, json, om, null);
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(DHCP_SELECTORS.size());
    Capture<Objective> capturedFromDev2 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_2_ID), capture(capturedFromDev2));
    expectLastCall().times(DHCP_SELECTORS.size());
    replay(manager.flowObjectiveService);
    manager.updateConfig(config);
    verify(manager.flowObjectiveService);
    List<Objective> objectivesFromDev1 = capturedFromDev1.getValues();
    List<Objective> objectivesFromDev2 = capturedFromDev2.getValues();
    assertTrue(objectivesFromDev1.containsAll(objectivesFromDev2));
    assertTrue(objectivesFromDev2.containsAll(objectivesFromDev1));
    TrafficTreatment dropTreatment = DefaultTrafficTreatment.emptyTreatment();
    dropTreatment.clearedDeferred();
    for (int index = 0; index < objectivesFromDev1.size(); index++) {
        TrafficSelector selector = DefaultTrafficSelector.builder(DHCP_SELECTORS.get(index)).matchVlanId(IGNORED_VLAN).build();
        ForwardingObjective fwd = (ForwardingObjective) objectivesFromDev1.get(index);
        assertEquals(selector, fwd.selector());
        assertEquals(dropTreatment, fwd.treatment());
        assertEquals(IGNORE_CONTROL_PRIORITY, fwd.priority());
        assertEquals(ForwardingObjective.Flag.VERSATILE, fwd.flag());
        assertEquals(Objective.Operation.ADD, fwd.op());
        fwd.context().ifPresent(ctx -> {
            ctx.onSuccess(fwd);
        });
    }
    objectivesFromDev2.forEach(obj -> obj.context().ifPresent(ctx -> ctx.onSuccess(obj)));
    assertEquals(2, manager.ignoredVlans.size());
}
#method_after
@Test
public void testIgnoreVlan() throws Exception {
    ObjectMapper om = new ObjectMapper();
    JsonNode json = om.readTree(Resources.getResource(CONFIG_FILE_PATH));
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    json = json.path("apps").path(DHCP_RELAY_APP).path(IgnoreDhcpConfig.KEY);
    config.init(APP_ID, IgnoreDhcpConfig.KEY, json, om, null);
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(DHCP_SELECTORS.size());
    Capture<Objective> capturedFromDev2 = newCapture(CaptureType.ALL);
    flowObjectiveService.apply(eq(DEV_2_ID), capture(capturedFromDev2));
    expectLastCall().times(DHCP_SELECTORS.size());
    replay(flowObjectiveService);
    manager.updateConfig(config);
    verify(flowObjectiveService);
    List<Objective> objectivesFromDev1 = capturedFromDev1.getValues();
    List<Objective> objectivesFromDev2 = capturedFromDev2.getValues();
    assertTrue(objectivesFromDev1.containsAll(objectivesFromDev2));
    assertTrue(objectivesFromDev2.containsAll(objectivesFromDev1));
    TrafficTreatment dropTreatment = DefaultTrafficTreatment.builder().wipeDeferred().build();
    for (int index = 0; index < objectivesFromDev1.size(); index++) {
        TrafficSelector selector = DefaultTrafficSelector.builder(DHCP_SELECTORS.get(index)).matchVlanId(IGNORED_VLAN).build();
        ForwardingObjective fwd = (ForwardingObjective) objectivesFromDev1.get(index);
        assertEquals(selector, fwd.selector());
        assertEquals(dropTreatment, fwd.treatment());
        assertEquals(IGNORE_CONTROL_PRIORITY, fwd.priority());
        assertEquals(ForwardingObjective.Flag.VERSATILE, fwd.flag());
        assertEquals(Objective.Operation.ADD, fwd.op());
        fwd.context().ifPresent(ctx -> {
            ctx.onSuccess(fwd);
        });
    }
    objectivesFromDev2.forEach(obj -> obj.context().ifPresent(ctx -> ctx.onSuccess(obj)));
    assertEquals(2, v4Handler.ignoredVlans.size());
    assertEquals(2, v6Handler.ignoredVlans.size());
}
#end_block

#method_before
@Test
public void testRemoveIgnoreVlan() {
    manager.ignoredVlans.put(DEV_1_ID, IGNORED_VLAN);
    manager.ignoredVlans.put(DEV_2_ID, IGNORED_VLAN);
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(DHCP_SELECTORS.size());
    Capture<Objective> capturedFromDev2 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_2_ID), capture(capturedFromDev2));
    expectLastCall().times(DHCP_SELECTORS.size());
    replay(manager.flowObjectiveService);
    manager.removeConfig(config);
    verify(manager.flowObjectiveService);
    List<Objective> objectivesFromDev1 = capturedFromDev1.getValues();
    List<Objective> objectivesFromDev2 = capturedFromDev2.getValues();
    assertTrue(objectivesFromDev1.containsAll(objectivesFromDev2));
    assertTrue(objectivesFromDev2.containsAll(objectivesFromDev1));
    TrafficTreatment dropTreatment = DefaultTrafficTreatment.emptyTreatment();
    dropTreatment.clearedDeferred();
    for (int index = 0; index < objectivesFromDev1.size(); index++) {
        TrafficSelector selector = DefaultTrafficSelector.builder(DHCP_SELECTORS.get(index)).matchVlanId(IGNORED_VLAN).build();
        ForwardingObjective fwd = (ForwardingObjective) objectivesFromDev1.get(index);
        assertEquals(selector, fwd.selector());
        assertEquals(dropTreatment, fwd.treatment());
        assertEquals(IGNORE_CONTROL_PRIORITY, fwd.priority());
        assertEquals(ForwardingObjective.Flag.VERSATILE, fwd.flag());
        assertEquals(Objective.Operation.REMOVE, fwd.op());
        fwd.context().ifPresent(ctx -> {
            ctx.onSuccess(fwd);
        });
    }
    objectivesFromDev2.forEach(obj -> obj.context().ifPresent(ctx -> ctx.onSuccess(obj)));
    assertEquals(0, manager.ignoredVlans.size());
}
#method_after
@Test
public void testRemoveIgnoreVlan() {
    v4Handler.ignoredVlans.put(DEV_1_ID, IGNORED_VLAN);
    v4Handler.ignoredVlans.put(DEV_2_ID, IGNORED_VLAN);
    v6Handler.ignoredVlans.put(DEV_1_ID, IGNORED_VLAN);
    v6Handler.ignoredVlans.put(DEV_2_ID, IGNORED_VLAN);
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(DHCP_SELECTORS.size());
    Capture<Objective> capturedFromDev2 = newCapture(CaptureType.ALL);
    flowObjectiveService.apply(eq(DEV_2_ID), capture(capturedFromDev2));
    expectLastCall().times(DHCP_SELECTORS.size());
    replay(flowObjectiveService);
    manager.removeConfig(config);
    verify(flowObjectiveService);
    List<Objective> objectivesFromDev1 = capturedFromDev1.getValues();
    List<Objective> objectivesFromDev2 = capturedFromDev2.getValues();
    assertTrue(objectivesFromDev1.containsAll(objectivesFromDev2));
    assertTrue(objectivesFromDev2.containsAll(objectivesFromDev1));
    TrafficTreatment dropTreatment = DefaultTrafficTreatment.builder().wipeDeferred().build();
    for (int index = 0; index < objectivesFromDev1.size(); index++) {
        TrafficSelector selector = DefaultTrafficSelector.builder(DHCP_SELECTORS.get(index)).matchVlanId(IGNORED_VLAN).build();
        ForwardingObjective fwd = (ForwardingObjective) objectivesFromDev1.get(index);
        assertEquals(selector, fwd.selector());
        assertEquals(dropTreatment, fwd.treatment());
        assertEquals(IGNORE_CONTROL_PRIORITY, fwd.priority());
        assertEquals(ForwardingObjective.Flag.VERSATILE, fwd.flag());
        assertEquals(Objective.Operation.REMOVE, fwd.op());
        fwd.context().ifPresent(ctx -> {
            ctx.onSuccess(fwd);
        });
    }
    objectivesFromDev2.forEach(obj -> obj.context().ifPresent(ctx -> ctx.onSuccess(obj)));
    assertEquals(0, v4Handler.ignoredVlans.size());
    assertEquals(0, v6Handler.ignoredVlans.size());
}
#end_block

#method_before
@Test
public void testIgnoreUnknownDevice() throws IOException {
    reset(manager.deviceService);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(manager.deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(manager.deviceService.getDevice(DEV_2_ID)).andReturn(null).anyTimes();
    ObjectMapper om = new ObjectMapper();
    JsonNode json = om.readTree(Resources.getResource(CONFIG_FILE_PATH));
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    json = json.path("apps").path(DHCP_RELAY_APP).path(IgnoreDhcpConfig.KEY);
    config.init(APP_ID, IgnoreDhcpConfig.KEY, json, om, null);
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(DHCP_SELECTORS.size());
    replay(manager.flowObjectiveService, manager.deviceService, device);
    manager.updateConfig(config);
    capturedFromDev1.getValues().forEach(obj -> obj.context().ifPresent(ctx -> ctx.onSuccess(obj)));
    assertEquals(1, manager.ignoredVlans.size());
}
#method_after
@Test
public void testIgnoreUnknownDevice() throws IOException {
    reset(manager.deviceService);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(manager.deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(manager.deviceService.getDevice(DEV_2_ID)).andReturn(null).anyTimes();
    ObjectMapper om = new ObjectMapper();
    JsonNode json = om.readTree(Resources.getResource(CONFIG_FILE_PATH));
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    json = json.path("apps").path(DHCP_RELAY_APP).path(IgnoreDhcpConfig.KEY);
    config.init(APP_ID, IgnoreDhcpConfig.KEY, json, om, null);
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(DHCP_SELECTORS.size());
    replay(flowObjectiveService, manager.deviceService, device);
    manager.updateConfig(config);
    capturedFromDev1.getValues().forEach(obj -> obj.context().ifPresent(ctx -> ctx.onSuccess(obj)));
    assertEquals(1, v4Handler.ignoredVlans.size());
    assertEquals(1, v6Handler.ignoredVlans.size());
}
#end_block

#method_before
@Test
public void testInstallIgnoreRuleWhenDeviceComesUp() throws IOException {
    ObjectMapper om = new ObjectMapper();
    JsonNode json = om.readTree(Resources.getResource(CONFIG_FILE_PATH));
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    json = json.path("apps").path(DHCP_RELAY_APP).path(IgnoreDhcpConfig.KEY);
    config.init(APP_ID, IgnoreDhcpConfig.KEY, json, om, null);
    reset(manager.cfgService, manager.flowObjectiveService, manager.deviceService);
    expect(manager.cfgService.getConfig(APP_ID, IgnoreDhcpConfig.class)).andReturn(config).anyTimes();
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(device.id()).andReturn(DEV_1_ID).anyTimes();
    expect(manager.deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    DeviceEvent event = new DeviceEvent(DeviceEvent.Type.DEVICE_ADDED, device);
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(DHCP_SELECTORS.size());
    replay(manager.cfgService, manager.flowObjectiveService, manager.deviceService, device);
    assertEquals(0, manager.ignoredVlans.size());
    manager.deviceListener.event(event);
    capturedFromDev1.getValues().forEach(obj -> obj.context().ifPresent(ctx -> ctx.onSuccess(obj)));
    assertEquals(1, manager.ignoredVlans.size());
}
#method_after
@Test
public void testInstallIgnoreRuleWhenDeviceComesUp() throws IOException {
    ObjectMapper om = new ObjectMapper();
    JsonNode json = om.readTree(Resources.getResource(CONFIG_FILE_PATH));
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    json = json.path("apps").path(DHCP_RELAY_APP).path(IgnoreDhcpConfig.KEY);
    config.init(APP_ID, IgnoreDhcpConfig.KEY, json, om, null);
    reset(manager.cfgService, flowObjectiveService, manager.deviceService);
    expect(manager.cfgService.getConfig(APP_ID, IgnoreDhcpConfig.class)).andReturn(config).anyTimes();
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(device.id()).andReturn(DEV_1_ID).anyTimes();
    expect(manager.deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    DeviceEvent event = new DeviceEvent(DeviceEvent.Type.DEVICE_ADDED, device);
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(DHCP_SELECTORS.size());
    replay(manager.cfgService, flowObjectiveService, manager.deviceService, device);
    manager.deviceListener.event(event);
    capturedFromDev1.getValues().forEach(obj -> obj.context().ifPresent(ctx -> ctx.onSuccess(obj)));
    assertEquals(1, v4Handler.ignoredVlans.size());
    assertEquals(1, v6Handler.ignoredVlans.size());
}
#end_block

#method_before
private void processGroupMod(OFGroupMod groupMod) {
    log.debug("processing GROUP_MOD {} message", groupMod.getCommand());
    ApplicationId appId = ofSwitchService.appId();
    GroupKey appCookie = new DefaultGroupKey(networkId.toString().getBytes());
    switch(groupMod.getCommand()) {
        case ADD:
            // TODO return OFGroupModFailedCode.GROUP_EXISTS if group already exists
            int groupId = groupMod.getGroup().getGroupNumber();
            OFGroupAdd groupAdd = (OFGroupAdd) groupMod;
            GroupBuckets groupAddBuckets = new OFAgentVirtualGroupBucketEntryBuilder(Dpid.dpid(Dpid.uri(dpid().getLong())), groupAdd.getBuckets(), groupAdd.getGroupType(), driverService).build();
            GroupDescription groupDescription = new DefaultGroupDescription(deviceId, getGroupType(groupAdd.getGroupType()), groupAddBuckets, appCookie, groupId, appId);
            groupService.addGroup(groupDescription);
            break;
        case MODIFY:
            // TODO return OFGroupModFailedCode.INVALID_GROUP if group does not exist
            OFGroupModify groupModify = (OFGroupModify) groupMod;
            GroupBuckets groupModifyBuckets = new OFAgentVirtualGroupBucketEntryBuilder(Dpid.dpid(Dpid.uri(dpid().getLong())), groupModify.getBuckets(), groupModify.getGroupType(), driverService).build();
            groupService.setBucketsForGroup(deviceId, appCookie, groupModifyBuckets, appCookie, appId);
            break;
        case DELETE:
            // OFGroupDelete groupDelete = (OFGroupDelete) groupMod;
            groupService.removeGroup(deviceId, appCookie, appId);
            break;
        default:
            // INSERT_BUCKET, REMOVE_BUCKET are effective OF 1.5.  OFAgent supports 1.3.
            log.warn("Unsupported GROUP_MOD {} message received for switch {}", groupMod.getCommand(), this);
    }
}
#method_after
private void processGroupMod(OFGroupMod groupMod) {
    log.debug("processing GROUP_MOD {} message", groupMod.getCommand());
    ApplicationId appId = ofSwitchService.appId();
    GroupKey appCookie = new DefaultGroupKey(networkId.toString().getBytes());
    switch(groupMod.getCommand()) {
        case ADD:
            // TODO return OFGroupModFailedCode.GROUP_EXISTS if group already exists
            int groupId = groupMod.getGroup().getGroupNumber();
            OFGroupAdd groupAdd = (OFGroupAdd) groupMod;
            GroupBuckets groupAddBuckets = new OFAgentVirtualGroupBucketEntryBuilder(Dpid.dpid(Dpid.uri(dpid().getLong())), groupAdd.getBuckets(), groupAdd.getGroupType(), driverService).build();
            GroupDescription groupDescription = new DefaultGroupDescription(deviceId, getGroupType(groupAdd.getGroupType()), groupAddBuckets, appCookie, groupId, appId);
            groupService.addGroup(groupDescription);
            break;
        case MODIFY:
            // TODO return OFGroupModFailedCode.INVALID_GROUP if group does not exist
            OFGroupModify groupModify = (OFGroupModify) groupMod;
            GroupBuckets groupModifyBuckets = new OFAgentVirtualGroupBucketEntryBuilder(Dpid.dpid(Dpid.uri(dpid().getLong())), groupModify.getBuckets(), groupModify.getGroupType(), driverService).build();
            groupService.setBucketsForGroup(deviceId, appCookie, groupModifyBuckets, appCookie, appId);
            break;
        case DELETE:
            groupService.removeGroup(deviceId, appCookie, appId);
            break;
        default:
            // INSERT_BUCKET, REMOVE_BUCKET are effective OF 1.5.  OFAgent supports 1.3.
            log.warn("Unsupported GROUP_MOD {} message received for switch {}", groupMod.getCommand(), this);
    }
}
#end_block

#method_before
private void processMeterMod(OFMeterMod meterMod, Channel channel) {
    log.debug("processing METER_MOD {} message", meterMod.getCommand());
    long meterModId = meterMod.getMeterId();
    Meter existingMeter = meterService.getMeter(deviceId, MeterId.meterId(meterModId));
    MeterRequest meterRequest = null;
    switch(meterMod.getCommand()) {
        case ADD:
            if (existingMeter != null) {
                meterModError(meterMod, OFMeterModFailedCode.METER_EXISTS, channel);
                return;
            }
            meterRequest = meterRequestBuilder(meterMod).add();
            break;
        case MODIFY:
            if (existingMeter == null) {
                meterModError(meterMod, OFMeterModFailedCode.UNKNOWN_METER, channel);
                return;
            }
            meterRequest = meterRequestBuilder(meterMod).add();
            break;
        case DELETE:
            meterRequest = meterRequestBuilder(meterMod).remove();
            break;
        default:
            log.warn("Unexpected message {} received for switch {}", meterMod.getCommand(), this);
            return;
    }
    meterService.submit(meterRequest);
}
#method_after
private void processMeterMod(OFMeterMod meterMod, Channel channel) {
    log.debug("processing METER_MOD {} message", meterMod.getCommand());
    long meterModId = meterMod.getMeterId();
    Meter existingMeter = meterService.getMeter(deviceId, MeterId.meterId(meterModId));
    MeterRequest meterRequest = null;
    switch(meterMod.getCommand()) {
        case ADD:
            if (existingMeter != null) {
                meterModError(meterMod, OFMeterModFailedCode.METER_EXISTS, channel);
                return;
            }
            meterRequest = meterRequestBuilder(meterMod).add();
            break;
        case MODIFY:
            if (existingMeter == null) {
                meterModError(meterMod, OFMeterModFailedCode.UNKNOWN_METER, channel);
                return;
            }
            meterRequest = meterRequestBuilder(meterMod).add();
            break;
        case DELETE:
            // non-existing meter id will not result in OFMeterModFailedErrorMsg
            // being sent to the controller
            meterRequest = meterRequestBuilder(meterMod).remove();
            break;
        default:
            log.warn("Unexpected message {} received for switch {}", meterMod.getCommand(), this);
            return;
    }
    meterService.submit(meterRequest);
}
#end_block

#method_before
@Override
public void processControllerCommand(Channel channel, OFMessage msg) {
    OFControllerRole myRole = role(channel);
    if (OFControllerRole.ROLE_SLAVE.equals(myRole)) {
        OFBadRequestErrorMsg errorMsg = FACTORY.errorMsgs().buildBadRequestErrorMsg().setXid(msg.getXid()).setCode(OFBadRequestCode.IS_SLAVE).build();
        channel.writeAndFlush(Collections.singletonList(errorMsg));
        return;
    }
    switch(msg.getType()) {
        case PORT_MOD:
            OFPortMod portMod = (OFPortMod) msg;
            processPortMod(portMod);
            break;
        case FLOW_MOD:
            OFFlowMod flowMod = (OFFlowMod) msg;
            processFlowMod(flowMod);
            break;
        case GROUP_MOD:
            OFGroupMod groupMod = (OFGroupMod) msg;
            processGroupMod(groupMod);
            break;
        case METER_MOD:
            OFMeterMod meterMod = (OFMeterMod) msg;
            processMeterMod(meterMod, channel);
        case TABLE_MOD:
            log.debug("processControllerCommand: {} not yet supported for {}", msg.getType(), msg);
            break;
        default:
            log.warn("Unexpected message {} received for switch {}", msg.getType(), this);
    }
}
#method_after
@Override
public void processControllerCommand(Channel channel, OFMessage msg) {
    OFControllerRole myRole = role(channel);
    if (OFControllerRole.ROLE_SLAVE.equals(myRole)) {
        OFBadRequestErrorMsg errorMsg = FACTORY.errorMsgs().buildBadRequestErrorMsg().setXid(msg.getXid()).setCode(OFBadRequestCode.IS_SLAVE).build();
        channel.writeAndFlush(Collections.singletonList(errorMsg));
        return;
    }
    switch(msg.getType()) {
        case PORT_MOD:
            OFPortMod portMod = (OFPortMod) msg;
            processPortMod(portMod);
            break;
        case FLOW_MOD:
            OFFlowMod flowMod = (OFFlowMod) msg;
            processFlowMod(flowMod);
            break;
        case GROUP_MOD:
            OFGroupMod groupMod = (OFGroupMod) msg;
            processGroupMod(groupMod);
            break;
        case METER_MOD:
            OFMeterMod meterMod = (OFMeterMod) msg;
            processMeterMod(meterMod, channel);
            break;
        case TABLE_MOD:
            log.debug("processControllerCommand: {} not yet supported for {}", msg.getType(), msg);
            break;
        default:
            log.warn("Unexpected message {} received for switch {}", msg.getType(), this);
    }
}
#end_block

#method_before
@Test
public void testListWithConfigFalse() {
    String path = "src/test/resources/testListWithConfigFalse.xml";
    DefaultCompositeStream external = new DefaultCompositeStream(null, parseInput(path));
    CompositeData compositeData = xmlSerializer.decode(external, context);
    DataNode rootNode = validateRootDataNode(compositeData.resourceData());
    List<String> keyNames = new LinkedList<>();
    keyNames.add("m1");
    keyNames.add("m2");
    List<String> keyNs = new LinkedList<>();
    keyNs.add(LIST_NS);
    keyNs.add(LIST_NS);
    List<Object> values = new LinkedList<>();
    values.add("m1_Value");
    values.add("m2_Value");
    DataNode c2Node = validateContainerDataNode(rootNode, "c2", LIST_NS);
    DataNode listl1 = validateListDataNode(c2Node, "l2", LIST_NS, keyNames, keyNs, values);
    validateLeafDataNode(listl1, "m1", LIST_NS, "m1_Value");
    validateLeafDataNode(listl1, "m2", LIST_NS, "m2_Value");
    // encode test
    CompositeStream compositeStream = xmlSerializer.encode(getNewCompositeData(compositeData), context);
    InputStream inputStream = compositeStream.resourceData();
    assertThat(convertInputStreamToString(inputStream), is(parseXml(path)));
}
#method_after
@Test
public void testListWithConfigFalse() {
    String path = "src/test/resources/testListWithConfigFalse.xml";
    DefaultCompositeStream external = new DefaultCompositeStream(null, parseInput(path));
    CompositeData compositeData = xmlSerializer.decode(external, context);
    DataNode rootNode = validateRootDataNode(compositeData.resourceData());
    List<String> keyNames = new LinkedList<>();
    keyNames.add("m1");
    keyNames.add("m2");
    List<String> keyNs = new LinkedList<>();
    keyNs.add(LIST_NS);
    keyNs.add(LIST_NS);
    List<Object> values = new LinkedList<>();
    values.add("m1_Value");
    values.add("m2_Value");
    DataNode c2Node = validateContainerDataNode(rootNode, "c2", LIST_NS);
    DataNode listl1 = validateListDataNode(c2Node, "l2", LIST_NS, keyNames, keyNs, values);
    validateLeafDataNode(listl1, "m1", LIST_NS, "m1_Value");
    validateLeafDataNode(listl1, "m2", LIST_NS, "m2_Value");
    List<Object> values1 = new LinkedList<>();
    values1.add("m1_Value1");
    values1.add("m2_Value1");
    DataNode listl2 = validateListDataNode(c2Node, "l2", LIST_NS, keyNames, keyNs, values1);
    validateLeafDataNode(listl2, "m1", LIST_NS, "m1_Value1");
    validateLeafDataNode(listl2, "m2", LIST_NS, "m2_Value1");
    // encode test
    CompositeStream compositeStream = xmlSerializer.encode(getNewCompositeData(compositeData), context);
    InputStream inputStream = compositeStream.resourceData();
    assertThat(convertInputStreamToString(inputStream), is(parseXml(path)));
}
#end_block

#method_before
@Override
public Set<Member> getMembers() {
    return clusterService.getNodes().stream().filter(node -> clusterService.getVersion(node.id()).equals(localMember.version())).map(this::toMemberId).collect(Collectors.toSet());
}
#method_after
@Override
public Set<Member> getMembers() {
    return clusterService.getNodes().stream().filter(node -> Optional.ofNullable(clusterService.getVersion(node.id())).filter(version -> version.equals(localMember.version())).isPresent()).map(this::toMemberId).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public boolean isRelevant(DeviceEvent event) {
    return event.type().equals(DeviceEvent.Type.DEVICE_REMOVED) && mastershipService.isLocalMaster(event.subject().id());
}
#method_after
@Override
public boolean isRelevant(DeviceEvent event) {
    return event.type().equals(DeviceEvent.Type.DEVICE_REMOVED);
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    log.info("Device {} removed from ONOS, removing all related alarms", event.subject().id());
    // TODO this can be improved when core supports multiple keys map and gets implemented in AlarmStore
    store.getAlarms(event.subject().id()).forEach(alarm -> store.removeAlarm(alarm.id()));
}
#method_after
@Override
public void event(DeviceEvent event) {
    if (mastershipService.isLocalMaster(event.subject().id())) {
        log.info("Device {} removed from ONOS, removing all related alarms", event.subject().id());
        // TODO this can be improved when core supports multiple keys map and gets implemented in AlarmStore
        store.getAlarms(event.subject().id()).forEach(alarm -> store.removeAlarm(alarm.id()));
    } else {
        log.info("This Node is not Master for device {}", event.subject().id());
    }
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getDevices() {
    List<Device> devices = new ArrayList<>();
    for (Device d : get(DeviceService.class).getDevices()) {
        if (getPowerConfig(d.id().toString()) != null) {
            devices.add(d);
        }
    }
    ObjectNode result = encodeArray(Device.class, "devices", devices);
    return ok(result).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getDevices() {
    ObjectNode root = mapper().createObjectNode();
    ArrayNode deviceIdsNode = root.putArray(DEVICE_IDS);
    Iterable<Device> devices = get(DeviceService.class).getDevices();
    if (devices != null) {
        for (Device d : devices) {
            if (getPowerConfig(d.id().toString()) != null) {
                deviceIdsNode.add(d.id().toString());
            }
        }
    }
    return ok(root).build();
}
#end_block

#method_before
@GET
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getDevice(@PathParam("id") String id) {
    getPowerConfig(id);
    ObjectNode result = codec(Device.class).encode(get(DeviceService.class).getDevice(deviceId(id)), this);
    return ok(result).build();
}
#method_after
@GET
@Path("{id}")
@Produces(MediaType.APPLICATION_JSON)
public Response getDevice(@PathParam("id") String id) {
    ObjectNode result = mapper.createObjectNode();
    result.put(POWERCONFIG_SUPPORTED, (getPowerConfig(id) != null) ? true : false);
    return ok(result).build();
}
#end_block

#method_before
private PowerConfig<Object> getPowerConfig(String id) {
    Device device = get(DeviceService.class).getDevice(deviceId(id));
    if (device == null) {
        throw new IllegalArgumentException(DEVICE_NOT_FOUND);
    }
    if (device.is(PowerConfig.class)) {
        return device.as(PowerConfig.class);
    }
    throw new IllegalArgumentException(POWERCONFIG_UNSUPPORTED);
}
#method_after
private PowerConfig<Object> getPowerConfig(String id) {
    Device device = get(DeviceService.class).getDevice(deviceId(id));
    if (device == null) {
        throw new IllegalArgumentException(DEVICE_NOT_FOUND);
    }
    if (device.is(PowerConfig.class)) {
        return device.as(PowerConfig.class);
    }
    return null;
}
#end_block

#method_before
@GET
@Path("{id}/ports")
@Produces(MediaType.APPLICATION_JSON)
public Response getDevicePorts(@PathParam("id") String id) {
    PowerConfig<Object> powerConfig = getPowerConfig(id);
    ObjectNode result = codec(PowerConfig.class).encode(powerConfig, this);
    return ok(result).build();
}
#method_after
@GET
@Path("{id}/ports")
@Produces(MediaType.APPLICATION_JSON)
public Response getDevicePorts(@PathParam("id") String id, @QueryParam("direction") String direction, @QueryParam("channel") String channel) {
    PowerConfig<Object> powerConfig = getPowerConfig(id);
    if (powerConfig == null) {
        throw new IllegalArgumentException(POWERCONFIG_UNSUPPORTED);
    }
    if (direction == null && channel == null) {
        direction = "ALL";
    // TODO: Fallback to all channels?
    }
    ObjectNode result = encode(powerConfig, direction, channel);
    return ok(result).build();
}
#end_block

#method_before
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    Device device = deviceService.getDevice(deviceId);
    if (mastershipService.isLocalMaster(deviceId) && device.is(PortAdmin.class)) {
        PortAdmin portAdmin = device.as(PortAdmin.class);
        CompletableFuture<Boolean> modified;
        if (enable) {
            modified = portAdmin.enable(portNumber);
        } else {
            modified = portAdmin.disable(portNumber);
        }
        modified.thenAcceptAsync(result -> {
            if (!result) {
                log.warn("Your device {} port {} status can't be changed to {}", deviceId, portNumber, enable);
            }
        });
    } else if (!device.is(PortAdmin.class)) {
        log.warn("Device {} does not support Port Admin", deviceId);
    } else if (mastershipService.isLocalMaster(deviceId)) {
        log.debug("Not master but {}, not changing port state", mastershipService.getLocalRole(deviceId));
    }
}
#method_after
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    Device device = deviceService.getDevice(deviceId);
    if (mastershipService.isLocalMaster(deviceId)) {
        if (device.is(PortAdmin.class)) {
            PortAdmin portAdmin = device.as(PortAdmin.class);
            CompletableFuture<Boolean> modified;
            if (enable) {
                modified = portAdmin.enable(portNumber);
            } else {
                modified = portAdmin.disable(portNumber);
            }
            modified.thenAccept(result -> {
                if (result) {
                    Port port = deviceService.getPort(deviceId, portNumber);
                    // rebuilding port description with admin state changed.
                    providerService.portStatusChanged(deviceId, new DefaultPortDescription(portNumber, enable, false, port.type(), port.portSpeed(), (SparseAnnotations) port.annotations()));
                } else {
                    log.warn("Your device {} port {} status can't be changed to {}", deviceId, portNumber, enable);
                }
            });
        } else {
            log.warn("Device {} does not support Port Admin", deviceId);
        }
    } else {
        log.debug("Not master but {}, not changing port state", mastershipService.getLocalRole(deviceId));
    }
}
#end_block

#method_before
@Activate
public void activate() {
    state = coordinationService.<Upgrade>atomicValueBuilder().withName("onos-upgrade-state").withSerializer(Serializer.using(KryoNamespaces.API)).build().asAtomicValue();
    localVersion = versionService.version();
    currentState.set(state.get());
    if (getState() == null) {
        currentState.set(new Upgrade(localVersion, localVersion, Upgrade.Status.INACTIVE));
        state.set(getState());
    }
    Upgrade upgrade = getState();
    // If the upgrade state is not initialized, ensure this node matches the version of the cluster.
    if (!upgrade.status().active() && !Objects.equals(upgrade.source(), localVersion)) {
        log.error("Node version {} inconsistent with cluster version {}", localVersion, upgrade.source());
        throw new IllegalStateException("Node version " + localVersion + " inconsistent with cluster version " + upgrade.source());
    }
    // If the upgrade state is initialized then check the node version.
    if (upgrade.status() == Upgrade.Status.INITIALIZED) {
        // If the source version equals the target version, attempt to update the target version.
        if (Objects.equals(upgrade.source(), upgrade.target()) && !Objects.equals(upgrade.target(), localVersion)) {
            checkPermission(UPGRADE_WRITE);
            upgrade = new Upgrade(upgrade.source(), localVersion, upgrade.status());
            currentState.set(upgrade);
            state.set(upgrade);
        }
    }
    // If the upgrade status is active, verify that the local version matches the upgrade version.
    if (upgrade.status().active() && !Objects.equals(upgrade.source(), upgrade.target())) {
        // the source or target version.
        if (!Objects.equals(localVersion, upgrade.source()) && !Objects.equals(localVersion, upgrade.target())) {
            log.error("Cannot upgrade node to version {}; Upgrade to {} already in progress", localVersion, upgrade.target());
            throw new IllegalStateException("Cannot upgrade node to version " + localVersion + "; Upgrade to " + upgrade.target() + " already in progress");
        }
    }
    state.addListener(stateListener);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    state = coordinationService.<Upgrade>atomicValueBuilder().withName("onos-upgrade-state").withSerializer(Serializer.using(KryoNamespaces.API)).build().asAtomicValue();
    localVersion = versionService.version();
    currentState.set(state.get());
    if (getState() == null) {
        initializeState(new Upgrade(localVersion, localVersion, Upgrade.Status.INACTIVE));
    }
    Upgrade upgrade = getState();
    // If the upgrade state is not initialized, ensure this node matches the version of the cluster.
    if (!upgrade.status().active() && !Objects.equals(upgrade.source(), localVersion)) {
        log.error("Node version {} inconsistent with cluster version {}", localVersion, upgrade.source());
        throw new IllegalStateException("Node version " + localVersion + " inconsistent with cluster version " + upgrade.source());
    }
    // If the upgrade state is initialized then check the node version.
    if (upgrade.status() == Upgrade.Status.INITIALIZED) {
        // If the source version equals the target version, attempt to update the target version.
        if (Objects.equals(upgrade.source(), upgrade.target()) && !Objects.equals(upgrade.target(), localVersion)) {
            checkPermission(UPGRADE_WRITE);
            upgrade = new Upgrade(upgrade.source(), localVersion, upgrade.status());
            initializeState(upgrade);
        }
    }
    // If the upgrade status is active, verify that the local version matches the upgrade version.
    if (upgrade.status().active() && !Objects.equals(upgrade.source(), upgrade.target())) {
        // the source or target version.
        if (!Objects.equals(localVersion, upgrade.source()) && !Objects.equals(localVersion, upgrade.target())) {
            log.error("Cannot upgrade node to version {}; Upgrade to {} already in progress", localVersion, upgrade.target());
            throw new IllegalStateException("Cannot upgrade node to version " + localVersion + "; Upgrade to " + upgrade.target() + " already in progress");
        }
    }
    state.addListener(stateListener);
    clusterService.addListener(clusterListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    state.removeListener(stateListener);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    state.removeListener(stateListener);
    clusterService.removeListener(clusterListener);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void changeState(Upgrade oldState, Upgrade newState) {
    checkPermission(UPGRADE_WRITE);
    if (!state.compareAndSet(oldState, newState)) {
        throw new IllegalStateException("Concurrent upgrade modification");
    } else {
        currentState.set(newState);
    }
}
#method_after
private void changeState(Upgrade oldState, Upgrade newState) {
    checkPermission(UPGRADE_WRITE);
    if (!state.compareAndSet(oldState, newState)) {
        throw new IllegalStateException("Concurrent upgrade modification");
    } else {
        currentState.set(newState);
    }
}
#end_block

#method_before
@Override
public void commit() {
    Upgrade upgraded = getState();
    // If the current upgrade status is not UPGRADED, throw an exception.
    if (upgraded.status() != Upgrade.Status.UPGRADED) {
        throw new IllegalStateException("Upgrade not performed");
    }
    // Determine whether any nodes have not been upgraded to the target version.
    boolean upgradeComplete = clusterService.getNodes().stream().allMatch(node -> {
        ControllerNode.State state = clusterService.getState(node.id());
        Version version = clusterService.getVersion(node.id());
        return state.isActive() && version != null && version.equals(upgraded.target());
    });
    // If some nodes have not yet been upgraded, throw an exception.
    if (!upgradeComplete) {
        throw new IllegalStateException("Some nodes have not yet been upgraded to version " + upgraded.target());
    }
    // Set the upgrade status to COMMITTING.
    Upgrade committing = new Upgrade(upgraded.source(), upgraded.target(), Upgrade.Status.COMMITTING);
    changeState(upgraded, committing);
    // Set the upgrade status to COMMITTED.
    Upgrade committed = new Upgrade(committing.source(), committing.target(), Upgrade.Status.COMMITTED);
    changeState(committing, committed);
    // Set the upgrade status to INACTIVE.
    Upgrade inactive = new Upgrade(localVersion, localVersion, Upgrade.Status.INACTIVE);
    changeState(committed, inactive);
}
#method_after
@Override
public void commit() {
    Upgrade upgraded = getState();
    // If the current upgrade status is not UPGRADED, throw an exception.
    if (upgraded.status() != Upgrade.Status.UPGRADED) {
        throw new IllegalStateException("Upgrade not performed");
    }
    // Determine whether any nodes have not been upgraded to the target version.
    boolean upgradeComplete = membershipService.getGroups().size() == 1 && membershipService.getLocalGroup().version().equals(upgraded.target());
    // If some nodes have not yet been upgraded, throw an exception.
    if (!upgradeComplete) {
        throw new IllegalStateException("Some nodes have not yet been upgraded to version " + upgraded.target());
    }
    // Set the upgrade status to COMMITTING.
    Upgrade committing = new Upgrade(upgraded.source(), upgraded.target(), Upgrade.Status.COMMITTING);
    changeState(upgraded, committing);
    // Set the upgrade status to COMMITTED.
    Upgrade committed = new Upgrade(committing.source(), committing.target(), Upgrade.Status.COMMITTED);
    changeState(committing, committed);
    // Set the upgrade status to INACTIVE.
    Upgrade inactive = new Upgrade(localVersion, localVersion, Upgrade.Status.INACTIVE);
    changeState(committed, inactive);
}
#end_block

#method_before
@Override
public void reset() {
    Upgrade upgraded = getState();
    // If the current upgrade status is not INITIALIZED or ROLLED_BACK, throw an exception.
    if (upgraded.status() != Upgrade.Status.INITIALIZED && upgraded.status() != Upgrade.Status.ROLLED_BACK) {
        throw new IllegalStateException("Upgrade not rolled back");
    }
    // Determine whether any nodes are still running the target version.
    boolean rollbackComplete = clusterService.getNodes().stream().allMatch(node -> {
        ControllerNode.State state = clusterService.getState(node.id());
        Version version = clusterService.getVersion(node.id());
        return state.isActive() && version != null && version.equals(upgraded.source());
    });
    // If some nodes have not yet been downgraded, throw an exception.
    if (!rollbackComplete) {
        throw new IllegalStateException("Some nodes have not yet been downgraded to version " + upgraded.source());
    }
    // Set the upgrade status to RESETTING.
    Upgrade resetting = new Upgrade(upgraded.source(), upgraded.target(), Upgrade.Status.RESETTING);
    changeState(upgraded, resetting);
    // Set the upgrade status to RESET.
    Upgrade reset = new Upgrade(resetting.source(), resetting.target(), Upgrade.Status.RESET);
    changeState(resetting, reset);
    // Set the upgrade status to INACTIVE.
    Upgrade inactive = new Upgrade(localVersion, localVersion, Upgrade.Status.INACTIVE);
    changeState(reset, inactive);
}
#method_after
@Override
public void reset() {
    Upgrade upgraded = getState();
    // If the current upgrade status is not INITIALIZED or ROLLED_BACK, throw an exception.
    if (upgraded.status() != Upgrade.Status.INITIALIZED && upgraded.status() != Upgrade.Status.ROLLED_BACK) {
        throw new IllegalStateException("Upgrade not rolled back");
    }
    // Determine whether any nodes are still running the target version.
    boolean rollbackComplete = membershipService.getGroups().size() == 1 && membershipService.getLocalGroup().version().equals(upgraded.source());
    // If some nodes have not yet been downgraded, throw an exception.
    if (!rollbackComplete) {
        throw new IllegalStateException("Some nodes have not yet been downgraded to version " + upgraded.source());
    }
    // Set the upgrade status to RESETTING.
    Upgrade resetting = new Upgrade(upgraded.source(), upgraded.target(), Upgrade.Status.RESETTING);
    changeState(upgraded, resetting);
    // Set the upgrade status to RESET.
    Upgrade reset = new Upgrade(resetting.source(), resetting.target(), Upgrade.Status.RESET);
    changeState(resetting, reset);
    // Set the upgrade status to INACTIVE.
    Upgrade inactive = new Upgrade(localVersion, localVersion, Upgrade.Status.INACTIVE);
    changeState(reset, inactive);
}
#end_block

#method_before
private static List<Permission> getAdminDefaultPerms() {
    List<Permission> permSet = Lists.newArrayList();
    permSet.add(new ServicePermission(ApplicationAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UnifiedClusterAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LeadershipAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterMetadataAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DriverAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(HostAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceKeyAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ResourceAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(RegionAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PartitionAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StorageAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ApplicationService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ComponentConfigService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterMetadataService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UnifiedClusterService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LeadershipService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(CodecService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(CoreService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(EventDeliveryService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipTermService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(BasicNetworkConfigService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(NetworkConfigService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DriverService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(EdgePortService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowRuleService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowObjectiveService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(GroupService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(HostService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentExtensionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(WorkPartitionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceKeyService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(MulticastRouteService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(MeterService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ResourceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PacketService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(RegionService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(LinkResourceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowStatisticService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StatisticService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PathService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(TopologyService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PersistenceService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(ApiDocService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterCommunicationService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UnifiedClusterCommunicationService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MessagingService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PartitionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LogicalClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StorageService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UiExtensionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UpgradeService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UpgradeAdminService.class.getName(), ServicePermission.GET));
    return permSet;
}
#method_after
private static List<Permission> getAdminDefaultPerms() {
    List<Permission> permSet = Lists.newArrayList();
    permSet.add(new ServicePermission(ApplicationAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LeadershipAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterMetadataAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DriverAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(HostAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceKeyAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ResourceAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(RegionAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PartitionAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StorageAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ApplicationService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ComponentConfigService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterMetadataService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LeadershipService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(CodecService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(CoreService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(EventDeliveryService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipTermService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(BasicNetworkConfigService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(NetworkConfigService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DriverService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(EdgePortService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowRuleService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowObjectiveService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(GroupService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(HostService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentExtensionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(WorkPartitionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceKeyService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(MulticastRouteService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(MeterService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ResourceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PacketService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(RegionService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(LinkResourceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowStatisticService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StatisticService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PathService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(TopologyService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PersistenceService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(ApiDocService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterCommunicationService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MessagingService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PartitionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LogicalClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StorageService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UiExtensionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UpgradeService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(UpgradeAdminService.class.getName(), ServicePermission.GET));
    return permSet;
}
#end_block

#method_before
private static ConcurrentHashMap<AppPermission.Type, Set<String>> getServiceDirectory() {
    ConcurrentHashMap<AppPermission.Type, Set<String>> serviceDirectory = new ConcurrentHashMap<>();
    serviceDirectory.put(APP_READ, ImmutableSet.of(ApplicationService.class.getName(), CoreService.class.getName()));
    serviceDirectory.put(APP_EVENT, ImmutableSet.of(ApplicationService.class.getName(), CoreService.class.getName()));
    serviceDirectory.put(APP_WRITE, ImmutableSet.of(CoreService.class.getName()));
    serviceDirectory.put(CONFIG_READ, ImmutableSet.of(ComponentConfigService.class.getName(), NetworkConfigService.class.getName()));
    serviceDirectory.put(CONFIG_WRITE, ImmutableSet.of(ComponentConfigService.class.getName(), NetworkConfigService.class.getName()));
    serviceDirectory.put(CONFIG_EVENT, ImmutableSet.of(NetworkConfigService.class.getName()));
    serviceDirectory.put(CLUSTER_READ, ImmutableSet.of(ClusterService.class.getName(), LeadershipService.class.getName(), MastershipService.class.getName(), ClusterMetadataService.class.getName(), MastershipTermService.class.getName(), UnifiedClusterService.class.getName()));
    serviceDirectory.put(CLUSTER_WRITE, ImmutableSet.of(LeadershipService.class.getName(), MastershipService.class.getName(), ClusterCommunicationService.class.getName(), MessagingService.class.getName(), UnifiedClusterCommunicationService.class.getName()));
    serviceDirectory.put(CLUSTER_EVENT, ImmutableSet.of(ClusterService.class.getName(), LeadershipService.class.getName(), MastershipService.class.getName(), UnifiedClusterService.class.getName()));
    serviceDirectory.put(DEVICE_READ, ImmutableSet.of(DeviceService.class.getName(), DeviceClockService.class.getName()));
    serviceDirectory.put(DEVICE_EVENT, ImmutableSet.of(DeviceService.class.getName()));
    serviceDirectory.put(DRIVER_READ, ImmutableSet.of(DriverService.class.getName()));
    serviceDirectory.put(DRIVER_WRITE, ImmutableSet.of(DriverService.class.getName()));
    serviceDirectory.put(FLOWRULE_READ, ImmutableSet.of(FlowRuleService.class.getName()));
    serviceDirectory.put(FLOWRULE_WRITE, ImmutableSet.of(FlowRuleService.class.getName(), FlowObjectiveService.class.getName()));
    serviceDirectory.put(FLOWRULE_EVENT, ImmutableSet.of(FlowRuleService.class.getName()));
    serviceDirectory.put(GROUP_READ, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(GROUP_WRITE, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(GROUP_EVENT, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(HOST_READ, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(HOST_WRITE, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(HOST_EVENT, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(INTENT_READ, ImmutableSet.of(IntentService.class.getName(), WorkPartitionService.class.getName(), IntentClockService.class.getName(), IntentExtensionService.class.getName()));
    serviceDirectory.put(INTENT_WRITE, ImmutableSet.of(IntentService.class.getName(), IntentExtensionService.class.getName()));
    serviceDirectory.put(INTENT_EVENT, ImmutableSet.of(IntentService.class.getName(), WorkPartitionService.class.getName()));
    // serviceDirectory.put(LINK_READ, ImmutableSet.of(
    // LinkService.class.getName(), LinkResourceService.class.getName(),
    // LabelResourceService.class.getName()));
    // serviceDirectory.put(LINK_WRITE, ImmutableSet.of(
    // LinkResourceService.class.getName(), LabelResourceService.class.getName()));
    // serviceDirectory.put(LINK_EVENT, ImmutableSet.of(
    // LinkService.class.getName(), LinkResourceService.class.getName(),
    // LabelResourceService.class.getName()));
    serviceDirectory.put(PACKET_EVENT, ImmutableSet.of(PacketService.class.getName()));
    serviceDirectory.put(STATISTIC_READ, ImmutableSet.of(StatisticService.class.getName(), FlowStatisticService.class.getName()));
    serviceDirectory.put(TOPOLOGY_READ, ImmutableSet.of(TopologyService.class.getName(), PathService.class.getName(), EdgePortService.class.getName()));
    serviceDirectory.put(TOPOLOGY_EVENT, ImmutableSet.of(TopologyService.class.getName()));
    // serviceDirectory.put(TUNNEL_READ, ImmutableSet.of(
    // TunnelService.class.getName()));
    // serviceDirectory.put(TUNNEL_WRITE, ImmutableSet.of(
    // TunnelService.class.getName()));
    // serviceDirectory.put(TUNNEL_EVENT, ImmutableSet.of(
    // TunnelService.class.getName()));
    serviceDirectory.put(STORAGE_WRITE, ImmutableSet.of(StorageService.class.getName()));
    serviceDirectory.put(CODEC_READ, ImmutableSet.of(CodecService.class.getName()));
    serviceDirectory.put(CODEC_WRITE, ImmutableSet.of(CodecService.class.getName()));
    serviceDirectory.put(EVENT_READ, ImmutableSet.of(EventDeliveryService.class.getName()));
    serviceDirectory.put(EVENT_WRITE, ImmutableSet.of(EventDeliveryService.class.getName()));
    serviceDirectory.put(RESOURCE_READ, ImmutableSet.of(ResourceService.class.getName()));
    serviceDirectory.put(RESOURCE_WRITE, ImmutableSet.of(ResourceService.class.getName()));
    serviceDirectory.put(RESOURCE_EVENT, ImmutableSet.of(ResourceService.class.getName()));
    serviceDirectory.put(REGION_READ, ImmutableSet.of(RegionService.class.getName()));
    serviceDirectory.put(PERSISTENCE_WRITE, ImmutableSet.of(PersistenceService.class.getName()));
    serviceDirectory.put(PARTITION_READ, ImmutableSet.of(PartitionService.class.getName()));
    serviceDirectory.put(PARTITION_EVENT, ImmutableSet.of(PartitionService.class.getName()));
    serviceDirectory.put(CLOCK_WRITE, ImmutableSet.of(LogicalClockService.class.getName()));
    serviceDirectory.put(UPGRADE_READ, ImmutableSet.of(UpgradeService.class.getName(), UpgradeAdminService.class.getName()));
    serviceDirectory.put(UPGRADE_WRITE, ImmutableSet.of(UpgradeAdminService.class.getName()));
    serviceDirectory.put(UPGRADE_EVENT, ImmutableSet.of(UpgradeService.class.getName(), UpgradeAdminService.class.getName()));
    return serviceDirectory;
}
#method_after
private static ConcurrentHashMap<AppPermission.Type, Set<String>> getServiceDirectory() {
    ConcurrentHashMap<AppPermission.Type, Set<String>> serviceDirectory = new ConcurrentHashMap<>();
    serviceDirectory.put(APP_READ, ImmutableSet.of(ApplicationService.class.getName(), CoreService.class.getName()));
    serviceDirectory.put(APP_EVENT, ImmutableSet.of(ApplicationService.class.getName(), CoreService.class.getName()));
    serviceDirectory.put(APP_WRITE, ImmutableSet.of(CoreService.class.getName()));
    serviceDirectory.put(CONFIG_READ, ImmutableSet.of(ComponentConfigService.class.getName(), NetworkConfigService.class.getName()));
    serviceDirectory.put(CONFIG_WRITE, ImmutableSet.of(ComponentConfigService.class.getName(), NetworkConfigService.class.getName()));
    serviceDirectory.put(CONFIG_EVENT, ImmutableSet.of(NetworkConfigService.class.getName()));
    serviceDirectory.put(CLUSTER_READ, ImmutableSet.of(ClusterService.class.getName(), LeadershipService.class.getName(), MastershipService.class.getName(), ClusterMetadataService.class.getName(), MastershipTermService.class.getName()));
    serviceDirectory.put(CLUSTER_WRITE, ImmutableSet.of(LeadershipService.class.getName(), MastershipService.class.getName(), ClusterCommunicationService.class.getName(), MessagingService.class.getName()));
    serviceDirectory.put(CLUSTER_EVENT, ImmutableSet.of(ClusterService.class.getName(), LeadershipService.class.getName(), MastershipService.class.getName()));
    serviceDirectory.put(DEVICE_READ, ImmutableSet.of(DeviceService.class.getName(), DeviceClockService.class.getName()));
    serviceDirectory.put(DEVICE_EVENT, ImmutableSet.of(DeviceService.class.getName()));
    serviceDirectory.put(DRIVER_READ, ImmutableSet.of(DriverService.class.getName()));
    serviceDirectory.put(DRIVER_WRITE, ImmutableSet.of(DriverService.class.getName()));
    serviceDirectory.put(FLOWRULE_READ, ImmutableSet.of(FlowRuleService.class.getName()));
    serviceDirectory.put(FLOWRULE_WRITE, ImmutableSet.of(FlowRuleService.class.getName(), FlowObjectiveService.class.getName()));
    serviceDirectory.put(FLOWRULE_EVENT, ImmutableSet.of(FlowRuleService.class.getName()));
    serviceDirectory.put(GROUP_READ, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(GROUP_WRITE, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(GROUP_EVENT, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(HOST_READ, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(HOST_WRITE, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(HOST_EVENT, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(INTENT_READ, ImmutableSet.of(IntentService.class.getName(), WorkPartitionService.class.getName(), IntentClockService.class.getName(), IntentExtensionService.class.getName()));
    serviceDirectory.put(INTENT_WRITE, ImmutableSet.of(IntentService.class.getName(), IntentExtensionService.class.getName()));
    serviceDirectory.put(INTENT_EVENT, ImmutableSet.of(IntentService.class.getName(), WorkPartitionService.class.getName()));
    // serviceDirectory.put(LINK_READ, ImmutableSet.of(
    // LinkService.class.getName(), LinkResourceService.class.getName(),
    // LabelResourceService.class.getName()));
    // serviceDirectory.put(LINK_WRITE, ImmutableSet.of(
    // LinkResourceService.class.getName(), LabelResourceService.class.getName()));
    // serviceDirectory.put(LINK_EVENT, ImmutableSet.of(
    // LinkService.class.getName(), LinkResourceService.class.getName(),
    // LabelResourceService.class.getName()));
    serviceDirectory.put(PACKET_EVENT, ImmutableSet.of(PacketService.class.getName()));
    serviceDirectory.put(STATISTIC_READ, ImmutableSet.of(StatisticService.class.getName(), FlowStatisticService.class.getName()));
    serviceDirectory.put(TOPOLOGY_READ, ImmutableSet.of(TopologyService.class.getName(), PathService.class.getName(), EdgePortService.class.getName()));
    serviceDirectory.put(TOPOLOGY_EVENT, ImmutableSet.of(TopologyService.class.getName()));
    // serviceDirectory.put(TUNNEL_READ, ImmutableSet.of(
    // TunnelService.class.getName()));
    // serviceDirectory.put(TUNNEL_WRITE, ImmutableSet.of(
    // TunnelService.class.getName()));
    // serviceDirectory.put(TUNNEL_EVENT, ImmutableSet.of(
    // TunnelService.class.getName()));
    serviceDirectory.put(STORAGE_WRITE, ImmutableSet.of(StorageService.class.getName()));
    serviceDirectory.put(CODEC_READ, ImmutableSet.of(CodecService.class.getName()));
    serviceDirectory.put(CODEC_WRITE, ImmutableSet.of(CodecService.class.getName()));
    serviceDirectory.put(EVENT_READ, ImmutableSet.of(EventDeliveryService.class.getName()));
    serviceDirectory.put(EVENT_WRITE, ImmutableSet.of(EventDeliveryService.class.getName()));
    serviceDirectory.put(RESOURCE_READ, ImmutableSet.of(ResourceService.class.getName()));
    serviceDirectory.put(RESOURCE_WRITE, ImmutableSet.of(ResourceService.class.getName()));
    serviceDirectory.put(RESOURCE_EVENT, ImmutableSet.of(ResourceService.class.getName()));
    serviceDirectory.put(REGION_READ, ImmutableSet.of(RegionService.class.getName()));
    serviceDirectory.put(PERSISTENCE_WRITE, ImmutableSet.of(PersistenceService.class.getName()));
    serviceDirectory.put(PARTITION_READ, ImmutableSet.of(PartitionService.class.getName()));
    serviceDirectory.put(PARTITION_EVENT, ImmutableSet.of(PartitionService.class.getName()));
    serviceDirectory.put(CLOCK_WRITE, ImmutableSet.of(LogicalClockService.class.getName()));
    serviceDirectory.put(UPGRADE_READ, ImmutableSet.of(UpgradeService.class.getName(), UpgradeAdminService.class.getName()));
    serviceDirectory.put(UPGRADE_WRITE, ImmutableSet.of(UpgradeAdminService.class.getName()));
    serviceDirectory.put(UPGRADE_EVENT, ImmutableSet.of(UpgradeService.class.getName(), UpgradeAdminService.class.getName()));
    return serviceDirectory;
}
#end_block

#method_before
@Override
public List<Alarm> consumeAlarms() {
    try {
        restCiena = new CienaRestDevice(handler());
    } catch (NullPointerException e) {
        log.error("unable to create CienaRestDevice:\n{}", e);
        return null;
    }
    return restCiena.getAlarms();
}
#method_after
@Override
public List<Alarm> consumeAlarms() {
    try {
        restCiena = new CienaRestDevice(handler());
    } catch (NullPointerException e) {
        log.error("unable to create CienaRestDevice:\n", e);
        return null;
    }
    return restCiena.getAlarms();
}
#end_block

#method_before
private Alarm newAlarmFromJsonNode(JsonNode jsonNode) {
    AlarmId alarmId = AlarmId.alarmId(jsonNode.get(ALARM_INSTANCE_ID).asText());
    Alarm.SeverityLevel severity = SERVERITY_MAP.get(jsonNode.get(SERVERITY).asText());
    String time = jsonNode.get(ALARM_LOCAL_DATE_TIME).asText();
    String instance = jsonNode.get(INSTANCE).asText().toLowerCase();
    String description = jsonNode.get(DESCRIPTION).asText() + " - " + instance + " - " + time;
    AlarmEntityId source;
    if (instance.contains(PORT)) {
        source = AlarmEntityId.alarmEntityId(instance.replace("-", ":"));
    } else if (instance.contains(PTP)) {
        source = AlarmEntityId.alarmEntityId(instance.replace(PTP + "-", PORT + ":"));
    } else {
        source = AlarmEntityId.alarmEntityId(OTHER + ":" + jsonNode.get(INSTANCE).asText());
    }
    boolean isAcknowledged = jsonNode.get(ACKNOWLEDGE).asBoolean();
    if (severity == null) {
        severity = Alarm.SeverityLevel.MINOR;
        log.warn("serverity level {} not supported, setting serverity level to {}", jsonNode.get(SERVERITY), severity.name());
    }
    // TODO: should we use time given by jsonNode and covert it long?
    long timeRaised = System.currentTimeMillis();
    return new DefaultAlarm.Builder(alarmId, deviceId, description, severity, timeRaised).withAcknowledged(isAcknowledged).forSource(source).build();
}
#method_after
private Alarm newAlarmFromJsonNode(JsonNode jsonNode) {
    try {
        AlarmId alarmId = AlarmId.alarmId(checkNotNull(jsonNode.get(ALARM_INSTANCE_ID)).asText());
        String time = checkNotNull(jsonNode.get(ALARM_LOCAL_DATE_TIME)).asText();
        String instance = checkNotNull(jsonNode.get(INSTANCE).asText()).toLowerCase();
        String description = checkNotNull(jsonNode.get(DESCRIPTION)).asText() + " - " + instance + " - " + time;
        AlarmEntityId source = getAlarmSource(instance);
        Alarm.SeverityLevel severity = Alarm.SeverityLevel.valueOf(checkNotNull(jsonNode.get(SEVERITY)).asText().toUpperCase());
        long timeRaised = parseAlarmTime(time);
        boolean isAcknowledged = checkNotNull(jsonNode.get(ACKNOWLEDGE)).asBoolean();
        return new DefaultAlarm.Builder(alarmId, deviceId, description, severity, timeRaised).withAcknowledged(isAcknowledged).forSource(source).build();
    } catch (NullPointerException e) {
        log.error("got exception while parsing alarm json node {} for device {}:\n", jsonNode, deviceId, e);
        return null;
    }
}
#end_block

#method_before
private List<Alarm> getActiveAlarms() {
    log.debug("getting active alarms for device {}", deviceId);
    try {
        List<JsonNode> alarms = Lists.newArrayList(get(ACTIVE_ALARMS_URL).get(ACTIVE).elements());
        return alarms.stream().map(a -> newAlarmFromJsonNode(a)).collect(Collectors.toList());
    } catch (IOException e) {
        log.error("unable to get active alarms fro device {}:\n{}", deviceId, e);
        return null;
    }
}
#method_after
private List<Alarm> getActiveAlarms() {
    log.debug("getting active alarms for device {}", deviceId);
    try {
        List<JsonNode> alarms = Lists.newArrayList(get(ACTIVE_ALARMS_URL).get(ACTIVE).elements());
        return alarms.stream().map(a -> newAlarmFromJsonNode(a)).filter(a -> a != null).collect(Collectors.toList());
    } catch (IOException e) {
        log.error("unable to get active alarms for device {}:\n", deviceId, e);
        return null;
    }
}
#end_block

#method_before
@Override
public void event(InterfaceEvent event) {
    Interface i = event.subject();
    switch(event.type()) {
        case INTERFACE_ADDED:
            activateRouterAdvertisement(i.connectPoint(), i.ipAddressesList());
            break;
        case INTERFACE_REMOVED:
            deactivateRouterAdvertisement(i.connectPoint(), i.ipAddressesList());
            break;
        case INTERFACE_UPDATED:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(InterfaceEvent event) {
    Interface i = event.subject();
    switch(event.type()) {
        case INTERFACE_ADDED:
            if (mastershipService.getLocalRole(i.connectPoint().deviceId()) == MastershipRole.MASTER) {
                activateRouterAdvertisement(i.connectPoint(), i.ipAddressesList());
            }
            break;
        case INTERFACE_REMOVED:
            if (mastershipService.getLocalRole(i.connectPoint().deviceId()) == MastershipRole.MASTER) {
                deactivateRouterAdvertisement(i.connectPoint(), i.ipAddressesList());
            }
            break;
        case INTERFACE_UPDATED:
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void activateRouterAdvertisement(ConnectPoint connectPoint, List<InterfaceIpAddress> addresses) {
    synchronized (this) {
        RAWorkerThread worker = new RAWorkerThread(connectPoint, addresses);
        ScheduledFuture<?> handler = executors.scheduleAtFixedRate(worker, raThreadDelay, raThreadDelay, TimeUnit.SECONDS);
        transmitters.put(connectPoint, handler);
    }
}
#method_after
private void activateRouterAdvertisement(ConnectPoint connectPoint, List<InterfaceIpAddress> addresses) {
    synchronized (this) {
        RAWorkerThread worker = new RAWorkerThread(connectPoint, addresses, raThreadDelay);
        ScheduledFuture<?> handler = executors.scheduleAtFixedRate(worker, raThreadDelay, raThreadDelay, TimeUnit.SECONDS);
        transmitters.put(connectPoint, handler);
    }
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    log.info("\nStarting RA application...");
    /* Basic application registrations. */
    appId = coreService.registerApplication(APP_NAME);
    componentConfigService.registerProperties(getClass());
    /* Loading configured properties. */
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        try {
            String s = get(properties, PROP_RA_THREADS_POOL);
            raPoolSize = isNullOrEmpty(s) ? DEFAULT_RA_THREADS_POOL_SIZE : Integer.parseInt(s.trim());
            s = get(properties, PROP_RA_THREADS_DELAY);
            raThreadDelay = isNullOrEmpty(s) ? DEFAULT_RA_THREADS_DELAY : Integer.parseInt(s.trim());
        } catch (NumberFormatException e) {
            log.warn("Component configuration had invalid value, loading default values.", e);
        }
    }
    /* Interface listener for dynamic RA handling. */
    interfaceService.addListener(interfaceListener);
    /* Initialize RA thread pool */
    executors = Executors.newScheduledThreadPool(raPoolSize, groupedThreads("RouterAdvertisement", "event-%d", log));
    /* Start Router Advertisement Transmission for all configured interfaces. */
    interfaceService.getInterfaces().stream().filter(i -> i.ipAddressesList().stream().anyMatch(ia -> ia.ipAddress().version().equals(IpAddress.Version.INET6))).forEach(j -> activateRouterAdvertisement(j.connectPoint(), j.ipAddressesList()));
    log.info("\nDone...");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    // Basic application registrations.
    appId = coreService.registerApplication(APP_NAME);
    componentConfigService.registerProperties(getClass());
    // Loading configured properties.
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        try {
            String s = get(properties, PROP_RA_THREADS_POOL);
            raPoolSize = isNullOrEmpty(s) ? DEFAULT_RA_THREADS_POOL_SIZE : Integer.parseInt(s.trim());
            s = get(properties, PROP_RA_THREADS_DELAY);
            raThreadDelay = isNullOrEmpty(s) ? DEFAULT_RA_THREADS_DELAY : Integer.parseInt(s.trim());
        } catch (NumberFormatException e) {
            log.warn("Component configuration had invalid value, loading default values.", e);
        }
    }
    // Interface listener for dynamic RA handling.
    interfaceService.addListener(interfaceListener);
    // Initialize RA thread pool
    executors = Executors.newScheduledThreadPool(raPoolSize, groupedThreads("RouterAdvertisement", "event-%d", log));
    // Start Router Advertisement Transmission for all configured interfaces.
    interfaceService.getInterfaces().stream().filter(i -> mastershipService.getLocalRole(i.connectPoint().deviceId()) == MastershipRole.MASTER).filter(i -> i.ipAddressesList().stream().anyMatch(ia -> ia.ipAddress().version().equals(IpAddress.Version.INET6))).forEach(j -> activateRouterAdvertisement(j.connectPoint(), j.ipAddressesList()));
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    log.info("Stopping RA application.");
    /* Unregister resources. */
    componentConfigService.unregisterProperties(getClass(), false);
    interfaceService.removeListener(interfaceListener);
    /* Clear out Router Advertisement Transmission for all configured interfaces. */
    interfaceService.getInterfaces().stream().filter(i -> i.ipAddressesList().stream().anyMatch(ia -> ia.ipAddress().version().equals(IpAddress.Version.INET6))).forEach(j -> deactivateRouterAdvertisement(j.connectPoint(), j.ipAddressesList()));
    log.info("Done...");
}
#method_after
@Deactivate
protected void deactivate() {
    // Unregister resources.
    componentConfigService.unregisterProperties(getClass(), false);
    interfaceService.removeListener(interfaceListener);
    // Clear out Router Advertisement Transmission for all configured interfaces.
    interfaceService.getInterfaces().stream().filter(i -> mastershipService.getLocalRole(i.connectPoint().deviceId()) == MastershipRole.MASTER).filter(i -> i.ipAddressesList().stream().anyMatch(ia -> ia.ipAddress().version().equals(IpAddress.Version.INET6))).forEach(j -> deactivateRouterAdvertisement(j.connectPoint(), j.ipAddressesList()));
}
#end_block

#method_before
public void run() {
    log.debug("\nTransmitting RA. ConnectPoint : {}, IPv6 : {}", connectPoint.toString(), ipAddresses.toString());
    /* Router Advertisement header filling. Please refer RFC-2461. */
    RouterAdvertisement ra = new RouterAdvertisement();
    ra.setCurrentHopLimit((byte) 64);
    ra.setMFlag((byte) 0x00);
    ra.setOFlag((byte) 0x00);
    ra.setRouterLifetime((short) 1800);
    ra.setReachableTime(0);
    ra.setRetransmitTimer(1000);
    /* Option : Source link-layer address. */
    byte[] optionBuffer = new byte[500];
    /* TODO : Set to maximum "Option" length. */
    ByteBuffer option = ByteBuffer.wrap(optionBuffer);
    MacAddress portMac = MacAddress.valueOf(deviceService.getPort(connectPoint.deviceId(), connectPoint.port()).annotations().value("portMac"));
    option.put(portMac.toBytes());
    ra.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, Arrays.copyOfRange(option.array(), 0, option.position()));
    /* Option : MTU. */
    option.rewind();
    option.putShort((short) 0);
    option.putInt(1500);
    /* TODO: Determine it dynamically. */
    ra.addOption(NeighborDiscoveryOptions.TYPE_MTU, Arrays.copyOfRange(option.array(), 0, option.position()));
    /* Option : Prefix information. */
    ipAddresses.stream().filter(i -> i.ipAddress().version().equals(IpAddress.Version.INET6)).forEach(i -> {
        option.rewind();
        option.put((byte) i.subnetAddress().prefixLength());
        option.put((byte) 0x80);
        /* TODO : Only "onlink" option enabled. */
        option.putInt(600);
        option.putInt(600);
        option.putInt(0x00000000);
        option.put(IpAddress.makeMaskedAddress(i.ipAddress(), i.subnetAddress().prefixLength()).toOctets());
        ra.addOption(NeighborDiscoveryOptions.TYPE_PREFIX_INFORMATION, Arrays.copyOfRange(option.array(), 0, option.position()));
    });
    /* ICMPv6 header filling. */
    ICMP6 icmpv6 = new ICMP6();
    icmpv6.setIcmpType(ICMP6.ROUTER_ADVERTISEMENT);
    icmpv6.setIcmpCode((byte) 0);
    icmpv6.setPayload(ra);
    /* IPv6 header filling. */
    IPv6 ipv6 = new IPv6();
    ipv6.setDestinationAddress(Ip6Address.valueOf("ff02::1").toOctets());
    /* RA packet L2 source address created from port MAC address.
             * Note : As per RFC-4861 RAs should be sent from link-local address.
             */
    ipv6.setSourceAddress(Ip6Address.valueOf(buildLinkLocalAddressFromMAC(portMac)).toOctets());
    ipv6.setNextHeader(IPv6.PROTOCOL_ICMP6);
    ipv6.setHopLimit((byte) 0xff);
    ipv6.setTrafficClass((byte) 0xe0);
    ipv6.setPayload(icmpv6);
    /* Ethernet header filling. */
    Ethernet ethernet = new Ethernet();
    ethernet.setDestinationMACAddress(MacAddress.BROADCAST);
    ethernet.setSourceMACAddress(portMac.toBytes());
    ethernet.setEtherType(EthType.EtherType.IPV6.ethType().toShort());
    ethernet.setVlanID(Ethernet.VLAN_UNTAGGED);
    ethernet.setPayload(ipv6);
    ethernet.setPad(false);
    /* Flush out PACKET_OUT.  */
    ByteBuffer stream = ByteBuffer.wrap(ethernet.serialize());
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(connectPoint.port()).build();
    OutboundPacket packet = new DefaultOutboundPacket(connectPoint.deviceId(), treatment, stream);
    packetService.emit(packet);
    log.debug("\nDone...");
}
#method_after
public void run() {
    // Router Advertisement header filling. Please refer RFC-2461.
    RouterAdvertisement ra = new RouterAdvertisement();
    ra.setCurrentHopLimit(RA_HOP_LIMIT);
    ra.setMFlag((byte) 0x01);
    ra.setOFlag((byte) 0x00);
    ra.setRouterLifetime(RA_ROUTER_LIFETIME);
    ra.setReachableTime(0);
    ra.setRetransmitTimer(retransmitPeriod + RA_RETRANSMIT_CALIBRATION_PERIOD);
    // Option : Source link-layer address.
    byte[] optionBuffer = new byte[RA_OPTIONS_BUFFER_SIZE];
    ByteBuffer option = ByteBuffer.wrap(optionBuffer);
    Optional<MacAddress> macAddress = interfaceService.getInterfacesByPort(connectPoint).stream().map(Interface::mac).findFirst();
    if (!macAddress.isPresent()) {
        log.warn("Unable to retrieve interface {} MAC address. Terminating RA transmission.", connectPoint);
        return;
    }
    option.put(macAddress.get().toBytes());
    ra.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, Arrays.copyOfRange(option.array(), 0, option.position()));
    // Option : MTU.
    option.rewind();
    option.putShort((short) 0);
    option.putInt(RA_OPTION_MTU_VALUE);
    ra.addOption(NeighborDiscoveryOptions.TYPE_MTU, Arrays.copyOfRange(option.array(), 0, option.position()));
    // Option : Prefix information.
    ipAddresses.stream().filter(i -> i.ipAddress().version().equals(IpAddress.Version.INET6)).forEach(i -> {
        option.rewind();
        option.put((byte) i.subnetAddress().prefixLength());
        // Enable "onlink" option only.
        option.put((byte) 0x80);
        option.putInt(RA_OPTION_PREFIX_VALID_LIFETIME);
        option.putInt(RA_OPTION_PREFIX_PREFERRED_LIFETIME);
        // Clear reserved fields
        option.putInt(0x00000000);
        option.put(IpAddress.makeMaskedAddress(i.ipAddress(), i.subnetAddress().prefixLength()).toOctets());
        ra.addOption(NeighborDiscoveryOptions.TYPE_PREFIX_INFORMATION, Arrays.copyOfRange(option.array(), 0, option.position()));
    });
    // ICMPv6 header filling.
    ICMP6 icmpv6 = new ICMP6();
    icmpv6.setIcmpType(ICMP6.ROUTER_ADVERTISEMENT);
    icmpv6.setIcmpCode((byte) 0);
    icmpv6.setPayload(ra);
    // IPv6 header filling.
    byte[] ip6AllNodesAddress = Ip6Address.valueOf("ff02::1").toOctets();
    IPv6 ipv6 = new IPv6();
    ipv6.setDestinationAddress(ip6AllNodesAddress);
    /* RA packet L2 source address created from port MAC address.
             * Note : As per RFC-4861 RAs should be sent from link-local address.
             */
    ipv6.setSourceAddress(IPv6.getLinkLocalAddress(macAddress.get().toBytes()));
    ipv6.setNextHeader(IPv6.PROTOCOL_ICMP6);
    ipv6.setHopLimit(RA_HOP_LIMIT);
    ipv6.setTrafficClass((byte) 0xe0);
    ipv6.setPayload(icmpv6);
    // Ethernet header filling.
    Ethernet ethernet = new Ethernet();
    /* Ethernet IPv6 multicast address creation.
             * Refer : RFC 2624 section 7.
             */
    byte[] l2Ipv6MulticastAddress = MacAddress.IPV6_MULTICAST.toBytes();
    IntStream.range(1, 4).forEach(i -> l2Ipv6MulticastAddress[l2Ipv6MulticastAddress.length - i] = ip6AllNodesAddress[ip6AllNodesAddress.length - i]);
    ethernet.setDestinationMACAddress(MacAddress.valueOf(l2Ipv6MulticastAddress));
    ethernet.setSourceMACAddress(macAddress.get().toBytes());
    ethernet.setEtherType(EthType.EtherType.IPV6.ethType().toShort());
    ethernet.setVlanID(Ethernet.VLAN_UNTAGGED);
    ethernet.setPayload(ipv6);
    ethernet.setPad(false);
    // Flush out PACKET_OUT.
    ByteBuffer stream = ByteBuffer.wrap(ethernet.serialize());
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(connectPoint.port()).build();
    OutboundPacket packet = new DefaultOutboundPacket(connectPoint.deviceId(), treatment, stream);
    packetService.emit(packet);
}
#end_block

#method_before
@Override
public boolean isAvailable() {
    try {
        URL url = new URL(metadataUrl);
        if ("file".equals(url.getProtocol())) {
            File file = new File(metadataUrl.replaceFirst("file://", ""));
            return file.exists();
        } else if ("http".equals(url.getProtocol())) {
            try (InputStream file = url.openStream()) {
                return true;
            }
        } else {
            // Unsupported protocol
            return false;
        }
    } catch (Exception e) {
        log.warn("Exception accessing metadata file at {}:", metadataUrl, e);
        return false;
    }
}
#method_after
@Override
public boolean isAvailable() {
    try {
        URL url = new URL(metadataUrl);
        if ("file".equals(url.getProtocol())) {
            File file = new File(metadataUrl.replaceFirst("file://", ""));
            return file.exists();
        } else {
            // Return true for HTTP URLs since we allow blocking until HTTP servers come up
            return "http".equals(url.getProtocol());
        }
    } catch (Exception e) {
        log.warn("Exception accessing metadata file at {}:", metadataUrl, e);
        return false;
    }
}
#end_block

#method_before
private Versioned<ClusterMetadata> blockForMetadata(String metadataUrl) {
    for (; ; ) {
        Versioned<ClusterMetadata> metadata = fetchMetadata(metadataUrl);
        if (metadata != null) {
            return metadata;
        }
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            throw Throwables.propagate(e);
        }
    }
}
#method_after
private Versioned<ClusterMetadata> blockForMetadata(String metadataUrl) {
    int iterations = 0;
    for (; ; ) {
        Versioned<ClusterMetadata> metadata = fetchMetadata(metadataUrl);
        if (metadata != null) {
            return metadata;
        }
        try {
            Thread.sleep(Math.min((int) Math.pow(2, ++iterations) * 10, 1000));
        } catch (InterruptedException e) {
            throw Throwables.propagate(e);
        }
    }
}
#end_block

#method_before
private Versioned<ClusterMetadata> fetchMetadata(String metadataUrl) {
    try {
        URL url = new URL(metadataUrl);
        ClusterMetadata metadata = null;
        long version = 0;
        if ("file".equals(url.getProtocol())) {
            File file = new File(metadataUrl.replaceFirst("file://", ""));
            version = file.lastModified();
            metadata = mapper.readValue(new FileInputStream(file), ClusterMetadata.class);
        } else if ("http".equals(url.getProtocol())) {
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            if (conn.getResponseCode() == HttpURLConnection.HTTP_NO_CONTENT) {
                return null;
            }
            version = conn.getLastModified();
            metadata = mapper.readValue(conn.getInputStream(), ClusterMetadata.class);
        }
        if (null == metadata) {
            log.warn("Metadata is null in the function fetchMetadata");
            throw new NullPointerException();
        }
        // needs to be polled until the partitions are populated.
        if (metadata.getPartitions().isEmpty() || metadata.getPartitions().stream().map(partition -> partition.getMembers().size()).reduce(Math::min).orElse(0) == 0) {
            return null;
        }
        return new Versioned<>(new ClusterMetadata(PROVIDER_ID, metadata.getName(), Sets.newHashSet(metadata.getNodes()), Sets.newHashSet(metadata.getPartitions())), version);
    } catch (IOException e) {
        throw Throwables.propagate(e);
    }
}
#method_after
private Versioned<ClusterMetadata> fetchMetadata(String metadataUrl) {
    try {
        URL url = new URL(metadataUrl);
        ClusterMetadata metadata = null;
        long version = 0;
        if ("file".equals(url.getProtocol())) {
            File file = new File(metadataUrl.replaceFirst("file://", ""));
            version = file.lastModified();
            metadata = mapper.readValue(new FileInputStream(file), ClusterMetadata.class);
        } else if ("http".equals(url.getProtocol())) {
            try {
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                if (conn.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {
                    log.warn("Could not reach metadata URL {}. Retrying...", url);
                    return null;
                }
                if (conn.getResponseCode() == HttpURLConnection.HTTP_NO_CONTENT) {
                    return null;
                }
                version = conn.getLastModified();
                metadata = mapper.readValue(conn.getInputStream(), ClusterMetadata.class);
            } catch (IOException e) {
                log.warn("Could not reach metadata URL {}. Retrying...", url);
                return null;
            }
        }
        if (null == metadata) {
            log.warn("Metadata is null in the function fetchMetadata");
            throw new NullPointerException();
        }
        // needs to be polled until the partitions are populated.
        if (metadata.getPartitions().isEmpty() || metadata.getPartitions().stream().map(partition -> partition.getMembers().size()).reduce(Math::min).orElse(0) == 0) {
            return null;
        }
        return new Versioned<>(new ClusterMetadata(PROVIDER_ID, metadata.getName(), Sets.newHashSet(metadata.getNodes()), Sets.newHashSet(metadata.getPartitions())), version);
    } catch (IOException e) {
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
private void watchUrl(String metadataUrl) {
    // This can be easily addressed for files. For http urls we need to move to a push style protocol.
    try {
        Versioned<ClusterMetadata> latestMetadata = fetchMetadata(metadataUrl);
        if (cachedMetadata.get() != null && latestMetadata != null && cachedMetadata.get().version() < latestMetadata.version()) {
            cachedMetadata.set(latestMetadata);
            providerService.clusterMetadataChanged(latestMetadata);
        }
    } catch (Exception e) {
        log.error("Caught Exception ", e);
    }
}
#method_after
private void watchUrl(String metadataUrl) {
    // This can be easily addressed for files. For http urls we need to move to a push style protocol.
    try {
        Versioned<ClusterMetadata> latestMetadata = fetchMetadata(metadataUrl);
        if (cachedMetadata.get() != null && latestMetadata != null && cachedMetadata.get().version() < latestMetadata.version()) {
            cachedMetadata.set(latestMetadata);
            providerService.clusterMetadataChanged(latestMetadata);
        }
    } catch (Exception e) {
        log.error("Unable to parse metadata : ", e);
    }
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createRoute(InputStream stream) {
    MulticastRouteService service = get(MulticastRouteService.class);
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        McastRoute route = codec(McastRoute.class).decode(jsonTree, this);
        service.add(route);
        if (jsonTree.has("ingress")) {
            String ingressP = jsonTree.path("ingress").asText();
            ConnectPoint igP = ConnectPoint.deviceConnectPoint(ingressP);
            service.addSource(route, igP);
        }
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.created(URI.create("")).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createRoute(InputStream stream) {
    final String ingressStr = "ingress";
    MulticastRouteService service = get(MulticastRouteService.class);
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        McastRoute route = codec(McastRoute.class).decode(jsonTree, this);
        service.add(route);
        if (jsonTree.has(ingressStr)) {
            String ingressPathStr = jsonTree.path(ingressStr).asText();
            ConnectPoint ingressConnectPoint = nullIsNotFound(ConnectPoint.deviceConnectPoint(ingressPathStr), "ingress connection point cannot be null!");
            service.addSource(route, ingressConnectPoint);
        }
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.created(URI.create("")).build();
}
#end_block

#method_before
@Override
public Builder add(Instruction instruction) {
    switch(instruction.type()) {
        case NOACTION:
        case OUTPUT:
        case GROUP:
        case QUEUE:
        case L0MODIFICATION:
        case L1MODIFICATION:
        case L2MODIFICATION:
        case L3MODIFICATION:
        case L4MODIFICATION:
        case PROTOCOL_INDEPENDENT:
        case EXTENSION:
            current.add(instruction);
            break;
        case TABLE:
            table = (Instructions.TableTypeTransition) instruction;
            break;
        case METADATA:
            meta = (Instructions.MetadataInstruction) instruction;
            break;
        case METER:
            meter = (Instructions.MeterInstruction) instruction;
            break;
        case STATTRIGGER:
            statTrigger = (Instructions.StatTriggerInstruction) instruction;
            break;
        default:
            throw new IllegalArgumentException("Unknown instruction type: " + instruction.type());
    }
    return this;
}
#method_after
@Override
public Builder add(Instruction instruction) {
    switch(instruction.type()) {
        case NOACTION:
        case OUTPUT:
        case GROUP:
        case QUEUE:
        case L0MODIFICATION:
        case L1MODIFICATION:
        case L2MODIFICATION:
        case L3MODIFICATION:
        case L4MODIFICATION:
        case PROTOCOL_INDEPENDENT:
        case EXTENSION:
            current.add(instruction);
            break;
        case TABLE:
            table = (Instructions.TableTypeTransition) instruction;
            break;
        case METADATA:
            meta = (Instructions.MetadataInstruction) instruction;
            break;
        case METER:
            meter = (Instructions.MeterInstruction) instruction;
            break;
        case STAT_TRIGGER:
            statTrigger = (Instructions.StatTriggerInstruction) instruction;
            break;
        default:
            throw new IllegalArgumentException("Unknown instruction type: " + instruction.type());
    }
    return this;
}
#end_block

#method_before
private Instruction decodeStatTrigger() {
    String statTriggerFlag = nullIsIllegal(json.get(InstructionCodec.STAT_TRIGGER_FLAG), InstructionCodec.STAT_TRIGGER_FLAG + InstructionCodec.ERROR_MESSAGE).asText();
    StatTriggerFlag flag = null;
    if (statTriggerFlag.equals(StatTriggerFlag.ONLY_FIRST.name())) {
        flag = StatTriggerFlag.ONLY_FIRST;
    } else if (statTriggerFlag.equals(StatTriggerFlag.PRERIODIC.name())) {
        flag = StatTriggerFlag.PRERIODIC;
    }
    if (flag == null) {
        throw new IllegalArgumentException("statTriggerFlag " + statTriggerFlag + " is not supported");
    }
    if (!json.has(InstructionCodec.STAT_THRESHOLDS)) {
        throw new IllegalArgumentException("statThreshold is not added");
    }
    JsonNode statThresholdsNode = json.get(InstructionCodec.STAT_THRESHOLDS);
    Map<StatTriggerField, Long> statThresholdMap = getStatThreshold(statThresholdsNode);
    if (statThresholdMap.isEmpty()) {
        throw new IllegalArgumentException("statThreshold must have at least one property");
    }
    return Instructions.statTrigger(statThresholdMap, flag);
}
#method_after
private Instruction decodeStatTrigger() {
    String statTriggerFlag = nullIsIllegal(json.get(InstructionCodec.STAT_TRIGGER_FLAG), InstructionCodec.STAT_TRIGGER_FLAG + InstructionCodec.ERROR_MESSAGE).asText();
    StatTriggerFlag flag = null;
    if (statTriggerFlag.equals(StatTriggerFlag.ONLY_FIRST.name())) {
        flag = StatTriggerFlag.ONLY_FIRST;
    } else if (statTriggerFlag.equals(StatTriggerFlag.PERIODIC.name())) {
        flag = StatTriggerFlag.PERIODIC;
    } else {
        throw new IllegalArgumentException("statTriggerFlag " + statTriggerFlag + " is not supported");
    }
    if (!json.has(InstructionCodec.STAT_THRESHOLDS)) {
        throw new IllegalArgumentException("statThreshold is not added");
    }
    JsonNode statThresholdsNode = nullIsIllegal(json.get(InstructionCodec.STAT_THRESHOLDS), InstructionCodec.STAT_THRESHOLDS + InstructionCodec.ERROR_MESSAGE);
    Map<StatTriggerField, Long> statThresholdMap = getStatThreshold(statThresholdsNode);
    if (statThresholdMap.isEmpty()) {
        throw new IllegalArgumentException("statThreshold must have at least one property");
    }
    return Instructions.statTrigger(statThresholdMap, flag);
}
#end_block

#method_before
private Map<StatTriggerField, Long> getStatThreshold(JsonNode statThresholdNode) {
    Map<StatTriggerField, Long> statThresholdMap = Maps.newHashMap();
    for (JsonNode jsonNode : statThresholdNode) {
        if (jsonNode.hasNonNull(InstructionCodec.STAT_BYTE_COUNT)) {
            JsonNode byteCountNode = jsonNode.get(InstructionCodec.STAT_BYTE_COUNT);
            if (!byteCountNode.isNull() && byteCountNode.isNumber()) {
                statThresholdMap.put(StatTriggerField.BYTE_COUNT, byteCountNode.asLong());
            }
        } else if (jsonNode.hasNonNull(STAT_PACKET_COUNT)) {
            JsonNode packetCount = jsonNode.get(STAT_PACKET_COUNT);
            if (!packetCount.isNull() && packetCount.isNumber()) {
                statThresholdMap.put(StatTriggerField.PACKET_COUNT, packetCount.asLong());
            }
        } else if (jsonNode.hasNonNull(InstructionCodec.STAT_DURATION)) {
            JsonNode duration = jsonNode.get(InstructionCodec.STAT_DURATION);
            if (!duration.isNull() && duration.isNumber()) {
                statThresholdMap.put(StatTriggerField.DURATION, duration.asLong());
            }
        } else {
            log.warn("Unsupported stat {}", jsonNode.toString());
        }
    }
    return statThresholdMap;
}
#method_after
private Map<StatTriggerField, Long> getStatThreshold(JsonNode statThresholdNode) {
    Map<StatTriggerField, Long> statThresholdMap = Maps.newEnumMap(StatTriggerField.class);
    for (JsonNode jsonNode : statThresholdNode) {
        if (jsonNode.hasNonNull(InstructionCodec.STAT_BYTE_COUNT)) {
            JsonNode byteCountNode = jsonNode.get(InstructionCodec.STAT_BYTE_COUNT);
            if (!byteCountNode.isNull() && byteCountNode.isNumber()) {
                statThresholdMap.put(StatTriggerField.BYTE_COUNT, byteCountNode.asLong());
            }
        } else if (jsonNode.hasNonNull(STAT_PACKET_COUNT)) {
            JsonNode packetCount = jsonNode.get(STAT_PACKET_COUNT);
            if (!packetCount.isNull() && packetCount.isNumber()) {
                statThresholdMap.put(StatTriggerField.PACKET_COUNT, packetCount.asLong());
            }
        } else if (jsonNode.hasNonNull(InstructionCodec.STAT_DURATION)) {
            JsonNode duration = jsonNode.get(InstructionCodec.STAT_DURATION);
            if (!duration.isNull() && duration.isNumber()) {
                statThresholdMap.put(StatTriggerField.DURATION, duration.asLong());
            }
        } else {
            log.error("Unsupported stat {}", jsonNode.toString());
        }
    }
    return statThresholdMap;
}
#end_block

#method_before
public Instruction decode() {
    String type = nullIsIllegal(json.get(InstructionCodec.TYPE), InstructionCodec.TYPE + InstructionCodec.ERROR_MESSAGE).asText();
    if (type.equals(Instruction.Type.OUTPUT.name())) {
        return Instructions.createOutput(getPortNumber(json));
    } else if (type.equals(Instruction.Type.NOACTION.name())) {
        return Instructions.createNoAction();
    } else if (type.equals(Instruction.Type.TABLE.name())) {
        return Instructions.transition(nullIsIllegal(json.get(InstructionCodec.TABLE_ID), InstructionCodec.TABLE_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt());
    } else if (type.equals(Instruction.Type.GROUP.name())) {
        GroupId groupId = new GroupId(nullIsIllegal(json.get(InstructionCodec.GROUP_ID), InstructionCodec.GROUP_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt());
        return Instructions.createGroup(groupId);
    } else if (type.equals(Instruction.Type.METER.name())) {
        MeterId meterId = MeterId.meterId(nullIsIllegal(json.get(InstructionCodec.METER_ID), InstructionCodec.METER_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong());
        return Instructions.meterTraffic(meterId);
    } else if (type.equals(Instruction.Type.QUEUE.name())) {
        long queueId = nullIsIllegal(json.get(InstructionCodec.QUEUE_ID), InstructionCodec.QUEUE_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong();
        if (json.get(InstructionCodec.PORT) == null || json.get(InstructionCodec.PORT).isNull()) {
            return Instructions.setQueue(queueId, null);
        } else {
            return Instructions.setQueue(queueId, getPortNumber(json));
        }
    } else if (type.equals(Instruction.Type.L0MODIFICATION.name())) {
        return decodeL0();
    } else if (type.equals(Instruction.Type.L1MODIFICATION.name())) {
        return decodeL1();
    } else if (type.equals(Instruction.Type.L2MODIFICATION.name())) {
        return decodeL2();
    } else if (type.equals(Instruction.Type.L3MODIFICATION.name())) {
        return decodeL3();
    } else if (type.equals(Instruction.Type.L4MODIFICATION.name())) {
        return decodeL4();
    } else if (type.equals(Instruction.Type.EXTENSION.name())) {
        return decodeExtension();
    } else if (type.equals(Instruction.Type.STATTRIGGER.name())) {
        return decodeStatTrigger();
    }
    throw new IllegalArgumentException("Instruction type " + type + " is not supported");
}
#method_after
public Instruction decode() {
    String type = nullIsIllegal(json.get(InstructionCodec.TYPE), InstructionCodec.TYPE + InstructionCodec.ERROR_MESSAGE).asText();
    if (type.equals(Instruction.Type.OUTPUT.name())) {
        return Instructions.createOutput(getPortNumber(json));
    } else if (type.equals(Instruction.Type.NOACTION.name())) {
        return Instructions.createNoAction();
    } else if (type.equals(Instruction.Type.TABLE.name())) {
        return Instructions.transition(nullIsIllegal(json.get(InstructionCodec.TABLE_ID), InstructionCodec.TABLE_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt());
    } else if (type.equals(Instruction.Type.GROUP.name())) {
        GroupId groupId = new GroupId(nullIsIllegal(json.get(InstructionCodec.GROUP_ID), InstructionCodec.GROUP_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asInt());
        return Instructions.createGroup(groupId);
    } else if (type.equals(Instruction.Type.METER.name())) {
        MeterId meterId = MeterId.meterId(nullIsIllegal(json.get(InstructionCodec.METER_ID), InstructionCodec.METER_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong());
        return Instructions.meterTraffic(meterId);
    } else if (type.equals(Instruction.Type.QUEUE.name())) {
        long queueId = nullIsIllegal(json.get(InstructionCodec.QUEUE_ID), InstructionCodec.QUEUE_ID + InstructionCodec.MISSING_MEMBER_MESSAGE).asLong();
        if (json.get(InstructionCodec.PORT) == null || json.get(InstructionCodec.PORT).isNull()) {
            return Instructions.setQueue(queueId, null);
        } else {
            return Instructions.setQueue(queueId, getPortNumber(json));
        }
    } else if (type.equals(Instruction.Type.L0MODIFICATION.name())) {
        return decodeL0();
    } else if (type.equals(Instruction.Type.L1MODIFICATION.name())) {
        return decodeL1();
    } else if (type.equals(Instruction.Type.L2MODIFICATION.name())) {
        return decodeL2();
    } else if (type.equals(Instruction.Type.L3MODIFICATION.name())) {
        return decodeL3();
    } else if (type.equals(Instruction.Type.L4MODIFICATION.name())) {
        return decodeL4();
    } else if (type.equals(Instruction.Type.EXTENSION.name())) {
        return decodeExtension();
    } else if (type.equals(Instruction.Type.STAT_TRIGGER.name())) {
        return decodeStatTrigger();
    }
    throw new IllegalArgumentException("Instruction type " + type + " is not supported");
}
#end_block

#method_before
@Override
public Type type() {
    return Type.STATTRIGGER;
}
#method_after
@Override
public Type type() {
    return Type.STAT_TRIGGER;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    StatTriggerInstruction that = (StatTriggerInstruction) o;
    if (statTriggerFieldMap != null ? !statTriggerFieldMap.equals(that.statTriggerFieldMap) : that.statTriggerFieldMap != null) {
        return false;
    }
    return statTriggerFlag == that.statTriggerFlag;
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    StatTriggerInstruction that = (StatTriggerInstruction) o;
    if (!Objects.equals(statTriggerFieldMap, that.statTriggerFieldMap)) {
        return false;
    }
    return statTriggerFlag == that.statTriggerFlag;
}
#end_block

#method_before
private Set<OFStatTriggerFlags> getStatTriggerFlag(StatTriggerFlag flag) {
    Set<OFStatTriggerFlags> statTriggerFlagsSet = Sets.newHashSet();
    switch(flag) {
        case PRERIODIC:
            statTriggerFlagsSet.add(PERIODIC);
            break;
        case ONLY_FIRST:
            statTriggerFlagsSet.add(ONLY_FIRST);
            break;
        default:
            break;
    }
    return statTriggerFlagsSet;
}
#method_after
private Set<OFStatTriggerFlags> getStatTriggerFlag(StatTriggerFlag flag) {
    Set<OFStatTriggerFlags> statTriggerFlagsSet = Sets.newHashSet();
    switch(flag) {
        case PERIODIC:
            statTriggerFlagsSet.add(PERIODIC);
            break;
        case ONLY_FIRST:
            statTriggerFlagsSet.add(ONLY_FIRST);
            break;
        default:
            break;
    }
    return statTriggerFlagsSet;
}
#end_block

#method_before
private OFAction buildMultipleMeterAction(Instructions.MeterInstruction meterInstruction) {
    OFActionMeter.Builder meterBuilder = factory().actions().buildMeter().setMeterId(meterInstruction.meterId().id());
    return meterBuilder.build();
}
#method_after
protected OFAction buildMultipleMeterAction(Instructions.MeterInstruction meterInstruction) {
    OFActionMeter.Builder meterBuilder = factory().actions().buildMeter().setMeterId(meterInstruction.meterId().id());
    return meterBuilder.build();
}
#end_block

#method_before
private OFInstruction buildStatTrigger(Instructions.StatTriggerInstruction s) {
    OFInstruction instruction = factory().instructions().statTrigger(getStatTriggerFlag(s.getStatTriggerFlag()), getOFOxsList(s.getStatTriggerFieldMap()));
    return instruction;
}
#method_after
protected OFInstruction buildStatTrigger(Instructions.StatTriggerInstruction s) {
    OFInstruction instruction = factory().instructions().statTrigger(getStatTriggerFlag(s.getStatTriggerFlag()), getOFOxsList(s.getStatTriggerFieldMap()));
    return instruction;
}
#end_block

#method_before
@Override
public void build(OFPort outPort) {
    if (isBuilt.getAndSet(true)) {
        return;
    }
    OFPacketOut.Builder builder = sw.factory().buildPacketOut();
    OFAction act = buildOutput(outPort.getPortNumber());
    builder.setXid(pktin.getXid()).setBufferId(OFBufferId.NO_BUFFER).setData(pktin.getData()).setActions(Collections.singletonList(act));
    if (sw.factory().getVersion().getWireVersion() <= OFVersion.OF_14.getWireVersion()) {
        builder.setInPort(pktinInPort());
    }
    pktout = builder.build();
}
#method_after
@Override
public void build(OFPort outPort) {
    if (isBuilt.getAndSet(true)) {
        return;
    }
    OFAction act = buildOutput(outPort.getPortNumber());
    pktout = createOFPacketOut(pktin.getData(), act, pktin.getXid());
}
#end_block

#method_before
@Override
public void build(Ethernet ethFrame, OFPort outPort) {
    if (isBuilt.getAndSet(true)) {
        return;
    }
    OFPacketOut.Builder builder = sw.factory().buildPacketOut();
    OFAction act = buildOutput(outPort.getPortNumber());
    builder.setXid(pktin.getXid()).setBufferId(OFBufferId.NO_BUFFER).setActions(Collections.singletonList(act)).setData(ethFrame.serialize()).build();
    if (sw.factory().getVersion().getWireVersion() <= OFVersion.OF_14.getWireVersion()) {
        builder.setInPort(pktinInPort());
    }
    pktout = builder.build();
}
#method_after
@Override
public void build(Ethernet ethFrame, OFPort outPort) {
    if (isBuilt.getAndSet(true)) {
        return;
    }
    OFAction act = buildOutput(outPort.getPortNumber());
    pktout = createOFPacketOut(ethFrame.serialize(), act, pktin.getXid());
}
#end_block

#method_before
private void processStatsReply(Dpid dpid, OFStatsReply reply) {
    switch(reply.getStatsType()) {
        case QUEUE:
            Collection<OFQueueStatsEntry> queueStatsEntries = publishQueueStats(dpid, (OFQueueStatsReply) reply);
            if (queueStatsEntries != null) {
                OFQueueStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildQueueStatsReply();
                rep.setEntries(ImmutableList.copyOf(queueStatsEntries));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case PORT_DESC:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case FLOW:
            Collection<OFFlowStatsEntry> flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
            if (flowStats != null) {
                OFFlowStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildFlowStatsReply();
                rep.setEntries(ImmutableList.copyOf(flowStats));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case FLOW_LIGHTWEIGHT:
            Collection<OFFlowLightweightStatsEntry> flowLightweightStats = publishFlowStatsLightweight(dpid, (OFFlowLightweightStatsReply) reply);
            if (flowLightweightStats != null) {
                OFFlowLightweightStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildFlowLightweightStatsReply();
                rep.setEntries(Lists.newLinkedList(flowLightweightStats));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case TABLE:
            Collection<OFTableStatsEntry> tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
            if (tableStats != null) {
                OFTableStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildTableStatsReply();
                rep.setEntries(ImmutableList.copyOf(tableStats));
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case GROUP:
            Collection<OFGroupStatsEntry> groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
            if (groupStats != null) {
                OFGroupStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildGroupStatsReply();
                rep.setEntries(ImmutableList.copyOf(groupStats));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case GROUP_DESC:
            Collection<OFGroupDescStatsEntry> groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
            if (groupDescStats != null) {
                OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildGroupDescStatsReply();
                rep.setEntries(ImmutableList.copyOf(groupDescStats));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case PORT:
            executorMsgs.execute(new OFMessageHandler(dpid, reply));
            break;
        case METER:
            executorMsgs.execute(new OFMessageHandler(dpid, reply));
            break;
        case EXPERIMENTER:
            if (reply instanceof OFCalientFlowStatsReply) {
                OpenFlowSwitch sw = this.getSwitch(dpid);
                // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                if (sw == null) {
                    log.error("Switch {} is not found", dpid);
                    break;
                }
                OFFlowStatsReply.Builder fsr = sw.factory().buildFlowStatsReply();
                List<OFFlowStatsEntry> entries = new ArrayList<>();
                for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) reply).getEntries()) {
                    // Single instruction, i.e., output to port
                    OFActionOutput action = sw.factory().actions().buildOutput().setPort(entry.getOutPort()).build();
                    OFInstruction instruction = sw.factory().instructions().applyActions(Collections.singletonList(action));
                    OFFlowStatsEntry fs = sw.factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                    entries.add(fs);
                }
                fsr.setEntries(entries);
                flowStats = publishFlowStats(dpid, fsr.build());
                if (flowStats != null) {
                    OFFlowStatsReply.Builder rep = sw.factory().buildFlowStatsReply();
                    rep.setEntries(ImmutableList.copyOf(flowStats));
                    executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                }
            } else {
                executorMsgs.execute(new OFMessageHandler(dpid, reply));
            }
            break;
        default:
            log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
            break;
    }
}
#method_after
private void processStatsReply(Dpid dpid, OFStatsReply reply) {
    switch(reply.getStatsType()) {
        case QUEUE:
            Collection<OFQueueStatsEntry> queueStatsEntries = publishQueueStats(dpid, (OFQueueStatsReply) reply);
            if (queueStatsEntries != null) {
                OFQueueStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildQueueStatsReply();
                rep.setEntries(ImmutableList.copyOf(queueStatsEntries));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case PORT_DESC:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case FLOW:
            Collection<OFFlowStatsEntry> flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
            if (flowStats != null) {
                OFFlowStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildFlowStatsReply();
                rep.setEntries(ImmutableList.copyOf(flowStats));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case FLOW_LIGHTWEIGHT:
            Collection<OFFlowLightweightStatsEntry> flowLightweightStats = publishFlowStatsLightweight(dpid, (OFFlowLightweightStatsReply) reply);
            if (flowLightweightStats != null) {
                OFFlowLightweightStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildFlowLightweightStatsReply();
                rep.setEntries(ImmutableList.copyOf(flowLightweightStats));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case TABLE:
            Collection<OFTableStatsEntry> tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
            if (tableStats != null) {
                OFTableStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildTableStatsReply();
                rep.setEntries(ImmutableList.copyOf(tableStats));
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case GROUP:
            Collection<OFGroupStatsEntry> groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
            if (groupStats != null) {
                OFGroupStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildGroupStatsReply();
                rep.setEntries(ImmutableList.copyOf(groupStats));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case GROUP_DESC:
            Collection<OFGroupDescStatsEntry> groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
            if (groupDescStats != null) {
                OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(reply.getVersion()).buildGroupDescStatsReply();
                rep.setEntries(ImmutableList.copyOf(groupDescStats));
                rep.setXid(reply.getXid());
                executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
            }
            break;
        case PORT:
            executorMsgs.execute(new OFMessageHandler(dpid, reply));
            break;
        case METER:
            executorMsgs.execute(new OFMessageHandler(dpid, reply));
            break;
        case EXPERIMENTER:
            if (reply instanceof OFCalientFlowStatsReply) {
                OpenFlowSwitch sw = this.getSwitch(dpid);
                // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                if (sw == null) {
                    log.error("Switch {} is not found", dpid);
                    break;
                }
                OFFlowStatsReply.Builder fsr = sw.factory().buildFlowStatsReply();
                List<OFFlowStatsEntry> entries = new ArrayList<>();
                for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) reply).getEntries()) {
                    // Single instruction, i.e., output to port
                    OFActionOutput action = sw.factory().actions().buildOutput().setPort(entry.getOutPort()).build();
                    OFInstruction instruction = sw.factory().instructions().applyActions(Collections.singletonList(action));
                    OFFlowStatsEntry fs = sw.factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                    entries.add(fs);
                }
                fsr.setEntries(entries);
                flowStats = publishFlowStats(dpid, fsr.build());
                if (flowStats != null) {
                    OFFlowStatsReply.Builder rep = sw.factory().buildFlowStatsReply();
                    rep.setEntries(ImmutableList.copyOf(flowStats));
                    executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                }
            } else {
                executorMsgs.execute(new OFMessageHandler(dpid, reply));
            }
            break;
        default:
            log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
            break;
    }
}
#end_block

#method_before
private FlowEntry createFlowEntryFromStat() {
    FlowRule.Builder builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).withIdleTimeout(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
    if (stat.getVersion() != OFVersion.OF_10) {
        builder.forTable(stat.getTableId().getValue());
    }
    if (stat.getVersion().getWireVersion() < OFVersion.OF_15.getWireVersion()) {
        if (afsc != null) {
            FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(stat.getDurationSec());
            return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(stat.getDurationSec()) + stat.getDurationNsec(), NANOSECONDS, liveType, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
        } else {
            return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
        }
    }
    FlowStatParser statParser = FlowStatParser.builder().withFlowStat(stat.getStats()).build();
    if (afsc != null && statParser.isDurationReceived()) {
        FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(statParser.getDuration());
        return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(statParser.getDuration()) + SECONDS.toNanos(statParser.getDuration()), NANOSECONDS, liveType, statParser.getPacketCount(), statParser.getByteCount());
    } else {
        return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, statParser.getDuration(), statParser.getPacketCount(), statParser.getByteCount());
    }
}
#method_after
private FlowEntry createFlowEntryFromStat() {
    FlowRule.Builder builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).withIdleTimeout(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
    if (stat.getVersion() != OFVersion.OF_10) {
        builder.forTable(stat.getTableId().getValue());
    }
    if (stat.getVersion().getWireVersion() < OFVersion.OF_15.getWireVersion()) {
        if (afsc != null) {
            FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(stat.getDurationSec());
            return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(stat.getDurationSec()) + stat.getDurationNsec(), NANOSECONDS, liveType, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
        } else {
            return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
        }
    }
    FlowStatParser statParser = new FlowStatParser(stat.getStats());
    if (afsc != null && statParser.isDurationReceived()) {
        FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(statParser.getDuration());
        return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(statParser.getDuration()) + SECONDS.toNanos(statParser.getDuration()), NANOSECONDS, liveType, statParser.getPacketCount(), statParser.getByteCount());
    } else {
        return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, statParser.getDuration(), statParser.getPacketCount(), statParser.getByteCount());
    }
}
#end_block

#method_before
private FlowEntry createFlowEntryForFlowRemoved() {
    FlowRule.Builder builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).withIdleTimeout(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue()).withReason(FlowRule.FlowRemoveReason.parseShort((short) removed.getReason().ordinal()));
    if (removed.getVersion() != OFVersion.OF_10) {
        builder.forTable(removed.getTableId().getValue());
    }
    if (removed.getVersion().getWireVersion() < OFVersion.OF_15.getWireVersion()) {
        if (afsc != null) {
            FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(removed.getDurationSec());
            return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(removed.getDurationSec()) + removed.getDurationNsec(), NANOSECONDS, liveType, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
        } else {
            return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
        }
    }
    FlowStatParser statParser = FlowStatParser.builder().withFlowStat(removed.getStats()).build();
    if (afsc != null && statParser.isDurationReceived()) {
        FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(statParser.getDuration());
        return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(statParser.getDuration()) + SECONDS.toNanos(statParser.getDuration()), NANOSECONDS, liveType, statParser.getPacketCount(), statParser.getByteCount());
    } else {
        return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, statParser.getDuration(), statParser.getPacketCount(), statParser.getByteCount());
    }
}
#method_after
private FlowEntry createFlowEntryForFlowRemoved() {
    FlowRule.Builder builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).withIdleTimeout(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue()).withReason(FlowRule.FlowRemoveReason.parseShort((short) removed.getReason().ordinal()));
    if (removed.getVersion() != OFVersion.OF_10) {
        builder.forTable(removed.getTableId().getValue());
    }
    if (removed.getVersion().getWireVersion() < OFVersion.OF_15.getWireVersion()) {
        if (afsc != null) {
            FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(removed.getDurationSec());
            return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(removed.getDurationSec()) + removed.getDurationNsec(), NANOSECONDS, liveType, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
        } else {
            return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
        }
    }
    FlowStatParser statParser = new FlowStatParser(removed.getStats());
    if (afsc != null && statParser.isDurationReceived()) {
        FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(statParser.getDuration());
        return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(statParser.getDuration()) + SECONDS.toNanos(statParser.getDuration()), NANOSECONDS, liveType, statParser.getPacketCount(), statParser.getByteCount());
    } else {
        return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, statParser.getDuration(), statParser.getPacketCount(), statParser.getByteCount());
    }
}
#end_block

#method_before
private FlowEntry createFlowEntryFromLightweightStat() {
    FlowRule.Builder builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(lightWeightStat.getPriority()).withIdleTimeout(0).withCookie(0);
    FlowStatParser flowLightweightStatParser = FlowStatParser.builder().withFlowStat(lightWeightStat.getStats()).build();
    builder.forTable(lightWeightStat.getTableId().getValue());
    if (afsc != null && flowLightweightStatParser.isDurationReceived()) {
        FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(flowLightweightStatParser.getDuration());
        return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(flowLightweightStatParser.getDuration()) + flowLightweightStatParser.getDuration(), NANOSECONDS, liveType, flowLightweightStatParser.getPacketCount(), flowLightweightStatParser.getByteCount());
    } else {
        return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, flowLightweightStatParser.getDuration(), flowLightweightStatParser.getPacketCount(), flowLightweightStatParser.getByteCount());
    }
}
#method_after
private FlowEntry createFlowEntryFromLightweightStat() {
    FlowRule.Builder builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(lightWeightStat.getPriority()).withIdleTimeout(0).withCookie(0);
    FlowStatParser flowLightweightStatParser = new FlowStatParser(lightWeightStat.getStats());
    builder.forTable(lightWeightStat.getTableId().getValue());
    if (afsc != null && flowLightweightStatParser.isDurationReceived()) {
        FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(flowLightweightStatParser.getDuration());
        return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(flowLightweightStatParser.getDuration()) + flowLightweightStatParser.getDuration(), NANOSECONDS, liveType, flowLightweightStatParser.getPacketCount(), flowLightweightStatParser.getByteCount());
    } else {
        return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, flowLightweightStatParser.getDuration(), flowLightweightStatParser.getPacketCount(), flowLightweightStatParser.getByteCount());
    }
}
#end_block

#method_before
private TrafficTreatment.Builder buildStatTrigger(OFOxsList oxsList, Set<OFStatTriggerFlags> flagsSet, TrafficTreatment.Builder builder) {
    Map<StatTriggerField, Long> statTriggerMap = Maps.newHashMap();
    for (OFOxs<?> ofOxs : oxsList) {
        switch(ofOxs.getStatField().id) {
            case DURATION:
                U64 durationType = (U64) ofOxs.getValue();
                statTriggerMap.put(DURATION, durationType.getValue());
                break;
            case FLOW_COUNT:
                U32 flowCount = (U32) ofOxs.getValue();
                statTriggerMap.put(FLOW_COUNT, flowCount.getValue());
                break;
            case PACKET_COUNT:
                U64 packetCount = (U64) ofOxs.getValue();
                statTriggerMap.put(PACKET_COUNT, packetCount.getValue());
                break;
            case BYTE_COUNT:
                U64 byteCount = (U64) ofOxs.getValue();
                statTriggerMap.put(BYTE_COUNT, byteCount.getValue());
                break;
            case IDLE_TIME:
                U64 idleTime = (U64) ofOxs.getValue();
                statTriggerMap.put(IDLE_TIME, idleTime.getValue());
                break;
            default:
                log.warn("getStatField not supported {}", ofOxs.getStatField().id);
                break;
        }
    }
    StatTriggerFlag flag = null;
    for (OFStatTriggerFlags flags : flagsSet) {
        switch(flags) {
            case PERIODIC:
                flag = PRERIODIC;
                break;
            case ONLY_FIRST:
                flag = ONLY_FIRST;
                break;
            default:
                log.warn("flag not supported {}", flags);
                break;
        }
    }
    if (!statTriggerMap.isEmpty() && flag != null) {
        builder.add(Instructions.statTrigger(statTriggerMap, flag));
    }
    return builder;
}
#method_after
private TrafficTreatment.Builder buildStatTrigger(OFOxsList oxsList, Set<OFStatTriggerFlags> flagsSet, TrafficTreatment.Builder builder) {
    Map<StatTriggerField, Long> statTriggerMap = Maps.newEnumMap(StatTriggerField.class);
    for (OFOxs<?> ofOxs : oxsList) {
        switch(ofOxs.getStatField().id) {
            case DURATION:
                U64 durationType = (U64) ofOxs.getValue();
                statTriggerMap.put(DURATION, durationType.getValue());
                break;
            case FLOW_COUNT:
                U32 flowCount = (U32) ofOxs.getValue();
                statTriggerMap.put(FLOW_COUNT, flowCount.getValue());
                break;
            case PACKET_COUNT:
                U64 packetCount = (U64) ofOxs.getValue();
                statTriggerMap.put(PACKET_COUNT, packetCount.getValue());
                break;
            case BYTE_COUNT:
                U64 byteCount = (U64) ofOxs.getValue();
                statTriggerMap.put(BYTE_COUNT, byteCount.getValue());
                break;
            case IDLE_TIME:
                U64 idleTime = (U64) ofOxs.getValue();
                statTriggerMap.put(IDLE_TIME, idleTime.getValue());
                break;
            default:
                log.warn("getStatField not supported {}", ofOxs.getStatField().id);
                break;
        }
    }
    StatTriggerFlag flag = null;
    for (OFStatTriggerFlags flags : flagsSet) {
        switch(flags) {
            case PERIODIC:
                flag = PERIODIC;
                break;
            case ONLY_FIRST:
                flag = ONLY_FIRST;
                break;
            default:
                log.warn("flag not supported {}", flags);
                break;
        }
    }
    if (!statTriggerMap.isEmpty() && flag != null) {
        builder.add(Instructions.statTrigger(statTriggerMap, flag));
    }
    return builder;
}
#end_block

#method_before
@Override
public Collection<FlowEntry> getFlowEntries() {
    DeviceId deviceId = handler().data().deviceId();
    log.debug("getting flow entries for device {}", deviceId);
    try {
        restCiena = new CienaRestDevice(handler());
    } catch (NullPointerException e) {
        log.error("unable to create CienaRestDevice:\n{}", e);
        return Collections.EMPTY_LIST;
    }
    return restCiena.getFlowEntries();
}
#method_after
@Override
public Collection<FlowEntry> getFlowEntries() {
    DeviceId deviceId = handler().data().deviceId();
    log.debug("getting flow entries for device {}", deviceId);
    try {
        restCiena = new CienaRestDevice(handler());
    } catch (NullPointerException e) {
        log.error("unable to create CienaRestDevice:\n{}", e);
        return Collections.emptyList();
    }
    return restCiena.getFlowEntries();
}
#end_block

#method_before
@Override
public Collection<FlowRule> applyFlowRules(Collection<FlowRule> rules) {
    log.debug("installing flow rules: {}", rules);
    try {
        restCiena = new CienaRestDevice(handler());
    } catch (NullPointerException e) {
        log.error("unable to create CienaRestDevice:\n{}", e);
        return Collections.EMPTY_LIST;
    }
    // Apply the valid rules on the device
    Collection<FlowRule> added = rules.stream().map(r -> createCrossConnectFlowRule(r)).filter(xc -> installCrossConnect(xc)).collect(Collectors.toList());
    restCiena.setCrossConnectCache(added);
    return added;
}
#method_after
@Override
public Collection<FlowRule> applyFlowRules(Collection<FlowRule> rules) {
    log.debug("installing flow rules: {}", rules);
    try {
        restCiena = new CienaRestDevice(handler());
    } catch (NullPointerException e) {
        log.error("unable to create CienaRestDevice:\n{}", e);
        return Collections.emptyList();
    }
    // Apply the valid rules on the device
    Collection<FlowRule> added = rules.stream().map(r -> createCrossConnectFlowRule(r)).filter(xc -> installCrossConnect(xc)).collect(Collectors.toList());
    restCiena.setCrossConnectCache(added);
    return added;
}
#end_block

#method_before
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rules) {
    log.debug("removing flow rules: {}", rules);
    try {
        restCiena = new CienaRestDevice(handler());
    } catch (NullPointerException e) {
        log.error("unable to create CienaRestDevice:\n{}", e);
        return Collections.EMPTY_LIST;
    }
    Collection<FlowRule> removed = rules.stream().map(r -> createCrossConnectFlowRule(r)).filter(xc -> xc != null).collect(Collectors.toList());
    restCiena.removeCrossConnectCache(removed);
    return removed;
}
#method_after
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rules) {
    log.debug("removing flow rules: {}", rules);
    try {
        restCiena = new CienaRestDevice(handler());
    } catch (NullPointerException e) {
        log.error("unable to create CienaRestDevice:\n{}", e);
        return Collections.emptyList();
    }
    Collection<FlowRule> removed = rules.stream().map(r -> createCrossConnectFlowRule(r)).filter(xc -> xc != null).collect(Collectors.toList());
    restCiena.removeCrossConnectCache(removed);
    return removed;
}
#end_block

#method_before
public static ArrayList<String> getLinesidePortId() {
    return LINESIDE_PORT_ID;
}
#method_after
public static List<String> getLinesidePortId() {
    return LINESIDE_PORT_ID;
}
#end_block

#method_before
private String getPortPowerFilter(PortNumber port) {
    final StringBuilder filter = new StringBuilder(xmlOpen(KEY_OPM_XMLNS)).append(xmlOpen(KEY_PORT)).append(xmlOpen(KEY_PORTID));
    if (port != null) {
        filter.append(port.toLong());
    }
    filter.append(xmlClose(KEY_PORTID)).append(xmlClose(KEY_PORT)).append(xmlClose(KEY_OPM)).toString();
    return filter.toString();
}
#method_after
private String getPortPowerFilter(PortNumber port) {
    StringBuilder filter = new StringBuilder(xmlOpen(KEY_OPM_XMLNS)).append(xmlOpen(KEY_PORT)).append(xmlOpen(KEY_PORTID));
    if (port != null) {
        filter.append(port.toLong());
    }
    return filter.append(xmlClose(KEY_PORTID)).append(xmlClose(KEY_PORT)).append(xmlClose(KEY_OPM)).toString();
}
#end_block

#method_before
public static Deserializer<Dhcp6Option> deserializer() {
    return (data, offset, len) -> {
        Dhcp6Option dhcp6Option = Dhcp6Option.deserializer().deserialize(data, offset, len);
        if (dhcp6Option.getLength() < DEFAULT_LEN) {
            throw new DeserializationException("Invalid InterfaceIoption data");
        }
        Dhcp6InterfaceIdOption interfaceIdOption = new Dhcp6InterfaceIdOption(dhcp6Option);
        byte[] optionData = interfaceIdOption.getData();
        if (optionData.length >= 31) {
            ByteBuffer bb = ByteBuffer.wrap(optionData);
            byte[] macAddr = new byte[MacAddress.MAC_ADDRESS_LENGTH];
            byte[] port = new byte[21];
            short vlan;
            byte[] vlanByte = new byte[2];
            bb.get(macAddr);
            // separator "-"
            bb.get();
            bb.get(port);
            // separator ":"
            bb.get();
            bb.get(vlanByte);
            vlan = (short) ((vlanByte[0] & 0xff) + (vlanByte[1] << 8));
            interfaceIdOption.setMacAddress(MacAddress.valueOf(macAddr));
            interfaceIdOption.setInPort(port);
            interfaceIdOption.setVlanId(vlan);
        }
        return interfaceIdOption;
    };
}
#method_after
public static Deserializer<Dhcp6Option> deserializer() {
    return (data, offset, len) -> {
        Dhcp6Option dhcp6Option = Dhcp6Option.deserializer().deserialize(data, offset, len);
        if (dhcp6Option.getLength() < DEFAULT_LEN) {
            throw new DeserializationException("Invalid InterfaceIoption data");
        }
        Dhcp6InterfaceIdOption interfaceIdOption = new Dhcp6InterfaceIdOption(dhcp6Option);
        byte[] optionData = interfaceIdOption.getData();
        if (optionData.length >= 31) {
            ByteBuffer bb = ByteBuffer.wrap(optionData);
            byte[] macAddr = new byte[MacAddress.MAC_ADDRESS_LENGTH];
            byte[] port = new byte[21];
            short vlan;
            bb.get(macAddr);
            // separator "-"
            bb.get();
            bb.get(port);
            // separator ":"
            bb.get();
            vlan = bb.getShort();
            interfaceIdOption.setMacAddress(MacAddress.valueOf(macAddr));
            interfaceIdOption.setInPort(port);
            interfaceIdOption.setVlanId(vlan > VlanId.MAX_VLAN ? VlanId.UNTAGGED : vlan);
        }
        return interfaceIdOption;
    };
}
#end_block

#method_before
public boolean configured() {
    log.warn("dhcpServerConnectPoint {} dhcpServerIp {}", this.dhcpServerConnectPoint, this.dhcpServerIp);
    return this.dhcpServerConnectPoint != null && this.dhcpServerIp != null;
}
#method_after
public boolean configured() {
    log.warn("dhcpServerConnectPoint {} dhcpServerIp {}," + "  indirectDhcpServerConnectPoint {} indirectDhcpServerIp {}", this.dhcpServerConnectPoint, this.dhcpServerIp, this.indirectDhcpServerConnectPoint, this.indirectDhcpServerIp);
    return (this.dhcpServerConnectPoint != null && this.dhcpServerIp != null) || (this.indirectDhcpServerConnectPoint != null && this.indirectDhcpServerIp != null);
}
#end_block

#method_before
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Ethernet etherReply = (Ethernet) clientPacket.clone();
    etherReply.setSourceMACAddress(relayAgentMac);
    if (directConnFlag && this.dhcpConnectMac == null) {
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.dhcpGatewayIp == null) ? "server IP " + this.dhcpServerIp : "gateway IP " + this.dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (!directConnFlag && this.indirectDhcpConnectMac == null) {
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.indirectDhcpGatewayIp == null) ? "server IP " + this.indirectDhcpServerIp : "gateway IP " + this.indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (this.dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point is not set up yet");
        return null;
    }
    etherReply.setDestinationMACAddress(directConnFlag ? this.dhcpConnectMac : this.indirectDhcpConnectMac);
    etherReply.setVlanID(directConnFlag ? this.dhcpConnectVlan.toShort() : this.indirectDhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(relayAgentIp.toOctets());
    ipv6Packet.setDestinationAddress(directConnFlag ? this.dhcpServerIp.toOctets() : this.indirectDhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    // notify onos and quagga to release PD
    // releasePD(dhcp6Packet);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    removeHostOrRoute(directConnFlag, dhcp6Packet, clientPacket, clientIpv6, clientInterface);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    // is located.
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (this.indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.warn("indirect connection: relayAgentIp NOT availale from config file! {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(this.indirectRelayAgentIpFromCfg.toOctets());
            log.debug("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(this.indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // peer address:  address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<Dhcp6Option>();
    // otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString() + ":";
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (clientPacket.getVlanID() & 0xff);
    vlanIdBytes[1] = (byte) ((clientPacket.getVlanID() >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    log.debug("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} vlan {}", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length, vlanIdBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
}
#method_after
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Ethernet etherReply = clientPacket.duplicate();
    etherReply.setSourceMACAddress(relayAgentMac);
    if ((directConnFlag && this.dhcpConnectMac == null) || !directConnFlag && this.indirectDhcpConnectMac == null && this.dhcpConnectMac == null) {
        log.warn("Packet received from {} connected client.", directConnFlag ? "directly" : "indirectly");
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.dhcpGatewayIp == null) ? "server IP " + this.dhcpServerIp : "gateway IP " + this.dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (this.dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point direct {} directConn {} indirectConn {} is not set up yet", directConnFlag, this.dhcpServerConnectPoint, this.indirectDhcpServerConnectPoint);
        return null;
    }
    etherReply.setDestinationMACAddress(this.dhcpConnectMac);
    etherReply.setVlanID(this.dhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(relayAgentIp.toOctets());
    ipv6Packet.setDestinationAddress(this.dhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    // notify onos and quagga to release PD
    // releasePD(dhcp6Packet);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    removeHostOrRoute(directConnFlag, dhcp6Packet, clientPacket, clientIpv6, clientInterface);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    // is located.
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (this.indirectDhcpServerIp == null) {
            log.warn("indirect DhcpServerIp not available, use default DhcpServerIp {}", HexString.toHexString(this.dhcpServerIp.toOctets()));
        } else {
            // Check if mac is obtained for valid server ip
            if (this.indirectDhcpConnectMac == null) {
                log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.indirectDhcpGatewayIp == null) ? "server IP " + this.indirectDhcpServerIp : "gateway IP " + this.indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
                return null;
            }
            etherReply.setDestinationMACAddress(this.indirectDhcpConnectMac);
            etherReply.setVlanID(this.indirectDhcpConnectVlan.toShort());
            ipv6Packet.setDestinationAddress(this.indirectDhcpServerIp.toOctets());
        }
        if (this.indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.warn("indirect connection: relayAgentIp NOT availale from config file! Use dynamic. {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(this.indirectRelayAgentIpFromCfg.toOctets());
            log.debug("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(this.indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // peer address:  address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<Dhcp6Option>();
    // otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString() + ":";
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (clientPacket.getVlanID() & 0xff);
    vlanIdBytes[1] = (byte) ((clientPacket.getVlanID() >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    log.debug("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} vlan {}", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length, vlanIdBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    ipv6Packet.setHopLimit((byte) 64);
    etherReply.setPayload(ipv6Packet);
    if (directConnFlag) {
        return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
    } else {
        if (this.indirectDhcpServerIp == null) {
            return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
        } else {
            return new InternalPacket(etherReply, this.indirectDhcpServerConnectPoint);
        }
    }
}
#end_block

#method_before
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (!inPort.equals(this.dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server port {}", inPort, this.dhcpServerConnectPoint);
        return null;
    }
    // get dhcp6 header.
    Ethernet etherReply = (Ethernet) receivedPacket.clone();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = directlyConnected(dhcp6Relay);
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId vlanIdInUse = VlanId.vlanId(interfaceIdOption.getVlanId());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot get client interface for from packet, abort... vlan {}", vlanIdInUse.toString());
        return null;
    }
    MacAddress relayAgentMac = clientInterface.mac();
    if (relayAgentMac == null) {
        log.warn("Can not get interface mac, abort packet..");
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac = null;
    Ip6Address peerAddress = Ip6Address.valueOf(dhcp6Relay.getPeerAddress());
    Set<Host> clients = hostService.getHostsByIp(peerAddress);
    if (clients.isEmpty()) {
        log.warn("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.warn("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            return null;
        }
        log.warn("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    // add host or route
    addHostOrRoute(directConnFlag, dhcp6Relay, embeddedDhcp6, clientMac, clientInterface);
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#method_after
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    // get dhcp6 header.
    Ethernet etherReply = receivedPacket.duplicate();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = directlyConnected(dhcp6Relay);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if ((directConnFlag || (!directConnFlag && this.indirectDhcpServerIp == null)) && !inPort.equals(this.dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for direct or indirect-null", inPort, this.dhcpServerConnectPoint);
        return null;
    }
    if (!directConnFlag && this.indirectDhcpServerIp != null && !inPort.equals(this.indirectDhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for indirect", inPort, this.indirectDhcpServerConnectPoint);
        return null;
    }
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId vlanIdInUse = VlanId.vlanId(interfaceIdOption.getVlanId());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot get client interface for from packet, abort... vlan {}", vlanIdInUse.toString());
        return null;
    }
    MacAddress relayAgentMac = clientInterface.mac();
    if (relayAgentMac == null) {
        log.warn("Can not get interface mac, abort packet..");
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac = null;
    Ip6Address peerAddress = Ip6Address.valueOf(dhcp6Relay.getPeerAddress());
    Set<Host> clients = hostService.getHostsByIp(peerAddress);
    if (clients.isEmpty()) {
        log.warn("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.warn("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            return null;
        }
        log.warn("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    // add host or route
    addHostOrRoute(directConnFlag, dhcp6Relay, embeddedDhcp6, clientMac, clientInterface);
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#end_block

#method_before
private boolean interfaceContainsVlan(Interface iface, VlanId vlanId) {
    return iface.vlan().equals(vlanId) || iface.vlanUntagged().equals(vlanId) || iface.vlanTagged().contains(vlanId) || iface.vlanNative().equals(vlanId);
}
#method_after
private boolean interfaceContainsVlan(Interface iface, VlanId vlanId) {
    if (vlanId.equals(VlanId.NONE)) {
        // untagged packet, check if vlan untagged or vlan native is not NONE
        return !iface.vlanUntagged().equals(VlanId.NONE) || !iface.vlanNative().equals(VlanId.NONE);
    }
    // tagged packet, check if the interface contains the vlan
    return iface.vlanTagged().contains(vlanId);
}
#end_block

#method_before
@Before
public void setup() {
    manager = new DhcpRelayManager();
    manager.cfgService = createNiceMock(NetworkConfigRegistry.class);
    expect(manager.cfgService.getConfig(APP_ID, DefaultDhcpRelayConfig.class)).andReturn(CONFIG).anyTimes();
    // TODO: add indirect test
    expect(manager.cfgService.getConfig(APP_ID, IndirectDhcpRelayConfig.class)).andReturn(CONFIG_INDIRECT).anyTimes();
    manager.coreService = createNiceMock(CoreService.class);
    expect(manager.coreService.registerApplication(anyString())).andReturn(APP_ID).anyTimes();
    manager.hostService = createNiceMock(HostService.class);
    expect(manager.hostService.getHostsByIp(anyObject())).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHost(OUTER_RELAY_HOST_ID)).andReturn(OUTER_RELAY_HOST).anyTimes();
    packetService = new MockPacketService();
    manager.packetService = packetService;
    manager.compCfgService = createNiceMock(ComponentConfigService.class);
    manager.deviceService = createNiceMock(DeviceService.class);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(manager.deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(manager.deviceService.getDevice(DEV_2_ID)).andReturn(device).anyTimes();
    replay(manager.deviceService, device);
    mockRouteStore = new MockRouteStore();
    mockDhcpRelayStore = new MockDhcpRelayStore();
    manager.dhcpRelayStore = mockDhcpRelayStore;
    manager.interfaceService = new MockInterfaceService();
    manager.flowObjectiveService = EasyMock.niceMock(FlowObjectiveService.class);
    mockHostProviderService = createNiceMock(HostProviderService.class);
    Dhcp4HandlerImpl v4Handler = new Dhcp4HandlerImpl();
    v4Handler.providerService = mockHostProviderService;
    v4Handler.dhcpRelayStore = mockDhcpRelayStore;
    v4Handler.hostService = manager.hostService;
    v4Handler.interfaceService = manager.interfaceService;
    v4Handler.packetService = manager.packetService;
    v4Handler.routeStore = mockRouteStore;
    manager.v4Handler = v4Handler;
    // TODO: initialize v6 handler.
    // DhcpHandler v6Handler = createNiceMock(DhcpHandler.class);
    Dhcp6HandlerImpl v6Handler = new Dhcp6HandlerImpl();
    v6Handler.dhcpRelayStore = mockDhcpRelayStore;
    v6Handler.hostService = manager.hostService;
    v6Handler.interfaceService = manager.interfaceService;
    v6Handler.packetService = manager.packetService;
    v6Handler.routeStore = mockRouteStore;
    v6Handler.providerService = mockHostProviderService;
    manager.v6Handler = v6Handler;
    // properties
    Dictionary<String, Object> dictionary = createNiceMock(Dictionary.class);
    expect(dictionary.get("arpEnabled")).andReturn(true).anyTimes();
    ComponentContext context = createNiceMock(ComponentContext.class);
    expect(context.getProperties()).andReturn(dictionary).anyTimes();
    EasyMock.replay(manager.cfgService, manager.coreService, manager.hostService, manager.compCfgService, dictionary, context);
    manager.activate(context);
}
#method_after
@Before
public void setup() {
    manager = new DhcpRelayManager();
    manager.cfgService = createNiceMock(NetworkConfigRegistry.class);
    expect(manager.cfgService.getConfig(APP_ID, DefaultDhcpRelayConfig.class)).andReturn(CONFIG).anyTimes();
    expect(manager.cfgService.getConfig(APP_ID, IndirectDhcpRelayConfig.class)).andReturn(CONFIG_INDIRECT).anyTimes();
    manager.coreService = createNiceMock(CoreService.class);
    expect(manager.coreService.registerApplication(anyString())).andReturn(APP_ID).anyTimes();
    manager.hostService = createNiceMock(HostService.class);
    expect(manager.hostService.getHostsByIp(anyObject())).andReturn(ImmutableSet.of(SERVER_HOST)).anyTimes();
    expect(manager.hostService.getHost(OUTER_RELAY_HOST_ID)).andReturn(OUTER_RELAY_HOST).anyTimes();
    packetService = new MockPacketService();
    manager.packetService = packetService;
    manager.compCfgService = createNiceMock(ComponentConfigService.class);
    manager.deviceService = createNiceMock(DeviceService.class);
    Device device = createNiceMock(Device.class);
    expect(device.is(Pipeliner.class)).andReturn(true).anyTimes();
    expect(manager.deviceService.getDevice(DEV_1_ID)).andReturn(device).anyTimes();
    expect(manager.deviceService.getDevice(DEV_2_ID)).andReturn(device).anyTimes();
    replay(manager.deviceService, device);
    mockRouteStore = new MockRouteStore();
    mockDhcpRelayStore = new MockDhcpRelayStore();
    manager.dhcpRelayStore = mockDhcpRelayStore;
    manager.interfaceService = new MockInterfaceService();
    manager.flowObjectiveService = EasyMock.niceMock(FlowObjectiveService.class);
    mockHostProviderService = createNiceMock(HostProviderService.class);
    Dhcp4HandlerImpl v4Handler = new Dhcp4HandlerImpl();
    v4Handler.providerService = mockHostProviderService;
    v4Handler.dhcpRelayStore = mockDhcpRelayStore;
    v4Handler.hostService = manager.hostService;
    v4Handler.interfaceService = manager.interfaceService;
    v4Handler.packetService = manager.packetService;
    v4Handler.routeStore = mockRouteStore;
    manager.v4Handler = v4Handler;
    Dhcp6HandlerImpl v6Handler = new Dhcp6HandlerImpl();
    v6Handler.dhcpRelayStore = mockDhcpRelayStore;
    v6Handler.hostService = manager.hostService;
    v6Handler.interfaceService = manager.interfaceService;
    v6Handler.packetService = manager.packetService;
    v6Handler.routeStore = mockRouteStore;
    v6Handler.providerService = mockHostProviderService;
    manager.v6Handler = v6Handler;
    // properties
    Dictionary<String, Object> dictionary = createNiceMock(Dictionary.class);
    expect(dictionary.get("arpEnabled")).andReturn(true).anyTimes();
    ComponentContext context = createNiceMock(ComponentContext.class);
    expect(context.getProperties()).andReturn(dictionary).anyTimes();
    replay(manager.cfgService, manager.coreService, manager.hostService, manager.compCfgService, dictionary, context);
    manager.activate(context);
}
#end_block

#method_before
@Test
public void relayDhcp6WithoutAgentInfo() {
    replay(mockHostProviderService);
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(CLIENT_MAC, VlanId.NONE, CLIENT_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    assertEquals(0, mockRouteStore.routes.size());
    Capture<HostDescription> capturedHostDesc = newCapture();
    mockHostProviderService.hostDetected(eq(HostId.hostId(CLIENT_MAC, CLIENT_VLAN)), capture(capturedHostDesc), eq(false));
    replay(mockHostProviderService);
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(CLIENT_CP, CLIENT_MAC, CLIENT_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    verify(mockHostProviderService);
    assertEquals(0, mockRouteStore.routes.size());
    HostDescription host = capturedHostDesc.getValue();
    assertEquals(CLIENT_VLAN, host.vlan());
    assertEquals(CLIENT_CP.deviceId(), host.location().elementId());
    assertEquals(CLIENT_CP.port(), host.location().port());
    assertEquals(1, host.ipAddress().size());
    assertEquals(IP_FOR_CLIENT_V6, host.ipAddress().iterator().next());
}
#method_after
@Test
public void relayDhcp6WithoutAgentInfo() {
    replay(mockHostProviderService);
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.REQUEST.value(), CLIENT_MAC, CLIENT_VLAN, CLIENT_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    assertEquals(0, mockRouteStore.routes.size());
    Capture<HostDescription> capturedHostDesc = newCapture();
    mockHostProviderService.hostDetected(eq(HostId.hostId(CLIENT_MAC, CLIENT_VLAN)), capture(capturedHostDesc), eq(false));
    replay(mockHostProviderService);
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT_CP, CLIENT_MAC, CLIENT_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    verify(mockHostProviderService);
    assertEquals(0, mockRouteStore.routes.size());
    HostDescription host = capturedHostDesc.getValue();
    assertEquals(CLIENT_VLAN, host.vlan());
    assertEquals(CLIENT_CP.deviceId(), host.location().elementId());
    assertEquals(CLIENT_CP.port(), host.location().port());
    assertEquals(1, host.ipAddress().size());
    assertEquals(IP_FOR_CLIENT_V6, host.ipAddress().iterator().next());
    // send release
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.RELEASE.value(), CLIENT_MAC, CLIENT_VLAN, CLIENT_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0));
    assertEquals(null, manager.hostService.getHost(HostId.hostId(CLIENT_MAC, CLIENT_VLAN)));
}
#end_block

#method_before
@Test
public void relayDhcp6WithAgentInfo() {
    replay(mockHostProviderService);
    // Assume outer dhcp6 relay agent exists in store already
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, INTERFACE_IP_V6.ipAddress().getIp6Address(), 1));
    assertEquals(0, mockRouteStore.routes.size());
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(CLIENT2_CP, CLIENT2_MAC, CLIENT2_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 1));
    // won't trigger the host provider service
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    // ipAddress and prefix
    assertEquals(2, mockRouteStore.routes.size());
    Route route = mockRouteStore.routes.get(0);
    assertEquals(OUTER_RELAY_IP_V6, route.nextHop());
    assertEquals(IP_FOR_CLIENT_V6.toIpPrefix(), route.prefix());
    assertEquals(Route.Source.STATIC, route.source());
}
#method_after
@Test
public void relayDhcp6WithAgentInfo() {
    replay(mockHostProviderService);
    // Assume outer dhcp6 relay agent exists in store already
    // send request
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.REQUEST.value(), CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, OUTER_RELAY_IP_V6, 1));
    assertEquals(0, mockRouteStore.routes.size());
    // send reply
    packetService.processPacket(new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT2_CP, CLIENT2_MAC, CLIENT2_VLAN, OUTER_RELAY_IP_V6, 1));
    // won't trigger the host provider service
    verify(mockHostProviderService);
    reset(mockHostProviderService);
    // ipAddress and prefix
    assertEquals(2, mockRouteStore.routes.size());
    Route aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(IP_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertNotEquals(null, aRoute);
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(PREFIX_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertNotEquals(null, aRoute);
    // send release msg
    packetService.processPacket(new TestDhcp6RequestPacketContext(DHCP6.MsgType.RELEASE.value(), CLIENT2_MAC, CLIENT2_VLAN, CLIENT2_CP, OUTER_RELAY_IP_V6, 1));
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(IP_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertEquals(null, aRoute);
    aRoute = mockRouteStore.routes.stream().filter(rt -> rt.prefix().contains(PREFIX_FOR_CLIENT_V6)).findFirst().orElse(null);
    assertEquals(null, aRoute);
    assertEquals(0, mockRouteStore.routes.size());
}
#end_block

#method_before
@Test
public void testDhcp6DualHome() {
    PacketContext packetContext = new TestDhcp6ReplyPacketContext(CLIENT_DH_CP, CLIENT_MAC, CLIENT_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0);
    reset(manager.hostService);
    expect(manager.hostService.getHostsByIp(CLIENT_LL_IP_V6)).andReturn(ImmutableSet.of(EXISTS_HOST)).anyTimes();
    // FIXME: currently DHCPv6 has a bug, we can't get correct vlan of client......
    // XXX: The vlan relied from DHCP6 handler might be wrong, do hack here
    HostId hostId = HostId.hostId(CLIENT_MAC, VlanId.NONE);
    expect(manager.hostService.getHost(hostId)).andReturn(EXISTS_HOST).anyTimes();
    // XXX: sometimes this will work, sometimes not
    expect(manager.hostService.getHost(CLIENT_HOST_ID)).andReturn(EXISTS_HOST).anyTimes();
    Capture<HostDescription> capturedHostDesc = newCapture();
    // XXX: also a hack here
    mockHostProviderService.hostDetected(eq(hostId), capture(capturedHostDesc), eq(false));
    expectLastCall().anyTimes();
    mockHostProviderService.hostDetected(eq(CLIENT_HOST_ID), capture(capturedHostDesc), eq(false));
    expectLastCall().anyTimes();
    replay(mockHostProviderService, manager.hostService);
    packetService.processPacket(packetContext);
    verify(mockHostProviderService);
    HostDescription hostDesc = capturedHostDesc.getValue();
    Set<HostLocation> hostLocations = hostDesc.locations();
    assertEquals(2, hostLocations.size());
    assertTrue(hostLocations.contains(CLIENT_LOCATION));
    assertTrue(hostLocations.contains(CLIENT_DH_LOCATION));
}
#method_after
@Test
public void testDhcp6DualHome() {
    PacketContext packetContext = new TestDhcp6ReplyPacketContext(DHCP6.MsgType.REPLY.value(), CLIENT_DH_CP, CLIENT_MAC, CLIENT_VLAN, INTERFACE_IP_V6.ipAddress().getIp6Address(), 0);
    reset(manager.hostService);
    expect(manager.hostService.getHostsByIp(CLIENT_LL_IP_V6)).andReturn(ImmutableSet.of(EXISTS_HOST)).anyTimes();
    // FIXME: currently DHCPv6 has a bug, we can't get correct vlan of client......
    // XXX: The vlan relied from DHCP6 handler might be wrong, do hack here
    HostId hostId = HostId.hostId(CLIENT_MAC, VlanId.NONE);
    expect(manager.hostService.getHost(hostId)).andReturn(EXISTS_HOST).anyTimes();
    // XXX: sometimes this will work, sometimes not
    expect(manager.hostService.getHost(CLIENT_HOST_ID)).andReturn(EXISTS_HOST).anyTimes();
    Capture<HostDescription> capturedHostDesc = newCapture();
    // XXX: also a hack here
    mockHostProviderService.hostDetected(eq(hostId), capture(capturedHostDesc), eq(false));
    expectLastCall().anyTimes();
    mockHostProviderService.hostDetected(eq(CLIENT_HOST_ID), capture(capturedHostDesc), eq(false));
    expectLastCall().anyTimes();
    replay(mockHostProviderService, manager.hostService);
    packetService.processPacket(packetContext);
    verify(mockHostProviderService);
    HostDescription hostDesc = capturedHostDesc.getValue();
    Set<HostLocation> hostLocations = hostDesc.locations();
    assertEquals(2, hostLocations.size());
    assertTrue(hostLocations.contains(CLIENT_LOCATION));
    assertTrue(hostLocations.contains(CLIENT_DH_LOCATION));
}
#end_block

#method_before
private byte[] buildInterfaceId(MacAddress clientMac, short vlanId, ConnectPoint clientCp) {
    String inPortString = "-" + clientCp.toString() + ":";
    byte[] clientSoureMacBytes = clientMac.toBytes();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    vlanIdBytes[0] = (byte) (vlanId & 0xff);
    vlanIdBytes[1] = (byte) ((vlanId >> 8) & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    return interfaceIdBytes;
}
#method_after
private byte[] buildInterfaceId(MacAddress clientMac, short vlanId, ConnectPoint clientCp) {
    String inPortString = "-" + clientCp.toString() + ":";
    byte[] clientSoureMacBytes = clientMac.toBytes();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] vlanIdBytes = new byte[2];
    // high-order byte first
    vlanIdBytes[0] = (byte) ((vlanId >> 8) & 0xff);
    vlanIdBytes[1] = (byte) (vlanId & 0xff);
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length + vlanIdBytes.length];
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(vlanIdBytes, 0, interfaceIdBytes, clientSoureMacBytes.length + inPortStringBytes.length, vlanIdBytes.length);
    return interfaceIdBytes;
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    parseKeyPairCompat(handler());
    return parseProductInformation();
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    return parseProductInformation();
}
#end_block

#method_before
private DeviceDescription parseProductInformation() {
    DeviceService devsvc = checkNotNull(handler().get(DeviceService.class));
    DeviceId devid = handler().data().deviceId();
    Device dev = devsvc.getDevice(devid);
    String reply = netconfGet(handler(), getProductInformationFilter());
    HierarchicalConfiguration cfg = configAt(reply, KEY_DATA_PRODINF);
    return new DefaultDeviceDescription(dev.id().uri(), FIBER_SWITCH, cfg.getString(KEY_MANUFACTURER), cfg.getString(KEY_HWVERSION), cfg.getString(KEY_SWVERSION), cfg.getString(KEY_SERIALNUMBER), dev.chassisId());
}
#method_after
private DeviceDescription parseProductInformation() {
    DeviceService devsvc = checkNotNull(handler().get(DeviceService.class));
    DeviceId devid = handler().data().deviceId();
    Device dev = devsvc.getDevice(devid);
    if (dev == null) {
        return new DefaultDeviceDescription(dev.id().uri(), FIBER_SWITCH, DEFAULT_MANUFACTURER, DEFAULT_DESCRIPTION_DATA, DEFAULT_DESCRIPTION_DATA, DEFAULT_DESCRIPTION_DATA, dev.chassisId());
    }
    String reply = netconfGet(handler(), getProductInformationFilter());
    HierarchicalConfiguration cfg = configAt(reply, KEY_DATA_PRODINF);
    return new DefaultDeviceDescription(dev.id().uri(), FIBER_SWITCH, cfg.getString(KEY_MANUFACTURER), cfg.getString(KEY_HWVERSION), cfg.getString(KEY_SWVERSION), cfg.getString(KEY_SERIALNUMBER), dev.chassisId());
}
#end_block

#method_before
private PortDescription parsePort(HierarchicalConfiguration cfg) {
    PortNumber portNumber = PortNumber.portNumber(cfg.getLong(KEY_PORTID));
    DefaultAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, cfg.getString(KEY_PORTLABEL)).build();
    return omsPortDescription(portNumber, cfg.getString(KEY_PORTSTATUS).equals("ENABLED"), Spectrum.O_BAND_MIN, Spectrum.L_BAND_MAX, Frequency.ofGHz((Spectrum.O_BAND_MIN.asGHz() - Spectrum.L_BAND_MAX.asGHz()) / POLATIS_NUM_OF_WAVELENGTHS), annotations);
}
#method_after
private PortDescription parsePort(HierarchicalConfiguration cfg) {
    PortNumber portNumber = PortNumber.portNumber(cfg.getLong(KEY_PORTID));
    DefaultAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, cfg.getString(KEY_PORTLABEL)).build();
    return omsPortDescription(portNumber, cfg.getString(KEY_PORTSTATUS).equals(PORT_ENABLED), Spectrum.O_BAND_MIN, Spectrum.L_BAND_MAX, Frequency.ofGHz((Spectrum.O_BAND_MIN.asGHz() - Spectrum.L_BAND_MAX.asGHz()) / POLATIS_NUM_OF_WAVELENGTHS), annotations);
}
#end_block

#method_before
public static String netconfGet(DriverHandler handler, String filter) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    String reply;
    try {
        reply = session.get(filter, null);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    return reply;
}
#method_after
public static String netconfGet(DriverHandler handler, String filter) {
    NetconfSession session = getNetconfSession(handler);
    String reply;
    try {
        reply = session.get(filter, null);
    } catch (NetconfException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    return reply;
}
#end_block

#method_before
public static String netconfGetConfig(DriverHandler handler, String filter) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    String reply;
    try {
        reply = session.getConfig(DatastoreId.RUNNING, filter);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    return reply;
}
#method_after
public static String netconfGetConfig(DriverHandler handler, String filter) {
    NetconfSession session = getNetconfSession(handler);
    String reply;
    try {
        reply = session.getConfig(DatastoreId.RUNNING, filter);
    } catch (NetconfException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    return reply;
}
#end_block

#method_before
public static boolean netconfEditConfig(DriverHandler handler, String mode, String cfg) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    boolean reply = false;
    try {
        reply = session.editConfig(DatastoreId.RUNNING, mode, cfg);
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to edit configuration.", e));
    }
    return reply;
}
#method_after
public static boolean netconfEditConfig(DriverHandler handler, String mode, String cfg) {
    NetconfSession session = getNetconfSession(handler);
    boolean reply = false;
    try {
        reply = session.editConfig(DatastoreId.RUNNING, mode, cfg);
    } catch (NetconfException e) {
        throw new RuntimeException(new NetconfException("Failed to edit configuration.", e));
    }
    return reply;
}
#end_block

#method_before
public static HierarchicalConfiguration configAt(String content, String key) {
    HierarchicalConfiguration info;
    try {
        HierarchicalConfiguration cfg = XmlConfigParser.loadXmlString(content);
        info = cfg.configurationAt(key);
    } catch (Exception e) {
        // Accept null for information polling
        return null;
    }
    return info;
}
#method_after
public static HierarchicalConfiguration configAt(String content, String key) {
    HierarchicalConfiguration info;
    try {
        HierarchicalConfiguration cfg = XmlConfigParser.loadXmlString(content);
        info = cfg.configurationAt(key);
    } catch (IllegalArgumentException e) {
        // Accept null for information polling
        return null;
    }
    return info;
}
#end_block

#method_before
public static List<HierarchicalConfiguration> configsAt(String content, String key) {
    List<HierarchicalConfiguration> info;
    try {
        HierarchicalConfiguration cfg = XmlConfigParser.loadXmlString(content);
        info = cfg.configurationsAt(key);
    } catch (Exception e) {
        // Accept empty for information polling
        return ImmutableList.of();
    }
    return info;
}
#method_after
public static List<HierarchicalConfiguration> configsAt(String content, String key) {
    List<HierarchicalConfiguration> info;
    try {
        HierarchicalConfiguration cfg = XmlConfigParser.loadXmlString(content);
        info = cfg.configurationsAt(key);
    } catch (IllegalArgumentException e) {
        // Accept empty for information polling
        return ImmutableList.of();
    }
    return info;
}
#end_block

#method_before
private static String opticalRevision(DriverHandler handler) {
    NetconfController controller = checkNotNull(handler.get(NetconfController.class));
    NetconfSession session = controller.getNetconfDevice(handler.data().deviceId()).getSession();
    Set<String> capabilities = session.getDeviceCapabilitiesSet();
    for (String c : capabilities) {
        if (c.startsWith(OPTICAL_CAPABILITY_PREFIX)) {
            return c.substring(OPTICAL_CAPABILITY_PREFIX.length());
        }
    }
    return null;
}
#method_after
public static String opticalRevision(DriverHandler handler) {
    NetconfSession session = getNetconfSession(handler);
    Set<String> capabilities = session.getDeviceCapabilitiesSet();
    for (String c : capabilities) {
        if (c.startsWith(OPTICAL_CAPABILITY_PREFIX)) {
            return c.substring(OPTICAL_CAPABILITY_PREFIX.length());
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void setTargetPower(PortNumber port, T component, long power) {
    if (component instanceof OchSignal) {
    // Note: Channel power is N/A
    } else {
        setPortTargetPower(port, power);
    }
}
#method_after
@Override
public void setTargetPower(PortNumber port, T component, long power) {
    if (component instanceof OchSignal) {
        log.warn("Channel power is not applicable.");
        return;
    }
    setPortTargetPower(port, power);
}
#end_block

#method_before
private Long acquireTargetPower(PortNumber port, T component) {
    if (component instanceof OchSignal) {
        // Note: Channel power is N/A
        return null;
    }
    log.debug("Get port{} target power...", port);
    // Note: To be implemented
    return null;
}
#method_after
private Long acquireTargetPower(PortNumber port, T component) {
    if (component instanceof OchSignal) {
        log.warn("Channel power is not applicable.");
        return null;
    }
    log.debug("Get port{} target power...", port);
    log.warn("This is currently unimplemented");
    return null;
}
#end_block

#method_before
private Long acquireCurrentPower(PortNumber port, T component) {
    if (component instanceof OchSignal) {
        // Note: Channel power is N/A
        return null;
    }
    log.debug("Get port{} current power...", port);
    return acquirePortPower(port);
}
#method_after
private Long acquireCurrentPower(PortNumber port, T component) {
    if (component instanceof OchSignal) {
        log.warn("Channel power is not applicable.");
        return null;
    }
    log.debug("Get port{} current power...", port);
    return acquirePortPower(port);
}
#end_block

#method_before
private boolean setPortTargetPower(PortNumber port, long power) {
    log.debug("Set port{} target power...", port);
    // TODO: To be implemented
    return false;
}
#method_after
private boolean setPortTargetPower(PortNumber port, long power) {
    log.debug("Set port{} target power...", port);
    log.warn("This is currently unimplemented");
    return false;
}
#end_block

#method_before
private Range<Long> getTxPowerRange(PortNumber port, T component) {
    if (component instanceof Direction) {
        log.debug("Get target port{} power range...", port);
        return getPowerRange();
    } else {
        log.debug("Get channel attenuation range...");
        // Note: Channel power is N/A
        return null;
    }
}
#method_after
private Range<Long> getTxPowerRange(PortNumber port, T component) {
    if (component instanceof Direction) {
        log.debug("Get target port{} power range...", port);
        return getPowerRange();
    } else {
        log.debug("Get channel attenuation range...");
        log.warn("Channel power is not applicable.");
        return null;
    }
}
#end_block

#method_before
private Collection<FlowEntry> parseConnections() {
    log.debug("Fetch connections...");
    String reply = netconfGet(handler(), getConnectionsFilter());
    List<HierarchicalConfiguration> subtrees = configsAt(reply, KEY_DATA_CONNS);
    Collection<FlowEntry> list = new ArrayList<>();
    for (HierarchicalConfiguration connection : subtrees) {
        list.add(new DefaultFlowEntry(parseConnection(connection), FlowEntry.FlowEntryState.ADDED));
    }
    return list;
}
#method_after
private Collection<FlowEntry> parseConnections() {
    log.debug("Fetch connections...");
    String reply = netconfGet(handler(), getConnectionsFilter());
    final String keyPairMode = String.format("%s.%s", KEY_DATA_CONNS, parseKeyPairCompat());
    List<HierarchicalConfiguration> subtrees = configsAt(reply, keyPairMode);
    ImmutableList.Builder<FlowEntry> connectionsBuilder = ImmutableList.builder();
    for (HierarchicalConfiguration connection : subtrees) {
        connectionsBuilder.add(new DefaultFlowEntry(parseConnection(connection), FlowEntry.FlowEntryState.ADDED));
    }
    return connectionsBuilder.build();
}
#end_block

#method_before
private boolean editConnection(FlowRule rule, String mode) {
    CrossConnects crossConnects = PolatisOpticalUtility.fromFlowRule(this, rule);
    final StringBuilder cfg = new StringBuilder(xmlOpen(KEY_CONNS_XMLNS));
    List<Pair> pairs = crossConnects.pair();
    final String keyPairMode = String.format("%s operation=\"%s\"", keyPairCompat, mode);
    pairs.forEach(p -> {
        cfg.append(xmlOpen(keyPairMode)).append(xmlOpen(KEY_SRC)).append(p.ingress()).append(xmlClose(KEY_SRC)).append(xmlOpen(KEY_DST)).append(p.egress()).append(xmlClose(KEY_DST)).append(xmlClose(keyPairCompat));
    });
    cfg.append(xmlClose(KEY_CONNS));
    return netconfEditConfig(handler(), null, cfg.toString());
}
#method_after
private boolean editConnection(FlowRule rule, String mode) {
    CrossConnects crossConnects = PolatisOpticalUtility.fromFlowRule(this, rule);
    final StringBuilder cfg = new StringBuilder(xmlOpen(KEY_CONNS_XMLNS));
    List<Pair> pairs = crossConnects.pair();
    final String keyPairCompat = parseKeyPairCompat();
    final String keyPairMode = String.format("%s operation=\"%s\"", keyPairCompat, mode);
    pairs.forEach(p -> {
        cfg.append(xmlOpen(keyPairMode)).append(xmlOpen(KEY_SRC)).append(p.ingress()).append(xmlClose(KEY_SRC)).append(xmlOpen(KEY_DST)).append(p.egress()).append(xmlClose(KEY_DST)).append(xmlClose(keyPairCompat));
    });
    cfg.append(xmlClose(KEY_CONNS));
    return netconfEditConfig(handler(), null, cfg.toString());
}
#end_block

#method_before
public static PolicerId policerId(short id) {
    checkArgument(id > 0, "id cannot be negative nor 0");
    checkArgument(id <= MAX, "id cannot be larger than {}", MAX);
    return new PolicerId(id);
}
#method_after
public static PolicerId policerId(URI uri) {
    return new PolicerId(uri);
}
#end_block

#method_before
@Test
public void testDropCreation() {
    // Create a block traffic policer
    Policer policer = DefaultPolicer.builder().forConnectPoint(CP1).fromApp(FOO_APP_ID).withId(ID1).withGreenBurstSize(0).withYellowBurstSize(0).build();
    // Assert on connect point
    assertThat(policer.connectPoint(), is(CP1));
    // Assert on app id
    assertThat(policer.applicationId(), is(FOO_APP_ID));
    // Assert on policer id
    assertThat(policer.policerId(), is(ID1));
    // Green rate and burst size should be 0
    assertThat(policer.greenRate(), is(0L));
    assertThat(policer.greenBurstSize(), is(0L));
    // Green marking is not used
    assertThat(policer.greenMarking(), is(NONE));
    // Green dscp is not used
    assertThat(policer.greenDscp(), is((short) 0));
    // Yellow rate and burst size should be 0
    assertThat(policer.yellowRate(), is(0L));
    assertThat(policer.yellowBurstSize(), is(0L));
    // Yellow marking is not used
    assertThat(policer.yellowMarking(), is(NONE));
    // Yellow dscp is not used
    assertThat(policer.yellowDscp(), is((short) 0));
    // It is not color aware
    assertFalse(policer.isColorAware());
    // Unit is Mbps
    assertThat(policer.unit(), is(MB_PER_SEC));
}
#method_after
@Test
public void testDropCreation() {
    // Create a drop traffic token bucket at 1MB/s
    TokenBucket tokenBucket = DefaultTokenBucket.builder().withRate(1).withAction(DROP).build();
    // Create a policer with above token bucket
    Policer policer = DefaultPolicer.builder().forDeviceId(DID1).fromApp(FOO_APP_ID).withId(ID2).withTokenBuckets(ImmutableList.of(tokenBucket)).build();
    // Assert on device id
    assertThat(policer.deviceId(), is(DID1));
    // Assert on app id
    assertThat(policer.applicationId(), is(FOO_APP_ID));
    // Assert on policer id
    assertThat(policer.policerId(), is(ID2));
    // It is not color aware
    assertFalse(policer.isColorAware());
    // Unit is Mbps
    assertThat(policer.unit(), is(MB_PER_SEC));
    // One token bucket
    assertThat(policer.tokenBuckets().size(), is(1));
    // One token bucket equals to tokenBucket
    assertTrue(policer.tokenBuckets().contains(tokenBucket));
}
#end_block

#method_before
@Test
public void testNullParam() {
    // Define expected exception
    exceptionNullParam.expect(NullPointerException.class);
    // Invalid policer, connect point is not defined
    DefaultPolicer.builder().fromApp(FOO_APP_ID).withId(ID8).build();
}
#method_after
@Test
public void testNullParam() {
    // Define expected exception
    exceptionNullParam.expect(NullPointerException.class);
    // Invalid policer, device id is not defined
    DefaultPolicer.builder().fromApp(FOO_APP_ID).withId(ID6).build();
}
#end_block

#method_before
@Test
public void testEqualilty() {
    // Create first policer
    Policer policerOne = DefaultPolicer.builder().forConnectPoint(CP1).fromApp(FOO_APP_ID).withId(ID1).withGreenBurstSize(0).withYellowBurstSize(0).build();
    // Create second policer
    Policer policerTwo = DefaultPolicer.builder().forConnectPoint(CP1).fromApp(FOO_APP_ID).withId(ID2).withGreenRate(1).withYellowBurstSize(0).build();
    // Create third policer
    Policer policerThree = DefaultPolicer.builder().forConnectPoint(CP1).fromApp(FOO_APP_ID).withId(ID1).withGreenRate(1).withGreenMarking(DSCP_CLASS).withGreenDscp((short) 254).withYellowBurstSize(0).build();
    // One and Three are equal
    assertEquals(policerOne, policerThree);
    // Two is different due to the different id
    assertNotEquals(policerOne, policerTwo);
    assertNotEquals(policerThree, policerTwo);
}
#method_after
@Test
public void testEqualilty() {
    // Create a block traffic token bucket
    TokenBucket blockTokenBucket = DefaultTokenBucket.builder().withBurstSize(0).withAction(DROP).build();
    // Create a mark traffic token bucket
    TokenBucket markTokenBucket = DefaultTokenBucket.builder().withBurstSize(0).withAction(DSCP_CLASS).withDscp((short) 10).build();
    // Create first policer
    Policer policerOne = DefaultPolicer.builder().forDeviceId(DID1).fromApp(FOO_APP_ID).withId(ID8).withTokenBuckets(ImmutableList.of(blockTokenBucket)).build();
    // Create second policer
    Policer policerTwo = DefaultPolicer.builder().forDeviceId(DID1).fromApp(FOO_APP_ID).withId(ID9).withTokenBuckets(ImmutableList.of(markTokenBucket)).build();
    // Create third policer copy of one
    // Create first policer
    Policer policerThree = DefaultPolicer.builder().forDeviceId(DID1).fromApp(FOO_APP_ID).withId(ID8).withTokenBuckets(ImmutableList.of(blockTokenBucket)).build();
    // One and Three are equal
    assertEquals(policerOne, policerThree);
    // Two is different due to the different id
    assertNotEquals(policerOne, policerTwo);
    assertNotEquals(policerThree, policerTwo);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("connectPoint", connectPoint()).add("appId", applicationId()).add("id", policerId()).add("greenRate", greenRate()).add("greenBurstSize", greenBurstSize()).add("greenMarking", greenMarking()).add("greenDscp", greenDscp()).add("yellowRate", yellowRate()).add("yellowBurstSize", yellowBurstSize()).add("yellowMarking", yellowMarking()).add("yellowDscp", yellowDscp()).add("isColorAware", isColorAware()).add("unit", unit()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("appId", applicationId()).add("id", policerId()).add("isColorAware", isColorAware()).add("unit", unit()).add("tokenBuckets", tokenBuckets()).add("description", description()).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    DefaultPolicer that = (DefaultPolicer) o;
    return Objects.equal(policerId, that.policerId) && Objects.equal(applicationId, that.applicationId) && Objects.equal(connectPoint, that.connectPoint);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    DefaultPolicer that = (DefaultPolicer) o;
    return Objects.equal(policerId, that.policerId);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(policerId, applicationId, connectPoint);
}
#method_after
@Override
public int hashCode() {
    return policerId.hashCode();
}
#end_block

#method_before
@Override
public Policer.Builder colorAware() {
    colorAware = true;
    return this;
}
#method_after
@Override
public Policer.Builder colorAware(boolean isColorAware) {
    colorAware = isColorAware;
    return this;
}
#end_block

#method_before
@Override
public Policer build() {
    // Not null condition on some mandatory parameters
    checkNotNull(connectPoint, "Must specify a connect point");
    checkNotNull(applicationId, "Must specify an application id");
    checkNotNull(policerId, "Must specify a policer id");
    checkNotNull(unit, "Must specify a unit for the policer");
    checkNotNull(greenMarking, "Must specify a green marking action");
    checkNotNull(yellowMarking, "Must specify a yellow marking action");
    // Verify consistency between green and yellow rate
    if (greenRate >= 0) {
        // It is not allowed to have a yellow rate less than green rate
        if (yellowRate != 0 && yellowRate < greenRate) {
            // Build has to fail
            throw new IllegalArgumentException("Green rate and yellow rate are not consistent");
        }
    }
    // Green marking is based only dscp class or none
    checkArgument(greenMarking == MarkingType.NONE || greenMarking == MarkingType.DSCP_CLASS, "Invalid green marking");
    // If green marking is based on dscp class
    if (greenMarking == MarkingType.DSCP_CLASS) {
        // dscp should be a value between 0 and 255
        checkArgument(greenDscp >= MIN_DSCP && greenDscp <= MAX_DSCP, "Green dscp is out of range");
    }
    // If yellow marking is based on dscp class or dscp precedence
    if (yellowMarking == MarkingType.DSCP_CLASS || yellowMarking == MarkingType.DSCP_PRECEDENCE) {
        // dscp should be a value between 0 and 255
        checkArgument(yellowDscp >= MIN_DSCP && yellowDscp <= MAX_DSCP, "Yellow dscp is out of range");
    }
    // Finally we build the policer
    return new DefaultPolicer(connectPoint, applicationId, policerId, greenRate, greenBurstSize, greenMarking, greenDscp, yellowRate, yellowBurstSize, yellowMarking, yellowDscp, colorAware, unit);
}
#method_after
@Override
public DefaultPolicer build() {
    // Not null condition on some mandatory parameters
    checkNotNull(deviceId, "Must specify a deviceId");
    checkNotNull(applicationId, "Must specify an application id");
    checkNotNull(policerId, "Must specify a policer id");
    checkNotNull(unit, "Must specify a unit for the policer");
    checkNotNull(tokenBuckets, "Must have token buckets");
    checkNotNull(description, "Must have a description");
    // Verify argument conditions
    checkArgument(!tokenBuckets.isEmpty(), "Must have at least one token bucket");
    // Finally we build the policer
    return new DefaultPolicer(deviceId, applicationId, policerId, colorAware, unit, tokenBuckets, description);
}
#end_block

#method_before
private OchSignal createOchSignal() throws IllegalArgumentException {
    if (signal == null) {
        return null;
    }
    try {
        String[] splitted = signal.split("/");
        checkArgument(splitted.length == 4, "signal requires 4 parameters: " + SIGNAL_FORMAT);
        int slotGranularity = Integer.parseInt(splitted[0]);
        String chSpacing = splitted[1];
        ChannelSpacing channelSpacing = checkNotNull(CHANNEL_SPACING_MAP.get(chSpacing), String.format("invalid channel spacing: %s", chSpacing));
        int multiplier = Integer.parseInt(splitted[2]);
        String gdType = splitted[3].toUpperCase();
        GridType gridType = checkNotNull(GRID_TYPE_MAP.get(gdType), String.format("invalid grid type: %s", gdType));
        return new OchSignal(gridType, channelSpacing, multiplier, slotGranularity);
    } catch (RuntimeException e) {
        /* catching RuntimeException as both NullPointerException (thrown by
             * checkNotNull) and IllegalArgumentException (thrown by checkArgument)
             * are subclasses of RuntimeException.
             */
        String msg = String.format("Invalid signal format: %s, expected format is %s\n%s", signal, SIGNAL_FORMAT, e);
        print(msg);
        throw new IllegalArgumentException(msg);
    }
}
#method_after
private OchSignal createOchSignal() throws IllegalArgumentException {
    if (signal == null) {
        return null;
    }
    try {
        String[] splitted = signal.split("/");
        checkArgument(splitted.length == 4, "signal requires 4 parameters: " + SIGNAL_FORMAT);
        int slotGranularity = Integer.parseInt(splitted[0]);
        String chSpacing = splitted[1];
        ChannelSpacing channelSpacing = checkNotNull(CHANNEL_SPACING_MAP.get(chSpacing), String.format("invalid channel spacing: %s", chSpacing));
        int multiplier = Integer.parseInt(splitted[2]);
        String gdType = splitted[3].toUpperCase();
        GridType gridType = checkNotNull(GRID_TYPE_MAP.get(gdType), String.format("invalid grid type: %s", gdType));
        return new OchSignal(gridType, channelSpacing, multiplier, slotGranularity);
    } catch (RuntimeException e) {
        /* catching RuntimeException as both NullPointerException (thrown by
             * checkNotNull) and IllegalArgumentException (thrown by checkArgument)
             * are subclasses of RuntimeException.
             */
        String msg = String.format("Invalid signal format: %s, expected format is %s.", signal, SIGNAL_FORMAT);
        print(msg);
        throw new IllegalArgumentException(msg, e);
    }
}
#end_block

#method_before
private List<OchSignal> findFirstAvailableLambda(OpticalConnectivityIntent intent, Path path) {
    if (intent.ochSignal().isPresent()) {
        // create lambdas w.r.t. slotGanularity/slotWidth
        OchSignal ochSignal = intent.ochSignal().get();
        if (ochSignal.gridType() == GridType.FLEX) {
            // multiplier sits in the middle of slots
            int startMultiplier = ochSignal.spacingMultiplier() - (ochSignal.slotGranularity() / 2);
            return IntStream.range(0, ochSignal.slotGranularity()).mapToObj(x -> OchSignal.newFlexGridSlot(startMultiplier + (2 * x))).collect(Collectors.toList());
        }
        log.error("Grid type: {} not supported for user defined signal intents", ochSignal.gridType());
        return Collections.emptyList();
    }
    Set<OchSignal> lambdas = findCommonLambdas(path);
    if (lambdas.isEmpty()) {
        return Collections.emptyList();
    }
    return findFirstLambda(lambdas, slotCount());
}
#method_after
private List<OchSignal> findFirstAvailableLambda(OpticalConnectivityIntent intent, Path path) {
    if (intent.ochSignal().isPresent()) {
        // create lambdas w.r.t. slotGanularity/slotWidth
        OchSignal ochSignal = intent.ochSignal().get();
        if (ochSignal.gridType() == GridType.FLEX) {
            // multiplier sits in the middle of slots
            int startMultiplier = ochSignal.spacingMultiplier() - (ochSignal.slotGranularity() / 2);
            return IntStream.range(0, ochSignal.slotGranularity()).mapToObj(x -> OchSignal.newFlexGridSlot(startMultiplier + (2 * x))).collect(Collectors.toList());
        } else if (ochSignal.gridType() == GridType.DWDM) {
            int startMultiplier = (int) (1 - ochSignal.slotGranularity() + ochSignal.spacingMultiplier() * ochSignal.channelSpacing().frequency().asHz() / ChannelSpacing.CHL_6P25GHZ.frequency().asHz());
            return IntStream.range(0, ochSignal.slotGranularity()).mapToObj(x -> OchSignal.newFlexGridSlot(startMultiplier + (2 * x))).collect(Collectors.toList());
        }
        // TODO: add support for other gridTypes
        log.error("Grid type: {} not supported for user defined signal intents", ochSignal.gridType());
        return Collections.emptyList();
    }
    Set<OchSignal> lambdas = findCommonLambdas(path);
    if (lambdas.isEmpty()) {
        return Collections.emptyList();
    }
    return findFirstLambda(lambdas, slotCount());
}
#end_block

#method_before
private Stream<Path> getOpticalPaths(OpticalConnectivityIntent intent) {
    // Route in WDM topology
    Topology topology = topologyService.currentTopology();
    // TODO: refactor with LinkWeigher class Implementation
    LinkWeight weight = new LinkWeight() {

        @Override
        public double weight(TopologyEdge edge) {
            // Disregard inactive or non-optical links
            if (edge.link().state() == Link.State.INACTIVE) {
                return -1;
            }
            if (edge.link().type() != Link.Type.OPTICAL) {
                return -1;
            }
            // Adhere to static port mappings
            DeviceId srcDeviceId = edge.link().src().deviceId();
            if (srcDeviceId.equals(intent.getSrc().deviceId())) {
                ConnectPoint srcStaticPort = staticPort(intent.getSrc());
                if (srcStaticPort != null) {
                    return srcStaticPort.equals(edge.link().src()) ? 1 : -1;
                }
                // src port must be same as intent src port
                if (!intent.getSrc().port().equals(edge.link().src().port())) {
                    return -1;
                }
            }
            DeviceId dstDeviceId = edge.link().dst().deviceId();
            if (dstDeviceId.equals(intent.getDst().deviceId())) {
                ConnectPoint dstStaticPort = staticPort(intent.getDst());
                if (dstStaticPort != null) {
                    return dstStaticPort.equals(edge.link().dst()) ? 1 : -1;
                }
                // dst port must be same as intent dst port
                if (!intent.getDst().port().equals(edge.link().dst().port())) {
                    return -1;
                }
            }
            return 1;
        }
    };
    ConnectPoint start = intent.getSrc();
    ConnectPoint end = intent.getDst();
    Stream<Path> paths = topologyService.getKShortestPaths(topology, start.deviceId(), end.deviceId(), AdapterLinkWeigher.adapt(weight));
    if (log.isDebugEnabled()) {
        return paths.map(path -> {
            // no-op map stage to add debug logging
            log.debug("Candidate path: {}", path.links().stream().map(lk -> lk.src() + "-" + lk.dst()).collect(Collectors.toList()));
            return path;
        });
    }
    return paths;
}
#method_after
private Stream<Path> getOpticalPaths(OpticalConnectivityIntent intent) {
    // Route in WDM topology
    Topology topology = topologyService.currentTopology();
    // TODO: refactor with LinkWeigher class Implementation
    LinkWeight weight = new LinkWeight() {

        @Override
        public double weight(TopologyEdge edge) {
            // Disregard inactive or non-optical links
            if (edge.link().state() == Link.State.INACTIVE) {
                return -1;
            }
            if (edge.link().type() != Link.Type.OPTICAL) {
                return -1;
            }
            // Adhere to static port mappings
            DeviceId srcDeviceId = edge.link().src().deviceId();
            if (srcDeviceId.equals(intent.getSrc().deviceId())) {
                ConnectPoint srcStaticPort = staticPort(intent.getSrc());
                if (srcStaticPort != null) {
                    return srcStaticPort.equals(edge.link().src()) ? 1 : -1;
                }
            }
            DeviceId dstDeviceId = edge.link().dst().deviceId();
            if (dstDeviceId.equals(intent.getDst().deviceId())) {
                ConnectPoint dstStaticPort = staticPort(intent.getDst());
                if (dstStaticPort != null) {
                    return dstStaticPort.equals(edge.link().dst()) ? 1 : -1;
                }
            }
            return 1;
        }
    };
    ConnectPoint start = intent.getSrc();
    ConnectPoint end = intent.getDst();
    // head link's src port should be same as intent src port and tail link dst port
    // should be same as intent dst port in the path.
    Stream<Path> paths = topologyService.getKShortestPaths(topology, start.deviceId(), end.deviceId(), AdapterLinkWeigher.adapt(weight)).filter(p -> p.links().get(0).src().port().equals(start.port()) && p.links().get(p.links().size() - 1).dst().port().equals(end.port()));
    if (log.isDebugEnabled()) {
        return paths.map(path -> {
            // no-op map stage to add debug logging
            log.debug("Candidate path: {}", path.links().stream().map(lk -> lk.src() + "-" + lk.dst()).collect(Collectors.toList()));
            return path;
        });
    }
    return paths;
}
#end_block

#method_before
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    // 88 channels of 50 GHz with 12.5 GHz slothWidth
    int slots = (int) (ChannelSpacing.CHL_50GHZ.frequency().asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz());
    int channels = 88;
    // total lambadas are equal to: channels * slots
    return IntStream.rangeClosed(0, channels * slots).mapToObj(x -> OchSignal.newFlexGridSlot(2 * x)).collect(ImmutableSet.toImmutableSet());
}
#method_after
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    // 88 channels of 50 GHz with 12.5 GHz slothWidth
    int slots = (int) (ChannelSpacing.CHL_50GHZ.frequency().asHz() / ChannelSpacing.CHL_12P5GHZ.frequency().asHz());
    int channels = 88;
    // total lambdas are equal to: channels * slots
    return IntStream.rangeClosed(0, channels * slots).mapToObj(x -> OchSignal.newFlexGridSlot(2 * x)).collect(ImmutableSet.toImmutableSet());
}
#end_block

#method_before
@Override
public boolean copyConfig(String targetConfiguration, String newConfiguration) throws NetconfException {
    return copyConfig(TargetConfig.valueOf(targetConfiguration), newConfiguration);
}
#method_after
@Override
public boolean copyConfig(String targetConfiguration, String newConfiguration) throws NetconfException {
    return copyConfig(DatastoreId.datastore(targetConfiguration), newConfiguration);
}
#end_block

#method_before
public static String getValidModelId(String id) throws IllegalArgumentException {
    // checking weather modelId contains the alphanumeric character or not.
    if (id.matches(".*[A-Za-z0-9].*")) {
        // replacing special characters with '_'
        id = id.replaceAll("[\\s\\/:*?\"\\[\\]<>|$@!#%&(){}';.,-]", "_");
        // remove leading and trailing underscore
        id = id.replaceAll("^_+|_+$", "");
        // replacing the consecutive underscores '_' to single _
        id = id.replaceAll("_+", "_");
        return id;
    } else {
        throw new IllegalArgumentException("Invalid model id " + id);
    }
}
#method_after
public static String getValidModelId(String id) throws IllegalArgumentException {
    // checking weather modelId contains the alphanumeric character or not.
    if (id.matches(".*[A-Za-z0-9].*")) {
        // replacing special characters with '_'
        id = id.replaceAll("[\\s\\/:*?\"\\[\\]<>|$@!#%&(){}';,]", "_");
        // remove leading and trailing underscore
        id = id.replaceAll("^_+|_+$", "");
        // replacing the consecutive underscores '_' to single _
        id = id.replaceAll("_+", "_");
        return id;
    } else {
        throw new IllegalArgumentException("Invalid model id " + id);
    }
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    String metaDataGenDir;
    String outputDir;
    try {
        validateMavenVersion();
        /*
             * For deleting the generated code in previous build.
             */
        outputDir = getDirectory(baseDir, outputDirectory);
        deleteDirectory(outputDir + SLASH + TEMP);
        deleteDirectory(outputDir + SLASH + YANG_RESOURCES);
        String searchDir = getDirectory(baseDir, yangFilesDir);
        // Get the code gen directory.
        codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Get the meta data gen directory.
        metaDataGenDir = outputDir + SLASH + DEFAULT_JAR_RES_PATH;
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Need to get dependent schema paths to give inter jar dependencies.
        List<Path> depSchemas = resolveInterJarDependencies(project, localRepository, remoteRepository, outputDir);
        // Create compiler param.
        DefaultYangCompilationParam.Builder bldr = DefaultYangCompilationParam.builder();
        bldr.setCodeGenDir(Paths.get(codeGenDir));
        bldr.setMetadataGenDir(Paths.get(metaDataGenDir));
        for (Path path : depSchemas) {
            bldr.addDependentSchema(path);
        }
        for (String file : getYangFiles(searchDir)) {
            bldr.addYangFile(Paths.get(file));
        }
        if (modelId != null) {
            bldr.setModelId(getValidModelId(modelId));
        } else {
            bldr.setModelId(getValidModelId(project.getArtifactId()));
        }
        // Compile yang files and generate java code.
        output = compiler.compileYangFiles(bldr.build());
        addToCompilationRoot(codeGenDir, project, context);
        addToProjectResource(outputDir + SLASH + TEMP + SLASH, project);
    } catch (YangCompilerException e) {
        String fileName = EMPTY_STRING;
        if (e.getYangFile() != null) {
            fileName = e.getYangFile().toString();
        }
        try {
            deleteDirectory(codeGenDir + getPackageDirPathFromJavaJPackage(DEFAULT_BASE_PKG));
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        getLog().info(e.getCause());
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + IN + fileName + " YANG file.");
    } catch (IOException e) {
        throw new MojoExecutionException("Failed to process files");
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    String metaDataGenDir;
    String outputDir;
    try {
        validateMavenVersion();
        /*
             * For deleting the generated code in previous build.
             */
        outputDir = getDirectory(baseDir, outputDirectory);
        deleteDirectory(outputDir + SLASH + TEMP);
        deleteDirectory(outputDir + SLASH + YANG_RESOURCES);
        String searchDir = getDirectory(baseDir, yangFilesDir);
        // Get the code gen directory.
        codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Get the meta data gen directory.
        metaDataGenDir = outputDir + SLASH + DEFAULT_JAR_RES_PATH;
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Need to get dependent schema paths to give inter jar dependencies.
        List<Path> depSchemas = resolveInterJarDependencies(project, localRepository, remoteRepository, outputDir);
        // Create compiler param.
        DefaultYangCompilationParam.Builder bldr = DefaultYangCompilationParam.builder();
        bldr.setCodeGenDir(Paths.get(codeGenDir));
        bldr.setMetadataGenDir(Paths.get(metaDataGenDir));
        for (Path path : depSchemas) {
            bldr.addDependentSchema(path);
        }
        for (String file : getYangFiles(searchDir)) {
            bldr.addYangFile(Paths.get(file));
        }
        if (modelId != null) {
            bldr.setModelId(getValidModelId(modelId));
        } else {
            bldr.setModelId(project.getArtifactId());
        }
        // Compile yang files and generate java code.
        output = compiler.compileYangFiles(bldr.build());
        addToCompilationRoot(codeGenDir, project, context);
        addToProjectResource(outputDir + SLASH + TEMP + SLASH, project);
    } catch (YangCompilerException e) {
        String fileName = EMPTY_STRING;
        if (e.getYangFile() != null) {
            fileName = e.getYangFile().toString();
        }
        try {
            deleteDirectory(codeGenDir + getPackageDirPathFromJavaJPackage(DEFAULT_BASE_PKG));
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        getLog().info(e.getCause());
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + IN + fileName + " YANG file.");
    } catch (IOException e) {
        throw new MojoExecutionException("Failed to process files");
    }
}
#end_block

#method_before
public int bytes() {
    return txBytes;
}
#method_after
public long bytes() {
    return txBytes;
}
#end_block

#method_before
public int packets() {
    return txPackets;
}
#method_after
public long packets() {
    return txPackets;
}
#end_block

#method_before
protected DriverHandler getDriver(DeviceId devId) {
    Driver driver = driverService.getDriver(devId);
    DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, devId));
    return handler;
}
#method_after
protected DriverHandler getDriver(DeviceId deviceId) {
    Driver driver = driverService.getDriver(deviceId);
    DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
    return handler;
}
#end_block

#method_before
protected DriverHandler getDriver(DeviceId devId) {
    log.info("running getDriver for {}", devId);
    Driver driver = driverService.getDriver("ovs");
    DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, devId));
    return handler;
}
#method_after
protected DriverHandler getDriver(DeviceId devId) {
    log.debug("calling getDriver for {}", devId);
    Driver driver = driverService.getDriver(DRIVER_NAME);
    DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driver, devId));
    return handler;
}
#end_block

#method_before
public static DefaultOFSwitch of(DatapathId dpid, OFSwitchCapabilities capabilities, NetworkId networkId, DeviceId deviceId, ServiceDirectory serviceDirectory) {
    checkNotNull(dpid, "DPID cannot be null");
    checkNotNull(capabilities, "OF capabilities cannot be null");
    VirtualNetworkService virtualNetworkService = serviceDirectory.get(VirtualNetworkService.class);
    return new DefaultOFSwitch(dpid, capabilities, networkId, deviceId, serviceDirectory.get(OFSwitchService.class), serviceDirectory.get(DriverService.class), virtualNetworkService.get(networkId, FlowRuleService.class));
}
#method_after
public static DefaultOFSwitch of(DatapathId dpid, OFSwitchCapabilities capabilities, NetworkId networkId, DeviceId deviceId, ServiceDirectory serviceDirectory) {
    checkNotNull(dpid, "DPID cannot be null");
    checkNotNull(capabilities, "OF capabilities cannot be null");
    return new DefaultOFSwitch(dpid, capabilities, networkId, deviceId, serviceDirectory);
}
#end_block

#method_before
@Override
public void processControllerCommand(Channel channel, OFMessage msg) {
    OFControllerRole myRole = role(channel);
    if (myRole.equals(OFControllerRole.ROLE_SLAVE)) {
        OFBadRequestErrorMsg errorMsg = FACTORY.errorMsgs().buildBadRequestErrorMsg().setXid(msg.getXid()).setCode(OFBadRequestCode.IS_SLAVE).build();
        channel.writeAndFlush(Collections.singletonList(errorMsg));
        return;
    }
    switch(msg.getType()) {
        case PORT_MOD:
            OFPortMod portMod = (OFPortMod) msg;
            processPortMod(portMod);
            break;
        case FLOW_MOD:
            OFFlowMod flowMod = (OFFlowMod) msg;
            processFlowMod(flowMod);
            break;
        case GROUP_MOD:
        case METER_MOD:
        case TABLE_MOD:
            log.debug("processControllerCommand: {} not yet supported for {}", msg.getType(), msg);
            break;
        default:
            log.warn("Unexpected message {} received for switch {}", msg.getType(), this);
    }
// TODO process controller command
}
#method_after
@Override
public void processControllerCommand(Channel channel, OFMessage msg) {
    OFControllerRole myRole = role(channel);
    if (OFControllerRole.ROLE_SLAVE.equals(myRole)) {
        OFBadRequestErrorMsg errorMsg = FACTORY.errorMsgs().buildBadRequestErrorMsg().setXid(msg.getXid()).setCode(OFBadRequestCode.IS_SLAVE).build();
        channel.writeAndFlush(Collections.singletonList(errorMsg));
        return;
    }
    switch(msg.getType()) {
        case PORT_MOD:
            OFPortMod portMod = (OFPortMod) msg;
            processPortMod(portMod);
            break;
        case FLOW_MOD:
            OFFlowMod flowMod = (OFFlowMod) msg;
            processFlowMod(flowMod);
            break;
        case GROUP_MOD:
        case METER_MOD:
        case TABLE_MOD:
            log.debug("processControllerCommand: {} not yet supported for {}", msg.getType(), msg);
            break;
        default:
            log.warn("Unexpected message {} received for switch {}", msg.getType(), this);
    }
}
#end_block

#method_before
public static Builder addDataNode(Builder builder, String name, String namespace, String value, DataNode.Type type) {
    try {
        Object valObject;
        SchemaContext node;
        ExtResourceIdBldr rIdBldr;
        HelperContext nodeInfo;
        boolean initWithRId = false;
        HelperContext info = (HelperContext) builder.appInfo();
        ExtResourceIdBldr curBldr = info.getResourceIdBuilder();
        if (curBldr != null) {
            rIdBldr = info.getResourceIdBuilder();
            node = (SchemaContext) rIdBldr.appInfo();
            nodeInfo = new HelperContext();
            initWithRId = true;
        } else {
            // If data node is initialized by resource id.
            node = (SchemaContext) info.getParentResourceIdBldr().appInfo();
            rIdBldr = info.getParentResourceIdBldr();
            nodeInfo = info;
        }
        SchemaContext childSchema = getChildSchemaContext(node, name, namespace);
        DataNode.Type nodeType = childSchema.getType();
        if (type != null && !nodeType.equals(type)) {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
        }
        // Updating the namespace
        namespace = childSchema.getSchemaId().namespace();
        updateResourceId(rIdBldr, name, value, childSchema, nodeType);
        if (!initWithRId) {
            // also handle list without key leaf scenario.
            switch(nodeType) {
                case SINGLE_INSTANCE_LEAF_VALUE_NODE:
                    if (((YangLeaf) childSchema).isKeyLeaf()) {
                        throw new IllegalArgumentException(E_RESID);
                    }
                    valObject = getLeafValueObject(value, childSchema);
                    builder = LeafNode.builder(name, namespace).type(nodeType).value(valObject);
                    break;
                case MULTI_INSTANCE_LEAF_VALUE_NODE:
                    valObject = getLeafListValueObject(value, childSchema);
                    builder = LeafNode.builder(name, namespace).type(nodeType).value(valObject);
                    builder = builder.addLeafListValue(valObject);
                    break;
                default:
                    /*
                     * Can't update the node key in dummy data node as
                     * keybuilder will be initialized only once when
                     * InnerNode.builder call is made with name and namespace.
                     */
                    builder = InnerNode.builder(name, namespace).type(nodeType);
                    break;
            }
        } else {
            switch(nodeType) {
                case SINGLE_INSTANCE_LEAF_VALUE_NODE:
                    valObject = getLeafValueObject(value, childSchema);
                    if (((YangLeaf) childSchema).isKeyLeaf()) {
                        builder = builder.addKeyLeaf(name, namespace, valObject);
                    }
                    builder = builder.createChildBuilder(name, namespace, valObject).type(nodeType);
                    break;
                case MULTI_INSTANCE_LEAF_VALUE_NODE:
                    valObject = getLeafListValueObject(value, childSchema);
                    builder = builder.createChildBuilder(name, namespace, valObject).type(nodeType);
                    builder = builder.addLeafListValue(valObject);
                    break;
                default:
                    builder = builder.createChildBuilder(name, namespace).type(nodeType);
            }
        }
        nodeInfo.setResourceIdBuilder(rIdBldr);
        builder.appInfo(nodeInfo);
    } catch (IllegalArgumentException | DataModelException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return builder;
}
#method_after
public static Builder addDataNode(Builder builder, String name, String namespace, String value, DataNode.Type type) {
    try {
        Object valObject;
        SchemaContext node;
        ExtResourceIdBldr rIdBldr;
        HelperContext nodeInfo;
        boolean initWithRId = false;
        HelperContext info = (HelperContext) builder.appInfo();
        ExtResourceIdBldr curBldr = info.getResourceIdBuilder();
        if (curBldr != null) {
            rIdBldr = info.getResourceIdBuilder();
            node = (SchemaContext) rIdBldr.appInfo();
            nodeInfo = new HelperContext();
            initWithRId = true;
        } else {
            // If data node is initialized by resource id.
            node = (SchemaContext) info.getParentResourceIdBldr().appInfo();
            rIdBldr = info.getParentResourceIdBldr();
            nodeInfo = info;
        }
        SchemaContext childSchema = getChildSchemaContext(node, name, namespace);
        DataNode.Type nodeType = childSchema.getType();
        if (type != null && !nodeType.equals(type)) {
            throw new IllegalArgumentException(errorMsg(FMT_NOT_EXIST, name));
        }
        // Updating the namespace
        namespace = childSchema.getSchemaId().namespace();
        updateResourceId(rIdBldr, name, value, childSchema, nodeType);
        if (!initWithRId) {
            // also handle list without key leaf scenario.
            switch(nodeType) {
                case SINGLE_INSTANCE_LEAF_VALUE_NODE:
                    if (((YangLeaf) childSchema).isKeyLeaf()) {
                        throw new IllegalArgumentException(E_RESID);
                    }
                    valObject = getLeaf(value, childSchema);
                    builder = LeafNode.builder(name, namespace).type(nodeType).value(valObject);
                    break;
                case MULTI_INSTANCE_LEAF_VALUE_NODE:
                    valObject = getLeafList(value, childSchema);
                    builder = LeafNode.builder(name, namespace).type(nodeType).value(valObject);
                    builder = builder.addLeafListValue(valObject);
                    break;
                default:
                    /*
                     * Can't update the node key in dummy data node as
                     * keybuilder will be initialized only once when
                     * InnerNode.builder call is made with name and namespace.
                     */
                    builder = InnerNode.builder(name, namespace).type(nodeType);
                    break;
            }
        } else {
            switch(nodeType) {
                case SINGLE_INSTANCE_LEAF_VALUE_NODE:
                    valObject = getLeaf(value, childSchema);
                    if (((YangLeaf) childSchema).isKeyLeaf()) {
                        builder = builder.addKeyLeaf(name, namespace, valObject);
                    }
                    builder = builder.createChildBuilder(name, namespace, valObject).type(nodeType);
                    break;
                case MULTI_INSTANCE_LEAF_VALUE_NODE:
                    valObject = getLeafList(value, childSchema);
                    builder = builder.createChildBuilder(name, namespace, valObject).type(nodeType);
                    builder = builder.addLeafListValue(valObject);
                    break;
                default:
                    builder = builder.createChildBuilder(name, namespace).type(nodeType);
            }
        }
        nodeInfo.setResourceIdBuilder(rIdBldr);
        builder.appInfo(nodeInfo);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(e.getMessage());
    }
    return builder;
}
#end_block

#method_before
private void connectDevice(DeviceId deviceId) {
    // retrieve the configuration
    GeneralProviderDeviceConfig providerConfig = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class);
    BasicDeviceConfig basicDeviceConfig = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
    if (providerConfig == null || basicDeviceConfig == null) {
        log.error("Configuration is NULL: basic config {}, general provider " + "config {}", basicDeviceConfig, providerConfig);
    } else {
        log.info("Connecting to device {} with driver {}", deviceId, basicDeviceConfig.driver());
        Driver driver = driverService.getDriver(basicDeviceConfig.driver());
        DriverData driverData = new DefaultDriverData(driver, deviceId);
        DeviceHandshaker handshaker = getBehaviour(driver, DeviceHandshaker.class, driverData);
        if (handshaker == null) {
            log.error("Device {}, with driver {} does not support DeviceHandshaker " + "behaviour, {}", deviceId, driver.name(), driver.behaviours());
            return;
        }
        // Storing deviceKeyId and all other config values
        // as data in the driver with protocol_<info>
        // name as the key. e.g protocol_ip
        providerConfig.protocolsInfo().forEach((protocol, deviceInfoConfig) -> {
            deviceInfoConfig.configValues().forEach((k, v) -> driverData.set(protocol + "_" + k, v));
            driverData.set(protocol + "_key", deviceInfoConfig.deviceKeyId());
        });
        // Connecting to the device
        CompletableFuture<Boolean> connected = handshaker.connect();
        connected.thenAcceptAsync(result -> {
            if (result) {
                // Populated with the default values obtained by the driver
                ChassisId cid = new ChassisId();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, providerConfig.protocolsInfo().keySet().toString()).build();
                DeviceDescription description = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, driver.manufacturer(), driver.hwVersion(), driver.swVersion(), UNKNOWN, cid, false, annotations);
                // Empty list of ports
                List<PortDescription> ports = new ArrayList<>();
                if (driver.hasBehaviour(DeviceDescriptionDiscovery.class)) {
                    DeviceDescriptionDiscovery deviceDiscovery = driver.createBehaviour(driverData, DeviceDescriptionDiscovery.class);
                    DeviceDescription newdescription = deviceDiscovery.discoverDeviceDetails();
                    if (newdescription != null) {
                        description = newdescription;
                    }
                    ports = deviceDiscovery.discoverPortDetails();
                }
                if (!handlePipeconf(deviceId, driver, driverData)) {
                    // Something went wrong during handling of pipeconf.
                    // We already logged the error.
                    handshaker.disconnect();
                    return;
                }
                advertiseDevice(deviceId, description, ports);
            } else {
                log.warn("Can't connect to device {}", deviceId);
            }
        });
    }
}
#method_after
private void connectDevice(DeviceId deviceId) {
    // retrieve the configuration
    GeneralProviderDeviceConfig providerConfig = cfgService.getConfig(deviceId, GeneralProviderDeviceConfig.class);
    BasicDeviceConfig basicDeviceConfig = cfgService.getConfig(deviceId, BasicDeviceConfig.class);
    if (providerConfig == null || basicDeviceConfig == null) {
        log.error("Configuration is NULL: basic config {}, general provider " + "config {}", basicDeviceConfig, providerConfig);
    } else {
        log.info("Connecting to device {} with driver {}", deviceId, basicDeviceConfig.driver());
        Driver driver;
        try {
            driver = driverService.getDriver(basicDeviceConfig.driver());
        } catch (ItemNotFoundException e) {
            log.warn("The driver of {} is not found : {}", deviceId, e.getMessage());
            return;
        }
        DriverData driverData = new DefaultDriverData(driver, deviceId);
        DeviceHandshaker handshaker = getBehaviour(driver, DeviceHandshaker.class, driverData);
        if (handshaker == null) {
            log.error("Device {}, with driver {} does not support DeviceHandshaker " + "behaviour, {}", deviceId, driver.name(), driver.behaviours());
            return;
        }
        // Storing deviceKeyId and all other config values
        // as data in the driver with protocol_<info>
        // name as the key. e.g protocol_ip
        providerConfig.protocolsInfo().forEach((protocol, deviceInfoConfig) -> {
            deviceInfoConfig.configValues().forEach((k, v) -> driverData.set(protocol + "_" + k, v));
            driverData.set(protocol + "_key", deviceInfoConfig.deviceKeyId());
        });
        // Connecting to the device
        CompletableFuture<Boolean> connected = handshaker.connect();
        connected.thenAcceptAsync(result -> {
            if (result) {
                // Populated with the default values obtained by the driver
                ChassisId cid = new ChassisId();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, providerConfig.protocolsInfo().keySet().toString()).build();
                DeviceDescription description = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, driver.manufacturer(), driver.hwVersion(), driver.swVersion(), UNKNOWN, cid, false, annotations);
                // Empty list of ports
                List<PortDescription> ports = new ArrayList<>();
                if (driver.hasBehaviour(DeviceDescriptionDiscovery.class)) {
                    DeviceDescriptionDiscovery deviceDiscovery = driver.createBehaviour(driverData, DeviceDescriptionDiscovery.class);
                    DeviceDescription newdescription = deviceDiscovery.discoverDeviceDetails();
                    if (newdescription != null) {
                        description = newdescription;
                    }
                    ports = deviceDiscovery.discoverPortDetails();
                }
                if (!handlePipeconf(deviceId, driver, driverData)) {
                    // Something went wrong during handling of pipeconf.
                    // We already logged the error.
                    handshaker.disconnect();
                    return;
                }
                advertiseDevice(deviceId, description, ports);
            } else {
                log.warn("Can't connect to device {}", deviceId);
            }
        });
    }
}
#end_block

#method_before
private void updatePortStatistics(DeviceId deviceId) {
    Collection<PortStatistics> statistics = deviceService.getDevice(deviceId).as(PortStatisticsDiscovery.class).discoverPortStatistics();
    // updating statistcs only if not empty
    if (!statistics.isEmpty()) {
        providerService.updatePortStatistics(deviceId, statistics);
    }
}
#method_after
private void updatePortStatistics(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (!Objects.isNull(device) && deviceService.isAvailable(deviceId) && device.is(PortStatisticsDiscovery.class)) {
        Collection<PortStatistics> statistics = device.as(PortStatisticsDiscovery.class).discoverPortStatistics();
        // updating statistcs only if not empty
        if (!statistics.isEmpty()) {
            providerService.updatePortStatistics(deviceId, statistics);
        }
    } else {
        log.debug("Can't update port statistics for device {}", deviceId);
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Type type = event.type();
    DeviceId deviceId = event.subject().id();
    if (type.equals((Type.DEVICE_ADDED))) {
        // be available we check and base it on the streaming API (e.g. gNMI)
        if (deviceService.getDevice(deviceId).is(PortStatisticsDiscovery.class)) {
            scheduledTasks.put(event.subject().id(), schedulePolling(event.subject().id(), false));
            updatePortStatistics(event.subject().id());
        }
    } else if (type.equals(Type.DEVICE_AVAILABILITY_CHANGED)) {
        if (deviceService.getDevice(deviceId) != null || !deviceService.isAvailable(deviceId)) {
            ScheduledFuture<?> pollingStatisticsTask = scheduledTasks.get(deviceId);
            if (pollingStatisticsTask != null) {
                pollingStatisticsTask.cancel(true);
            }
        }
    } else if (type.equals(Type.DEVICE_REMOVED)) {
        connectionExecutor.submit(exceptionSafe(() -> disconnectDevice(deviceId)));
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Type type = event.type();
    DeviceId deviceId = event.subject().id();
    if (type.equals((Type.DEVICE_ADDED))) {
        // For now this is scheduled periodically, when streaming API will
        // be available we check and base it on the streaming API (e.g. gNMI)
        scheduledTasks.put(deviceId, schedulePolling(deviceId, false));
        updatePortStatistics(deviceId);
    } else if (type.equals(Type.DEVICE_REMOVED)) {
        connectionExecutor.submit(exceptionSafe(() -> disconnectDevice(deviceId)));
    }
}
#end_block

#method_before
@Override
public void enterAnydataStatement(AnydataStatementContext ctx) {
// TODO to be implemented
}
#method_after
@Override
public void enterAnydataStatement(AnydataStatementContext ctx) {
    AnydataListener.processAnydataEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitAnydataStatement(AnydataStatementContext ctx) {
// TODO to be implemented
}
#method_after
@Override
public void exitAnydataStatement(AnydataStatementContext ctx) {
    AnydataListener.processAnydataExit(this, ctx);
}
#end_block

