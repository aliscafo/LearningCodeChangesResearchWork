581
#method_before
@Test
public void testGetAllForEntity() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID);
    assertGetllForEntityResult(result);
}
#method_after
@Test
public void testGetAllForEntity() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID);
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForEntityFilteredWithPermissions() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID, PRIVILEGED_USER_ID, true);
    assertGetllForEntityResult(result);
}
#method_after
@Test
public void testGetAllForEntityFilteredWithPermissions() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID, PRIVILEGED_USER_ID, true);
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForEntityFilteredWithNoPermissionsFilteringDisabled() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID, UNPRIVILEGED_USER_ID, false);
    assertGetllForEntityResult(result);
}
#method_after
@Test
public void testGetAllForEntityFilteredWithNoPermissionsFilteringDisabled() {
    List<permissions> result = dao.getAllForEntity(VM_ENTITY_ID, UNPRIVILEGED_USER_ID, false);
    assertGetAllForEntityResult(result);
}
#end_block

#method_before
public void Edit() {
    VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ClusterModel model = new ClusterModel();
    model.setEntity(cluster);
    model.Init(true, getGlusterModeEnum());
    setWindow(model);
    model.setTitle("Edit Cluster");
    model.setHashName("edit_cluster");
    model.setOriginalName(cluster.getname());
    model.getName().setEntity(cluster.getname());
    model.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        model.getName().setIsChangable(false);
        model.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle("OK");
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle("Cancel");
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ClusterModel model = new ClusterModel();
    model.setEntity(cluster);
    model.Init(true, getGlusterModeEnum());
    setWindow(model);
    model.setTitle("Edit Cluster");
    model.setHashName("edit_cluster");
    model.setOriginalName(cluster.getname());
    model.getName().setEntity(cluster.getname());
    model.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(model);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            java.util.ArrayList<GlusterVolumeEntity> volumes = (java.util.ArrayList<GlusterVolumeEntity>) result;
            if (volumes.size() != 0) {
                if (cluster.supportsGlusterService()) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
        }
    };
    AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        model.getName().setIsChangable(false);
        model.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle("OK");
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle("Cancel");
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void OnSaveInternal() {
    ClusterModel model = (ClusterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // cancel confirm window if there is
    CancelConfirmation();
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setstorage_pool_id(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setVirtService(true);
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            localModel.PostOnSaveInternal(result.getReturnValue());
        }
    }, this);
}
#method_after
public void OnSaveInternal() {
    ClusterModel model = (ClusterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // cancel confirm window if there is
    CancelConfirmation();
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setstorage_pool_id(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            localModel.PostOnSaveInternal(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
@Override
public DevicesResource<Disk, Disks> getDisksResource() {
    return inject(new BackendDisksResource(guid, VdcQueryType.GetAllDisksByVmId, new GetAllDisksByVmIdParameters(guid)));
}
#method_after
@Override
public DisksResource getDisksResource() {
    return inject(new BackendDisksResource(guid, VdcQueryType.GetAllDisksByVmId, new GetAllDisksByVmIdParameters(guid)));
}
#end_block

#method_before
@Override
public BackendVmNicsResource getNicsResource() {
    return inject(new BackendVmNicsResource(guid));
}
#method_after
@Override
public VmNicsResource getNicsResource() {
    return inject(new BackendVmNicsResource(guid));
}
#end_block

#method_before
@Override
public Response activate(Action action) {
    HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(((BackendDisksResource) collection).parentId, Guid.createGuidFromString(id));
    return performAction(VdcActionType.HotPlugDiskToVm, params);
}
#method_after
@Override
public Response activate(Action action) {
    HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(((BackendDisksResource) collection).parentId, guid);
    return performAction(VdcActionType.HotPlugDiskToVm, params);
}
#end_block

#method_before
@Override
public Response deactivate(Action action) {
    HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(((BackendDisksResource) collection).parentId, Guid.createGuidFromString(id));
    return performAction(VdcActionType.HotUnPlugDiskFromVm, params);
}
#method_after
@Override
public Response deactivate(Action action) {
    HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(((BackendDisksResource) collection).parentId, guid);
    return performAction(VdcActionType.HotUnPlugDiskFromVm, params);
}
#end_block

#method_before
@Override
protected void ExecuteVdsIdCommand() {
    if (_vdsManager != null) {
        final DestroyVmVDSCommandParameters parameters = getParameters();
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        final VM curVm = DbFacade.getInstance().getVmDAO().get(parameters.getVmId());
        // TODO: This is done to keep consistency with VmDAO.getById(Guid).
        // It should probably be removed, but some research is required.
        curVm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(curVm.getId()));
        DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(parameters);
        vdsBrokerCommand.Execute();
        if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
            if (curVm.getstatus() == VMStatus.Down) {
                getVDSReturnValue().setReturnValue(VMStatus.Down);
            }
            // Updating the DB
            ResourceManager.getInstance().InternalSetVmStatus(curVm, parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        curVm.guestLogoutTimeTreatmentAfterDestroy();
                        // SaveVmDynamicToDBThreaded(curVm);
                        DbFacade.getInstance().getVmDynamicDAO().update(curVm.getDynamicData());
                        DbFacade.getInstance().getVmStatisticsDAO().update(curVm.getStatisticsData());
                        List<VmNetworkInterface> interfaces = curVm.getInterfaces();
                        if (interfaces != null && interfaces.size() > 0) {
                            for (VmNetworkInterface ifc : interfaces) {
                                VmNetworkStatistics stats = ifc.getStatistics();
                                DbFacade.getInstance().getVmNetworkStatisticsDAO().update(stats);
                            }
                        }
                        // will not be called from UpdateRunTimeInfo
                        if (!parameters.getGracefully()) {
                            ResourceManager.getInstance().getEventListener().processOnVmStop(curVm.getId());
                        }
                    } catch (RepositoryException ex) {
                        log.errorFormat("VDS::destroy Failed to update vds status in database,  vds = {1} : {2}, error = {3}", getVds().getId(), getVds().getvds_name(), ex.getMessage());
                        log.error("Exception: ", ex);
                        throw ex;
                    }
                    getVds().setmem_commited(getVds().getmem_commited() - curVm.getvm_mem_size_mb());
                    getVds().setmem_commited(getVds().getmem_commited() - getVds().getguest_overhead());
                    getVds().setvms_cores_count(getVds().getvms_cores_count() - curVm.getnum_of_cpus());
                    _vdsManager.UpdateDynamicData(getVds().getDynamicData());
                    return null;
                }
            });
            getVDSReturnValue().setReturnValue(curVm.getstatus());
        } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
            log.errorFormat("VDS::destroy Failed destroying vm '{0}' in vds = {1} : {2}, error = {3}", parameters.getVmId(), getVds().getId(), getVds().getvds_name(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setExceptionString(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsBrokerCommand.getVDSReturnValue().getExceptionObject());
            getVDSReturnValue().setVdsError(vdsBrokerCommand.getVDSReturnValue().getVdsError());
        }
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#method_after
@Override
protected void ExecuteVdsIdCommand() {
    if (_vdsManager != null) {
        final DestroyVmVDSCommandParameters parameters = getParameters();
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        final VM curVm = DbFacade.getInstance().getVmDAO().get(parameters.getVmId());
        curVm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(curVm.getId()));
        DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(parameters);
        vdsBrokerCommand.Execute();
        if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
            if (curVm.getstatus() == VMStatus.Down) {
                getVDSReturnValue().setReturnValue(VMStatus.Down);
            }
            // Updating the DB
            ResourceManager.getInstance().InternalSetVmStatus(curVm, parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        curVm.guestLogoutTimeTreatmentAfterDestroy();
                        // SaveVmDynamicToDBThreaded(curVm);
                        DbFacade.getInstance().getVmDynamicDAO().update(curVm.getDynamicData());
                        DbFacade.getInstance().getVmStatisticsDAO().update(curVm.getStatisticsData());
                        List<VmNetworkInterface> interfaces = curVm.getInterfaces();
                        if (interfaces != null && interfaces.size() > 0) {
                            for (VmNetworkInterface ifc : interfaces) {
                                VmNetworkStatistics stats = ifc.getStatistics();
                                DbFacade.getInstance().getVmNetworkStatisticsDAO().update(stats);
                            }
                        }
                        // will not be called from UpdateRunTimeInfo
                        if (!parameters.getGracefully()) {
                            ResourceManager.getInstance().getEventListener().processOnVmStop(curVm.getId());
                        }
                    } catch (RepositoryException ex) {
                        log.errorFormat("VDS::destroy Failed to update vds status in database,  vds = {1} : {2}, error = {3}", getVds().getId(), getVds().getvds_name(), ex.getMessage());
                        log.error("Exception: ", ex);
                        throw ex;
                    }
                    getVds().setmem_commited(getVds().getmem_commited() - curVm.getvm_mem_size_mb());
                    getVds().setmem_commited(getVds().getmem_commited() - getVds().getguest_overhead());
                    getVds().setvms_cores_count(getVds().getvms_cores_count() - curVm.getnum_of_cpus());
                    _vdsManager.UpdateDynamicData(getVds().getDynamicData());
                    return null;
                }
            });
            getVDSReturnValue().setReturnValue(curVm.getstatus());
        } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
            log.errorFormat("VDS::destroy Failed destroying vm '{0}' in vds = {1} : {2}, error = {3}", parameters.getVmId(), getVds().getId(), getVds().getvds_name(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setExceptionString(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsBrokerCommand.getVDSReturnValue().getExceptionObject());
            getVDSReturnValue().setVdsError(vdsBrokerCommand.getVDSReturnValue().getVdsError());
        }
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    initializeObjectState();
    // Since 'VmId' is overriden, 'Vm' should be retrieved manually.
    VM vm = DbFacade.getInstance().getVmDAO().get(getVmId());
    if (vm != null) {
        // TODO: This is done to be consistent with the behavior of VMDAO.getById.
        // It's probably redundant, but some research is required to validate this.
        VmHandler.updateNetworkInterfacesFromDb(vm);
    }
    setVm(vm);
    getReturnValue().setCanDoAction(validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())));
    if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, true, true, true, null)) {
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the template
    if (DbFacade.getInstance().getVmTemplateDAO().get(getSourceImages().get(0).getId()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the vm working snapshot
    if (DbFacade.getInstance().getDiskImageDAO().get(getSourceImages().get(0).getId()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_ACTIVE_IMAGE);
        getReturnValue().setCanDoAction(false);
    }
    if (!getReturnValue().getCanDoAction()) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    }
    return getReturnValue().getCanDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    initializeObjectState();
    // Since 'VmId' is overriden, 'Vm' should be retrieved manually.
    setVm(DbFacade.getInstance().getVmDAO().get(getVmId()));
    getReturnValue().setCanDoAction(validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())));
    if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, true, true, true, null)) {
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the template
    if (DbFacade.getInstance().getVmTemplateDAO().get(getSourceImages().get(0).getId()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the vm working snapshot
    if (DbFacade.getInstance().getDiskImageDAO().get(getSourceImages().get(0).getId()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_ACTIVE_IMAGE);
        getReturnValue().setCanDoAction(false);
    }
    if (!getReturnValue().getCanDoAction()) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    }
    return getReturnValue().getCanDoAction();
}
#end_block

#method_before
@Override
protected void ExecuteVdsIdCommand() {
    MigrateVDSCommandParameters parameters = getParameters();
    if (_vdsManager != null) {
        VMStatus retval;
        MigrateBrokerVDSCommand<MigrateVDSCommandParameters> command = new MigrateBrokerVDSCommand<MigrateVDSCommandParameters>(parameters);
        command.Execute();
        VDSReturnValue vdsReturnValue = command.getVDSReturnValue();
        if (vdsReturnValue.getSucceeded()) {
            retval = VMStatus.MigratingFrom;
        } else {
            log.error("VDS::migrate:: Failed migration setting vm status to ERROR");
            retval = VMStatus.NotResponding;
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
            getVDSReturnValue().setExceptionString(vdsReturnValue.getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsReturnValue.getExceptionObject());
        }
        // update the db
        // VM vm = _vdsManager.VmDict[parameters.VmId];
        final VM vm = DbFacade.getInstance().getVmDAO().get(parameters.getVmId());
        // TODO: This is done to keep consistency with VmDAO.getById(Guid).
        // It should probably be removed, but some research is required.
        vm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()));
        ResourceManager.getInstance().InternalSetVmStatus(vm, retval);
        if (retval == VMStatus.MigratingFrom) {
            vm.setmigrating_to_vds(parameters.getDstVdsId());
            // get vdsEventListener from callback channel (if wcf-user backend) or resource manager
            if (ResourceManager.getInstance().getBackendCallback() != null) {
                ResourceManager.getInstance().AddAsyncRunningVm(parameters.getVmId(), ResourceManager.getInstance().getBackendCallback());
            }
        }
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                DbFacade.getInstance().getVmDynamicDAO().update(vm.getDynamicData());
                return null;
            }
        });
        if (retval == VMStatus.MigratingFrom) {
            UpdateDestinationVdsThreaded(parameters.getDstVdsId(), vm);
        }
        getVDSReturnValue().setReturnValue(retval);
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#method_after
@Override
protected void ExecuteVdsIdCommand() {
    MigrateVDSCommandParameters parameters = getParameters();
    if (_vdsManager != null) {
        VMStatus retval;
        MigrateBrokerVDSCommand<MigrateVDSCommandParameters> command = new MigrateBrokerVDSCommand<MigrateVDSCommandParameters>(parameters);
        command.Execute();
        VDSReturnValue vdsReturnValue = command.getVDSReturnValue();
        if (vdsReturnValue.getSucceeded()) {
            retval = VMStatus.MigratingFrom;
        } else {
            log.error("VDS::migrate:: Failed migration setting vm status to ERROR");
            retval = VMStatus.NotResponding;
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
            getVDSReturnValue().setExceptionString(vdsReturnValue.getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsReturnValue.getExceptionObject());
        }
        // update the db
        // VM vm = _vdsManager.VmDict[parameters.VmId];
        final VM vm = DbFacade.getInstance().getVmDAO().get(parameters.getVmId());
        ResourceManager.getInstance().InternalSetVmStatus(vm, retval);
        if (retval == VMStatus.MigratingFrom) {
            vm.setmigrating_to_vds(parameters.getDstVdsId());
            // get vdsEventListener from callback channel (if wcf-user backend) or resource manager
            if (ResourceManager.getInstance().getBackendCallback() != null) {
                ResourceManager.getInstance().AddAsyncRunningVm(parameters.getVmId(), ResourceManager.getInstance().getBackendCallback());
            }
        }
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                DbFacade.getInstance().getVmDynamicDAO().update(vm.getDynamicData());
                return null;
            }
        });
        if (retval == VMStatus.MigratingFrom) {
            UpdateDestinationVdsThreaded(parameters.getDstVdsId(), vm);
        }
        getVDSReturnValue().setReturnValue(retval);
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllForDedicatedPowerClientByVds(getVdsId());
    if (vms != null && vms.size() != 0) {
        vms.get(0).setdedicated_vm_for_vds(null);
        DbFacade.getInstance().getVmStaticDAO().update(vms.get(0).getStaticData());
    }
    VM vm = DbFacade.getInstance().getVmDAO().get(getVmId());
    // TODO: This is done to keep consistency with VmDAO.getById(Guid).
    // It should probably be removed, but some research is required.
    VmHandler.updateNetworkInterfacesFromDb(vm);
    vm.setdedicated_vm_for_vds(!(getVdsId().equals(Guid.Empty)) ? getVdsId() : null);
    DbFacade.getInstance().getVmStaticDAO().update(vm.getStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    List<VM> vms = getVmDAO().getAllForDedicatedPowerClientByVds(getVdsId());
    if (vms != null && vms.size() != 0) {
        vms.get(0).setdedicated_vm_for_vds(null);
        getVmStaticDAO().update(vms.get(0).getStaticData());
    }
    VM vm = getVmDAO().get(getVmId());
    vm.setdedicated_vm_for_vds(!(getVdsId().equals(Guid.Empty)) ? getVdsId() : null);
    getVmStaticDAO().update(vm.getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORK_MTU_DIFFER_FROM_LOGICAL_NETWORK, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getGlusterVolume().isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STOPPED);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!getGlusterVolume().isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STOPPED);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getGlusterVolume().isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STARTED);
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getGlusterVolume().isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STARTED);
        return false;
    }
    return true;
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORK_MTU_DIFFER_FROM_LOGICAL_NETWORK, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeStart(volumeName, force.toString()));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeStart(volumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
protected String callValidateSession(String sessionID) {
    try {
        // Formatting data
        String data = String.format(SESSION_DATA_FORMAT, URLEncoder.encode(sessionID, "UTF-8"));
        HttpURLConnection servletConnection = createURLConnection();
        if (servletConnection == null) {
            logger.error("Unable to create servlet connection.");
            return null;
        }
        // Sending the sessionID parameter
        DataOutputStream output = new DataOutputStream(servletConnection.getOutputStream());
        output.writeBytes(data);
        output.flush();
        output.close();
        // Checking the result
        if (servletConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
            logger.error("ValidateSession servlet returned " + servletConnection.getResponseCode());
            return null;
        }
        // Getting the user name
        InputStream inputStream = servletConnection.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String inputLine;
        inputLine = reader.readLine();
        return inputLine;
    } catch (MalformedURLException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (IOException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (CertificateException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (KeyStoreException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    } catch (KeyManagementException e) {
        e.printStackTrace();
        logger.error(e);
        return null;
    }
}
#method_after
protected String callValidateSession(String sessionID) {
    DataOutputStream output = null;
    try {
        // Formatting data
        String data = String.format(SESSION_DATA_FORMAT, URLEncoder.encode(sessionID, "UTF-8"));
        HttpURLConnection servletConnection = createURLConnection();
        if (servletConnection == null) {
            logger.error("Unable to create servlet connection.");
            return null;
        }
        // Sending the sessionID parameter
        output = new DataOutputStream(servletConnection.getOutputStream());
        output.writeBytes(data);
        output.flush();
        output.close();
        // Checking the result
        if (servletConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
            logger.error("ValidateSession servlet returned " + servletConnection.getResponseCode());
            return null;
        }
        // Getting the user name
        InputStream inputStream = servletConnection.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String inputLine;
        inputLine = reader.readLine();
        return inputLine;
    } catch (Exception ex) {
        logger.error(ex);
    } finally {
        try {
            if (output != null)
                output.close();
        } catch (IOException ex) {
            logger.error(ex);
        }
    }
    return null;
}
#end_block

#method_before
public UsernamePasswordAuthenticationToken getAuthRequest(HttpServletRequest request, String sessionID) {
    UsernamePasswordAuthenticationToken authRequest = null;
    if (sessionID != null) {
        String result = callValidateSession(sessionID);
        if (result == null) {
            return null;
        } else if (result.isEmpty()) {
            return null;
        }
        String userName = result;
        String password = "";
        userName = userName.trim();
        GrantedAuthority[] grantedAuthorities = new GrantedAuthority[1];
        grantedAuthorities[0] = new GrantedAuthorityImpl("ROLE_ADMINISTRATOR");
        Calendar recheckOn = Calendar.getInstance();
        recheckOn.setTime(new Date());
        recheckOn.add(Calendar.MINUTE, sessionTimeout);
        EngineUserDetails userDetails = new EngineUserDetails(userName, password, grantedAuthorities, sessionID, recheckOn, true, true, true, true);
        authRequest = new UsernamePasswordAuthenticationToken(userDetails, password, grantedAuthorities);
        setDetails(request, authRequest);
    }
    return authRequest;
}
#method_after
public UsernamePasswordAuthenticationToken getAuthRequest(HttpServletRequest request, String sessionID) {
    UsernamePasswordAuthenticationToken authRequest = null;
    if (sessionID != null) {
        String result = callValidateSession(sessionID);
        if (result == null) {
            return null;
        } else if (result.isEmpty()) {
            return null;
        }
        String userName = result;
        String password = "";
        userName = userName.trim();
        GrantedAuthority[] grantedAuthorities = new GrantedAuthority[1];
        grantedAuthorities[0] = new GrantedAuthorityImpl("ROLE_USER");
        Calendar recheckOn = Calendar.getInstance();
        recheckOn.setTime(new Date());
        recheckOn.add(Calendar.MINUTE, pollingTimeout);
        EngineUserDetails userDetails = new EngineUserDetails(userName, password, grantedAuthorities, sessionID, recheckOn, true, true, true, true);
        authRequest = new UsernamePasswordAuthenticationToken(userDetails, password, grantedAuthorities);
        setDetails(request, authRequest);
    }
    return authRequest;
}
#end_block

#method_before
private void updateDefaultQuota() {
    if (_oldStoragePool.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED) {
        RefObject<Boolean> reuseQuota = new RefObject<Boolean>(true);
        Quota newDefaultQuota = getQutoaHelper().getUnlimitedQuota(getStoragePool(), true, reuseQuota);
        if (reuseQuota.argvalue) {
            log.infoFormat("Reusing quota {0} as the default quota for Storage Pool {1}", newDefaultQuota.getId(), newDefaultQuota.getStoragePoolId());
        } else {
            newDefaultQuota.setQuotaName(getQutoaHelper().getDefaultQuotaName(getStoragePool()));
        }
        getQutoaHelper().saveQuotaForUser(newDefaultQuota, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, reuseQuota.argvalue);
    }
}
#method_after
private void updateDefaultQuota() {
    if (wasQuotaEnforcementDisabled()) {
        Pair<Quota, Boolean> defaultQuotaPair = getQutoaHelper().getUnlimitedQuota(getStoragePool(), true, true);
        Quota defaultQuota = defaultQuotaPair.getFirst();
        boolean isQuotaReused = defaultQuotaPair.getSecond();
        if (isQuotaReused) {
            log.debugFormat("Reusing quota {0} as the default quota for Storage Pool {1}", defaultQuota.getId(), defaultQuota.getStoragePoolId());
        } else {
            defaultQuota.setQuotaName(getQutoaHelper().getDefaultQuotaName(getStoragePool()));
        }
        getQutoaHelper().saveOrUpdateQuotaForUser(defaultQuota, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, isQuotaReused);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    returnValue = returnValue && isNotLocalfsWithDefaultCluster();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    returnValue = returnValue && isNotLocalfsWithDefaultCluster();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    returnValue = returnValue && isNotLocalfsWithDefaultCluster();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    returnValue = returnValue && isNotLocalfsWithDefaultCluster();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#end_block

#method_before
protected void spyCommand(StoragePoolManagementParameter params) {
    cmd = spy(new UpdateStoragePoolCommand<StoragePoolManagementParameter>(params));
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getcompatibility_version())).when(cmd).isVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(vdsDao).when(cmd).getVdsGroupDAO();
}
#method_after
protected void spyCommand(StoragePoolManagementParameter params) {
    cmd = spy(new UpdateStoragePoolCommand<StoragePoolManagementParameter>(params));
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getcompatibility_version())).when(cmd).isStoragePoolVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(vdsDao).when(cmd).getVdsGroupDAO();
}
#end_block

#method_before
protected Guid getMasterDomainIdFromDb() {
    if (getStoragePool() != null) {
        return DbFacade.getInstance().getStorageDomainDAO().getMasterStorageDomainIdForPool(getStoragePool().getId());
    }
    return Guid.Empty;
}
#method_after
protected Guid getMasterDomainIdFromDb() {
    Guid ret = Guid.Empty;
    if (getStoragePool() != null) {
        ret = DbFacade.getInstance().getStorageDomainDAO().getMasterStorageDomainIdForPool(getStoragePool().getId());
    }
    return ret;
}
#end_block

#method_before
protected void CalcStoragePoolStatusByDomainsStatus() {
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    storage_domains masterDomain = LinqUtils.firstOrNull(domains, new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains a) {
            return a.getstorage_domain_type() == StorageDomainType.Master;
        }
    });
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getstatus() != null && masterDomain.getstatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintanance : (masterDomain.getstatus() != null && masterDomain.getstatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.Problematic;
    if (newStatus != getStoragePool().getstatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setstatus(newStatus);
        storage_pool poolFromDb = DbFacade.getInstance().getStoragePoolDAO().get(getStoragePool().getId());
        if ((getStoragePool().getspm_vds_id() == null && poolFromDb.getspm_vds_id() != null) || (getStoragePool().getspm_vds_id() != null && !getStoragePool().getspm_vds_id().equals(poolFromDb.getspm_vds_id()))) {
            getStoragePool().setspm_vds_id(poolFromDb.getspm_vds_id());
        }
        if (getStoragePool().getstatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setspm_vds_id(null);
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<storage_pool>() {

            @Override
            public storage_pool runInTransaction() {
                DbFacade.getInstance().getStoragePoolDAO().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getstatus());
    }
}
#method_after
protected void CalcStoragePoolStatusByDomainsStatus() {
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    // set masterDomain to the first element of domains with type=master, or null if non have this type.
    storage_domains masterDomain = LinqUtils.firstOrNull(domains, new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains a) {
            return a.getstorage_domain_type() == StorageDomainType.Master;
        }
    });
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getstatus() != null && masterDomain.getstatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintanance : (masterDomain.getstatus() != null && masterDomain.getstatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.Problematic;
    if (newStatus != getStoragePool().getstatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setstatus(newStatus);
        storage_pool poolFromDb = DbFacade.getInstance().getStoragePoolDAO().get(getStoragePool().getId());
        if ((getStoragePool().getspm_vds_id() == null && poolFromDb.getspm_vds_id() != null) || (getStoragePool().getspm_vds_id() != null && !getStoragePool().getspm_vds_id().equals(poolFromDb.getspm_vds_id()))) {
            getStoragePool().setspm_vds_id(poolFromDb.getspm_vds_id());
        }
        if (getStoragePool().getstatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setspm_vds_id(null);
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<storage_pool>() {

            @Override
            public storage_pool runInTransaction() {
                DbFacade.getInstance().getStoragePoolDAO().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.PoolStatusChanged(getStoragePool().getId(), getStoragePool().getstatus());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (getQuotaDAO().getById(getParameters().getQuota().getId()) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!QuotaHelper.getInstance().checkQuotaValidationForEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (getQuotaDAO().getById(getParameters().getQuota().getId()) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return true;
}
#end_block

#method_before
private Quota generateUnlimitedQuota(storage_pool storagePool) {
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(storagePool.getId());
    quota.setQuotaName(getDefaultQuotaName(storagePool));
    quota.setDescription("Automatic generated Quota for Data Center " + storagePool.getname());
    quota.setThresholdVdsGroupPercentage(getIntegerConfig(ConfigValues.QuotaThresholdVdsGroup));
    quota.setThresholdStoragePercentage(getIntegerConfig(ConfigValues.QuotaThresholdStorage));
    quota.setGraceVdsGroupPercentage(getIntegerConfig(ConfigValues.QuotaGraceVdsGroup));
    quota.setGraceStoragePercentage(getIntegerConfig(ConfigValues.QuotaGraceStorage));
    quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>());
    quota.setQuotaStorages(new ArrayList<QuotaStorage>());
    // Set Quota storage capacity definition.
    QuotaStorage quotaStorage = new QuotaStorage();
    quotaStorage.setStorageSizeGB(UNLIMITED);
    quota.setGlobalQuotaStorage(quotaStorage);
    // Set Quota cluster virtual memory definition and virtual CPU definition.
    QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup();
    quotaVdsGroup.setVirtualCpu(UNLIMITED.intValue());
    quotaVdsGroup.setMemSizeMB(UNLIMITED);
    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
    return quota;
}
#method_after
private Quota generateUnlimitedQuota(storage_pool storagePool) {
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(storagePool.getId());
    quota.setQuotaName(getDefaultQuotaName(storagePool));
    quota.setDescription("Automatic generated Quota for Data Center " + storagePool.getname());
    quota.setThresholdVdsGroupPercentage(getQuotaThresholdVdsGroup());
    quota.setThresholdStoragePercentage(getQuotaThresholdStorage());
    quota.setGraceVdsGroupPercentage(getQuotaGraceVdsGroup());
    quota.setGraceStoragePercentage(getQuotaGraceStorage());
    quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>());
    quota.setQuotaStorages(new ArrayList<QuotaStorage>());
    // Set Quota storage capacity definition.
    QuotaStorage quotaStorage = new QuotaStorage();
    quotaStorage.setStorageSizeGB(UNLIMITED);
    quota.setGlobalQuotaStorage(quotaStorage);
    // Set Quota cluster virtual memory definition and virtual CPU definition.
    QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup();
    quotaVdsGroup.setVirtualCpu(UNLIMITED.intValue());
    quotaVdsGroup.setMemSizeMB(UNLIMITED);
    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
    return quota;
}
#end_block

#method_before
public void saveQuotaForUser(Quota quota, Guid ad_element_id) {
    saveQuotaForUser(quota, ad_element_id, false);
}
#method_after
public void saveQuotaForUser(Quota quota, Guid ad_element_id) {
    saveOrUpdateQuotaForUser(quota, ad_element_id, false);
}
#end_block

#method_before
protected Integer getIntegerConfig(ConfigValues value) {
    return Config.GetValue(value);
}
#method_after
private static int getIntegerConfig(ConfigValues value) {
    return Config.<Integer>GetValue(value);
}
#end_block

#method_before
public void saveQuotaForUser(Quota quota, Guid ad_element_id) {
    saveQuotaForUser(quota, ad_element_id, false);
}
#method_after
public void saveQuotaForUser(Quota quota, Guid ad_element_id) {
    saveOrUpdateQuotaForUser(quota, ad_element_id, false);
}
#end_block

#method_before
@Before
public void setUp() {
    setUpPoolToAdd();
    setUpCommandWithMocks();
}
#method_after
@Before
public void setUp() {
    initMocks(this);
    setUpPoolToAdd();
    setUpCommandWithMocks();
}
#end_block

#method_before
protected void setUpPoolToAdd() {
    poolToAdd = new storage_pool();
    poolToAdd.setname(RandomUtils.instance().nextString(10));
    poolToAdd.setId(Guid.NewGuid());
}
#method_after
protected void setUpPoolToAdd() {
    poolToAdd = new storage_pool();
    poolToAdd.setname(RandomUtils.instance().nextString(10));
    poolToAdd.setId(Guid.NewGuid());
    poolToAdd.setQuotaEnforcementType(type);
}
#end_block

#method_before
private Quota generateQuotaForNewStoragePool() {
    boolean isDefaultQuota = (getStoragePool().getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED);
    Quota defaultStoragePoolQuota = getQuotaHelper().getUnlimitedQuota(getStoragePool(), isDefaultQuota);
    return defaultStoragePoolQuota;
}
#method_after
private Quota generateQuotaForNewStoragePool() {
    return getQuotaHelper().getUnlimitedQuota(getStoragePool(), true);
}
#end_block

#method_before
private void validateSession(String sessionID) {
    getQueryReturnValue().setSucceeded(false);
    if (sessionID != null) {
        log.debug("Input session ID is: " + sessionID);
        VdcUser vdcUser = (VdcUser) SessionDataContainer.getInstance().GetData(sessionID, USER_SESSION_KEY);
        if (vdcUser != null) {
            log.debug("Found session user");
            getQueryReturnValue().setReturnValue(vdcUser);
            getQueryReturnValue().setSucceeded(true);
        } else {
            log.debug("Didn't find session user");
        }
    }
}
#method_after
private void validateSession(String sessionID) {
    getQueryReturnValue().setSucceeded(false);
    if (sessionID != null) {
        log.debug("Input session ID is: " + sessionID);
        VdcUser vdcUser = (VdcUser) getSessionUser(sessionID);
        if (vdcUser != null) {
            log.debug("Found session user");
            getQueryReturnValue().setReturnValue(vdcUser);
            getQueryReturnValue().setSucceeded(true);
        } else {
            log.debug("Didn't find session user");
        }
    }
}
#end_block

#method_before
@Test
public void testGetRelevantQuotasExistingVdsGroupNoSpecificQuotas() throws Exception {
    // there are no specific quotas, but all the general quotas relate to the storage pool containing this group
    assertGetAllRelevantQuoatsForVdsGroup(FixturesTool.VDS_GROUP_RHEL6_NFS_OTHER, NUM_QUOTAS - 1);
}
#method_after
@Test
public void testGetRelevantQuotasExistingVdsGroupNoSpecificQuotas() throws Exception {
    // there are no specific quotas, but all the general quotas relate to the storage pool containing this group
    assertGetAllRelevantQuoatsForVdsGroup(FixturesTool.VDS_GROUP_RHEL6_NFS_NO_SPECIFIC_QUOTAS, NUM_QUOTAS - 1);
}
#end_block

#method_before
private <T extends QuotaStorageProperties> ParameterizedRowMapper<QuotaVdsGroup> getVdsGroupQuotaResultSet() {
    ParameterizedRowMapper<QuotaVdsGroup> mapperQuotaLimitation = new ParameterizedRowMapper<QuotaVdsGroup>() {

        @Override
        public QuotaVdsGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
            QuotaVdsGroup entity = new QuotaVdsGroup();
            entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
            entity.setQuotaVdsGroupId(Guid.createGuidFromString(rs.getString("quota_vds_group_id")));
            entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setVdsGroupName(rs.getString("vds_group_name"));
            mapVdsGroupResultSet(rs, entity);
            return entity;
        }
    };
    return mapperQuotaLimitation;
}
#method_after
private ParameterizedRowMapper<QuotaVdsGroup> getVdsGroupQuotaResultSet() {
    ParameterizedRowMapper<QuotaVdsGroup> mapperQuotaLimitation = new ParameterizedRowMapper<QuotaVdsGroup>() {

        @Override
        public QuotaVdsGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
            QuotaVdsGroup entity = new QuotaVdsGroup();
            entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
            entity.setQuotaVdsGroupId(Guid.createGuidFromString(rs.getString("quota_vds_group_id")));
            entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setVdsGroupName(rs.getString("vds_group_name"));
            entity.setMemSizeMB((Long) rs.getObject("mem_size_mb"));
            entity.setMemSizeMBUsage((Long) rs.getObject("mem_size_mb_usage"));
            entity.setVirtualCpu((Integer) rs.getObject("virtual_cpu"));
            entity.setVirtualCpuUsage((Integer) rs.getObject("virtual_cpu_usage"));
            return entity;
        }
    };
    return mapperQuotaLimitation;
}
#end_block

#method_before
private ParameterizedRowMapper<QuotaStorage> getQuotaStorageResultSet() {
    ParameterizedRowMapper<QuotaStorage> mapperQuotaLimitation = new ParameterizedRowMapper<QuotaStorage>() {

        @Override
        public QuotaStorage mapRow(ResultSet rs, int rowNum) throws SQLException {
            QuotaStorage entity = new QuotaStorage();
            entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
            entity.setQuotaStorageId(Guid.createGuidFromString(rs.getString("quota_storage_id")));
            entity.setStorageId(Guid.createGuidFromString(rs.getString("storage_id")));
            entity.setStorageName(rs.getString("storage_name"));
            mapStorageResultSet(rs, entity);
            return entity;
        }
    };
    return mapperQuotaLimitation;
}
#method_after
private ParameterizedRowMapper<QuotaStorage> getQuotaStorageResultSet() {
    ParameterizedRowMapper<QuotaStorage> mapperQuotaLimitation = new ParameterizedRowMapper<QuotaStorage>() {

        @Override
        public QuotaStorage mapRow(ResultSet rs, int rowNum) throws SQLException {
            QuotaStorage entity = new QuotaStorage();
            entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
            entity.setQuotaStorageId(Guid.createGuidFromString(rs.getString("quota_storage_id")));
            entity.setStorageId(Guid.createGuidFromString(rs.getString("storage_id")));
            entity.setStorageName(rs.getString("storage_name"));
            entity.setStorageSizeGB((Long) rs.getObject("storage_size_gb"));
            entity.setStorageSizeGBUsage((Double) rs.getObject("storage_size_gb_usage"));
            return entity;
        }
    };
    return mapperQuotaLimitation;
}
#end_block

#method_before
private ParameterizedRowMapper<Quota> getQuotaFromResultSet() {
    ParameterizedRowMapper<Quota> mapper = new ParameterizedRowMapper<Quota>() {

        @Override
        public Quota mapRow(ResultSet rs, int rowNum) throws SQLException {
            Quota entity = getQuotaMetaDataFromResultSet(rs);
            mapVdsGroupResultSet(rs, entity);
            mapStorageResultSet(rs, entity);
            return entity;
        }
    };
    return mapper;
}
#method_after
private ParameterizedRowMapper<Quota> getQuotaFromResultSet() {
    ParameterizedRowMapper<Quota> mapper = new ParameterizedRowMapper<Quota>() {

        @Override
        public Quota mapRow(ResultSet rs, int rowNum) throws SQLException {
            Quota entity = getQuotaMetaDataFromResultSet(rs);
            // not, since global limitation must be for all the quota vds group parameters.
            if (rs.getObject("mem_size_mb") != null) {
                // Set global vds group quota.
                QuotaVdsGroup vdsGroupEntity = new QuotaVdsGroup();
                vdsGroupEntity.setMemSizeMB((Long) rs.getObject("mem_size_mb"));
                vdsGroupEntity.setMemSizeMBUsage((Long) rs.getObject("mem_size_mb_usage"));
                vdsGroupEntity.setVirtualCpu((Integer) rs.getObject("virtual_cpu"));
                vdsGroupEntity.setVirtualCpuUsage((Integer) rs.getObject("virtual_cpu_usage"));
                entity.setGlobalQuotaVdsGroup(vdsGroupEntity);
            }
            // not.
            if (rs.getObject("storage_size_gb") != null) {
                // Set global storage quota.
                QuotaStorage storageEntity = new QuotaStorage();
                storageEntity.setStorageSizeGB((Long) rs.getObject("storage_size_gb"));
                storageEntity.setStorageSizeGBUsage((Double) rs.getObject("storage_size_gb_usage"));
                entity.setGlobalQuotaStorage(storageEntity);
            }
            return entity;
        }
    };
    return mapper;
}
#end_block

#method_before
private MapSqlParameterSource getQuotaStorageParameterMap(Guid quotaId, QuotaStorage quotaStorage) {
    MapSqlParameterSource storageQuotaParameterMap = createQuotaIdParameterMapper(quotaStorage.getQuotaStorageId()).addValue("quota_id", quotaId).addValue("storage_id", quotaStorage.getStorageId()).addValue("vds_group_id", null);
    addQuotaStorageLimitMapper(quotaStorage, storageQuotaParameterMap);
    // Add null to storage parameter map to indicate the limit is only for specific storage.
    addQuotaVdsGroupLimitMapper(null, storageQuotaParameterMap);
    return storageQuotaParameterMap;
}
#method_after
private MapSqlParameterSource getQuotaStorageParameterMap(Guid quotaId, QuotaStorage quotaStorage) {
    MapSqlParameterSource storageQuotaParameterMap = createQuotaIdParameterMapper(quotaStorage.getQuotaStorageId()).addValue("quota_id", quotaId).addValue("storage_id", quotaStorage.getStorageId()).addValue("vds_group_id", null).addValue("storage_size_gb", quotaStorage.getStorageSizeGB()).addValue("virtual_cpu", null).addValue("mem_size_mb", null);
    return storageQuotaParameterMap;
}
#end_block

#method_before
private MapSqlParameterSource getQuotaVdsGroupParameterMap(Guid quotaId, QuotaVdsGroup quotaVdsGroup) {
    MapSqlParameterSource vdsGroupQuotaParameterMap = createQuotaIdParameterMapper(quotaVdsGroup.getQuotaVdsGroupId()).addValue("quota_id", quotaId).addValue("vds_group_id", quotaVdsGroup.getVdsGroupId()).addValue("storage_id", null);
    // Add null to vds group parameter map to indicate the limit is only for specific vdsGroup.
    addQuotaStorageLimitMapper(null, vdsGroupQuotaParameterMap);
    addQuotaVdsGroupLimitMapper(quotaVdsGroup, vdsGroupQuotaParameterMap);
    return vdsGroupQuotaParameterMap;
}
#method_after
private MapSqlParameterSource getQuotaVdsGroupParameterMap(Guid quotaId, QuotaVdsGroup quotaVdsGroup) {
    MapSqlParameterSource vdsGroupQuotaParameterMap = createQuotaIdParameterMapper(quotaVdsGroup.getQuotaVdsGroupId()).addValue("quota_id", quotaId).addValue("vds_group_id", quotaVdsGroup.getVdsGroupId()).addValue("storage_id", null).addValue("storage_size_gb", null).addValue("virtual_cpu", quotaVdsGroup.getVirtualCpu()).addValue("mem_size_mb", quotaVdsGroup.getMemSizeMB());
    return vdsGroupQuotaParameterMap;
}
#end_block

#method_before
private MapSqlParameterSource getFullQuotaParameterMap(Quota quota) {
    MapSqlParameterSource quotaParameterMap = getCustomMapSqlParameterSource().addValue("id", quota.getId()).addValue("quota_id", quota.getId()).addValue("vds_group_id", null).addValue("storage_id", null);
    addQuotaStorageLimitMapper(quota, quotaParameterMap);
    addQuotaVdsGroupLimitMapper(quota, quotaParameterMap);
    return quotaParameterMap;
}
#method_after
private MapSqlParameterSource getFullQuotaParameterMap(Quota quota) {
    MapSqlParameterSource quotaParameterMap = getCustomMapSqlParameterSource().addValue("id", quota.getId()).addValue("quota_id", quota.getId()).addValue("vds_group_id", null).addValue("storage_id", null).addValue("storage_size_gb", quota.getGlobalQuotaStorage() != null ? quota.getGlobalQuotaStorage().getStorageSizeGB() : null).addValue("virtual_cpu", quota.getGlobalQuotaVdsGroup() != null ? quota.getGlobalQuotaVdsGroup().getVirtualCpu() : null).addValue("mem_size_mb", quota.getGlobalQuotaVdsGroup() != null ? quota.getGlobalQuotaVdsGroup().getMemSizeMB() : null);
    return quotaParameterMap;
}
#end_block

#method_before
@Test
public void testSpecificAndGeneralQuotaLimitations() throws Exception {
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(FixturesTool.STORAGE_POOL_NFS);
    quota.setQuotaName("Watson");
    quota.setDescription("General and specific quota");
    quota.setThresholdVdsGroupPercentage(Config.<Integer>GetValue(ConfigValues.QuotaThresholdVdsGroup));
    quota.setThresholdStoragePercentage(Config.<Integer>GetValue(ConfigValues.QuotaThresholdStorage));
    quota.setGraceVdsGroupPercentage(Config.<Integer>GetValue(ConfigValues.QuotaGraceVdsGroup));
    quota.setGraceStoragePercentage(Config.<Integer>GetValue(ConfigValues.QuotaGraceStorage));
    quota.setQuotaVdsGroups(getQuotaVdsGroup(getSpecificQuotaVdsGroup(quotaId)));
    quota.setQuotaStorages(getQuotaStorage(null));
    quota.setStorageSizeGB(10000l);
    quota.setStorageSizeGBUsage(0d);
    dao.save(quota);
    Quota quotaEntity = dao.getById(quota.getId());
    assertNotNull(quotaEntity);
    assertEquals(quotaEntity, quota);
}
#method_after
@Test
public void testSpecificAndGeneralQuotaLimitations() throws Exception {
    // Set new Quota definition.
    Quota quota = new Quota();
    Guid quotaId = Guid.NewGuid();
    quota.setId(quotaId);
    quota.setStoragePoolId(FixturesTool.STORAGE_POOL_NFS);
    quota.setQuotaName("Watson");
    quota.setDescription("General and specific quota");
    quota.setThresholdVdsGroupPercentage(Config.<Integer>GetValue(ConfigValues.QuotaThresholdVdsGroup));
    quota.setThresholdStoragePercentage(Config.<Integer>GetValue(ConfigValues.QuotaThresholdStorage));
    quota.setGraceVdsGroupPercentage(Config.<Integer>GetValue(ConfigValues.QuotaGraceVdsGroup));
    quota.setGraceStoragePercentage(Config.<Integer>GetValue(ConfigValues.QuotaGraceStorage));
    quota.setQuotaVdsGroups(getQuotaVdsGroup(getSpecificQuotaVdsGroup(quotaId)));
    quota.setQuotaStorages(getQuotaStorage(null));
    quota.setGlobalQuotaStorage(new QuotaStorage(null, null, null, 10000l, 0d));
    dao.save(quota);
    Quota quotaEntity = dao.getById(quota.getId());
    assertNotNull(quotaEntity);
    assertEquals(quotaEntity, quota);
}
#end_block

#method_before
@Test
public void testUpdateQuota() throws Exception {
    Quota quotaGeneralToSpecific = dao.getById(FixturesTool.QUOTA_GENERAL);
    // Save quotaName and vdsGroup list for future check.
    String quotaName = "New Temporary name";
    List<QuotaVdsGroup> quotaVdsGroupList = getQuotaVdsGroup(getSpecificQuotaVdsGroup(quotaGeneralToSpecific.getId()));
    Long newStorageLimit = new Long("2345");
    // Check before the update, that the fields are not equal.
    assertEquals(quotaName.equals(quotaGeneralToSpecific.getQuotaName()), false);
    assertEquals(quotaVdsGroupList.size() == quotaGeneralToSpecific.getQuotaVdsGroups().size(), false);
    assertEquals(quotaGeneralToSpecific.getStorageSizeGB().equals(newStorageLimit), false);
    // Update
    quotaGeneralToSpecific.setQuotaName(quotaName);
    quotaGeneralToSpecific.setStorageSizeGB(newStorageLimit);
    quotaGeneralToSpecific.setQuotaVdsGroups(quotaVdsGroupList);
    dao.update(quotaGeneralToSpecific);
    quotaGeneralToSpecific = dao.getById(FixturesTool.QUOTA_GENERAL);
    // Check after the update, that the fields are equal now.
    assertEquals(quotaName.equals(quotaGeneralToSpecific.getQuotaName()), true);
    assertEquals(quotaVdsGroupList.size() == quotaGeneralToSpecific.getQuotaVdsGroups().size(), true);
    assertEquals(quotaGeneralToSpecific.getStorageSizeGB().equals(newStorageLimit), true);
}
#method_after
@Test
public void testUpdateQuota() throws Exception {
    Quota quotaGeneralToSpecific = dao.getById(FixturesTool.QUOTA_GENERAL);
    // Save quotaName and vdsGroup list for future check.
    String quotaName = "New Temporary name";
    List<QuotaVdsGroup> quotaVdsGroupList = getQuotaVdsGroup(getSpecificQuotaVdsGroup(quotaGeneralToSpecific.getId()));
    Long newStorageLimit = new Long("2345");
    // Check before the update, that the fields are not equal.
    assertEquals(quotaName.equals(quotaGeneralToSpecific.getQuotaName()), false);
    assertEquals(quotaVdsGroupList.size() == quotaGeneralToSpecific.getQuotaVdsGroups().size(), false);
    assertEquals(quotaGeneralToSpecific.getGlobalQuotaStorage().getStorageSizeGB().equals(newStorageLimit), false);
    // Update
    quotaGeneralToSpecific.setQuotaName(quotaName);
    quotaGeneralToSpecific.getGlobalQuotaStorage().setStorageSizeGB(newStorageLimit);
    quotaGeneralToSpecific.setQuotaVdsGroups(quotaVdsGroupList);
    dao.update(quotaGeneralToSpecific);
    quotaGeneralToSpecific = dao.getById(FixturesTool.QUOTA_GENERAL);
    // Check after the update, that the fields are equal now.
    assertEquals(quotaName.equals(quotaGeneralToSpecific.getQuotaName()), true);
    assertEquals(quotaVdsGroupList.size() == quotaGeneralToSpecific.getQuotaVdsGroups().size(), true);
    assertEquals(quotaGeneralToSpecific.getGlobalQuotaStorage().getStorageSizeGB().equals(newStorageLimit), true);
}
#end_block

#method_before
private static void setQuotaGlobalLimitations(Quota quota) {
    // Set Quota storage capacity definition.
    quota.setStorageSizeGB(10000l);
    quota.setStorageSizeGBUsage(0d);
    // Set Quota cluster virtual memory definition.
    quota.setMemSizeMB(16000000l);
    quota.setMemSizeMBUsage(0l);
    // Set Quota cluster virtual CPU definition.
    quota.setVirtualCpu(2880);
    quota.setVirtualCpuUsage(0);
}
#method_after
private static void setQuotaGlobalLimitations(Quota quota) {
    QuotaStorage quotaStorage = new QuotaStorage();
    QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup();
    // Set Quota storage capacity definition.
    quotaStorage.setStorageSizeGB(10000l);
    quotaStorage.setStorageSizeGBUsage(0d);
    // Set Quota cluster virtual memory definition.
    quotaVdsGroup.setMemSizeMB(16000000l);
    quotaVdsGroup.setMemSizeMBUsage(0l);
    // Set Quota cluster virtual CPU definition.
    quotaVdsGroup.setVirtualCpu(2880);
    quotaVdsGroup.setVirtualCpuUsage(0);
    quota.setGlobalQuotaStorage(quotaStorage);
    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
}
#end_block

#method_before
public GlusterVolumeOption getVolumeOption() {
    return volumeOption;
}
#method_after
public GlusterVolumeOptionEntity getVolumeOption() {
    return volumeOption;
}
#end_block

#method_before
public void setVolumeOption(GlusterVolumeOption volumeOption) {
    this.volumeOption = volumeOption;
}
#method_after
public void setVolumeOption(GlusterVolumeOptionEntity volumeOption) {
    this.volumeOption = volumeOption;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
    if (!super.canDoAction()) {
        return false;
    }
    volume = getParameters().getVolume();
    if (volume == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REQUIRED);
        return false;
    }
    // set the cluster id
    setVdsGroupId(volume.getClusterId());
    VDSGroup cluster = getVdsGroup();
    if (cluster == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    if (StringHelper.isNullOrEmpty(volume.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_REQUIRED);
        return false;
    }
    if (volume.getVolumeType() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_TYPE_REQUIRED);
        return false;
    }
    if (volume.getTransportType() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TRANSPORT_TYPE_REQUIRED);
        return false;
    }
    return validateBricks(volume);
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VDSGroup cluster = getVdsGroup();
    if (cluster == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    return validateBricks(volume);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // set the gluster volume name for audit purpose
    setGlusterVolumeName(volume.getName());
    // GLUSTER access protocol is enabled by default
    if (volume.getAccessProtocols() == null) {
        volume.setAccessProtocol(AccessProtocol.GLUSTER);
    }
    VDSReturnValue returnValue = executeVdsCommand(VDSCommandType.CreateGlusterVolume, new CreateGlusterVolumeVDSParameters(getUpServer().getId(), volume));
    if (!getSucceeded()) {
        errorType = AuditLogType.GLUSTER_VOLUME_CREATE_FAILED;
        return;
    }
    // Volume created successfully. Insert it to database.
    GlusterVolumeEntity createdVolume = (GlusterVolumeEntity) returnValue.getReturnValue();
    addVolumeToDb(createdVolume);
    // set all options of the volume
    setVolumeOptions(createdVolume);
}
#method_after
@Override
protected void executeCommand() {
    // set the gluster volume name for audit purpose
    setGlusterVolumeName(volume.getName());
    // GLUSTER access protocol is enabled by default
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CreateGlusterVolume, new CreateGlusterVolumeVDSParameters(getUpServer().getId(), volume));
    setSucceeded(returnValue.getSucceeded());
    // Volume created successfully. Insert it to database.
    GlusterVolumeEntity createdVolume = (GlusterVolumeEntity) returnValue.getReturnValue();
    addVolumeToDb(createdVolume);
    // set all options of the volume
    setVolumeOptions(createdVolume);
}
#end_block

#method_before
private void setVolumeOptions(GlusterVolumeEntity volume) {
    List<String> errors = new ArrayList<String>();
    for (GlusterVolumeOption option : volume.getOptions()) {
        // make sure that volume id is set
        option.setVolumeId(volume.getId());
        VdcReturnValueBase setOptionReturnValue = executeBllAction(VdcActionType.SetGlusterVolumeOption, new GlusterVolumeOptionParameters(option));
        if (!getSucceeded()) {
            errors.addAll(setOptionReturnValue.getCanDoActionMessages());
            errors.addAll(setOptionReturnValue.getExecuteFailedMessages());
        }
    }
    if (!errors.isEmpty()) {
        setSucceeded(false);
        errorType = AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED;
        getReturnValue().getExecuteFailedMessages().addAll(errors);
    }
}
#method_after
private void setVolumeOptions(GlusterVolumeEntity volume) {
    List<String> errors = new ArrayList<String>();
    for (GlusterVolumeOptionEntity option : volume.getOptions()) {
        // make sure that volume id is set
        option.setVolumeId(volume.getId());
        VdcReturnValueBase setOptionReturnValue = runBllAction(VdcActionType.SetGlusterVolumeOption, new GlusterVolumeOptionParameters(option));
        if (!getSucceeded()) {
            errors.addAll(setOptionReturnValue.getCanDoActionMessages());
            errors.addAll(setOptionReturnValue.getExecuteFailedMessages());
        }
    }
    if (!errors.isEmpty()) {
        errorType = AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED;
        getReturnValue().getExecuteFailedMessages().addAll(errors);
    }
}
#end_block

#method_before
private boolean validateBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    if (bricks == null || bricks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    switch(volume.getVolumeType()) {
        case REPLICATE:
        case DISTRIBUTED_REPLICATE:
            if (!validateReplicaCount(bricks.size(), volume.getReplicaCount())) {
                return false;
            }
            break;
        case STRIPE:
        case DISTRIBUTED_STRIPE:
            if (!validateStripeCount(bricks.size(), volume.getReplicaCount())) {
                return false;
            }
            break;
    }
    return true;
}
#method_after
private boolean validateBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    if (bricks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    int brickCount = bricks.size();
    int replicaCount = volume.getReplicaCount();
    int stripeCount = volume.getStripeCount();
    switch(volume.getVolumeType()) {
        case REPLICATE:
            if (replicaCount < 2) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_REPLICA_COUNT_MIN_2);
                return false;
            }
            if (brickCount != replicaCount) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_REPLICATE);
                return false;
            }
            break;
        case DISTRIBUTED_REPLICATE:
            if (replicaCount < 4) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_REPLICA_COUNT_MIN_4);
                return false;
            }
            if (brickCount < replicaCount || Math.IEEEremainder(brickCount, replicaCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_REPLICATE);
                return false;
            }
            break;
        case STRIPE:
            if (stripeCount < 4) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STRIPE_COUNT_MIN_4);
                return false;
            }
            if (brickCount != stripeCount) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_STRIPE);
                return false;
            }
            break;
        case DISTRIBUTED_STRIPE:
            if (stripeCount < 8) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STRIPE_COUNT_MIN_8);
                return false;
            }
            if (brickCount < stripeCount || Math.IEEEremainder(brickCount, stripeCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_STRIPE);
                return false;
            }
            break;
    }
    return true;
}
#end_block

#method_before
private void addVolumeToDb(final GlusterVolumeEntity createdVolume) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            // volume fetched from VDSM doesn't contain cluster id GlusterFS
            // is not aware of multiple clusters
            createdVolume.setClusterId(getVdsGroupId());
            DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume);
            return null;
        }
    });
}
#method_after
private void addVolumeToDb(final GlusterVolumeEntity createdVolume) {
    // volume fetched from VDSM doesn't contain cluster id GlusterFS
    // is not aware of multiple clusters
    createdVolume.setClusterId(getVdsGroupId());
    DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME_OPTION);
    if (!super.canDoAction()) {
        return false;
    }
    if (option == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_OPTION_REQUIRED);
        return false;
    }
    if (StringHelper.isNullOrEmpty(option.getKey())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_OPTION_KEY_REQUIRED);
        return false;
    }
    if (StringHelper.isNullOrEmpty(option.getValue())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_OPTION_VALUE_REQUIRED);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    return super.canDoAction();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // set volume details for audit purpose
    setGlusterVolumeId(option.getVolumeId());
    setGlusterVolumeName(getGlusterVolume().getName());
    executeVdsCommand(VDSCommandType.SetGlusterVolumeOption, new GlusterVolumeOptionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getVolumeOption()));
    if (getSucceeded()) {
        updateOptionInDb(getParameters().getVolumeOption());
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.SetGlusterVolumeOption, new GlusterVolumeOptionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getVolumeOption()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        updateOptionInDb(getParameters().getVolumeOption());
    }
}
#end_block

#method_before
private void updateOptionInDb(final GlusterVolumeOption option) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            // update the option value if it exists, else add it
            if (getGlusterVolume().getOptionValue(option.getKey()) != null) {
                glusterVolumeDao.updateVolumeOption(option);
            } else {
                glusterVolumeDao.addVolumeOption(option);
            }
            return null;
        }
    });
}
#method_after
private void updateOptionInDb(final GlusterVolumeOptionEntity option) {
    // update the option value if it exists, else add it
    if (getGlusterVolume().getOptionValue(option.getKey()) != null) {
        getGlusterVolumeDao().updateVolumeOption(option);
    } else {
        getGlusterVolumeDao().addVolumeOption(option);
    }
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    GlusterVolumeEntity volume = getParameters().getVolume();
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put("volumeName", volume.getName());
    parameters.put("volumeType", volume.getVolumeType().toString());
    parameters.put("replicaCount", volume.getReplicaCount());
    parameters.put("stripeCount", volume.getStripeCount());
    TransportType transportType = volume.getTransportType();
    parameters.put("transportType", transportType.toString());
    parameters.put("bricks", volume.getBrickDirectories().toArray());
    OneUuidReturnForXmlRpc uuidReturn = getBroker().glusterVolumeCreate(parameters);
    status = uuidReturn.mStatus;
    volume.setId(Guid.createGuidFromString(uuidReturn.mUuid));
    // Proceed only if there were no errors in the VDS command
    ProceedProxyReturnValue();
    if (!volume.isNfsEnabled()) {
        status = getBroker().glusterVolumeSet(volume.getName(), GlusterConstants.OPTION_NFS_DISABLE, "on").mStatus;
        ProceedProxyReturnValue();
    }
    for (GlusterVolumeOption option : volume.getOptions()) {
        status = getBroker().glusterVolumeSet(volume.getName(), option.getKey(), option.getValue()).mStatus;
        ProceedProxyReturnValue();
    }
    // set the volume updated with id as the return value
    setReturnValue(volume);
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    GlusterVolumeEntity volume = getParameters().getVolume();
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put("volumeName", volume.getName());
    parameters.put("volumeType", volume.getVolumeType().name());
    parameters.put("replicaCount", volume.getReplicaCount());
    parameters.put("stripeCount", volume.getStripeCount());
    TransportType transportType = volume.getTransportType();
    parameters.put("transportType", transportType.name());
    parameters.put("bricks", volume.getBrickDirectories().toArray());
    OneUuidReturnForXmlRpc uuidReturn = getBroker().glusterVolumeCreate(parameters);
    status = uuidReturn.mStatus;
    volume.setId(Guid.createGuidFromString(uuidReturn.mUuid));
    // Proceed only if there were no errors in the VDS command
    ProceedProxyReturnValue();
    if (!volume.isNfsEnabled()) {
        status = getBroker().glusterVolumeSet(volume.getName(), GlusterConstants.OPTION_NFS_DISABLE, "on").mStatus;
        ProceedProxyReturnValue();
    }
    for (GlusterVolumeOptionEntity option : volume.getOptions()) {
        status = getBroker().glusterVolumeSet(volume.getName(), option.getKey(), option.getValue()).mStatus;
        ProceedProxyReturnValue();
    }
    // set the volume updated with id as the return value
    setReturnValue(volume);
}
#end_block

#method_before
public GlusterVolumeOption getVolumeOption() {
    return volumeOption;
}
#method_after
public GlusterVolumeOptionEntity getVolumeOption() {
    return volumeOption;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORK_MTU_DIFFER_FROM_LOGICAL_NETWORK, AuditLogSeverity.WARNING);
}
#end_block

#method_before
public String getGlusterVolumeName() {
    return glusterVolumeName;
}
#method_after
public String getGlusterVolumeName() {
    if (glusterVolumeName == null && getGlusterVolume() != null) {
        glusterVolumeName = getGlusterVolume().getName();
    }
    return glusterVolumeName;
}
#end_block

#method_before
@Test
public void testDetermineMessageReturnsClassNameForNoParameterExpansion() throws Exception {
    Log log = mock(Log.class);
    when(log.isDebugEnabled()).thenReturn(false);
    assertEquals("LoggedUtils.determineMessage shouldn't return parameter expansion for a disabled log level.", Object.class.getName(), LoggedUtils.determineMessage(log, LoggedOverridingSubclassNoParameters.class.getAnnotation(Logged.class), new Object()));
    assertEquals("LoggedUtils.determineMessage shouldn't return parameter expansion when diabled completely.", Object.class.getName(), LoggedUtils.determineMessage(log, LoggedClass.class.getAnnotation(Logged.class), new Object()));
}
#method_after
@Test
public void testDetermineMessageReturnsClassNameForNoParameterExpansion() throws Exception {
    Log log = mock(Log.class);
    assertEquals("LoggedUtils.determineMessage shouldn't return parameter expansion for a disabled log level.", Object.class.getName(), LoggedUtils.determineMessage(log, LoggedOverridingSubclassNoParameters.class.getAnnotation(Logged.class), new Object()));
    assertEquals("LoggedUtils.determineMessage shouldn't return parameter expansion when diabled completely.", Object.class.getName(), LoggedUtils.determineMessage(log, LoggedClass.class.getAnnotation(Logged.class), new Object()));
}
#end_block

#method_before
/* --- Tests for the method "logEntry" --- */
@Test
public void testLogEntryDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logEntry(log, "", new Object());
}
#method_after
/* --- Tests for the method "logEntry" --- */
@Test
public void testLogEntryDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logEntry(log, "", new Object());
    verifyZeroInteractions(log);
}
#end_block

#method_before
@Test
public void testLogEntryDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    when(log.isDebugEnabled()).thenReturn(false);
    LoggedUtils.logEntry(log, "", new LoggedOverridingSubclass());
}
#method_after
@Test
public void testLogEntryDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logEntry(log, "", new LoggedOverridingSubclass());
    verifyNoLogging(log);
}
#end_block

#method_before
/* --- Tests for the method "logReturn" --- */
@Test
public void testLogReturnDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logReturn(log, "", new Object(), new Object());
}
#method_after
/* --- Tests for the method "logReturn" --- */
@Test
public void testLogReturnDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logReturn(log, "", new Object(), new Object());
    verifyZeroInteractions(log);
}
#end_block

#method_before
@Test
public void testLogReturnDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    when(log.isDebugEnabled()).thenReturn(false);
    LoggedUtils.logReturn(log, "", new LoggedOverridingSubclass(), new Object());
}
#method_after
@Test
public void testLogReturnDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logReturn(log, "", new LoggedOverridingSubclass(), new Object());
    verifyNoLogging(log);
}
#end_block

#method_before
/* --- Tests for the method "logError" --- */
@Test
public void testLogErrorDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logError(log, "", new Object(), new Exception());
}
#method_after
/* --- Tests for the method "logError" --- */
@Test
public void testLogErrorDoesntLogWhenNoAnnotation() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logError(log, "", new Object(), new Exception());
    verifyZeroInteractions(log);
}
#end_block

#method_before
@Test
public void testLogErrorDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    when(log.isWarnEnabled()).thenReturn(false);
    LoggedUtils.logError(log, "", new LoggedOverridingSubclass(), new Exception());
}
#method_after
@Test
public void testLogErrorDoesntLogWhenLogLevelInactive() throws Exception {
    Log log = mock(Log.class);
    LoggedUtils.logError(log, "", new LoggedOverridingSubclass(), new Exception());
    verifyNoLogging(log);
}
#end_block

#method_before
/* --- Helper methods --- */
private static void helpTestLog(LogLevel logLevel, LogSetup logSetup) {
    Log log = mock(Log.class);
    String message = "{0}";
    Object args = new Object();
    logSetup.setup(log, message, args);
    LoggedUtils.log(log, logLevel, message, args);
    logSetup.verifyCall(log, message, args);
}
#method_after
private static void helpTestLog(LogLevel logLevel, LogSetup logSetup) {
    Log log = mock(Log.class);
    String message = "{0}";
    Object args = new Object();
    logSetup.setup(log, message, args);
    LoggedUtils.log(log, logLevel, message, args);
    logSetup.verifyCall(log, message, args);
}
#end_block

#method_before
public void RemoveVmFromDownVms(Guid vdsId, Guid vmId) {
    java.util.HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        vms.remove(vmId);
    }
}
#method_after
public void RemoveVmFromDownVms(Guid vdsId, Guid vmId) {
    HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        vms.remove(vmId);
    }
}
#end_block

#method_before
public void HandleVdsFinishedInit(Guid vdsId) {
    java.util.HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        for (Guid vmId : vms) {
            getEventListener().processOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        _vdsAndVmsList.remove(vdsId);
    }
}
#method_after
public void HandleVdsFinishedInit(Guid vdsId) {
    HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        for (Guid vmId : vms) {
            getEventListener().processOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        _vdsAndVmsList.remove(vdsId);
    }
}
#end_block

#method_before
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, boolean saveToDb, Guid domainId, Map<String, String> customLogValues) {
    log.info("ResourceManager:vdsMaintanance - no event listener defined, nothing done.");
}
#method_after
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, boolean saveToDb, Guid domainId) {
    log.info("ResourceManager:vdsMaintanance - no event listener defined, nothing done.");
}
#end_block

#method_before
public void UpdateVdsDomainsData(Guid vdsId, String vdsName, Guid storagePoolId, java.util.ArrayList<VDSDomainsData> vdsDomainData) {
    IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, vdsDomainData);
}
#method_after
public void UpdateVdsDomainsData(Guid vdsId, String vdsName, Guid storagePoolId, ArrayList<VDSDomainsData> vdsDomainData) {
    IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, vdsDomainData);
}
#end_block

#method_before
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    return CheckStoragePool() && CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.InActive, StorageDomainStatus.Maintenance) && (isMaster() || isDestroyStoragePool || CheckMasterDomainIsUp()) && isNotLocalData(isInternal) && isDetachAllowed(isRemoveLast);
}
#method_after
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    return checkStoragePool() && CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.InActive, StorageDomainStatus.Maintenance) && (isMaster() || isDestroyStoragePool || CheckMasterDomainIsUp()) && isNotLocalData(isInternal) && isDetachAllowed(isRemoveLast);
}
#end_block

#method_before
private boolean hasImages() {
    return DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForStorageDomain(getStorageDomain().getId()).size() != 0 || DbFacade.getInstance().getStorageDomainDAO().getAllImageStorageDomainMapsForStorageDomain(getStorageDomain().getId()).size() != 0;
}
#method_after
private boolean hasImages() {
    return DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForStorageDomain(getStorageDomain().getId()).size() != 0 || DbFacade.getInstance().getImageStorageDomainMapDao().getAllByStorageDomainId(getStorageDomain().getId()).size() != 0;
}
#end_block

#method_before
protected void RefreshAllVdssInPool(boolean connect) {
    java.util.ArrayList<Guid> vdsIdsToSetNonOperational = new java.util.ArrayList<Guid>();
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE, null);
        tempVar.setSaveToDb(true);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
    }
}
#method_after
protected void RefreshAllVdssInPool(boolean connect) {
    java.util.ArrayList<Guid> vdsIdsToSetNonOperational = new java.util.ArrayList<Guid>();
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE);
        tempVar.setSaveToDb(true);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static void updateNetworkData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDAO().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    // Interfaces list
    java.util.Map nics = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_nics) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_nics) : null);
    if (nics != null) {
        for (Object keyAsObject : nics.keySet()) {
            String key = (String) keyAsObject;
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            // name value of nic property, i.e.: speed = 1000
            java.util.Map<String, Object> dataAsMap = (java.util.Map) ((nics.get(key) instanceof java.util.Map) ? nics.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data != null) {
                if (data.getItem("speed") != null) {
                    Object speed = data.getItem("speed");
                    iface.setSpeed((Integer) speed);
                }
                if (data.getItem("addr") != null) {
                    iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
                }
                if (data.getItem("netmask") != null) {
                    iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
                }
                if (data.getItem("hwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("hwaddr") instanceof String) ? data.getItem("hwaddr") : null));
                }
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                if (data.getItem("permhwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("permhwaddr") instanceof String) ? data.getItem("permhwaddr") : null));
                }
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // interface to vlan map
    Map<String, Integer> currVlans = new java.util.HashMap<String, Integer>();
    // vlans
    java.util.Map<String, Object> vlans = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_vlans) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_vlans) : null);
    if (vlans != null) {
        for (String key : vlans.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            if (key.contains(".")) {
                String[] names = key.split("[.]", -1);
                String vlan = names[1];
                iface.setVlanId(Integer.parseInt(vlan));
                currVlans.put(key, iface.getVlanId());
            }
            java.util.Map dataAsMap = (java.util.Map) ((vlans.get(key) instanceof java.util.Map) ? vlans.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data.getItem("addr") != null) {
                iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
            }
            if (data.getItem("netmask") != null) {
                iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // bonds
    java.util.Map<String, Object> bonds = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_bondings) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_bondings) : null);
    if (bonds != null) {
        for (String key : bonds.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            java.util.Map dataAsMap = (java.util.Map) ((bonds.get(key) instanceof java.util.Map) ? bonds.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data != null) {
                if (data.getItem("hwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("hwaddr") instanceof String) ? data.getItem("hwaddr") : null));
                }
                if (data.getItem("addr") != null) {
                    iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
                }
                if (data.getItem("netmask") != null) {
                    iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
                }
                if (data.getItem(VdsProperties.GLOBAL_GATEWAY) != null) {
                    iface.setGateway((String) ((data.getItem(VdsProperties.GLOBAL_GATEWAY) instanceof String) ? data.getItem(VdsProperties.GLOBAL_GATEWAY) : null));
                }
                if (data.getItem("slaves") != null) {
                    Object[] interfaces = (Object[]) ((data.getItem("slaves") instanceof Object[]) ? data.getItem("slaves") : null);
                    iStats.setVdsId(vds.getId());
                    AddBond(vds, iface, interfaces);
                }
                XmlRpcStruct config = (data.getItem("cfg") instanceof Map) ? new XmlRpcStruct((Map) data.getItem("cfg")) : null;
                if (config != null && config.getItem("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.getItem("BONDING_OPTS").toString());
                }
                AddBootProtocol(config, iface);
            }
        }
    }
    // network to vlan map
    Map<String, Integer> networkVlans = new java.util.HashMap<String, Integer>();
    // Networks collection (name point to list of nics or bonds)
    java.util.Map<String, Object> networks = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_networks) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_networks) : null);
    if (networks != null) {
        vds.getNetworks().clear();
        for (String key : networks.keySet()) {
            java.util.Map<String, Object> networkAsMap = (java.util.Map) ((networks.get(key) instanceof java.util.Map) ? networks.get(key) : null);
            XmlRpcStruct network = new XmlRpcStruct(networkAsMap);
            if (network != null) {
                network net = new network();
                net.setname(key);
                if (network.getItem("addr") != null) {
                    net.setaddr(network.getItem("addr").toString());
                }
                if (network.getItem("netmask") != null) {
                    net.setsubnet(network.getItem("netmask").toString());
                }
                if (network.getItem(VdsProperties.GLOBAL_GATEWAY) != null) {
                    net.setgateway(network.getItem(VdsProperties.GLOBAL_GATEWAY).toString());
                }
                // map interface to network
                Object[] ports = (Object[]) ((network.getItem("ports") instanceof Object[]) ? network.getItem("ports") : null);
                if (ports != null) {
                    for (Object port : ports) {
                        VdsNetworkInterface iface = null;
                        for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                            if (tempInterface.getName().equals(port.toString())) {
                                iface = tempInterface;
                                break;
                            }
                        }
                        if (iface != null) {
                            iface.setNetworkName(net.getname());
                            if (currVlans.containsKey(iface.getName())) {
                                networkVlans.put(net.getname(), currVlans.get(iface.getName()));
                            }
                            iface.setAddress(net.getaddr());
                            // ifaces is bridged if it is reported as one of the bridge ports
                            iface.setBridged(true);
                            // set the management ip
                            if (StringHelper.EqOp(iface.getNetworkName(), NetworkUtils.EngineNetwork)) {
                                iface.setType(iface.getType() | VdsInterfaceType.Management.getValue());
                            }
                            iface.setSubnet(net.getsubnet());
                            iface.setGateway(net.getgateway());
                            java.util.Map networkConfigAsMap = (java.util.Map) ((network.getItem("cfg") instanceof java.util.Map) ? network.getItem("cfg") : null);
                            XmlRpcStruct networkConfig = networkConfigAsMap == null ? null : new XmlRpcStruct(networkConfigAsMap);
                            AddBootProtocol(networkConfig, iface);
                        }
                    }
                }
                vds.getNetworks().add(net);
            }
        }
    }
    // Check vlans are line with Clusters vlans
    checkClusterVlans(vds, networkVlans);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
}
#method_after
@SuppressWarnings("unchecked")
public static void updateNetworkData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDAO().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    // Interfaces list
    java.util.Map nics = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_nics) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_nics) : null);
    if (nics != null) {
        for (Object keyAsObject : nics.keySet()) {
            String key = (String) keyAsObject;
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            // name value of nic property, i.e.: speed = 1000
            java.util.Map<String, Object> dataAsMap = (java.util.Map) ((nics.get(key) instanceof java.util.Map) ? nics.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data != null) {
                if (data.getItem("speed") != null) {
                    Object speed = data.getItem("speed");
                    iface.setSpeed((Integer) speed);
                }
                if (data.getItem("addr") != null) {
                    iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
                }
                if (data.getItem("netmask") != null) {
                    iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
                }
                if (data.getItem("hwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("hwaddr") instanceof String) ? data.getItem("hwaddr") : null));
                }
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                if (data.getItem("permhwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("permhwaddr") instanceof String) ? data.getItem("permhwaddr") : null));
                }
                if (StringUtils.isNotBlank((String) data.getItem(mtu))) {
                    iface.setMtu(Integer.parseInt((String) data.getItem(mtu)));
                }
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // interface to vlan map
    Map<String, Integer> currVlans = new java.util.HashMap<String, Integer>();
    // vlans
    java.util.Map<String, Object> vlans = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_vlans) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_vlans) : null);
    if (vlans != null) {
        for (String key : vlans.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            if (key.contains(".")) {
                String[] names = key.split("[.]", -1);
                String vlan = names[1];
                iface.setVlanId(Integer.parseInt(vlan));
                currVlans.put(key, iface.getVlanId());
            }
            java.util.Map dataAsMap = (java.util.Map) ((vlans.get(key) instanceof java.util.Map) ? vlans.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data.getItem("addr") != null) {
                iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
            }
            if (data.getItem("netmask") != null) {
                iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
            }
            if (StringUtils.isNotBlank((String) data.getItem(mtu))) {
                iface.setMtu(Integer.parseInt((String) data.getItem(mtu)));
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // bonds
    java.util.Map<String, Object> bonds = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_bondings) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_bondings) : null);
    if (bonds != null) {
        for (String key : bonds.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            java.util.Map dataAsMap = (java.util.Map) ((bonds.get(key) instanceof java.util.Map) ? bonds.get(key) : null);
            XmlRpcStruct data = new XmlRpcStruct(dataAsMap);
            if (data != null) {
                if (data.getItem("hwaddr") != null) {
                    iface.setMacAddress((String) ((data.getItem("hwaddr") instanceof String) ? data.getItem("hwaddr") : null));
                }
                if (data.getItem("addr") != null) {
                    iface.setAddress((String) ((data.getItem("addr") instanceof String) ? data.getItem("addr") : null));
                }
                if (data.getItem("netmask") != null) {
                    iface.setSubnet((String) ((data.getItem("netmask") instanceof String) ? data.getItem("netmask") : null));
                }
                if (data.getItem(VdsProperties.GLOBAL_GATEWAY) != null) {
                    iface.setGateway((String) ((data.getItem(VdsProperties.GLOBAL_GATEWAY) instanceof String) ? data.getItem(VdsProperties.GLOBAL_GATEWAY) : null));
                }
                if (data.getItem("slaves") != null) {
                    Object[] interfaces = (Object[]) ((data.getItem("slaves") instanceof Object[]) ? data.getItem("slaves") : null);
                    iStats.setVdsId(vds.getId());
                    AddBond(vds, iface, interfaces);
                }
                if (StringUtils.isNotBlank((String) data.getItem(mtu))) {
                    iface.setMtu(Integer.parseInt((String) data.getItem(mtu)));
                }
                XmlRpcStruct config = (data.getItem("cfg") instanceof Map) ? new XmlRpcStruct((Map) data.getItem("cfg")) : null;
                if (config != null && config.getItem("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.getItem("BONDING_OPTS").toString());
                }
                AddBootProtocol(config, iface);
            }
        }
    }
    // network to vlan map
    Map<String, Integer> networkVlans = new java.util.HashMap<String, Integer>();
    // Networks collection (name point to list of nics or bonds)
    java.util.Map<String, Object> networks = (java.util.Map) ((xmlRpcStruct.getItem(VdsProperties.network_networks) instanceof java.util.Map) ? xmlRpcStruct.getItem(VdsProperties.network_networks) : null);
    if (networks != null) {
        vds.getNetworks().clear();
        for (String key : networks.keySet()) {
            java.util.Map<String, Object> networkAsMap = (java.util.Map) ((networks.get(key) instanceof java.util.Map) ? networks.get(key) : null);
            XmlRpcStruct network = new XmlRpcStruct(networkAsMap);
            if (network != null) {
                network net = new network();
                net.setname(key);
                if (network.getItem("addr") != null) {
                    net.setaddr(network.getItem("addr").toString());
                }
                if (network.getItem("netmask") != null) {
                    net.setsubnet(network.getItem("netmask").toString());
                }
                if (network.getItem(VdsProperties.GLOBAL_GATEWAY) != null) {
                    net.setgateway(network.getItem(VdsProperties.GLOBAL_GATEWAY).toString());
                }
                if (StringUtils.isNotBlank((String) network.getItem(mtu))) {
                    net.setMtu(Integer.parseInt((String) network.getItem(mtu)));
                }
                // map interface to network
                Object[] ports = (Object[]) ((network.getItem("ports") instanceof Object[]) ? network.getItem("ports") : null);
                if (ports != null) {
                    for (Object port : ports) {
                        VdsNetworkInterface iface = null;
                        for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                            if (tempInterface.getName().equals(port.toString())) {
                                iface = tempInterface;
                                break;
                            }
                        }
                        if (iface != null) {
                            iface.setNetworkName(net.getname());
                            if (currVlans.containsKey(iface.getName())) {
                                networkVlans.put(net.getname(), currVlans.get(iface.getName()));
                            }
                            iface.setAddress(net.getaddr());
                            // ifaces is bridged if it is reported as one of the bridge ports
                            iface.setBridged(true);
                            // set the management ip
                            if (StringHelper.EqOp(iface.getNetworkName(), NetworkUtils.EngineNetwork)) {
                                iface.setType(iface.getType() | VdsInterfaceType.Management.getValue());
                            }
                            iface.setSubnet(net.getsubnet());
                            iface.setGateway(net.getgateway());
                            java.util.Map networkConfigAsMap = (java.util.Map) ((network.getItem("cfg") instanceof java.util.Map) ? network.getItem("cfg") : null);
                            XmlRpcStruct networkConfig = networkConfigAsMap == null ? null : new XmlRpcStruct(networkConfigAsMap);
                            AddBootProtocol(networkConfig, iface);
                        }
                    }
                }
                vds.getNetworks().add(net);
            }
        }
    }
    // Check vlans are line with Clusters vlans
    checkClusterVlans(vds, networkVlans);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
}
#end_block

#method_before
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, boolean saveToDb, Guid domainId, Map<String, String> customLogValues) {
    ExecutionHandler.updateSpecificActionJobCompleted(vdsId, VdcActionType.MaintananceVds, false);
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, reason, customLogValues);
    tempVar.setSaveToDb(saveToDb);
    tempVar.setStorageDomainId(domainId);
    tempVar.setShouldBeLogged(logCommand);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
}
#method_after
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, boolean saveToDb, Guid domainId) {
    vdsNonOperational(vdsId, reason, logCommand, saveToDb, domainId, null);
}
#end_block

#method_before
@Override
public void processOnCpuFlagsChange(Guid vdsId) {
    Backend.getInstance().runInternalAction(VdcActionType.HandleVdsCpuFlagsOrClusterChanged, new VdsActionParameters(vdsId));
    Backend.getInstance().runInternalAction(VdcActionType.HandleVdsVersion, new VdsActionParameters(vdsId));
}
#method_after
@Override
public void processOnCpuFlagsChange(Guid vdsId) {
    Backend.getInstance().runInternalAction(VdcActionType.HandleVdsCpuFlagsOrClusterChanged, new VdsActionParameters(vdsId));
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    try {
        setIsSetNonOperationalExecuted(false);
        Guid vdsId = null;
        Guid storagePoolId = null;
        String vdsName = null;
        ArrayList<VDSDomainsData> domainsList = null;
        synchronized (getLockObj()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    {
                        _vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
                        if (_vds == null) {
                            log.errorFormat("ResourceManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                            return null;
                        }
                        try {
                            if (_refreshIteration == _numberRefreshesBeforeSave) {
                                _refreshIteration = 1;
                            } else {
                                _refreshIteration++;
                            }
                            if ((_vds.getstatus() != VDSStatus.NonOperational || (_vds.getvm_count() > 0)) && (_vds.getstatus() != VDSStatus.Installing && _vds.getstatus() != VDSStatus.InstallFailed && _vds.getstatus() != VDSStatus.Reboot && _vds.getstatus() != VDSStatus.Maintenance && _vds.getstatus() != VDSStatus.PendingApproval && _vds.getstatus() != VDSStatus.Down)) {
                                _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds);
                                _vdsUpdater.Refresh();
                                mUnrespondedAttempts.set(0);
                                mLastUpdate = DateTime.getNow();
                            }
                            if (!getInitialized() && getVds().getstatus() != VDSStatus.NonResponsive && getVds().getstatus() != VDSStatus.PendingApproval) {
                                log.info("Initializing Host: " + getVds().getvds_name());
                                ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                                setInitialized(true);
                            }
                        } catch (VDSNetworkException e) {
                            logNetworkException(e);
                        } catch (VDSRecoveringException ex) {
                            HandleVdsRecoveringException(ex);
                        } catch (IRSErrorException ex) {
                            logFailureMessage(ex);
                            if (log.isDebugEnabled()) {
                                logException(ex);
                            }
                        } catch (RuntimeException ex) {
                            logFailureMessage(ex);
                            logException(ex);
                        }
                    }
                    return null;
                }

                private void logFailureMessage(RuntimeException ex) {
                    log.warnFormat("ResourceManager::refreshVdsRunTimeInfo::Failed to refresh VDS , vds = {0} : {1}, error = '{2}', continuing.", _vds.getId(), _vds.getvds_name(), ExceptionUtils.getMessage(ex));
                }
            });
            try {
                if (_vdsUpdater != null) {
                    _vdsUpdater.AfterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (_vds != null && _vds.getstatus() != VDSStatus.Maintenance) {
                        vdsId = _vds.getId();
                        vdsName = _vds.getvds_name();
                        storagePoolId = _vds.getstorage_pool_id();
                        domainsList = _vds.getDomains();
                    }
                }
                _vds = null;
                _vdsUpdater = null;
            } catch (IRSErrorException ex) {
                logFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logFailureMessage(ex);
                logException(ex);
            }
        }
        // synchronized part of code
        if (domainsList != null) {
            IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, domainsList);
        }
    } catch (Exception e) {
        log.error("Timer update runtimeinfo failed. Exception:", e);
    }
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    try {
        setIsSetNonOperationalExecuted(false);
        Guid vdsId = null;
        Guid storagePoolId = null;
        String vdsName = null;
        ArrayList<VDSDomainsData> domainsList = null;
        synchronized (getLockObj()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    {
                        _vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
                        if (_vds == null) {
                            log.errorFormat("ResourceManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                            return null;
                        }
                        try {
                            if (_refreshIteration == _numberRefreshesBeforeSave) {
                                _refreshIteration = 1;
                            } else {
                                _refreshIteration++;
                            }
                            if (isMonitoringNeeded()) {
                                _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds);
                                _vdsUpdater.Refresh();
                                mUnrespondedAttempts.set(0);
                                mLastUpdate = DateTime.getNow();
                            }
                            if (!getInitialized() && getVds().getstatus() != VDSStatus.NonResponsive && getVds().getstatus() != VDSStatus.PendingApproval) {
                                log.info("Initializing Host: " + getVds().getvds_name());
                                ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                                setInitialized(true);
                            }
                        } catch (VDSNetworkException e) {
                            logNetworkException(e);
                        } catch (VDSRecoveringException ex) {
                            HandleVdsRecoveringException(ex);
                        } catch (IRSErrorException ex) {
                            logFailureMessage(ex);
                            if (log.isDebugEnabled()) {
                                logException(ex);
                            }
                        } catch (RuntimeException ex) {
                            logFailureMessage(ex);
                            logException(ex);
                        }
                    }
                    return null;
                }

                private void logFailureMessage(RuntimeException ex) {
                    log.warnFormat("ResourceManager::refreshVdsRunTimeInfo::Failed to refresh VDS , vds = {0} : {1}, error = '{2}', continuing.", _vds.getId(), _vds.getvds_name(), ExceptionUtils.getMessage(ex));
                }
            });
            try {
                if (_vdsUpdater != null) {
                    _vdsUpdater.AfterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (_vds != null && _vds.getstatus() != VDSStatus.Maintenance) {
                        vdsId = _vds.getId();
                        vdsName = _vds.getvds_name();
                        storagePoolId = _vds.getstorage_pool_id();
                        domainsList = _vds.getDomains();
                    }
                }
                _vds = null;
                _vdsUpdater = null;
            } catch (IRSErrorException ex) {
                logFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logFailureMessage(ex);
                logException(ex);
            }
        }
        // synchronized part of code
        if (domainsList != null) {
            IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, domainsList);
        }
    } catch (Exception e) {
        log.error("Timer update runtimeinfo failed. Exception:", e);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimerHandleVdsRecovering")
public void onTimerHandleVdsRecovering() {
    recoveringJobIdMap.remove(getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
    if (vds.getstatus() == VDSStatus.Initializing) {
        try {
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH, true, true, Guid.Empty, null);
            setIsSetNonOperationalExecuted(true);
        } catch (RuntimeException exp) {
            log.errorFormat("HandleVdsRecoveringException::Error in recovery timer treatment, vds = {0} : {1}, error = {2}.", vds.getId(), vds.getvds_name(), exp.getMessage());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimerHandleVdsRecovering")
public void onTimerHandleVdsRecovering() {
    recoveringJobIdMap.remove(getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
    if (vds.getstatus() == VDSStatus.Initializing) {
        try {
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH, true, true, Guid.Empty);
            setIsSetNonOperationalExecuted(true);
        } catch (RuntimeException exp) {
            log.errorFormat("HandleVdsRecoveringException::Error in recovery timer treatment, vds = {0} : {1}, error = {2}.", vds.getId(), vds.getvds_name(), exp.getMessage());
        }
    }
}
#end_block

#method_before
public void activate() {
    VDS vds = null;
    boolean cpuFlagsChanged = false;
    try {
        // new VdsIdVDSCommandParametersBase(_vds.vds_id));
        if (log.isDebugEnabled()) {
            log.debugFormat("ResourceManager::activateVds - trying to activate host {0} , meanwhile setting status to Unassigned meanwhile", getVdsId());
        }
        vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
        /**
         * refresh capabilities
         */
        RefObject<Boolean> tempRefObject = new RefObject<Boolean>(cpuFlagsChanged);
        VDSStatus newStatus = refreshCapabilities(tempRefObject, vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("ResourceManager::activateVds - success to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
        cpuFlagsChanged = tempRefObject.argvalue;
    } catch (java.lang.Exception e) {
        log.infoFormat("ResourceManager::activateVds - failed to get VDS = {0} capabilities with error: {1}.", getVdsId(), e.getMessage());
        log.infoFormat("ResourceManager::activateVds - failed to activate VDS = {0}", getVdsId());
    } finally {
        if (vds != null) {
            UpdateDynamicData(vds.getDynamicData());
            // always check flags in case host cluster changed
            ResourceManager.getInstance().getEventListener().processOnCpuFlagsChange(vds.getId());
        }
    }
}
#method_after
public void activate() {
    VDS vds = null;
    boolean processHardwareCapsNeeded = false;
    try {
        // new VdsIdVDSCommandParametersBase(_vds.vds_id));
        if (log.isDebugEnabled()) {
            log.debugFormat("ResourceManager::activateVds - trying to activate host {0} , meanwhile setting status to Unassigned meanwhile", getVdsId());
        }
        vds = DbFacade.getInstance().getVdsDAO().get(getVdsId());
        /**
         * refresh capabilities
         */
        RefObject<Boolean> tempRefObject = new RefObject<Boolean>(processHardwareCapsNeeded);
        VDSStatus newStatus = refreshCapabilities(tempRefObject, vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("ResourceManager::activateVds - success to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
        processHardwareCapsNeeded = tempRefObject.argvalue;
    } catch (java.lang.Exception e) {
        log.infoFormat("ResourceManager::activateVds - failed to get VDS = {0} capabilities with error: {1}.", getVdsId(), e.getMessage());
        log.infoFormat("ResourceManager::activateVds - failed to activate VDS = {0}", getVdsId());
    } finally {
        if (vds != null) {
            UpdateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(RefObject<Boolean> cpuFlagsHasChanged, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    String oldFlags = vds.getcpu_flags();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks  not match it's cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        if (vds.getkvm_enabled() != null && vds.getkvm_enabled().equals(false) && vds.getstatus() != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} has not kvm, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.KVM_NOT_RUNNING, true, true, Guid.Empty, null);
            vds.setstatus(VDSStatus.NonOperational);
            returnStatus = vds.getstatus();
            setIsSetNonOperationalExecuted(true);
        }
        cpuFlagsHasChanged.argvalue = (!StringHelper.EqOp(oldFlags, vds.getcpu_flags()));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(RefObject<Boolean> processHardwareCapsNeeded, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks  not match it's cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.argvalue = monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds);
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    XmlRpcStruct bonds = new XmlRpcStruct();
    XmlRpcStruct networks = new XmlRpcStruct();
    Map<String, String> removeObj = new HashMap<String, String>();
    removeObj.put("remove", "true");
    // Networks
    for (network net : getParameters().getNetworks()) {
        Map<String, String> opts = new HashMap<String, String>();
        VdsNetworkInterface i = findNetworkInterface(net.getname(), getParameters().getInterfaces(), getParameters().getBonds());
        String type = (i.getBonded() != null && i.getBonded()) ? "bonding" : "nic";
        opts.put(type, NetworkUtils.StripVlan(i.getName()));
        if (net.getvlan_id() != null) {
            opts.put("vlan", net.getvlan_id().toString());
        }
        // TODO: add bootproto to network object
        switch(i.getBootProtocol()) {
            case Dhcp:
                opts.put(VdsProperties.bootproto, VdsProperties.dhcp);
                break;
            case StaticIp:
                if (!StringHelper.isNullOrEmpty(i.getAddress())) {
                    opts.put("ipaddr", i.getAddress());
                }
                if (!StringHelper.isNullOrEmpty(i.getSubnet())) {
                    opts.put("netmask", i.getSubnet());
                }
                if (!StringHelper.isNullOrEmpty(i.getGateway())) {
                    opts.put("gateway", i.getGateway());
                }
                break;
        }
        opts.put("bridged", net.isVmNetwork() ? "true" : "false");
        networks.add(net.getname(), opts);
    }
    // Removed Networks
    for (network net : getParameters().getRemovedNetworks()) {
        networks.add(net.getname(), removeObj);
    }
    // Bonds
    for (VdsNetworkInterface bond : getParameters().getBonds()) {
        XmlRpcStruct opts = new XmlRpcStruct();
        opts.add("nics", getBondNics(bond, getParameters().getInterfaces()));
        if (!StringHelper.isNullOrEmpty(bond.getBondOptions())) {
            opts.add("BONDING_OPTS", bond.getBondOptions());
        }
        bonds.add(bond.getName(), opts);
    }
    // Removed Bonds
    for (VdsNetworkInterface bond : getParameters().getRemovedBonds()) {
        bonds.add(bond.getName(), removeObj);
    }
    // Options
    XmlRpcStruct options = new XmlRpcStruct();
    if (getParameters().isCheckConnectivity()) {
        options.add(VdsProperties.connectivityCheck, "true");
    } else {
        options.add(VdsProperties.connectivityCheck, "false");
    }
    if (getParameters().getConectivityTimeout() >= 0) {
        options.add(VdsProperties.connectivityTimeout, (new Integer(getParameters().getConectivityTimeout())).toString());
    }
    httpTask = getBroker().setupNetworks(networks, bonds, options);
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    XmlRpcStruct bonds = new XmlRpcStruct();
    XmlRpcStruct networks = new XmlRpcStruct();
    Map<String, String> removeObj = new HashMap<String, String>();
    removeObj.put("remove", "true");
    // Networks
    for (network net : getParameters().getNetworks()) {
        Map<String, String> opts = new HashMap<String, String>();
        VdsNetworkInterface i = findNetworkInterface(net.getname(), getParameters().getInterfaces(), getParameters().getBonds());
        String type = (i.getBonded() != null && i.getBonded()) ? "bonding" : "nic";
        opts.put(type, NetworkUtils.StripVlan(i.getName()));
        if (net.getvlan_id() != null) {
            opts.put("vlan", net.getvlan_id().toString());
        }
        // TODO: add bootproto to network object
        switch(i.getBootProtocol()) {
            case Dhcp:
                opts.put(VdsProperties.bootproto, VdsProperties.dhcp);
                break;
            case StaticIp:
                if (!StringHelper.isNullOrEmpty(i.getAddress())) {
                    opts.put("ipaddr", i.getAddress());
                }
                if (!StringHelper.isNullOrEmpty(i.getSubnet())) {
                    opts.put("netmask", i.getSubnet());
                }
                if (!StringHelper.isNullOrEmpty(i.getGateway())) {
                    opts.put("gateway", i.getGateway());
                }
                break;
        }
        if (net.getMtu() != 0) {
            opts.put("mtu", String.valueOf(net.getMtu()));
        }
        opts.put("bridged", Boolean.toString(net.isVmNetwork()));
        networks.add(net.getname(), opts);
    }
    // Removed Networks
    for (network net : getParameters().getRemovedNetworks()) {
        networks.add(net.getname(), removeObj);
    }
    // Bonds
    for (VdsNetworkInterface bond : getParameters().getBonds()) {
        XmlRpcStruct opts = new XmlRpcStruct();
        opts.add("nics", getBondNics(bond, getParameters().getInterfaces()));
        if (!StringHelper.isNullOrEmpty(bond.getBondOptions())) {
            opts.add("BONDING_OPTS", bond.getBondOptions());
        }
        bonds.add(bond.getName(), opts);
    }
    // Removed Bonds
    for (VdsNetworkInterface bond : getParameters().getRemovedBonds()) {
        bonds.add(bond.getName(), removeObj);
    }
    // Options
    XmlRpcStruct options = new XmlRpcStruct();
    if (getParameters().isCheckConnectivity()) {
        options.add(VdsProperties.connectivityCheck, "true");
    } else {
        options.add(VdsProperties.connectivityCheck, "false");
    }
    if (getParameters().getConectivityTimeout() >= 0) {
        options.add(VdsProperties.connectivityTimeout, (new Integer(getParameters().getConectivityTimeout())).toString());
    }
    httpTask = getBroker().setupNetworks(networks, bonds, options);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    boolean retVal = ImportExportCommon.checkStoragePool(getStoragePool(), canDoActionMessages);
    Map<Guid, storage_domains> domainsMap = null;
    if (retVal) {
        domainsMap = new HashMap<Guid, storage_domains>();
        for (Guid destGuid : imageToDestinationDomainMap.values()) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                for (DiskImage image : getVm().getImages()) {
                    for (DiskImage p : imageList) {
                        // only if requested by the user
                        if (getParameters().getCopyCollapse()) {
                            if (p.getId().equals(image.getId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                            }
                        }
                        if (image.getimage_group_id().equals(p.getimage_group_id()) && !imageToDestinationDomainMap.containsKey(image.getId())) {
                            imageToDestinationDomainMap.put(image.getId(), imageToDestinationDomainMap.get(p.getId()));
                        }
                    }
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<String, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                    for (String drive : images.keySet()) {
                        List<DiskImage> list = images.get(drive);
                        getVm().addDriveToImageMap(drive, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getParameters().getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    // check that the imported vm name is not in engine
    if (retVal) {
        List<VmStatic> dupVmNames = getVmStaticDAO().getAllByName(getParameters().getVm().getvm_name());
        if (dupVmNames.size() >= 1) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", getVm().getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getDiskInfoList() != null) {
        for (DiskImageBase imageBase : getParameters().getDiskInfoList().values()) {
            DiskImage key = getVm().getDiskMap().get(imageBase.getinternal_drive_mapping());
            if (key != null) {
                retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), imageBase, canDoActionMessages);
                if (!retVal) {
                    break;
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    boolean retVal = checkStoragePool();
    Map<Guid, storage_domains> domainsMap = null;
    if (retVal) {
        domainsMap = new HashMap<Guid, storage_domains>();
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                for (DiskImage image : getVm().getImages()) {
                    for (DiskImage p : imageList) {
                        // only if requested by the user
                        if (getParameters().getCopyCollapse()) {
                            if (p.getId().equals(image.getId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                            }
                        }
                        if (image.getimage_group_id().equals(p.getimage_group_id()) && !imageToDestinationDomainMap.containsKey(image.getId())) {
                            imageToDestinationDomainMap.put(image.getId(), imageToDestinationDomainMap.get(p.getId()));
                        }
                    }
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<String, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                    for (String drive : images.keySet()) {
                        List<DiskImage> list = images.get(drive);
                        getVm().addDriveToImageMap(drive, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getParameters().getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getDiskInfoList() != null) {
        for (DiskImageBase imageBase : getParameters().getDiskInfoList().values()) {
            DiskImage key = getVm().getDiskMap().get(imageBase.getinternal_drive_mapping());
            if (key != null) {
                retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), imageBase, canDoActionMessages);
                if (!retVal) {
                    break;
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
private void processImages() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmImages();
            MoveOrCopyAllImageGroups();
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getVm().getId());
            VmHandler.LockVm(getVm().getId());
            return null;
        }
    });
}
#method_after
private void processImages() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            MoveOrCopyAllImageGroups();
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getVm().getId(), new ArrayList<VmDevice>(), new ArrayList<VmDevice>());
            VmHandler.LockVm(getVm().getId());
            return null;
        }
    });
}
#end_block

#method_before
public static Map<String, List<DiskImage>> GetImagesLeaf(List<DiskImage> images) {
    Map<String, List<DiskImage>> retVal = new HashMap<String, List<DiskImage>>();
    for (DiskImage image : images) {
        if (!retVal.keySet().contains(image.getinternal_drive_mapping())) {
            retVal.put(image.getinternal_drive_mapping(), new ArrayList<DiskImage>(Arrays.asList(new DiskImage[] { image })));
        } else {
            retVal.get(image.getinternal_drive_mapping()).add(image);
        }
    }
    for (String key : retVal.keySet()) {
        SortImageList(retVal.get(key));
    }
    return retVal;
}
#method_after
public static Map<String, List<DiskImage>> GetImagesLeaf(List<DiskImage> images) {
    Map<String, List<DiskImage>> retVal = new HashMap<String, List<DiskImage>>();
    for (DiskImage image : images) {
        MultiValueMapUtils.addToMap(image.getinternal_drive_mapping(), image, retVal);
    }
    for (String key : retVal.keySet()) {
        SortImageList(retVal.get(key));
    }
    return retVal;
}
#end_block

#method_before
private void addInterfacesFromTemplate() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
        iface.setVmTemplateId(null);
        iface.setVmId(getVm().getStaticData().getId());
        iface.setVmName(getVm().getvm_name());
        macAdded = vmInterfaceManager.add(iface, getCompensationContext());
    }
}
#method_after
private void addInterfacesFromTemplate() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        iface.setVmTemplateId(null);
        iface.setVmId(getVm().getStaticData().getId());
        iface.setVmName(getVm().getvm_name());
        macAdded = vmInterfaceManager.add(iface, getCompensationContext());
    }
}
#end_block

#method_before
protected void EndImportCommand() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm().getId());
        UpdateVmImSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#method_after
protected void EndImportCommand() {
    setVm(null);
    EndActionOnAllImageGroups();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm().getId());
        UpdateVmImSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#end_block

#method_before
private void auditInvalidInterfaces() {
    List<VmNetworkInterface> interfaces = getVm().getInterfaces();
    Map<String, network> networksByName = Entities.entitiesByName(DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    StringBuffer networks = new StringBuffer();
    for (VmNetworkInterface iface : interfaces) {
        if (networksByName.containsKey(iface.getNetworkName()) && !networksByName.get(iface.getNetworkName()).isVmNetwork()) {
            networks.append(iface.getNetworkName()).append(",");
        }
    }
    if (networks.length() > 0) {
        // remove the last comma
        networks.deleteCharAt(networks.length());
        AuditLogableBase logable = new AuditLogableBase();
        logable.AddCustomValue("Newtorks", networks.toString());
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_INTERFACES_ON_NON_VM_NETWORKS);
    }
}
#method_after
private void auditInvalidInterfaces() {
    List<VmNetworkInterface> interfaces = getVm().getInterfaces();
    Map<String, network> networksByName = Entities.entitiesByName(DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    StringBuilder networks = new StringBuilder();
    StringBuilder ifaces = new StringBuilder();
    for (VmNetworkInterface iface : interfaces) {
        if (networksByName.containsKey(iface.getNetworkName()) && !networksByName.get(iface.getNetworkName()).isVmNetwork()) {
            networks.append(iface.getNetworkName()).append(",");
            ifaces.append(iface.getName()).append(",");
        }
    }
    if (networks.length() > 0) {
        // remove the last comma
        networks.deleteCharAt(networks.length());
        AuditLogableBase logable = new AuditLogableBase();
        logable.AddCustomValue("Newtorks", networks.toString());
        logable.AddCustomValue("Interfaces", ifaces.toString());
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_INTERFACES_ON_NON_VM_NETWORKS);
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && !getVm().getDiskList().isEmpty() && getVm().getstatus() != VMStatus.Suspended) {
                StatelessVmTreatment();
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() > 0) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && !getVm().getDiskList().isEmpty() && getVm().getstatus() != VMStatus.Suspended) {
                StatelessVmTreatment();
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
private void StatelessVmTreatment() {
    /**
     * if one of vm's images is in the DB dont do anything.
     */
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() == 0) {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        lockVmWithCompensationIfNeeded();
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            // RestoreAllSnapshots)
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * add new stateless vm image to db
                 */
                DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(disk.getId(), disk.getinternal_drive_mapping(), getVm().getId()));
            }
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getReturnValue().setFault(vdcReturnValue.getFault());
            }
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    } else {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    }
}
#method_after
private void StatelessVmTreatment() {
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    }
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    Guid storageDomainId = vmImages.get(0).getstorage_ids().get(0);
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                        retValue = false;
                    } else // Check if iso and floppy path exists
                    if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = getPluggedImages(vm);
        if (boot_sequence == BootSequence.C && vmImages.size() == 0) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmImages)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vm.getId())) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected static boolean validateIsoPath(Guid storageDomainId, RunVmParams runParams, java.util.ArrayList<String> messages) {
    if (!StringHelper.isNullOrEmpty(runParams.getDiskPath())) {
        if (storageDomainId == null) {
            messages.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
            return false;
        }
        boolean retValForIso = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllIsoImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getDiskPath())) {
                        retValForIso = true;
                        break;
                    }
                }
            }
        }
        if (!retValForIso) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH.toString());
            return false;
        }
    }
    if (!StringHelper.isNullOrEmpty(runParams.getFloppyPath())) {
        boolean retValForFloppy = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllFloppyImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getFloppyPath())) {
                        retValForFloppy = true;
                        break;
                    }
                }
            }
        }
        if (!retValForFloppy) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH.toString());
            return false;
        }
    }
    return true;
}
#method_after
@SuppressWarnings("unchecked")
protected static boolean validateIsoPath(Guid storageDomainId, RunVmParams runParams, ArrayList<String> messages) {
    if (!StringHelper.isNullOrEmpty(runParams.getDiskPath())) {
        if (storageDomainId == null) {
            messages.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
            return false;
        }
        boolean retValForIso = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllIsoImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getDiskPath())) {
                        retValForIso = true;
                        break;
                    }
                }
            }
        }
        if (!retValForIso) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH.toString());
            return false;
        }
    }
    if (!StringHelper.isNullOrEmpty(runParams.getFloppyPath())) {
        boolean retValForFloppy = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllFloppyImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getFloppyPath())) {
                        retValForFloppy = true;
                        break;
                    }
                }
            }
        }
        if (!retValForFloppy) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH.toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // setting the RunVmParams Internal flag according to the command Internal flag.
    // we can not use only the command Internal flag and remove this flag from RunVmParams
    // since canRunVm is static and can not call non-static method isInternalExecution
    getParameters().setIsInternal(isInternalExecution());
    boolean canDoAction = CanRunVm();
    return canDoAction;
}
#method_after
@Override
protected boolean canDoAction() {
    // setting the RunVmParams Internal flag according to the command Internal flag.
    // we can not use only the command Internal flag and remove this flag from RunVmParams
    // since canRunVm is static and can not call non-static method isInternalExecution
    getParameters().setIsInternal(isInternalExecution());
    boolean canDoAction = CanRunVm(getVm(), getReturnValue().getCanDoActionMessages(), getParameters(), getVdsSelector(), getSnapshotsValidator()) && isVmInterfacesAttachedToVmNetworks();
    return canDoAction;
}
#end_block

#method_before
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RUN);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RUN);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        if (getVm() != null) {
            VmHandler.updateDisksFromDb(getVm());
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * remove stateless vm image from db:
                 */
                DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(disk.getId());
            }
        } else {
            setCommandShouldBeLogged(false);
            log.warn("RunVmCommand::EndWithFailure [stateless]: Vm is null - not performing full EndAction");
        }
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.EndWithFailure();
    }
}
#method_after
@Override
protected void EndWithFailure() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.EndWithFailure();
    }
}
#end_block

#method_before
private void SetIsVmRunningStateless() {
    List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
    _isVmRunningStateless = (list != null && list.size() > 0);
}
#method_after
private void SetIsVmRunningStateless() {
    _isVmRunningStateless = statelessSnapshotExistsForVm();
}
#end_block

#method_before
protected void removeQuotaCommandLeftOver() {
    QuotaManager.removeVdsGroupDeltaQuotaCommand(getQuotaId(), getVm().getvds_group_id(), getCommandId());
}
#method_after
@Override
protected void removeQuotaCommandLeftOver() {
    QuotaManager.removeVdsGroupDeltaQuotaCommand(getQuotaId(), getVm().getvds_group_id(), getCommandId());
}
#end_block

#method_before
private boolean isVmInterfacesAttachedToVmNetworks() {
    Map<String, VmNetworkInterface> interfacesByNetworkName = Entities.interfacesByNetworkName(getVm().getInterfaces());
    List<String> nonVmNetworkNames = NetworkUtils.filterNonVmNetworkNames(DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVm().getvds_group_id()), interfacesByNetworkName.keySet());
    if (nonVmNetworkNames.size() > 0) {
        AddCustomValue("Networks", StringUtils.join(nonVmNetworkNames, ","));
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        return false;
    }
    return true;
}
#method_after
private boolean isVmInterfacesAttachedToVmNetworks() {
    List<String> nonVmNetworkNames = NetworkUtils.filterNonVmNetworkNames(DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVm().getvds_group_id()), Entities.interfacesByNetworkName(getVm().getInterfaces()).keySet());
    if (nonVmNetworkNames.size() > 0) {
        AddCustomValue("Networks", StringUtils.join(nonVmNetworkNames, ","));
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        return false;
    }
    return true;
}
#end_block

#method_before
public static <E extends Nameble> Map<String, E> entitiesByName(List<E> entityList) {
    if (entityList != null) {
        Map<String, E> map = new HashMap<String, E>();
        for (E e : entityList) {
            map.put(e.getName(), e);
        }
        return map;
    } else {
        return Collections.emptyMap();
    }
}
#method_after
public static <E extends Nameable> Map<String, E> entitiesByName(List<E> entityList) {
    if (entityList != null) {
        Map<String, E> map = new HashMap<String, E>();
        for (E e : entityList) {
            map.put(e.getName(), e);
        }
        return map;
    } else {
        return Collections.emptyMap();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((addr == null) ? 0 : addr.hashCode());
    // FIXME: remove cluster from hashCode calculation - breaks the tests when working in JDBC template mode
    /*
        result = prime * result + ((cluster == null) ? 0 : cluster.hashCode());
        */
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((storage_pool_id == null) ? 0 : storage_pool_id.hashCode());
    result = prime * result + (stp ? 1231 : 1237);
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((vlan_id == null) ? 0 : vlan_id.hashCode());
    result = prime * result + ((vmNetwork) ? 11 : 13);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((addr == null) ? 0 : addr.hashCode());
    // FIXME: remove cluster from hashCode calculation - breaks the tests when working in JDBC template mode
    /*
        result = prime * result + ((cluster == null) ? 0 : cluster.hashCode());
        */
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((storage_pool_id == null) ? 0 : storage_pool_id.hashCode());
    result = prime * result + (stp ? 1231 : 1237);
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((vlan_id == null) ? 0 : vlan_id.hashCode());
    result = prime * result + (mtu);
    result = prime * result + ((vmNetwork) ? 11 : 13);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    network other = (network) obj;
    if (addr == null) {
        if (other.addr != null)
            return false;
    } else if (!addr.equals(other.addr))
        return false;
    /*
        if (cluster == null) {
            if (other.cluster != null)
                return false;
        } else if (!cluster.equals(other.cluster))
            return false;
            */
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (gateway == null) {
        if (other.gateway != null)
            return false;
    } else if (!gateway.equals(other.gateway))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (storage_pool_id == null) {
        if (other.storage_pool_id != null)
            return false;
    } else if (!storage_pool_id.equals(other.storage_pool_id))
        return false;
    if (stp != other.stp)
        return false;
    if (subnet == null) {
        if (other.subnet != null)
            return false;
    } else if (!subnet.equals(other.subnet))
        return false;
    if (type == null) {
        if (other.type != null)
            return false;
    } else if (!type.equals(other.type))
        return false;
    if (vlan_id == null) {
        if (other.vlan_id != null)
            return false;
    } else if (!vlan_id.equals(other.vlan_id))
        return false;
    if (vmNetwork != other.vmNetwork) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    network other = (network) obj;
    if (addr == null) {
        if (other.addr != null)
            return false;
    } else if (!addr.equals(other.addr))
        return false;
    /*
        if (cluster == null) {
            if (other.cluster != null)
                return false;
        } else if (!cluster.equals(other.cluster))
            return false;
            */
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (gateway == null) {
        if (other.gateway != null)
            return false;
    } else if (!gateway.equals(other.gateway))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (storage_pool_id == null) {
        if (other.storage_pool_id != null)
            return false;
    } else if (!storage_pool_id.equals(other.storage_pool_id))
        return false;
    if (stp != other.stp)
        return false;
    if (subnet == null) {
        if (other.subnet != null)
            return false;
    } else if (!subnet.equals(other.subnet))
        return false;
    if (type == null) {
        if (other.type != null)
            return false;
    } else if (!type.equals(other.type))
        return false;
    if (vlan_id == null) {
        if (other.vlan_id != null)
            return false;
    } else if (!vlan_id.equals(other.vlan_id))
        return false;
    if (mtu != other.mtu)
        return false;
    if (vmNetwork != other.vmNetwork) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public /**
 * test setup: 2 existing cluster networks, red and blue, only blue is currently attached to the host
 * test case: sending "red" as the network to add
 * expected: network blue should return from the function
 */
void extractRemovedNetwork() {
    initMocks(null, null);
    SetupNetworksHelper helper = createHelper(new SetupNetworksParameters());
    String[] networkNames = { "red" };
    Map<String, network> clusterNetworksMap = new HashMap<String, network>();
    clusterNetworksMap.put("red", new network(null, null, null, "red", null, null, 1, 100, false, true));
    clusterNetworksMap.put("blue", new network(null, null, null, "blue", null, null, 1, 100, false, true));
    List<network> removeNetworks = helper.extractRemoveNetworks(new HashSet<String>(asList(networkNames)), clusterNetworksMap, Arrays.asList("blue"));
    assertTrue(removeNetworks.get(0).getname().equals("blue"));
}
#method_after
@Test
public /**
 * test setup: 2 existing cluster networks, red and blue, only blue is currently attached to the host
 * test case: sending "red" as the network to add
 * expected: network blue should return from the function
 */
void extractRemovedNetwork() {
    initMocks(null, null);
    SetupNetworksHelper helper = createHelper(new SetupNetworksParameters());
    String[] networkNames = { "red" };
    Map<String, network> clusterNetworksMap = new HashMap<String, network>();
    clusterNetworksMap.put("red", new network(null, null, null, "red", null, null, 1, 100, false, 1500, true));
    clusterNetworksMap.put("blue", new network(null, null, null, "blue", null, null, 1, 100, false, 1500, true));
    List<network> removeNetworks = helper.extractRemoveNetworks(new HashSet<String>(asList(networkNames)), clusterNetworksMap, Arrays.asList("blue"));
    assertTrue(removeNetworks.get(0).getname().equals("blue"));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getaddr()).addValue("description", network.getdescription()).addValue("id", network.getId()).addValue("name", network.getname()).addValue("subnet", network.getsubnet()).addValue("gateway", network.getgateway()).addValue("type", network.gettype()).addValue("vlan_id", network.getvlan_id()).addValue("stp", network.getstp()).addValue("storage_pool_id", network.getstorage_pool_id()).addValue("vm_network", network.isVmNetwork());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getaddr()).addValue("description", network.getdescription()).addValue("id", network.getId()).addValue("name", network.getname()).addValue("subnet", network.getsubnet()).addValue("gateway", network.getgateway()).addValue("type", network.gettype()).addValue("vlan_id", network.getvlan_id()).addValue("stp", network.getstp()).addValue("storage_pool_id", network.getstorage_pool_id()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork());
}
#end_block

#method_before
@Override
public void saveInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", stats.getAddress()).addValue("bond_name", stats.getBondName()).addValue("bond_type", stats.getBondType()).addValue("gateway", stats.getGateway()).addValue("id", stats.getId()).addValue("is_bond", stats.getBonded()).addValue("bond_opts", stats.getBondOptions()).addValue("mac_addr", stats.getMacAddress()).addValue("name", stats.getName()).addValue("network_name", stats.getNetworkName()).addValue("speed", stats.getSpeed()).addValue("subnet", stats.getSubnet()).addValue("boot_protocol", stats.getBootProtocol()).addValue("type", stats.getType()).addValue("vds_id", stats.getVdsId()).addValue("vlan_id", stats.getVlanId()).addValue("bridged", stats.isBridged());
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#method_after
@Override
public void saveInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", stats.getAddress()).addValue("bond_name", stats.getBondName()).addValue("bond_type", stats.getBondType()).addValue("gateway", stats.getGateway()).addValue("id", stats.getId()).addValue("is_bond", stats.getBonded()).addValue("bond_opts", stats.getBondOptions()).addValue("mac_addr", stats.getMacAddress()).addValue("name", stats.getName()).addValue("network_name", stats.getNetworkName()).addValue("speed", stats.getSpeed()).addValue("subnet", stats.getSubnet()).addValue("boot_protocol", stats.getBootProtocol()).addValue("type", stats.getType()).addValue("vds_id", stats.getVdsId()).addValue("vlan_id", stats.getVlanId()).addValue("mtu", stats.getMtu()).addValue("bridged", stats.isBridged());
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#end_block

#method_before
@Override
public void updateInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", stats.getAddress()).addValue("bond_name", stats.getBondName()).addValue("bond_type", stats.getBondType()).addValue("gateway", stats.getGateway()).addValue("id", stats.getId()).addValue("is_bond", stats.getBonded()).addValue("bond_opts", stats.getBondOptions()).addValue("mac_addr", stats.getMacAddress()).addValue("name", stats.getName()).addValue("network_name", stats.getNetworkName()).addValue("speed", stats.getSpeed()).addValue("subnet", stats.getSubnet()).addValue("boot_protocol", stats.getBootProtocol()).addValue("type", stats.getType()).addValue("vds_id", stats.getVdsId()).addValue("vlan_id", stats.getVlanId()).addValue("bridged", stats.isBridged());
    getCallsHandler().executeModification("Updatevds_interface", parameterSource);
}
#method_after
@Override
public void updateInterfaceForVds(VdsNetworkInterface stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", stats.getAddress()).addValue("bond_name", stats.getBondName()).addValue("bond_type", stats.getBondType()).addValue("gateway", stats.getGateway()).addValue("id", stats.getId()).addValue("is_bond", stats.getBonded()).addValue("bond_opts", stats.getBondOptions()).addValue("mac_addr", stats.getMacAddress()).addValue("name", stats.getName()).addValue("network_name", stats.getNetworkName()).addValue("speed", stats.getSpeed()).addValue("subnet", stats.getSubnet()).addValue("boot_protocol", stats.getBootProtocol()).addValue("type", stats.getType()).addValue("vds_id", stats.getVdsId()).addValue("vlan_id", stats.getVlanId()).addValue("mtu", stats.getMtu()).addValue("bridged", stats.isBridged());
    getCallsHandler().executeModification("Updatevds_interface", parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<VdsNetworkInterface> getAllInterfacesForVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    ParameterizedRowMapper<VdsNetworkInterface> mapper = new ParameterizedRowMapper<VdsNetworkInterface>() {

        @Override
        public VdsNetworkInterface mapRow(ResultSet rs, int rowNum) throws SQLException {
            VdsNetworkInterface entity = new VdsNetworkInterface();
            entity.getStatistics().setId(Guid.createGuidFromString(rs.getString("id")));
            entity.getStatistics().setReceiveRate(rs.getDouble("rx_rate"));
            entity.getStatistics().setTransmitRate(rs.getDouble("tx_rate"));
            entity.getStatistics().setReceiveDropRate(rs.getDouble("rx_drop"));
            entity.getStatistics().setTransmitDropRate(rs.getDouble("tx_drop"));
            entity.getStatistics().setStatus(InterfaceStatus.forValue(rs.getInt("iface_status")));
            entity.getStatistics().setVdsId(Guid.createGuidFromString(rs.getString("vds_id")));
            entity.setType((Integer) rs.getObject("type"));
            entity.setGateway(rs.getString("gateway"));
            entity.setSubnet(rs.getString("subnet"));
            entity.setAddress(rs.getString("addr"));
            entity.setSpeed((Integer) rs.getObject("speed"));
            entity.setVlanId((Integer) rs.getObject("vlan_id"));
            entity.setBondType((Integer) rs.getObject("bond_type"));
            entity.setBondName(rs.getString("bond_name"));
            entity.setBonded((Boolean) rs.getObject("is_bond"));
            entity.setBondOptions(rs.getString("bond_opts"));
            entity.setMacAddress(rs.getString("mac_addr"));
            entity.setNetworkName(rs.getString("network_name"));
            entity.setName(rs.getString("name"));
            entity.setVdsId(NGuid.createGuidFromString(rs.getString("vds_id")));
            entity.setVdsName(rs.getString("vds_name"));
            entity.setId(Guid.createGuidFromString(rs.getString("id")));
            entity.setBootProtocol(NetworkBootProtocol.forValue(rs.getInt("boot_protocol")));
            entity.setBridged(rs.getBoolean("bridged"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("Getinterface_viewByvds_id", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<VdsNetworkInterface> getAllInterfacesForVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    ParameterizedRowMapper<VdsNetworkInterface> mapper = new ParameterizedRowMapper<VdsNetworkInterface>() {

        @Override
        public VdsNetworkInterface mapRow(ResultSet rs, int rowNum) throws SQLException {
            VdsNetworkInterface entity = new VdsNetworkInterface();
            entity.getStatistics().setId(Guid.createGuidFromString(rs.getString("id")));
            entity.getStatistics().setReceiveRate(rs.getDouble("rx_rate"));
            entity.getStatistics().setTransmitRate(rs.getDouble("tx_rate"));
            entity.getStatistics().setReceiveDropRate(rs.getDouble("rx_drop"));
            entity.getStatistics().setTransmitDropRate(rs.getDouble("tx_drop"));
            entity.getStatistics().setStatus(InterfaceStatus.forValue(rs.getInt("iface_status")));
            entity.getStatistics().setVdsId(Guid.createGuidFromString(rs.getString("vds_id")));
            entity.setType((Integer) rs.getObject("type"));
            entity.setGateway(rs.getString("gateway"));
            entity.setSubnet(rs.getString("subnet"));
            entity.setAddress(rs.getString("addr"));
            entity.setSpeed((Integer) rs.getObject("speed"));
            entity.setVlanId((Integer) rs.getObject("vlan_id"));
            entity.setBondType((Integer) rs.getObject("bond_type"));
            entity.setBondName(rs.getString("bond_name"));
            entity.setBonded((Boolean) rs.getObject("is_bond"));
            entity.setBondOptions(rs.getString("bond_opts"));
            entity.setMacAddress(rs.getString("mac_addr"));
            entity.setNetworkName(rs.getString("network_name"));
            entity.setName(rs.getString("name"));
            entity.setVdsId(NGuid.createGuidFromString(rs.getString("vds_id")));
            entity.setVdsName(rs.getString("vds_name"));
            entity.setId(Guid.createGuidFromString(rs.getString("id")));
            entity.setBootProtocol(NetworkBootProtocol.forValue(rs.getInt("boot_protocol")));
            entity.setMtu(rs.getInt("mtu"));
            entity.setBridged(rs.getBoolean("bridged"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("Getinterface_viewByvds_id", mapper, parameterSource);
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm.getStaticData(), managedDevices, vm.getboot_sequence(), VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version()));
        for (VmDevice vmDevice : managedDevices) {
            for (int i = 0; i < devices.size(); i++) {
                XmlRpcStruct struct = (XmlRpcStruct) devices.get(i);
                Object o = struct.getItem(VdsProperties.SpecParams);
                if (o instanceof Map<?, ?>) {
                    if (StringUtils.map2String((Map<String, String>) o).indexOf(vmDevice.getDeviceId().toString()) > 0) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                        break;
                    }
                }
            }
        }
    }
}
#method_after
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm.getStaticData(), managedDevices, vm.getboot_sequence(), VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version()));
        for (VmDevice vmDevice : managedDevices) {
            for (XmlRpcStruct struct : devices) {
                Object o = struct.getItem(VdsProperties.SpecParams);
                if (o instanceof Map<?, ?>) {
                    if (StringUtils.map2String((Map<String, String>) o).contains(vmDevice.getDeviceId().toString())) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                        break;
                    }
                } else {
                    log.errorFormat("Improper value of spec_params for VM {0} : {1}", vm.getvm_name(), o.toString());
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    storage_domains dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_STORAGE_DOMAIN_ID);
        return false;
    }
    VDS vds = getVds();
    boolean format = getParameters().getDoFormat();
    boolean localFs = isLocalFs(dom);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    if (!CheckStorageDomain() || !checkStorageDomainSharedStatusNotLocked(dom)) {
        return false;
    }
    if (!localFs && !CheckStorageDomainNotInPool()) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!InitializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (isDataDomain(dom) && !format) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_STORAGE_DOMAIN_DO_FORMAT);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    storage_domains dom = getStorageDomain();
    if (dom == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    VDS vds = getVds();
    boolean format = getParameters().getDoFormat();
    boolean localFs = isLocalFs(dom);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    if (!CheckStorageDomain() || !checkStorageDomainSharedStatusNotLocked(dom)) {
        return false;
    }
    if (!localFs && !CheckStorageDomainNotInPool()) {
        return false;
    }
    if (localFs && isDomainAttached(dom) && !canDetachDomain(getParameters().getDestroyingPool(), false, true)) {
        return false;
    }
    if (vds == null) {
        if (localFs) {
            if (!InitializeVds()) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_HOST_ID);
            return false;
        }
    }
    if (isDataDomain(dom) && !format) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_STORAGE_DOMAIN_DO_FORMAT);
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerExcpetion
    assertFalse("canDoActtion shouldn't be possible for a non-existant storage domain", command.canDoAction());
    List<String> messages = command.getReturnValue().getCanDoActionMessages();
    assertEquals("Wrong number of messages", 2, messages.size());
    assertEquals("Wrong message", VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN.name(), messages.get(0));
    assertEquals("Wrong message", VdcBllMessages.CANNOT_REMOVE_STORAGE_DOMAIN_INVALID_STORAGE_DOMAIN_ID.name(), messages.get(1));
}
#method_after
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerExcpetion
    assertFalse("canDoActtion shouldn't be possible for a non-existant storage domain", command.canDoAction());
    List<String> messages = command.getReturnValue().getCanDoActionMessages();
    assertEquals("Wrong number of messages", 2, messages.size());
    assertEquals("Wrong message", VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN.name(), messages.get(0));
    assertEquals("Wrong message", VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.name(), messages.get(1));
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmImages)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vm.getId())) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = getPluggedImages(vm);
        if (boot_sequence == BootSequence.C && vmImages.size() == 0) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmImages)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vm.getId())) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
private String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    return ".*" + search.getDefaultSort(SearchObjects.GLUSTER_VOLUMES_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUMES_OBJ_NAME) + ".* " + search.getPrimeryKeyName(SearchObjects.GLUSTER_VOLUMES_OBJ_NAME) + ".*";
}
#method_after
private String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    return ".*" + search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".* " + search.getPrimeryKeyName(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*";
}
#end_block

#method_before
public IAutoCompleter getCrossRefAutoCompleter(String obj) {
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        return new AuditCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        return new TemplateCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        return new UserCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        return new VdsCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        return new VmCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        return new ClusterCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        return new StoragePoolCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        return new StorageDomainCrossRefAutoCompleter();
    // no need for empty case before default: case
    // SearchObjects.VDC_POOL_OBJ_NAME:
    // no need for empty case before default: case
    // SearchObjects.VDC_POOL_PLU_OBJ_NAME:
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        return GlusterVolumeCrossRefAutoCompleter.INSTANCE;
    } else {
        return null;
    }
}
#method_after
public IAutoCompleter getCrossRefAutoCompleter(String obj) {
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        return new AuditCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        return new TemplateCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        return new UserCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        return new VdsCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        return new VmCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        return new ClusterCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        return new StoragePoolCrossRefAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        return new StorageDomainCrossRefAutoCompleter();
    // no need for empty case before default: case
    // SearchObjects.VDC_POOL_OBJ_NAME:
    // no need for empty case before default: case
    // SearchObjects.VDC_POOL_PLU_OBJ_NAME:
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        return GlusterVolumeCrossRefAutoCompleter.INSTANCE;
    } else {
        return null;
    }
}
#end_block

#method_before
public IConditionFieldAutoCompleter getFieldAutoCompleter(String obj) {
    IConditionFieldAutoCompleter retval = null;
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = new VdsConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = new VmConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = new VmTemplateConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = new AuditLogConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = new VdcUserConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = new PoolConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = new DiskImageConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = new ClusterConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = new StoragePoolFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = new StorageDomainFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        retval = GlusterVolumeConditionFieldAutoCompleter.INSTANCE;
    }
    return retval;
}
#method_after
public IConditionFieldAutoCompleter getFieldAutoCompleter(String obj) {
    IConditionFieldAutoCompleter retval = null;
    if (obj == null) {
        return null;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = new VdsConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = new VmConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = new VmTemplateConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = new AuditLogConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = new VdcUserConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = new PoolConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = new DiskImageConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = new ClusterConditionFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = new StoragePoolFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = new StorageDomainFieldAutoCompleter();
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = GlusterVolumeConditionFieldAutoCompleter.INSTANCE;
    }
    return retval;
}
#end_block

#method_before
public String getRelatedTableName(String obj) {
    String retval = null;
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vms_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vm_templates_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "vm_images_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "vdc_users_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pools_full_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_groups_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "storage_pool_with_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_domains_with_hosts_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        retval = "gluster_volumes";
    }
    return retval;
}
#method_after
public String getRelatedTableName(String obj) {
    String retval = null;
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vms_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vm_templates_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "vm_images_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "vdc_users_with_tags";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pools_full_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_groups_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "storage_pool_with_storage_domain";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_domains_with_hosts_view";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = "gluster_volumes";
    }
    return retval;
}
#end_block

#method_before
public String getPrimeryKeyName(String obj) {
    String retval = null;
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vm_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "image_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vmt_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "user_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pool_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_group_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "id";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        retval = "id";
    }
    return retval;
}
#method_after
public String getPrimeryKeyName(String obj) {
    String retval = null;
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vm_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "image_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "vmt_guid";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "user_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pool_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "vds_group_id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "id";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "id";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = "id";
    }
    return retval;
}
#end_block

#method_before
public String getDefaultSort(String obj) {
    String retval = "";
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vm_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "disk_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log_id DESC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pool_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUMES_OBJ_NAME)) {
        retval = "vol_name ASC ";
    }
    return retval;
}
#method_after
public String getDefaultSort(String obj) {
    String retval = "";
    if (obj == null) {
        return retval;
    }
    if (StringHelper.EqOp(obj, SearchObjects.VDS_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDS_PLU_OBJ_NAME)) {
        retval = "vds_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VM_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VM_PLU_OBJ_NAME)) {
        retval = "vm_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.DISK_IMAGE_PLU_OBJ_NAME)) {
        retval = "disk_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.AUDIT_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.AUDIT_PLU_OBJ_NAME)) {
        retval = "audit_log_id DESC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_USER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_USER_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.TEMPLATE_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.TEMPLATE_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_POOL_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_POOL_PLU_OBJ_NAME)) {
        retval = "vm_pool_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
        retval = "storage_name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.VDC_CLUSTER_PLU_OBJ_NAME)) {
        retval = "name ASC ";
    } else if (StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_OBJ_NAME) || StringHelper.EqOp(obj, SearchObjects.GLUSTER_VOLUME_PLU_OBJ_NAME)) {
        retval = "vol_name ASC ";
    }
    return retval;
}
#end_block

#method_before
private static void init() {
    final char SEPERATOR = ':';
    SAFE_SEARCH_EXPR.add(VDS_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDS_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VM_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VM_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(AUDIT_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(AUDIT_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(TEMPLATE_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(TEMPLATE_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_USER_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_USER_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_POOL_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_POOL_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_CLUSTER_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_CLUSTER_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_STORAGE_POOL_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_STORAGE_DOMAIN_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(DISK_IMAGE_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(DISK_IMAGE_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(GLUSTER_VOLUMES_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(ALERT.toLowerCase());
    SAFE_SEARCH_EXPR.add(ERROR.toLowerCase());
    SAFE_SEARCH_EXPR.add(HOST_BY_CPU.toLowerCase());
    SAFE_SEARCH_EXPR.add(DATACENTER_BY_NAME.toLowerCase());
    SAFE_SEARCH_EXPR.add(VM_BY_STATUS.toLowerCase());
}
#method_after
private static void init() {
    final char SEPERATOR = ':';
    SAFE_SEARCH_EXPR.add(VDS_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDS_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VM_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VM_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(AUDIT_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(AUDIT_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(TEMPLATE_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(TEMPLATE_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_USER_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_USER_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_POOL_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_POOL_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_CLUSTER_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_CLUSTER_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_STORAGE_POOL_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(VDC_STORAGE_DOMAIN_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(DISK_IMAGE_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(DISK_IMAGE_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(GLUSTER_VOLUME_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(GLUSTER_VOLUME_PLU_OBJ_NAME.toLowerCase() + SEPERATOR);
    SAFE_SEARCH_EXPR.add(ALERT.toLowerCase());
    SAFE_SEARCH_EXPR.add(ERROR.toLowerCase());
    SAFE_SEARCH_EXPR.add(HOST_BY_CPU.toLowerCase());
    SAFE_SEARCH_EXPR.add(DATACENTER_BY_NAME.toLowerCase());
    SAFE_SEARCH_EXPR.add(VM_BY_STATUS.toLowerCase());
}
#end_block

#method_before
public boolean isOnline() {
    return status == GlusterBrickStatus.ONLINE;
}
#method_after
public boolean isOnline() {
    return status == GlusterBrickStatus.UP;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((volumeId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((serverName == null) ? 0 : serverName.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((serverName == null) ? 0 : serverName.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (volumeId.equals(brick.getVolumeId()) && serverId.equals(brick.getServerId()) && brickDirectory.equals(brick.getBrickDirectory()) && status == brick.getStatus());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (volumeId.equals(brick.getVolumeId()) && serverId.equals(brick.getServerId()) && serverName.equals(brick.getServerName()) && brickDirectory.equals(brick.getBrickDirectory()) && status == brick.getStatus());
}
#end_block

#method_before
public boolean isOnline() {
    return this.status == GlusterVolumeStatus.ONLINE;
}
#method_after
public boolean isOnline() {
    return this.status == GlusterVolumeStatus.UP;
}
#end_block

#method_before
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setname(node.InnerText);
        name = _vmTemplate.getname();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setId(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vmTemplate.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vmTemplate.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    java.util.Date creationDate = new java.util.Date(0);
    RefObject<java.util.Date> tempRefObject = new RefObject<java.util.Date>(creationDate);
    boolean tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    creationDate = tempRefObject.argvalue;
    if (tempVar) {
        _vmTemplate.setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    java.util.Date exportDate = new java.util.Date(0);
    tempRefObject = new RefObject<java.util.Date>(exportDate);
    tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    exportDate = tempRefObject.argvalue;
    if (tempVar) {
        _vmTemplate.set_export_date(exportDate);
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vmTemplate.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vmTemplate.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setkernel_params((node.InnerText));
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        }
    }
    node = content.SelectSingleNode("default_display_type");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
}
#method_after
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setname(node.InnerText);
        name = _vmTemplate.getname();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setId(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vmTemplate.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vmTemplate.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    java.util.Date creationDate = new java.util.Date(0);
    RefObject<java.util.Date> tempRefObject = new RefObject<java.util.Date>(creationDate);
    boolean tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    creationDate = tempRefObject.argvalue;
    if (tempVar) {
        _vmTemplate.setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    java.util.Date exportDate = new java.util.Date(0);
    tempRefObject = new RefObject<java.util.Date>(exportDate);
    tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    exportDate = tempRefObject.argvalue;
    if (tempVar) {
        _vmTemplate.setExportDate(exportDate);
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vmTemplate.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vmTemplate.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setkernel_params((node.InnerText));
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        }
    }
    node = content.SelectSingleNode("default_display_type");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vmTemplate.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
}
#end_block

#method_before
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vm.getStaticData().setvm_name(node.InnerText);
        name = _vm.getStaticData().getvm_name();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.getStaticData().setvmt_guid(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("TemplateName");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvmt_name(node.InnerText);
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vm.getStaticData().setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vm.getStaticData().setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    java.util.Date creationDate = new java.util.Date(0);
    RefObject<java.util.Date> tempRefObject = new RefObject<java.util.Date>(creationDate);
    boolean tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    creationDate = tempRefObject.argvalue;
    if (tempVar) {
        _vm.getStaticData().setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    java.util.Date exportDate = new java.util.Date(0);
    tempRefObject = new RefObject<java.util.Date>(exportDate);
    tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    exportDate = tempRefObject.argvalue;
    if (tempVar) {
        _vm.getStaticData().set_export_date(exportDate);
    }
    node = content.SelectSingleNode("IsInitilized");
    if (node != null) {
        _vm.getStaticData().setis_initialized(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vm.getStaticData().setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vm.getStaticData().settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        _vm.getStaticData().setis_stateless(Boolean.parseBoolean(node.InnerText));
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_params((node.InnerText));
        }
    }
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a list of all the aliases of the fields that should be logged in
    // ovd For each one of these fields, the proper value will be read from
    // the ovf and field in vm static
    List<String> aliases = handler.getAliases();
    for (String alias : aliases) {
        String value = readEventLogValue(content, alias);
        if (!StringHelper.isNullOrEmpty(value)) {
            handler.addValueForAlias(alias, value);
        }
    }
    node = content.SelectSingleNode("app_list");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setapp_list(node.InnerText);
        }
    } else // if no app list in VM, get it from one of the leafs
    if (_images != null && _images.size() > 0) {
        int root = GetFirstImage(_images, _images.get(0));
        if (root != -1) {
            for (int i = 0; i < _images.size(); i++) {
                int x = GetNextImage(_images, _images.get(i));
                if (x == -1) {
                    _vm.setapp_list(_images.get(i).getappList());
                }
            }
        } else {
            _vm.setapp_list(_images.get(0).getappList());
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("DefaultDisplayType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setMinAllocatedMem(Integer.parseInt(node.InnerText));
        }
    }
}
#method_after
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vm.getStaticData().setvm_name(node.InnerText);
        name = _vm.getStaticData().getvm_name();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.getStaticData().setvmt_guid(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("TemplateName");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvmt_name(node.InnerText);
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vm.getStaticData().setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vm.getStaticData().setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    java.util.Date creationDate = new java.util.Date(0);
    RefObject<java.util.Date> tempRefObject = new RefObject<java.util.Date>(creationDate);
    boolean tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    creationDate = tempRefObject.argvalue;
    if (tempVar) {
        _vm.getStaticData().setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    java.util.Date exportDate = new java.util.Date(0);
    tempRefObject = new RefObject<java.util.Date>(exportDate);
    tempVar = node != null && OvfParser.UtcDateStringToLocaDate(node.InnerText, tempRefObject);
    exportDate = tempRefObject.argvalue;
    if (tempVar) {
        _vm.getStaticData().setExportDate(exportDate);
    }
    node = content.SelectSingleNode("IsInitilized");
    if (node != null) {
        _vm.getStaticData().setis_initialized(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vm.getStaticData().setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vm.getStaticData().settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        _vm.getStaticData().setis_stateless(Boolean.parseBoolean(node.InnerText));
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_params((node.InnerText));
        }
    }
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a list of all the aliases of the fields that should be logged in
    // ovd For each one of these fields, the proper value will be read from
    // the ovf and field in vm static
    List<String> aliases = handler.getAliases();
    for (String alias : aliases) {
        String value = readEventLogValue(content, alias);
        if (!StringHelper.isNullOrEmpty(value)) {
            handler.addValueForAlias(alias, value);
        }
    }
    node = content.SelectSingleNode("app_list");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setapp_list(node.InnerText);
        }
    } else // if no app list in VM, get it from one of the leafs
    if (_images != null && _images.size() > 0) {
        int root = GetFirstImage(_images, _images.get(0));
        if (root != -1) {
            for (int i = 0; i < _images.size(); i++) {
                int x = GetNextImage(_images, _images.get(i));
                if (x == -1) {
                    _vm.setapp_list(_images.get(i).getappList());
                }
            }
        } else {
            _vm.setapp_list(_images.get(0).getappList());
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("DefaultDisplayType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setMinAllocatedMem(Integer.parseInt(node.InnerText));
        }
    }
}
#end_block

#method_before
@Test
public void testGetAllForQuotaId() {
    List<DiskImage> disks = dao.getAllForQuotaId(FixturesTool.QUOTA_GENERAL);
    assertEquals("Wrong number of disk images for quota ", 12, disks.size());
}
#method_after
@Test
public void testGetAllForQuotaId() {
    List<DiskImage> disks = dao.getAllForQuotaId(FixturesTool.QUOTA_GENERAL);
    assertEquals("Wrong number of disk images for quota ", TOTAL_DISK_IMAGES_FOR_QAUOTA, disks.size());
}
#end_block

#method_before
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        _vmInterfaces = ((DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getVmTemplate().getId())) != null) ? DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getVmTemplate().getId()) : new ArrayList<VmNetworkInterface>();
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNetworkInterface> vmNetworkInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getVmTemplate().getId());
        _vmInterfaces = (vmNetworkInterfaces != null) ? vmNetworkInterfaces : new ArrayList<VmNetworkInterface>();
    }
    return _vmInterfaces;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        buildStorageToDiskMap();
        returnValue = CanDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    if (returnValue && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // check that we have no more then 8 interfaces (kvm limitation in version 2.x)
        if (!validateNumberOfNics(getVmInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            returnValue = false;
        }
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getVmTemplate().getDiskMap().values(), imageToDestinationDomainMap);
        returnValue = CanDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    if (returnValue && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // check that we have no more then 8 interfaces (kvm limitation in version 2.x)
        if (!validateNumberOfNics(getVmInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            returnValue = false;
        }
    }
    return returnValue && checkCpuSockets();
}
#end_block

#method_before
protected boolean buildAndCheckDestStorageDomains() {
    boolean returnValue = true;
    ensureDomainMap();
    Set<Guid> destStorageDomains = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destStorageDomain : destStorageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(destStorageDomain, getStoragePoolId());
        StorageDomainValidator validator = new StorageDomainValidator(storage);
        if (!validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) || !validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
            break;
        }
        destStorages.put(storage.getId(), storage);
    }
    return returnValue;
}
#method_after
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (imageToDestinationDomainMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getVmTemplate().getDiskMap().values().size() != imageToDestinationDomainMap.size()) {
        log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, int vmsCount, String name, Guid storagePoolId, int vmPriority) {
    boolean returnValue;
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) Backend.getInstance().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(name)).getReturnValue();
    if (exists) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST.toString());
        }
        return false;
    }
    boolean checkTemplateLock = getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms ? false : true;
    returnValue = VmHandler.VerifyAddVm(reasons, vmsCount, getVmTemplate(), storagePoolId, null, false, checkTemplateLock, vmPriority);
    if (!getParameters().getDontCheckTemplateImages()) {
        for (storage_domains storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, int vmsCount, String name, Guid storagePoolId, int vmPriority) {
    boolean returnValue;
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) Backend.getInstance().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(name)).getReturnValue();
    if (exists) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST.toString());
        }
        return false;
    }
    boolean checkTemplateLock = getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms ? false : true;
    returnValue = VmHandler.VerifyAddVm(reasons, vmsCount, getVmTemplate(), storagePoolId, vmPriority);
    if (returnValue && !getParameters().getDontCheckTemplateImages()) {
        for (storage_domains storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getVmTemplate().getQuotaId(), getStoragePool()));
    for (DiskImage diskImage : mImages) {
        diskImage.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getVmTemplate().getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getQuotaId(), getStoragePool()));
    for (DiskImage diskImage : mImages) {
        diskImage.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (mImages.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Guid srcStorageDomainId = mImages.get(0).getstorage_ids().get(0);
    // or populate storage domain id from the vm domain (of the first disk)
    if (getParameters().getDestinationStorageDomainId() != null) {
        setStorageDomainId(getParameters().getDestinationStorageDomainId());
    } else {
        setStorageDomainId(srcStorageDomainId);
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!ImagesHandler.PerformImagesChecks(getParameters().getMasterVm().getId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, true, true, true, true, true, false, true)) {
        return false;
    }
    VM vm = DbFacade.getInstance().getVmDAO().getById(getParameters().getMasterVm().getId());
    if (vm.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    if (getStorageDomainId() != null) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(getStorageDomainId().getValue(), getVm().getstorage_pool_id());
        // if source and destination domains are different we need to check destination domain also
        if (!srcStorageDomainId.equals(getStorageDomainId().getValue())) {
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDAO().get(getStorageDomainId().getValue()) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        // update vm snapshots for storage free space check
        for (DiskImage diskImage : getVm().getDiskMap().values()) {
            diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        }
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(storage, (int) getVm().getActualDiskWithSnapshotsSize())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    if (!AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (mImages.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    if (imageToDestinationDomainMap == null) {
        imageToDestinationDomainMap = new HashMap<Guid, Guid>();
    }
    for (DiskImage image : mImages) {
        List<DiskImage> diskImageList = sourceImageDomainsImageMap.get(image.getstorage_ids().get(0));
        if (diskImageList == null) {
            diskImageList = new ArrayList<DiskImage>();
            sourceImageDomainsImageMap.put(image.getstorage_ids().get(0), diskImageList);
        }
        diskImageList.add(image);
        if (!imageToDestinationDomainMap.containsKey(image.getId())) {
            Guid destImageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            imageToDestinationDomainMap.put(image.getId(), destImageId);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = new HashSet<Guid>(imageToDestinationDomainMap.values());
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(destImageDomain, getVm().getstorage_pool_id());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDAO().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(getVmTemplate().getDiskImageMap().values(), storageDomains, imageToDestinationDomainMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void AddVmInterfaces() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        // \\interface_statistics iStat = new interface_statistics();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        // TODO why is a VM interface getting VDS details?
        // iDynamic.setAddress(iface.getInterfaceDynamic().getAddress());
        // iDynamic.setBondName(iface.getInterfaceDynamic().getBondName());
        // iDynamic.setBondType(iface.getInterfaceDynamic().getBondType());
        // iDynamic.setGateway(iface.getInterfaceDynamic().getGateway());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        // iDynamic.setSubnet(iface.getInterfaceDynamic().getSubnet());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDAO().save(iDynamic);
    // \\DbFacade.Instance.addInterfaceStatistics(iStat);
    }
}
#method_after
protected void AddVmInterfaces() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDAO().save(iDynamic);
    }
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_ids().get(0);
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!Guid.Empty.equals(diskImage.getstorage_ids().get(0))) {
            createParams.setStorageDomainId(diskImage.getstorage_ids().get(0));
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        createParams.setStorageDomainId(diskImage.getstorage_ids().get(0));
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(imageToDestinationDomainMap.get(diskImage.getId()));
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    VmTemplate template = getVmTemplate();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVmId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void EndWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVmId());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> list = new ArrayList<PermissionSubject>();
    Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
    list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    list = QuotaHelper.getInstance().addQuotaPermissionSubject(list, getStoragePool(), getVm().getStaticData().getQuotaId());
    list = setPermissionListForDiskImage(list);
    return list;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        permissionCheckSubject = QuotaHelper.getInstance().addQuotaPermissionSubject(permissionCheckSubject, getStoragePool(), getQuotaId());
        permissionCheckSubject = setPermissionListForDiskImage(permissionCheckSubject);
    }
    return permissionCheckSubject;
}
#end_block

#method_before
// Sysprep section is displayed only when VM's OS-type is 'Windows'
// and [Reinitialize-sysprep == true || IsVmFirstRun == true (IsVmFirstRun == !VM.is_initialized) and no attached
private void UpdateIsSysprepEnabled() {
    boolean isFloppyAttached = (Boolean) getAttachFloppy().getEntity();
    boolean isVmFirstRun = (Boolean) getIsVmFirstRun().getEntity();
    getIsSysprepEnabled().setEntity(getIsWindowsOS() && (getReinitialize()));
}
#method_after
// Sysprep section is displayed only when VM's OS-type is 'Windows'
// and [Reinitialize-sysprep == true || IsVmFirstRun == true (IsVmFirstRun == !VM.is_initialized) and no attached
private void UpdateIsSysprepEnabled() {
    boolean isFloppyAttached = (Boolean) getAttachFloppy().getEntity();
    boolean isVmFirstRun = (Boolean) getIsVmFirstRun().getEntity();
    getIsSysprepEnabled().setEntity(getIsWindowsOS() && getReinitialize());
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    List<Map<String, String>> drives = new ArrayList<Map<String, String>>(vm.getDiskMap().size());
    int ideCount = 0, pciCount = 0;
    List<DiskImage> diskImages = getSortedDiskImages();
    for (DiskImage disk : diskImages) {
        // get vm device for this disk from DB
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDAO().get(new VmDeviceId(disk.getDisk().getId(), disk.getvm_guid()));
        if (vmDevice.getIsPlugged()) {
            Map<String, String> drive = new HashMap<String, String>();
            drive.put("domainID", disk.getstorage_ids().get(0).toString());
            drive.put("poolID", disk.getstorage_pool_id().toString());
            drive.put("volumeID", disk.getId().toString());
            drive.put("imageID", disk.getimage_group_id().toString());
            drive.put("format", disk.getvolume_format().toString().toLowerCase());
            drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
            switch(disk.getdisk_interface()) {
                case IDE:
                    try {
                        drive.put("if", "ide");
                        drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                        ideCount++;
                    } catch (IndexOutOfBoundsException e) {
                        log.errorFormat("buildVmDrives throws IndexOutOfBoundsException for index {0}, IDE slots are limited to 4.", ideCount);
                        throw e;
                    }
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            drives.add(drive);
        }
    }
    @SuppressWarnings("unchecked")
    Map<String, String>[] drivesArray = new Map[drives.size()];
    createInfo.add("drives", drives.toArray(drivesArray));
}
#method_after
@Override
protected void buildVmDrives() {
    List<Map<String, String>> drives = new ArrayList<Map<String, String>>(vm.getDiskMap().size());
    int ideCount = 0, pciCount = 0;
    List<DiskImage> diskImages = getSortedDiskImages();
    List<VmDevice> vmDiskDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.DISK.getName(), VmDeviceType.DISK.getName());
    for (DiskImage disk : diskImages) {
        // Get the VM device for this disk
        VmDevice vmDevice = findVmDeviceForDisk(disk.getDisk().getId(), vmDiskDevices);
        if (vmDevice == null || vmDevice.getIsPlugged()) {
            Map<String, String> drive = new HashMap<String, String>();
            drive.put("domainID", disk.getstorage_ids().get(0).toString());
            drive.put("poolID", disk.getstorage_pool_id().toString());
            drive.put("volumeID", disk.getId().toString());
            drive.put("imageID", disk.getimage_group_id().toString());
            drive.put("format", disk.getvolume_format().toString().toLowerCase());
            drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
            switch(disk.getdisk_interface()) {
                case IDE:
                    try {
                        drive.put("if", "ide");
                        drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                        ideCount++;
                    } catch (IndexOutOfBoundsException e) {
                        log.errorFormat("buildVmDrives throws IndexOutOfBoundsException for index {0}, IDE slots are limited to 4.", ideCount);
                        throw e;
                    }
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            drives.add(drive);
        }
    }
    @SuppressWarnings("unchecked")
    Map<String, String>[] drivesArray = new Map[drives.size()];
    createInfo.add("drives", drives.toArray(drivesArray));
}
#end_block

#method_before
public Collection<DetailedLink> getLinks() throws ClassNotFoundException, IOException {
    // SortedSet<Link> results = new TreeSet<Link>();
    List<DetailedLink> results = new ArrayList<DetailedLink>();
    List<Class<?>> classes = ReflectionHelper.getClasses(RESOURCES_PACKAGE);
    for (String path : apiResource.getRels()) {
        Class<?> resource = findResource(path, classes);
        results.addAll(describe(resource, entryPoint + path, new HashMap<String, Type>()));
    }
    return results;
}
#method_after
public Collection<DetailedLink> getLinks() throws ClassNotFoundException, IOException {
    // SortedSet<Link> results = new TreeSet<Link>();
    List<DetailedLink> results = new ArrayList<DetailedLink>();
    List<Class<?>> classes = ReflectionHelper.getClasses(RESOURCES_PACKAGE);
    for (String path : apiResource.getRels()) {
        Class<?> resource = findResource(path, classes);
        results.addAll(describe(resource, entryPoint + "/" + path, new HashMap<String, Type>()));
    }
    return results;
}
#end_block

#method_before
private void addBodyParams(ParametersSet ps, Set<Entry<Object, Object>> entrySet, boolean mandatory) {
    for (Entry<Object, Object> paramData : entrySet) {
        Parameter param = createBodyParam(paramData, mandatory);
        ps.getParameters().add(param);
    }
}
#method_after
private void addBodyParams(ParametersSet ps, Set<Entry<Object, Object>> entrySet, boolean required) {
    for (Entry<Object, Object> paramData : entrySet) {
        Parameter param = createBodyParam(paramData, required);
        ps.getParameters().add(param);
    }
}
#end_block

#method_before
private Parameter createBodyParam(Entry<Object, Object> mandatoryKeyValuePair, boolean mandatory) {
    Parameter param = new Parameter();
    param.setMandatory(mandatory);
    String paramName = mandatoryKeyValuePair.getKey().toString();
    if (paramName.endsWith(LIST_PARAMETER_YAML)) {
        param.setName(paramName.substring(0, paramName.length() - (LIST_PARAMETER_YAML.length())));
        param.setType(LIST_PARAMETER_RSDL);
        @SuppressWarnings("unchecked")
        Map<Object, Object> listParams = (Map<Object, Object>) mandatoryKeyValuePair.getValue();
        param.setParametersSet(new ParametersSet());
        for (Entry<Object, Object> listParamData : listParams.entrySet()) {
            Parameter listParam = createBodyParam(listParamData, mandatory);
            param.getParametersSet().getParameters().add(listParam);
        }
    } else {
        param.setName(paramName);
        param.setType(mandatoryKeyValuePair.getValue().toString());
    }
    return param;
}
#method_after
private Parameter createBodyParam(Entry<Object, Object> mandatoryKeyValuePair, boolean required) {
    Parameter param = new Parameter();
    param.setRequired(required);
    String paramName = mandatoryKeyValuePair.getKey().toString();
    if (paramName.endsWith(COLLECTION_PARAMETER_YAML)) {
        param.setName(paramName.substring(0, paramName.length() - (COLLECTION_PARAMETER_YAML.length())));
        param.setType(COLLECTION_PARAMETER_RSDL);
        @SuppressWarnings("unchecked")
        Map<Object, Object> listParams = (Map<Object, Object>) mandatoryKeyValuePair.getValue();
        param.setParametersSet(new ParametersSet());
        for (Entry<Object, Object> listParamData : listParams.entrySet()) {
            Parameter listParam = createBodyParam(listParamData, required);
            param.getParametersSet().getParameters().add(listParam);
        }
    } else {
        param.setName(paramName);
        param.setType(mandatoryKeyValuePair.getValue().toString());
    }
    return param;
}
#end_block

#method_before
private void addUrlParams(DetailedLink link, Action action) {
    if (action.getRequest().getUrlparams() != null && !action.getRequest().getUrlparams().isEmpty()) {
        link.getRequest().setUrl(new Url());
        ParametersSet ps = new ParametersSet();
        for (Object key : action.getRequest().getUrlparams().keySet()) {
            Parameter param = new Parameter();
            param.setName(key.toString());
            Object value = action.getRequest().getUrlparams().get(key);
            if (value != null) {
                param.setValue(value.toString());
            }
            ps.getParameters().add(param);
        }
        link.getRequest().getUrl().getParametersSets().add(ps);
    }
}
#method_after
private void addUrlParams(DetailedLink link, Action action) {
    if (action.getRequest().getUrlparams() != null && !action.getRequest().getUrlparams().isEmpty()) {
        link.getRequest().setUrl(new Url());
        ParametersSet ps = new ParametersSet();
        for (Object key : action.getRequest().getUrlparams().keySet()) {
            Parameter param = new Parameter();
            param.setName(key.toString());
            Object value = action.getRequest().getUrlparams().get(key);
            if (value != null) {
                UrlParamData urlParamData = (UrlParamData) value;
                param.setType(urlParamData.getType());
                param.setContext(urlParamData.getContext());
                param.setValue(urlParamData.getValue());
                param.setRequired(urlParamData.getRequired() == null ? false : urlParamData.getRequired());
            }
            ps.getParameters().add(param);
        }
        link.getRequest().getUrl().getParametersSets().add(ps);
    }
}
#end_block

#method_before
public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) {
    Guid returnValue = Guid.Empty;
    List<storage_domains> domains = getAllForStoragePool(pool);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == StorageDomainType.Master) {
            returnValue = domain.getId();
            break;
        }
    }
    return returnValue;
}
#method_after
public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) {
    Guid returnValue = Guid.Empty;
    List<storage_domains> domains = getAllForStoragePool(pool);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == type) {
            returnValue = domain.getId();
            break;
        }
    }
    return returnValue;
}
#end_block

#method_before
public void add(String key, XmlRpcStruct[] devices) {
    int i = 0;
    Map[] map = new Map[devices.length];
    for (XmlRpcStruct device : devices) {
        map[i++] = device.getInnerMap();
    }
    this.add(key, map);
}
#method_after
public void add(String key, XmlRpcStruct[] devices) {
    int i = 0;
    // TODO work with typed collection
    Map[] map = new Map[devices.length];
    for (XmlRpcStruct device : devices) {
        map[i++] = device.getInnerMap();
    }
    this.add(key, map);
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    List<String> vmIds = ((FullListVDSCommandParameters) getParameters()).getVmIds();
    String[] vmIdsArray = vmIds.toArray(new String[vmIds.size()]);
    fullVmListReturn = getBroker().list("true", vmIdsArray);
    ProceedProxyReturnValue();
    XmlRpcStruct[] struct = fullVmListReturn.mVmList;
    setReturnValue(struct);
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    List<String> vmIds = getParameters().getVmIds();
    String[] vmIdsArray = vmIds.toArray(new String[vmIds.size()]);
    fullVmListReturn = getBroker().list(Boolean.TRUE.toString(), vmIdsArray);
    ProceedProxyReturnValue();
    XmlRpcStruct[] struct = fullVmListReturn.mVmList;
    setReturnValue(struct);
}
#end_block

#method_before
public String getSpecParams() {
    this.specParams = VmDeviceCommonUtils.appendDeviceIdToSpecParams(this.getId().getDeviceId(), this.specParams);
    return this.specParams;
}
#method_after
public String getSpecParams() {
    specParams = VmDeviceCommonUtils.appendDeviceIdToSpecParams(this.getId().getDeviceId(), specParams);
    return this.specParams;
}
#end_block

#method_before
public Boolean getIsPlugged() {
    return isPlugged;
}
#method_after
public Boolean getIsPlugged() {
    return isPlugged == null ? Boolean.FALSE : isPlugged;
}
#end_block

#method_before
private void SaveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        CheckVdsMemoryThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    DbFacade.getInstance().getInterfaceDAO().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    updateAllInTransaction(_vmDynamicToSave.values(), DbFacade.getInstance().getVmDynamicDAO());
    updateAllInTransaction(_vmStatisticsToSave.values(), DbFacade.getInstance().getVmStatisticsDAO());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    updateAllInTransaction(allVmInterfaceStatistics, DbFacade.getInstance().getVmNetworkStatisticsDAO());
    updateAllInTransaction(_vmDiskImageDynamicToSave.values(), DbFacade.getInstance().getDiskImageDynamicDAO());
}
#method_after
private void SaveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        CheckVdsMemoryThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    DbFacade.getInstance().getInterfaceDAO().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    updateAllInTransaction(_vmDynamicToSave.values(), DbFacade.getInstance().getVmDynamicDAO());
    updateAllInTransaction(_vmStatisticsToSave.values(), DbFacade.getInstance().getVmStatisticsDAO());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    updateAllInTransaction(allVmInterfaceStatistics, DbFacade.getInstance().getVmNetworkStatisticsDAO());
    updateAllInTransaction(_vmDiskImageDynamicToSave.values(), DbFacade.getInstance().getDiskImageDynamicDAO());
    saveVmDevicesToDb();
}
#end_block

#method_before
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                IrsBrokerCommand.lockDbSave(_vds.getstorage_pool_id());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                ResourceManager.getInstance().getEventListener().VdsUpEvent(_vds.getId());
                markIsSetNonOperationalExecuted();
                // Check cpu flags if vm moved to up
                _cpuFlagsChanged = true;
            }
            // save all data to db
            SaveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        } finally {
            IrsBrokerCommand.unlockDbSave(_vds.getstorage_pool_id());
        }
    }
}
#method_after
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                IrsBrokerCommand.lockDbSave(_vds.getstorage_pool_id());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId());
                markIsSetNonOperationalExecuted();
                // Check cpu flags if vm moved to up
                _cpuFlagsChanged = true;
            }
            // save all data to db
            SaveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        } finally {
            IrsBrokerCommand.unlockDbSave(_vds.getstorage_pool_id());
        }
    }
}
#end_block

#method_before
public void AfterRefreshTreatment() {
    try {
        if (_cpuFlagsChanged) {
            ResourceManager.getInstance().getEventListener().ProcessOnCpuFlagsChange(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getstatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().VdsMovedToMaintanance(_vds.getId());
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode. The Host status will change to Non operational status.");
                ResourceManager.getInstance().getEventListener().VdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, true, Guid.Empty);
                throw ex;
            }
        } else if (_vds.getstatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().VdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getvds_name());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getvds_name());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.SuccededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().RunFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (java.util.Map.Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().ProcessOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().ProcessOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getdisplay_ip(), runningVm.getdisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().ProcessOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void AfterRefreshTreatment() {
    try {
        if (_cpuFlagsChanged) {
            ResourceManager.getInstance().getEventListener().processOnCpuFlagsChange(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getstatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().vdsMovedToMaintanance(_vds.getId());
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode. The Host status will change to Non operational status.");
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, true, Guid.Empty);
                throw ex;
            }
        } else if (_vds.getstatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getvds_name());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getvds_name());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.SuccededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().runFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (java.util.Map.Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getdisplay_ip(), runningVm.getdisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    List<String> vmsToUpdate = new ArrayList<String>();
    for (java.util.Map.Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic vm = vm_helper.getKey();
        String dbHash = _vmDict.get(vm.getId()).getHash();
        if ((dbHash == null && vm.getHash() != null) || !dbHash.equals(vm.getHash())) {
            vmsToUpdate.add(vm.getId().toString());
            // update new hash value
            vm.setHash(vm.getHash());
            // DbFacade.getInstance().getVmDynamicDAO().update(vm);
            AddVmDynamicToList(vm);
        }
    }
    if (vmsToUpdate.size() > 0) {
        updateVmDevices(vmsToUpdate);
    }
}
#method_after
private void handleVmDeviceChange() {
    List<String> vmsToUpdate = new ArrayList<String>();
    for (Map.Entry<VmDynamic, VmStatistics> vmHelper : _runningVms.values()) {
        VmDynamic vmDynamic = vmHelper.getKey();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdate.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdate.size() > 0) {
        updateVmDevices(vmsToUpdate);
    }
}
#end_block

#method_before
private XmlRpcStruct[] getVmInfo(List<String> vmsToUpdate) {
    return (XmlRpcStruct[]) (new FullListVdsCommand<VdsIdAndVdsVDSCommandParametersBase>(new FullListVDSCommandParameters(_vds.getId(), vmsToUpdate)).ExecuteWithReturnValue());
}
#method_after
private XmlRpcStruct[] getVmInfo(List<String> vmsToUpdate) {
    return (XmlRpcStruct[]) (new FullListVdsCommand<FullListVDSCommandParameters>(new FullListVDSCommandParameters(_vds.getId(), vmsToUpdate)).ExecuteWithReturnValue());
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    int i = 0;
    if (vm == null || vm.getItem("vmId") == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem("vmId"));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem("devices");
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem("address")) == null) {
            log.infoFormat("Recieved a Device without an address when processing VM devices, skipping device: {0}.", device.getInnerMap().toString());
            continue;
        }
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDAO().get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.getItem("address")).toString());
            DbFacade.getInstance().getVmDeviceDAO().update(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            log.infoFormat("Recieved a Device without an address when processing VM {0} devices, skipping device: {1}.", vmId, device.getInnerMap().toString());
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void handleRemovedDevices(Guid vmId, HashSet<Guid> processedDevices) {
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmId(vmId);
    for (VmDevice device : devices) {
        if (!processedDevices.contains(device.getDeviceId())) {
            if (device.getIsManaged()) {
                if (device.getIsPlugged()) {
                    log.errorFormat("Managed non plugable device was removed unexpetedly from libvirt: {0}", device.toString());
                } else {
                    device.setAddress("");
                    DbFacade.getInstance().getVmDeviceDAO().update(device);
                    log.debugFormat("Unmanaged pluggable device was unplugged : {0}", device.toString());
                }
            } else {
                DbFacade.getInstance().getVmDeviceDAO().remove(device.getId());
                log.debugFormat("unmanaged device was removed : {0}", device.toString());
            }
        }
    }
}
#method_after
private void handleRemovedDevices(Guid vmId, HashSet<Guid> processedDevices, List<VmDevice> devices) {
    for (VmDevice device : devices) {
        if (!processedDevices.contains(device.getDeviceId())) {
            if (device.getIsManaged()) {
                if (device.getIsPlugged()) {
                    log.errorFormat("VM {0} managed non plugable device was removed unexpetedly from libvirt: {1}", vmId, device.toString());
                } else {
                    device.setAddress("");
                    addVmDeviceToList(device);
                    log.debugFormat("VM {0} unmanaged pluggable device was unplugged : {1}", vmId, device.toString());
                }
            } else {
                removedDeviceIds.add(device.getId());
                log.debugFormat("VM {0} unmanaged device was marked for remove : {1}", vmId, device.toString());
            }
        }
    }
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, XmlRpcStruct device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.getItem("type");
    String deviceName = (String) device.getItem("device");
    // do not allow null or empty device or type values
    if (!StringUtils.isEmpty(typeName) && !StringUtils.isEmpty(deviceName)) {
        String address = ((Map<String, String>) device.getItem("address")).toString();
        String specParams = "";
        Object o = device.getItem("specParams");
        newDeviceId = Guid.NewGuid();
        if (o != null) {
            specParams = ((Map<String, String>) o).toString();
        }
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, typeName, deviceName, address, 0, specParams, false, true, false);
        DbFacade.getInstance().getVmDeviceDAO().save(newDevice);
        log.debugFormat("New device was added to VM Devices : {0}", newDevice.toString());
    } else {
        log.error("Empty or NULL values were passed for a VM device, Device is skipped");
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, XmlRpcStruct device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.getItem(VdsProperties.Type);
    String deviceName = (String) device.getItem(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (!StringUtils.isEmpty(typeName) && !StringUtils.isEmpty(deviceName)) {
        String address = ((Map<String, String>) device.getItem(VdsProperties.Address)).toString();
        String specParams = "";
        Object o = device.getItem(VdsProperties.SpecParams);
        newDeviceId = Guid.NewGuid();
        if (o != null) {
            specParams = org.ovirt.engine.core.utils.StringUtils.map2String((Map<String, String>) o);
        }
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, typeName, deviceName, address, 0, specParams, false, true, false);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice.toString());
    } else {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    }
    return newDeviceId;
}
#end_block

#method_before
@XmlElement(name = "Interfaces")
public List<VmNetworkInterface> getInterfaces() {
    if (mVmStatic == null)
        return new ArrayList<VmNetworkInterface>();
    else
        return mVmStatic.getInterfaces();
}
#method_after
@XmlElement(name = "Interfaces")
public List<VmNetworkInterface> getInterfaces() {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    return mVmStatic.getInterfaces();
}
#end_block

#method_before
public void setInterfaces(List<VmNetworkInterface> value) {
    mVmStatic.setInterfaces(value);
}
#method_after
public void setInterfaces(List<VmNetworkInterface> value) {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    mVmStatic.setInterfaces(value);
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getImages() {
    if (mVmStatic == null)
        return new ArrayList<DiskImage>();
    else
        return mVmStatic.getImages();
}
#method_after
public ArrayList<DiskImage> getImages() {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    return mVmStatic.getImages();
}
#end_block

#method_before
public void setImages(java.util.ArrayList<DiskImage> value) {
    mVmStatic.setImages(value);
}
#method_after
public void setImages(ArrayList<DiskImage> value) {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    mVmStatic.setImages(value);
}
#end_block

#method_before
// This function is left only to leave the option of creating a VM without
// having all the data in the DB
// Currently it is used mainly by tests and VdcClient (for direct acccess to
// the VDS)
public void addDriveToImageMap(String drive, DiskImage image) {
    mDiskMap.put(drive, image);
    mVmStatic.getDiskList().add(image);
}
#method_after
// This function is left only to leave the option of creating a VM without
// having all the data in the DB
// Currently it is used mainly by tests and VdcClient (for direct acccess to
// the VDS)
public void addDriveToImageMap(String drive, DiskImage image) {
    mDiskMap.put(drive, image);
    getDiskList().add(image);
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getDiskList() {
    return mVmStatic.getDiskList();
}
#method_after
public ArrayList<DiskImage> getDiskList() {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    return mVmStatic.getDiskList();
}
#end_block

#method_before
public static boolean VerifyAddVm(java.util.ArrayList<String> reasons, int vmsCount, Object vmTemplateId, Guid storagePoolId, Guid storageDomainId, boolean checkVmTemplateImages, boolean checkTemplateLock, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < vmsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            } else if (checkVmTemplateImages) {
                returnValue = VmTemplateCommand.isVmTemplateImagesReady((Guid) vmTemplateId, storageDomainId, reasons, true, checkTemplateLock, true, true);
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
public static boolean VerifyAddVm(java.util.ArrayList<String> reasons, int vmsCount, VmTemplate vmTemplate, Guid storagePoolId, Guid storageDomainId, boolean checkVmTemplateImages, boolean checkTemplateLock, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < vmsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            } else if (checkVmTemplateImages) {
                returnValue = VmTemplateCommand.isVmTemplateImagesReady(vmTemplate, storageDomainId, reasons, true, checkTemplateLock, true, true);
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getImages() {
    return images;
}
#method_after
public ArrayList<DiskImage> getImages() {
    return images;
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#method_after
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#end_block

#method_before
@XmlElement
public java.util.Date getcreation_date() {
    return this.creationDate;
}
#method_after
@XmlElement
public Date getcreation_date() {
    return this.creationDate;
}
#end_block

#method_before
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, VmDeviceType.getName(type), VmDeviceType.getName(device), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#method_after
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, type.getName(), device.getName(), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#end_block

#method_before
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#method_after
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#end_block

#method_before
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#method_after
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#end_block

#method_before
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.BRIDGE))) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.INTERFACE.getName()) && device.getDevice().equals(VmDeviceType.BRIDGE.getName())) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM))) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#method_after
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.CDROM.getName())) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK))) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.DISK.getName())) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        Guid newId = Guid.NewGuid();
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        StringBuilder sb = new StringBuilder();
        sb.append(VRAM);
        sb.append("=");
        sb.append(mem);
        sb = new StringBuilder(appendDeviceIdToSpecParams(newId, sb.toString()));
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.getName(VmDeviceType.VIDEO));
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        Guid newId = Guid.NewGuid();
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        StringBuilder sb = new StringBuilder();
        sb.append(VRAM);
        sb.append("=");
        sb.append(mem);
        sb = new StringBuilder(appendDeviceIdToSpecParams(newId, sb.toString()));
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedDisks(T entity) {
    Guid id = Guid.Empty;
    id = entity.getId();
    List<DiskImage> disks = entity.getImages();
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedDisks(T entity) {
    final Guid id = entity.getId();
    List<DiskImage> disks;
    if (entity instanceof VmTemplate) {
        disks = entity.getDiskList();
    } else {
        disks = entity.getImages();
    }
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    Guid id = Guid.Empty;
    id = entity.getId();
    List<VmNetworkInterface> ifaces = entity.getInterfaces();
    for (VmNetworkInterface iface : ifaces) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    final Guid id = entity.getId();
    for (VmNetworkInterface iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId) {
    Guid id;
    VmBase vmBase = DbFacade.getInstance().getVmStaticDAO().get(dstId);
    List<DiskImage> disks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(dstId);
    List<VmNetworkInterface> ifaces;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (isVm) {
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(dstId);
    } else {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        String specParams = "";
        if (srcId.equals(Guid.Empty)) {
            // only update number of monitors if this is a desktop
            if (vmBase.getvm_type() == VmType.Desktop) {
                updateNumOfMonitorsInVmDevice(null, vmBase);
            }
            // skip Blank template devices
            continue;
        }
        if (device.getType().equalsIgnoreCase(VmDeviceType.DISK.name()) && device.getDevice().equalsIgnoreCase(VmDeviceType.DISK.name())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getimage_group_id();
            }
        } else if (device.getType().equalsIgnoreCase(VmDeviceType.INTERFACE.name())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (device.getType().equalsIgnoreCase(VmDeviceType.VIDEO.name())) {
            specParams = getMemExpr(vmBase.getnum_of_monitors());
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(appendDeviceIdToSpecParams(id, specParams));
        dao.save(device);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId) {
    Guid id;
    VmBase vmBase = DbFacade.getInstance().getVmStaticDAO().get(dstId);
    List<DiskImage> disks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(dstId);
    List<VmNetworkInterface> ifaces;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (isVm) {
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(dstId);
    } else {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
        ifaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        String specParams = "";
        if (srcId.equals(Guid.Empty)) {
            // only update number of monitors if this is a desktop
            if (vmBase.getvm_type() == VmType.Desktop) {
                updateNumOfMonitorsInVmDevice(null, vmBase);
            }
            // skip Blank template devices
            continue;
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getimage_group_id();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            specParams = getMemExpr(vmBase.getnum_of_monitors());
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(appendDeviceIdToSpecParams(id, specParams));
        dao.save(device);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
    }
}
#end_block

#method_before
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, VmDeviceType.getName(type), VmDeviceType.getName(device), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#method_after
public static void addManagedDevice(VmDeviceId id, VmDeviceType type, VmDeviceType device, String specParams, boolean is_plugged, boolean isReadOnly) {
    VmDevice managedDevice = new VmDevice(id, type.getName(), device.getName(), "", 0, specParams, true, is_plugged, isReadOnly);
    dao.save(managedDevice);
}
#end_block

#method_before
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#method_after
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    String newIsoPath = newVmBase.getiso_path();
    String oldIsoPath = oldVmBase.getiso_path();
    if (StringUtils.isEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath)) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newIsoPath, true, null, false);
        dao.save(cd);
    } else {
        if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isEmpty(newIsoPath)) {
            // existing CD was removed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            dao.remove(list.get(0).getId());
        } else if (StringUtils.isNotEmpty(oldIsoPath) && StringUtils.isNotEmpty(newIsoPath) && !oldIsoPath.equals(newIsoPath)) {
            // CD was changed
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
            VmDevice cd = list.get(0);
            cd.setSpecParams(newIsoPath);
            dao.update(cd);
        }
    }
}
#end_block

#method_before
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#method_after
/**
 * updates new VM CD ROM in vm_device
 * @param newVmBase
 */
private static void updateCdInVmDevice(VmBase newVmBase) {
    if (StringUtils.isNotEmpty(newVmBase.getiso_path())) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmBase.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, newVmBase.getiso_path(), true, null, false);
        dao.save(cd);
    }
}
#end_block

#method_before
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.BRIDGE))) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.INTERFACE.getName()) && device.getDevice().equals(VmDeviceType.BRIDGE.getName())) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM))) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#method_after
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.CDROM.getName())) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK))) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.DISK.getName()) && device.getDevice().equals(VmDeviceType.DISK.getName())) {
            Guid id = device.getDeviceId();
            Disk disk = DbFacade.getInstance().getDiskDao().get(id);
            if (id != null && !id.equals(Guid.Empty)) {
                if (isOldCluster) {
                    // old version.
                    if (disk != null && disk.getDiskType().equals(DiskType.System)) {
                        device.setBootOrder(bootOrder++);
                        break;
                    }
                } else {
                    // supporting more than 1 bootable disk in 3.1 and up.
                    device.setBootOrder(bootOrder++);
                }
            }
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            StringBuilder sb = new StringBuilder(appendDeviceIdToSpecParams(newId, getMemExpr(newStatic.getnum_of_monitors())));
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.getName(VmDeviceType.VIDEO));
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            StringBuilder sb = new StringBuilder(appendDeviceIdToSpecParams(newId, getMemExpr(newStatic.getnum_of_monitors())));
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, sb.toString(), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        for (int i = 0; i < (prevNumOfMonitors - newStatic.getnum_of_monitors()); i++) {
            dao.remove(list.get(i).getId());
        }
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedDisks(T entity) {
    Guid id = entity.getId();
    List<DiskImage> disks = entity.getImages();
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedDisks(T entity) {
    final Guid id = entity.getId();
    List<DiskImage> disks;
    if (entity instanceof VmTemplate) {
        disks = entity.getDiskList();
    } else {
        disks = entity.getImages();
    }
    for (DiskImage disk : disks) {
        Guid deviceId = disk.getDisk().getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.DISK, VmDeviceType.DISK, specParams, true, false);
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    Guid id = entity.getId();
    List<VmNetworkInterface> ifaces = entity.getInterfaces();
    for (VmNetworkInterface iface : ifaces) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#method_after
private static <T extends VmBase> void addImportedInterfaces(T entity) {
    final Guid id = entity.getId();
    for (VmNetworkInterface iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        String specParams = appendDeviceIdToSpecParams(deviceId, "");
        addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceType.INTERFACE, VmDeviceType.BRIDGE, specParams, true, false);
    }
}
#end_block

#method_before
private DetailedLink addParametersMetadata(DetailedLink link) {
    String link_name = link.getHref() + "|rel=" + link.getRel();
    if (this.parametersMetaData.containsKey(link_name)) {
        Action action = this.parametersMetaData.get(link_name);
        if (action.getRequest() != null) {
            if (action.getRequest().getUrlparams() != null && !action.getRequest().getUrlparams().isEmpty()) {
                link.getRequest().setUrl(new Url());
                ParametersSet ps = new ParametersSet();
                for (Object key : action.getRequest().getUrlparams().keySet()) {
                    Parameter param = new Parameter();
                    param.setName(key.toString());
                    Object value = action.getRequest().getUrlparams().get(key);
                    if (value != null) {
                        UrlParamData urlParamData = (UrlParamData) value;
                        param.setType(urlParamData.getType());
                        param.setContext(urlParamData.getContext());
                        param.setValue(urlParamData.getDescription());
                    }
                    ps.getParameters().add(param);
                }
                link.getRequest().getUrl().getParametersSets().add(ps);
            }
            if (action.getRequest().getHeaders() != null && !action.getRequest().getHeaders().isEmpty()) {
                link.getRequest().setHeaders(new Headers());
                for (Object key : action.getRequest().getHeaders().keySet()) {
                    Header header = new Header();
                    header.setName(key.toString());
                    Object value = action.getRequest().getHeaders().get(key);
                    if (value != null) {
                        header.setValue(value.toString());
                    }
                    link.getRequest().getHeaders().getHeaders().add(header);
                }
            }
            if (action.getRequest().getBody() != null) {
                if (action.getRequest().getBody().getSignatures() != null) {
                    for (Signature signature : action.getRequest().getBody().getSignatures()) {
                        ParametersSet ps = new ParametersSet();
                        for (Entry<Object, Object> mandatoryKeyValuePair : signature.getMandatoryArguments().entrySet()) {
                            Parameter mandatory_param = new Parameter();
                            mandatory_param.setName(mandatoryKeyValuePair.getKey().toString());
                            mandatory_param.setType(mandatoryKeyValuePair.getValue().toString());
                            mandatory_param.setMandatory(true);
                            ps.getParameters().add(mandatory_param);
                        }
                        for (Entry<Object, Object> optionalKeyValuePair : signature.getOptionalArguments().entrySet()) {
                            Parameter optional_param = new Parameter();
                            optional_param.setName(optionalKeyValuePair.getKey().toString());
                            optional_param.setType(optionalKeyValuePair.getValue().toString());
                            optional_param.setMandatory(false);
                            ps.getParameters().add(optional_param);
                        }
                        link.getRequest().getBody().getParametersSets().add(ps);
                    }
                }
            }
        }
    }
    return link;
}
#method_after
private DetailedLink addParametersMetadata(DetailedLink link) {
    String link_name = link.getHref() + "|rel=" + link.getRel();
    if (this.parametersMetaData.containsKey(link_name)) {
        Action action = this.parametersMetaData.get(link_name);
        if (action.getRequest() != null) {
            if (action.getRequest().getUrlparams() != null && !action.getRequest().getUrlparams().isEmpty()) {
                link.getRequest().setUrl(new Url());
                ParametersSet ps = new ParametersSet();
                for (Object key : action.getRequest().getUrlparams().keySet()) {
                    Parameter param = new Parameter();
                    param.setName(key.toString());
                    Object value = action.getRequest().getUrlparams().get(key);
                    if (value != null) {
                        UrlParamData urlParamData = (UrlParamData) value;
                        param.setType(urlParamData.getType());
                        param.setContext(urlParamData.getContext());
                        param.setValue(urlParamData.getValue());
                        param.setRequired(urlParamData.getRequired() == null ? false : urlParamData.getRequired());
                    }
                    ps.getParameters().add(param);
                }
                link.getRequest().getUrl().getParametersSets().add(ps);
            }
            if (action.getRequest().getHeaders() != null && !action.getRequest().getHeaders().isEmpty()) {
                link.getRequest().setHeaders(new Headers());
                for (Object key : action.getRequest().getHeaders().keySet()) {
                    Header header = new Header();
                    header.setName(key.toString());
                    Object value = action.getRequest().getHeaders().get(key);
                    if (value != null) {
                        header.setValue(value.toString());
                    }
                    link.getRequest().getHeaders().getHeaders().add(header);
                }
            }
            if (action.getRequest().getBody() != null) {
                if (action.getRequest().getBody().getSignatures() != null) {
                    for (Signature signature : action.getRequest().getBody().getSignatures()) {
                        ParametersSet ps = new ParametersSet();
                        for (Entry<Object, Object> mandatoryKeyValuePair : signature.getMandatoryArguments().entrySet()) {
                            Parameter mandatory_param = new Parameter();
                            mandatory_param.setName(mandatoryKeyValuePair.getKey().toString());
                            mandatory_param.setType(mandatoryKeyValuePair.getValue().toString());
                            mandatory_param.setRequired(true);
                            ps.getParameters().add(mandatory_param);
                        }
                        for (Entry<Object, Object> optionalKeyValuePair : signature.getOptionalArguments().entrySet()) {
                            Parameter optional_param = new Parameter();
                            optional_param.setName(optionalKeyValuePair.getKey().toString());
                            optional_param.setType(optionalKeyValuePair.getValue().toString());
                            optional_param.setRequired(false);
                            ps.getParameters().add(optional_param);
                        }
                        link.getRequest().getBody().getParametersSets().add(ps);
                    }
                }
            }
        }
    }
    return link;
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = prepareDAO(dbFacade.getVdsDAO());
    existingVds = vdsDAO.get(new NGuid("afce7a39-8e8c-4819-ba9c-796d316592e6"));
    StoragePoolDAO storagePoolDAO = prepareDAO(dbFacade.getStoragePoolDAO());
    storagePool = storagePoolDAO.get(new Guid("6d849ebf-755f-4552-ad09-9a090cda105d"));
    dao = prepareDAO(dbFacade.getVdsGroupDAO());
    existingVdsGroup = dao.get(existingVds.getvds_group_id());
    groupWithNoRunningVms = dbFacade.getVdsGroupDAO().get(new Guid("b399944a-81ab-4ec5-8266-e19ba7c3c9d3"));
    newGroup = new VDSGroup();
    newGroup.setname("New VDS Group");
    newGroup.setcompatibility_version(new Version("3.0"));
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = prepareDAO(dbFacade.getVdsDAO());
    existingVds = vdsDAO.get(FixturesTool.VDS_RHEL6_NFS_SPM);
    StoragePoolDAO storagePoolDAO = prepareDAO(dbFacade.getStoragePoolDAO());
    storagePool = storagePoolDAO.get(FixturesTool.STORAGE_POOL_RHEL6_ISCSI_OTHER);
    dao = prepareDAO(dbFacade.getVdsGroupDAO());
    existingVdsGroup = dao.get(existingVds.getvds_group_id());
    groupWithNoRunningVms = dbFacade.getVdsGroupDAO().get(FixturesTool.VDS_GROUP_NO_RUNNING_VMS);
    newGroup = new VDSGroup();
    newGroup.setname("New VDS Group");
    newGroup.setcompatibility_version(new Version("3.0"));
}
#end_block

#method_before
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getVmPoolId() == null ? null : getVmPoolId().getValue(), VdcObjectType.VmPool);
}
#method_after
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVmPoolId() == null ? null : getVmPoolId().getValue(), VdcObjectType.VmPool, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
private void managePrestartedVmsInPool(vm_pools vmPool) {
    int prestartedVms;
    int missingPrestartedVms;
    int vmsToPrestart;
    Guid vmGuid;
    prestartedVms = VmPoolCommandBase.getNumOfPrestartedVmsInPool(vmPool.getvm_pool_id());
    missingPrestartedVms = vmPool.getPrestartedVms() - prestartedVms;
    if (missingPrestartedVms > 0) {
        // We do not want to start too many vms at once
        int batchSize = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorBatchSize);
        if (missingPrestartedVms > batchSize) {
            vmsToPrestart = batchSize;
        } else {
            vmsToPrestart = missingPrestartedVms;
        }
        log.infoFormat("Missing {0} prestarted Vms, attempting to prestart {1} Vms", missingPrestartedVms, vmsToPrestart);
        for (int i = 0; i < vmsToPrestart; i++) {
            vmGuid = VmPoolCommandBase.getNonPrestartedVmToAttach(vmPool.getvm_pool_id());
            if (vmGuid != Guid.Empty) {
                // If failed to prestart a Vm, stop trying
                if (!prestartVm(vmGuid)) {
                    break;
                }
            } else {
                log.infoFormat("No Vms avaialable for prestarting");
                break;
            }
        }
    }
}
#method_after
private void managePrestartedVmsInPool(vm_pools vmPool) {
    int prestartedVms;
    int missingPrestartedVms;
    int numOfVmsToPrestart;
    prestartedVms = VmPoolCommandBase.getNumOfPrestartedVmsInPool(vmPool.getvm_pool_id());
    missingPrestartedVms = vmPool.getPrestartedVms() - prestartedVms;
    if (missingPrestartedVms > 0) {
        // We do not want to start too many vms at once
        int batchSize = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorBatchSize);
        if (missingPrestartedVms > batchSize) {
            numOfVmsToPrestart = batchSize;
        } else {
            numOfVmsToPrestart = missingPrestartedVms;
        }
        log.infoFormat("VmPool {0} is missing {1} prestarted Vms, attempting to prestart {2} Vms", vmPool.getvm_pool_id(), missingPrestartedVms, numOfVmsToPrestart);
        prestartVms(vmPool, numOfVmsToPrestart);
    }
}
#end_block

#method_before
private boolean prestartVm(Guid vmGuid) {
    log.infoFormat("Prestarting Vm {0}", vmGuid);
    boolean prestartingVmSucceeded = false;
    RunVmParams runVmParams = new RunVmParams(vmGuid);
    VM vm = DbFacade.getInstance().getVmDAO().get(vmGuid);
    runVmParams.setUseVnc(vm.getvm_type() == VmType.Server);
    runVmParams.setEntityId(vm);
    runVmParams.setParentCommand(VdcActionType.RunVm);
    runVmParams.setUseVnc(vm.getvm_type() == VmType.Server);
    runVmParams.setRunAsStateless(true);
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
    prestartingVmSucceeded = vdcReturnValue.getSucceeded();
    if (prestartingVmSucceeded) {
        log.infoFormat("Prestarting Vm {0} succeeded", vmGuid);
    } else {
        log.infoFormat("Prestarting Vm {0} failed", vmGuid);
    }
    return prestartingVmSucceeded;
}
#method_after
private boolean prestartVm(VM vmToPrestart) {
    log.infoFormat("Prestarting Vm {0}", vmToPrestart);
    boolean prestartingVmSucceeded = false;
    RunVmParams runVmParams = new RunVmParams(vmToPrestart.getId());
    runVmParams.setUseVnc(vmToPrestart.getvm_type() == VmType.Server);
    runVmParams.setEntityId(vmToPrestart);
    runVmParams.setRunAsStateless(true);
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
    prestartingVmSucceeded = vdcReturnValue.getSucceeded();
    if (prestartingVmSucceeded) {
        log.infoFormat("Prestarting Vm {0} succeeded", vmToPrestart);
    } else {
        log.infoFormat("Prestarting Vm {0} failed", vmToPrestart);
    }
    return prestartingVmSucceeded;
}
#end_block

#method_before
private void RestoreVmFromBaseSnapshot(VM vm) {
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId()).size() > 0) {
        log.infoFormat("Deleting snapshots for stateless vm {0}", vm.getId());
        Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(vm.getId()), new CommandContext(getCompensationContext()));
    }
}
#method_after
private void RestoreVmFromBaseSnapshot(VM vm) {
    if (getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId()).size() > 0) {
        log.infoFormat("Deleting snapshots for stateless vm {0}", vm.getId());
        Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(vm.getId()), new CommandContext(getCompensationContext()));
    }
}
#end_block

#method_before
@Override
public vm_pools get(NGuid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_id", id);
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            entity.setvm_assigned_count(rs.getInt("assigned_vm_count"));
            entity.setvm_running_count(rs.getInt("vm_running_count"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetVm_poolsByvm_pool_id", mapper, parameterSource);
}
#method_after
@Override
public vm_pools get(NGuid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_id", id);
    return getCallsHandler().executeRead("GetVm_poolsByvm_pool_id", vmPoolFullRowMapper, parameterSource);
}
#end_block

#method_before
@Override
public vm_pools getByName(String name) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_name", name);
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetVm_poolsByvm_pool_name", mapper, parameterSource);
}
#method_after
@Override
public vm_pools getByName(String name) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_name", name);
    return getCallsHandler().executeRead("GetVm_poolsByvm_pool_name", vmPoolNonFullRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvm_assigned_count(rs.getInt("assigned_vm_count"));
            entity.setvm_running_count(rs.getInt("vm_running_count"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllFromVm_pools", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return getCallsHandler().executeReadList("GetAllFromVm_pools", vmPoolFullRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForUser(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", id);
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllVm_poolsByUser_id_with_groups_and_UserRoles", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForUser(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", id);
    return getCallsHandler().executeReadList("GetAllVm_poolsByUser_id_with_groups_and_UserRoles", vmPoolNonFullRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForAdGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_group_id", id);
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetVm_poolsByAdGroup_id", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForAdGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_group_id", id);
    return getCallsHandler().executeReadList("GetVm_poolsByAdGroup_id", vmPoolNonFullRowMapper, parameterSource);
}
#end_block

#method_before
@Override
public List<vm_pools> getAllWithQuery(String query) {
    ParameterizedRowMapper<vm_pools> mapper = new ParameterizedRowMapper<vm_pools>() {

        @Override
        public vm_pools mapRow(ResultSet rs, int rowNum) throws SQLException {
            vm_pools entity = new vm_pools();
            entity.setvm_pool_description(rs.getString("vm_pool_description"));
            entity.setvm_pool_id(Guid.createGuidFromString(rs.getString("vm_pool_id")));
            entity.setvm_pool_name(rs.getString("vm_pool_name"));
            entity.setvm_pool_type(VmPoolType.forValue(rs.getInt("vm_pool_type")));
            entity.setparameters(rs.getString("parameters"));
            entity.setPrestartedVms(rs.getInt("prestarted_vms"));
            entity.setvm_assigned_count(rs.getInt("assigned_vm_count"));
            entity.setvm_running_count(rs.getInt("vm_running_count"));
            entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
            entity.setvds_group_name(rs.getString("vds_group_name"));
            return entity;
        }
    };
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, mapper);
}
#method_after
@Override
public List<vm_pools> getAllWithQuery(String query) {
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, vmPoolFullRowMapper);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    initUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach = Guid.Empty;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach(getParameters().getVmPoolId());
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach(getParameters().getVmPoolId());
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityId(vmToAttach);
            setVmId(vmToAttach);
            permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
            VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, new CommandContext(getCompensationContext()));
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.infoFormat("Succceeded giving user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
            }
        } else {
            log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
            throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        setVm(DbFacade.getInstance().getVmDAO().get(vmToAttach));
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setUseVnc(getVm().getvm_type() == VmType.Server);
        runVmParams.setParentParemeters(getParameters());
        runVmParams.setEntityId(vmToAttach);
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
    }
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    initUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach = Guid.Empty;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach(getParameters().getVmPoolId());
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach(getParameters().getVmPoolId());
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityId(vmToAttach);
            setVmId(vmToAttach);
            permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
            VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, new CommandContext(getCompensationContext()));
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.infoFormat("Succceeded giving user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
            }
        } else {
            log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
            throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        setVm(getVmDAO().get(vmToAttach));
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setUseVnc(getVm().getvm_type() == VmType.Server);
        runVmParams.setParentParemeters(getParameters());
        runVmParams.setEntityId(vmToAttach);
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
public DiskImage get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setactive((Boolean) rs.getObject("active"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetImageByImageGuid", mapper, parameterSource);
}
#method_after
@Override
public DiskImage get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    List<DiskImage> images = groupImagesStorage(getCallsHandler().executeReadList("GetImageByImageGuid", fullDiskImageRowMapper, parameterSource));
    if (images == null || images.isEmpty()) {
        return null;
    }
    return images.get(0);
}
#end_block

#method_before
@Override
public DiskImage getSnapshotById(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetSnapshotByGuid", mapper, parameterSource);
}
#method_after
@Override
public DiskImage getSnapshotById(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    return getCallsHandler().executeRead("GetSnapshotByGuid", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllForVm(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setactive((Boolean) rs.getObject("active"));
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetImagesByVmGuid", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllForVm(Guid id) {
    return getAllForVm(id, null, false);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllForVm(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setactive((Boolean) rs.getObject("active"));
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetImagesByVmGuid", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllForVm(Guid id, Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id).addValue("user_id", userID).addValue("is_filtered", isFiltered);
    return groupImagesStorage(getCallsHandler().executeReadList("GetImagesByVmGuid", fullDiskImageRowMapper, parameterSource));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllSnapshotsForParent(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("parent_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetSnapshotByParentGuid", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllSnapshotsForParent(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("parent_guid", id);
    return getCallsHandler().executeReadList("GetSnapshotByParentGuid", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllSnapshotsForStorageDomain(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_domain_id", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetSnapshotsByStorageDomainId", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllSnapshotsForStorageDomain(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_domain_id", id);
    return getCallsHandler().executeReadList("GetSnapshotsByStorageDomainId", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllSnapshotsForVmSnapshot(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_snapshot_id", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetSnapshotsByVmSnapshotId", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllSnapshotsForVmSnapshot(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_snapshot_id", id);
    return getCallsHandler().executeReadList("GetSnapshotsByVmSnapshotId", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAllSnapshotsForImageGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_group_id", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetSnapshotsByImageGroupId", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllSnapshotsForImageGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_group_id", id);
    return getCallsHandler().executeReadList("GetSnapshotsByImageGroupId", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<DiskImage> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setactual_size(rs.getLong("actual_size"));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setstorage_path(rs.getString("storage_path"));
            entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            entity.setread_rate(rs.getInt("read_rate"));
            entity.setwrite_rate(rs.getInt("write_rate"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllFromImages", mapper, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return groupImagesStorage(getCallsHandler().executeReadList("GetAllFromImages", diskImageRowMapper, parameterSource));
}
#end_block

#method_before
@Override
public void save(DiskImage image) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("creation_date", image.getcreation_date()).addValue("description", image.getdescription()).addValue("image_guid", image.getId()).addValue("internal_drive_mapping", image.getinternal_drive_mapping()).addValue("it_guid", image.getit_guid()).addValue("size", image.getsize()).addValue("ParentId", image.getParentId()).addValue("imageStatus", image.getimageStatus()).addValue("lastModified", image.getlastModified()).addValue("app_list", image.getappList()).addValue("storage_id", image.getstorage_id()).addValue("vm_snapshot_id", image.getvm_snapshot_id()).addValue("volume_type", image.getvolume_type()).addValue("volume_format", image.getvolume_format()).addValue("disk_type", image.getdisk_type()).addValue("image_group_id", image.getimage_group_id()).addValue("disk_interface", image.getdisk_interface()).addValue("boot", image.getboot()).addValue("wipe_after_delete", image.getwipe_after_delete()).addValue("propagate_errors", image.getpropagate_errors());
    getCallsHandler().executeModification("InsertImage", parameterSource);
}
#method_after
@Override
public void save(DiskImage image) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("creation_date", image.getcreation_date()).addValue("description", image.getdescription()).addValue("image_guid", image.getId()).addValue("internal_drive_mapping", image.getinternal_drive_mapping()).addValue("it_guid", image.getit_guid()).addValue("size", image.getsize()).addValue("ParentId", image.getParentId()).addValue("imageStatus", image.getimageStatus()).addValue("lastModified", image.getlastModified()).addValue("app_list", image.getappList()).addValue("vm_snapshot_id", image.getvm_snapshot_id()).addValue("volume_type", image.getvolume_type()).addValue("volume_format", image.getvolume_format()).addValue("disk_type", image.getdisk_type()).addValue("image_group_id", image.getimage_group_id()).addValue("disk_interface", image.getdisk_interface()).addValue("boot", image.getboot()).addValue("wipe_after_delete", image.getwipe_after_delete()).addValue("propagate_errors", image.getpropagate_errors()).addValue("quota_id", image.getQuotaId());
    getCallsHandler().executeModification("InsertImage", parameterSource);
}
#end_block

#method_before
@Override
public void update(DiskImage image) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("creation_date", image.getcreation_date()).addValue("description", image.getdescription()).addValue("image_guid", image.getId()).addValue("internal_drive_mapping", image.getinternal_drive_mapping()).addValue("it_guid", image.getit_guid()).addValue("size", image.getsize()).addValue("ParentId", image.getParentId()).addValue("imageStatus", image.getimageStatus()).addValue("lastModified", image.getlastModified()).addValue("app_list", image.getappList()).addValue("storage_id", image.getstorage_id()).addValue("vm_snapshot_id", image.getvm_snapshot_id()).addValue("volume_type", image.getvolume_type()).addValue("volume_format", image.getvolume_format()).addValue("disk_type", image.getdisk_type()).addValue("image_group_id", image.getimage_group_id()).addValue("disk_interface", image.getdisk_interface()).addValue("boot", image.getboot()).addValue("wipe_after_delete", image.getwipe_after_delete()).addValue("propagate_errors", image.getpropagate_errors());
    getCallsHandler().executeModification("UpdateImage", parameterSource);
}
#method_after
@Override
public void update(DiskImage image) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("creation_date", image.getcreation_date()).addValue("description", image.getdescription()).addValue("image_guid", image.getId()).addValue("internal_drive_mapping", image.getinternal_drive_mapping()).addValue("it_guid", image.getit_guid()).addValue("size", image.getsize()).addValue("ParentId", image.getParentId()).addValue("imageStatus", image.getimageStatus()).addValue("lastModified", image.getlastModified()).addValue("app_list", image.getappList()).addValue("vm_snapshot_id", image.getvm_snapshot_id()).addValue("volume_type", image.getvolume_type()).addValue("volume_format", image.getvolume_format()).addValue("disk_type", image.getdisk_type()).addValue("image_group_id", image.getimage_group_id()).addValue("disk_interface", image.getdisk_interface()).addValue("boot", image.getboot()).addValue("wipe_after_delete", image.getwipe_after_delete()).addValue("propagate_errors", image.getpropagate_errors()).addValue("quota_id", image.getQuotaId());
    getCallsHandler().executeModification("UpdateImage", parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<stateless_vm_image_map> getAllStatelessVmImageMapsForVm(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", vmId);
    ParameterizedRowMapper<stateless_vm_image_map> mapper = new ParameterizedRowMapper<stateless_vm_image_map>() {

        @Override
        public stateless_vm_image_map mapRow(ResultSet rs, int rowNum) throws SQLException {
            stateless_vm_image_map entity = new stateless_vm_image_map();
            entity.setimage_guid(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("Getstateless_vm_image_mapByvm_guid", mapper, parameterSource);
}
#method_after
@Override
public List<stateless_vm_image_map> getAllStatelessVmImageMapsForVm(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", vmId);
    ParameterizedRowMapper<stateless_vm_image_map> mapper = new ParameterizedRowMapper<stateless_vm_image_map>() {

        @Override
        public stateless_vm_image_map mapRow(ResultSet rs, int rowNum) throws SQLException {
            stateless_vm_image_map entity = new stateless_vm_image_map();
            entity.setimage_guid(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("Getstateless_vm_image_mapByvm_guid", mapper, parameterSource);
}
#end_block

#method_before
@Override
public DiskImage getAncestor(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    ParameterizedRowMapper<DiskImage> mapper = new ParameterizedRowMapper<DiskImage>() {

        @Override
        public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
            DiskImage entity = new DiskImage();
            entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
            entity.setdescription(rs.getString("description"));
            entity.setId(Guid.createGuidFromString(rs.getString("image_guid")));
            entity.setinternal_drive_mapping(rs.getString("internal_drive_mapping"));
            entity.setit_guid(Guid.createGuidFromString(rs.getString("it_guid")));
            entity.setsize(rs.getLong("size"));
            entity.setParentId(Guid.createGuidFromString(rs.getString("ParentId")));
            entity.setimageStatus(ImageStatus.forValue(rs.getInt("imageStatus")));
            entity.setlastModified(DbFacadeUtils.fromDate(rs.getTimestamp("lastModified")));
            entity.setappList(rs.getString("app_list"));
            entity.setstorage_id(NGuid.createGuidFromString(rs.getString("storage_id")));
            entity.setvm_snapshot_id(NGuid.createGuidFromString(rs.getString("vm_snapshot_id")));
            entity.setvolume_type(VolumeType.forValue(rs.getInt("volume_type")));
            entity.setvolume_format(VolumeFormat.forValue(rs.getInt("volume_format")));
            entity.setdisk_type(DiskType.forValue(rs.getInt("disk_type")));
            entity.setimage_group_id(Guid.createGuidFromString(rs.getString("image_group_id")));
            entity.setdisk_interface(DiskInterface.forValue(rs.getInt("disk_interface")));
            entity.setboot(rs.getBoolean("boot"));
            entity.setwipe_after_delete(rs.getBoolean("wipe_after_delete"));
            entity.setpropagate_errors(PropagateErrors.forValue(rs.getInt("propagate_errors")));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetAncestralImageByImageGuid", mapper, parameterSource);
}
#method_after
@Override
public DiskImage getAncestor(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    return getCallsHandler().executeRead("GetAncestralImageByImageGuid", diskImageRowMapper, parameterSource);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    diskImageDynamicDao = prepareDAO(dbFacade.getDiskImageDynamicDAO());
    diskDao = prepareDAO(dbFacade.getDiskDao());
    existingStatelessMapping = dao.getStatelessVmImageMapForImageId(EXISTING_IMAGE_ID);
    newImage = new DiskImage();
    newImage.setactive(true);
    newImage.setvm_guid(EXISTING_VM_ID);
    newImage.setit_guid(EXISTING_IMAGE_DISK_TEMPLATE);
    newImage.setId(Guid.NewGuid());
    newImage.setinternal_drive_mapping("4");
    newImage.setvolume_format(VolumeFormat.COW);
    newImage.setvolume_type(VolumeType.Sparse);
    newImage.setdisk_interface(DiskInterface.IDE);
    newImage.setdisk_type(DiskType.Data);
    newImage.setimage_group_id(Guid.NewGuid());
    newImageVmPoolMapping = new stateless_vm_image_map(FREE_IMAGE_ID, "z", FREE_VM_ID);
    existingStatelessDiskImageMap = dao.getStatelessVmImageMapForImageId(existingEntity.getId());
    newStatelessVmImageMap = new stateless_vm_image_map(FREE_IMAGE_ID, "q", FREE_VM_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    diskImageDynamicDao = prepareDAO(dbFacade.getDiskImageDynamicDAO());
    diskDao = prepareDAO(dbFacade.getDiskDao());
    existingStatelessMapping = dao.getStatelessVmImageMapForImageId(EXISTING_IMAGE_ID);
    newImage = new DiskImage();
    newImage.setactive(true);
    newImage.setvm_guid(FixturesTool.VM_RHEL5_POOL_57);
    newImage.setit_guid(EXISTING_IMAGE_DISK_TEMPLATE);
    newImage.setId(Guid.NewGuid());
    newImage.setinternal_drive_mapping("4");
    newImage.setvolume_format(VolumeFormat.COW);
    newImage.setvolume_type(VolumeType.Sparse);
    newImage.setdisk_interface(DiskInterface.IDE);
    newImage.setdisk_type(DiskType.Data);
    newImage.setimage_group_id(Guid.NewGuid());
    newImage.setQuotaId(Guid.NewGuid());
    newImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(Guid.Empty)));
    newImageVmPoolMapping = new stateless_vm_image_map(FREE_IMAGE_ID, "z", FREE_VM_ID);
    existingStatelessDiskImageMap = dao.getStatelessVmImageMapForImageId(existingEntity.getId());
    newStatelessVmImageMap = new stateless_vm_image_map(FREE_IMAGE_ID, "q", FREE_VM_ID);
    existingTemplate = dao.get(EXISTING_IMAGE_DISK_TEMPLATE);
}
#end_block

#method_before
@Test
@Override
public void testSave() {
    dao.save(newImage);
    // TODO this call is only necessary when we have a DbFacade implementation
    if (dao instanceof BaseDAODbFacade) {
        dbFacade.getImageVmMapDAO().save(new image_vm_map(true, newImage.getId(), EXISTING_VM_ID));
    }
    DiskImageDynamic dynamic = new DiskImageDynamic();
    dynamic.setId(newImage.getId());
    diskDao.save(newImage.getDisk());
    diskImageDynamicDao.save(dynamic);
    DiskImageDynamic dynamicFromDB = diskImageDynamicDao.get(dynamic.getId());
    assertNotNull(dynamicFromDB);
    DiskImage result = dao.get(newImage.getId());
    assertNotNull(result);
    assertEquals(newImage, result);
    image_vm_map mapping = dbFacade.getImageVmMapDAO().getByImageId(result.getId());
    assertNotNull(mapping);
    assertTrue(mapping.getactive());
    assertEquals(newImage.getId(), mapping.getimage_id());
    assertEquals(newImage.getvm_guid(), mapping.getvm_id());
}
#method_after
@Test
@Override
public void testSave() {
    dao.save(newImage);
    // TODO this call is only necessary when we have a DbFacade implementation
    if (dao instanceof BaseDAODbFacade) {
        dbFacade.getImageVmMapDAO().save(new image_vm_map(true, newImage.getId(), FixturesTool.VM_RHEL5_POOL_57));
    }
    DiskImageDynamic dynamic = new DiskImageDynamic();
    dynamic.setId(newImage.getId());
    diskDao.save(newImage.getDisk());
    diskImageDynamicDao.save(dynamic);
    DiskImageDynamic dynamicFromDB = diskImageDynamicDao.get(dynamic.getId());
    assertNotNull(dynamicFromDB);
    DiskImage result = dao.get(newImage.getId());
    assertNotNull(result);
    assertEquals(newImage, result);
    image_vm_map mapping = dbFacade.getImageVmMapDAO().getByImageId(result.getId());
    assertNotNull(mapping);
    assertTrue(mapping.getactive());
    assertEquals(newImage.getId(), mapping.getimage_id());
    assertEquals(newImage.getvm_guid(), mapping.getvm_id());
}
#end_block

#method_before
@Test
public void testGetStatelessImageMapByVmId() {
    List<stateless_vm_image_map> result = dao.getAllStatelessVmImageMapsForVm(EXISTING_VM_ID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (stateless_vm_image_map map : result) {
        assertEquals(EXISTING_VM_ID, map.getvm_guid());
    }
}
#method_after
@Test
public void testGetStatelessImageMapByVmId() {
    List<stateless_vm_image_map> result = dao.getAllStatelessVmImageMapsForVm(FixturesTool.VM_RHEL5_POOL_57);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (stateless_vm_image_map map : result) {
        assertEquals(FixturesTool.VM_RHEL5_POOL_57, map.getvm_guid());
    }
}
#end_block

#method_before
@Test
public void testGetAllStatelessDiskImagesForVm() {
    List<stateless_vm_image_map> result = dao.getAllStatelessVmImageMapsForVm(EXISTING_VM_ID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (stateless_vm_image_map mapping : result) {
        assertEquals(EXISTING_VM_ID, mapping.getvm_guid());
    }
}
#method_after
@Test
public void testGetAllStatelessDiskImagesForVm() {
    List<stateless_vm_image_map> result = dao.getAllStatelessVmImageMapsForVm(FixturesTool.VM_RHEL5_POOL_57);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (stateless_vm_image_map mapping : result) {
        assertEquals(FixturesTool.VM_RHEL5_POOL_57, mapping.getvm_guid());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // if (CanAddVmToPool(VmId,null,null))
    // {
    DbFacade.getInstance().getVmPoolDAO().addVmToPool(new vm_pool_map(getVmId(), getVmPoolId()));
    // VM vm = DbFacade.Instance.GetvmsBy_vm_guid(VmId);
    VmHandler.updateDisksFromDb(getVm());
    // todo: omer - save only vm_snapshot_id instead all vm images
    for (DiskImage image : getVm()) {
        DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(image.getId(), image.getinternal_drive_mapping(), getVmId()));
    }
    setSucceeded(true);
// }
}
#method_after
@Override
protected void executeCommand() {
    DbFacade.getInstance().getVmPoolDAO().addVmToPool(new vm_pool_map(getVmId(), getVmPoolId()));
    setSucceeded(true);
}
#end_block

#method_before
protected void DetachAllVmsFromUser() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
    for (VM vm : vms) {
        if (getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
            permissions perm = DbFacade.getInstance().getPermissionDAO().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), vm.getvm_guid());
            if (perm != null) {
                DbFacade.getInstance().getPermissionDAO().remove(perm.getId());
                RestoreVmFromBaseSnapshot(vm);
            }
        }
    }
}
#method_after
protected void DetachAllVmsFromUser() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
    for (VM vm : vms) {
        if (getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
            permissions perm = DbFacade.getInstance().getPermissionDAO().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), vm.getId());
            if (perm != null) {
                DbFacade.getInstance().getPermissionDAO().remove(perm.getId());
                RestoreVmFromBaseSnapshot(vm);
            }
        }
    }
}
#end_block

#method_before
private void RestoreVmFromBaseSnapshot(VM vm) {
    List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getvm_guid());
    // java.util.ArrayList<DiskImage> imagesList = null; // LINQ 32934
    // list.Select(a =>
    // DbFacade.Instance.GetSnapshotById(a.image_guid)).ToList();
    List<DiskImage> imagesList = LinqUtils.foreach(list, new Function<stateless_vm_image_map, DiskImage>() {

        @Override
        public DiskImage eval(stateless_vm_image_map a) {
            return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(a.getimage_guid());
        }
    });
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(vm.getvm_guid(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar);
    }
}
#method_after
private void RestoreVmFromBaseSnapshot(VM vm) {
    List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId());
    // java.util.ArrayList<DiskImage> imagesList = null; // LINQ 32934
    // list.Select(a =>
    // DbFacade.Instance.GetSnapshotById(a.image_guid)).ToList();
    List<DiskImage> imagesList = LinqUtils.foreach(list, new Function<stateless_vm_image_map, DiskImage>() {

        @Override
        public DiskImage eval(stateless_vm_image_map a) {
            return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(a.getimage_guid());
        }
    });
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(vm.getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
}
#end_block

#method_before
public static boolean CanRemoveVmFromPool(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue = false;
    // Check if the vm is in a pool.
    if (DbFacade.getInstance().getVmPoolDAO().getVmPoolMapByVmGuid(vmId) == null) {
        // Check if the vm is in a time leased pool.
        if (DbFacade.getInstance().getVmPoolDAO().getTimeLeasedVmPoolMapByIdForVmPool(vmId, Guid.Empty) == null) {
            messages.add(VdcBllMessages.VM_POOL_CANNOT_DETACH_VM_NOT_ATTACHED_TO_POOL.toString());
            returnValue = true;
        }
    } else {
        returnValue = RemoveVmCommand.IsVmRunning(vmId);
        if (returnValue) {
            messages.add(VdcBllMessages.VM_POOL_CANNOT_REMOVE_RUNNING_VM_FROM_POOL.toString());
        }
    }
    return !returnValue;
}
#method_after
public static boolean CanRemoveVmFromPool(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue = true;
    // Check if the vm is in a pool.
    if (DbFacade.getInstance().getVmPoolDAO().getVmPoolMapByVmGuid(vmId) == null) {
        messages.add(VdcBllMessages.VM_POOL_CANNOT_DETACH_VM_NOT_ATTACHED_TO_POOL.toString());
        returnValue = false;
    }
    if (returnValue) {
        if (RemoveVmCommand.IsVmRunning(vmId)) {
            messages.add(VdcBllMessages.VM_POOL_CANNOT_REMOVE_RUNNING_VM_FROM_POOL.toString());
            returnValue = false;
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmPoolId() != null) {
        List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
        for (stateless_vm_image_map imageMap : list) {
            DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(imageMap.getimage_guid());
        }
        DbFacade.getInstance().getVmPoolDAO().removeVmFromVmPool(getVmId());
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmPoolId() != null) {
        DbFacade.getInstance().getVmPoolDAO().removeVmFromVmPool(getVmId());
        setSucceeded(true);
    }
}
#end_block

#method_before
public static Guid GetVmToAttach(NGuid poolId) {
    Guid vmGuid = Guid.Empty;
    vmGuid = getPrestartedVmToAttach(poolId);
    if (vmGuid == null || vmGuid.equals(Guid.Empty)) {
        vmGuid = getNonPrestartedVmToAttach(poolId);
    }
    return vmGuid;
}
#method_after
public static Guid GetVmToAttach(NGuid poolId) {
    Guid vmGuid = Guid.Empty;
    vmGuid = getPrestartedVmToAttach(poolId);
    if (vmGuid == null || Guid.Empty.equals(vmGuid)) {
        vmGuid = getNonPrestartedVmToAttach(poolId);
    }
    return vmGuid;
}
#end_block

#method_before
protected static Guid getNonPrestartedVmToAttach(NGuid poolId) {
    List<vm_pool_map> vmPools = DbFacade.getInstance().getVmPoolDAO().getVmPoolsMapByVmPoolId(poolId);
    if (vmPools != null) {
        for (vm_pool_map map : vmPools) {
            if (CanAttacheVmToUser(map.getvm_guid())) {
                return map.getvm_guid();
            }
        }
    }
    return Guid.Empty;
}
#method_after
protected static Guid getNonPrestartedVmToAttach(NGuid vmPoolId) {
    List<vm_pool_map> vmPoolMaps = DbFacade.getInstance().getVmPoolDAO().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, VMStatus.Down);
    if (vmPoolMaps != null) {
        for (vm_pool_map map : vmPoolMaps) {
            if (CanAttachNonPrestartedVmToUser(map.getvm_guid())) {
                return map.getvm_guid();
            }
        }
    }
    return Guid.Empty;
}
#end_block

#method_before
protected static Guid getPrestartedVmToAttach(NGuid poolId) {
    // TODO: implement prestarted Vm logic
    return Guid.Empty;
}
#method_after
protected static Guid getPrestartedVmToAttach(NGuid vmPoolId) {
    List<vm_pool_map> vmPoolMaps = DbFacade.getInstance().getVmPoolDAO().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, VMStatus.Up);
    if (vmPoolMaps != null) {
        for (vm_pool_map map : vmPoolMaps) {
            if (CanAttachPrestartedVmToUser(map.getvm_guid())) {
                return map.getvm_guid();
            }
        }
    }
    return Guid.Empty;
}
#end_block

#method_before
protected static boolean IsVmFree(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue;
    // check that there isn't another user already attached to this VM:
    if (DbFacade.getInstance().getDbUserDAO().getAllForVm(vmId).size() > 0) {
        returnValue = false;
        if (messages != null) {
            messages.add(VdcBllMessages.VM_POOL_CANNOT_ADD_VM_WITH_USERS_ATTACHED_TO_POOL.toString());
        }
    } else // check that vm can be run:
    if (!CanRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vmId);
        Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_id().getValue() : Guid.Empty;
        returnValue = ImagesHandler.PerformImagesChecks(vmId, messages, DbFacade.getInstance().getVmDAO().getById(vmId).getstorage_pool_id(), storageDomainId, false, true, false, false, true, false, !storageDomainId.equals(Guid.Empty));
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACHE_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#method_after
protected static boolean IsVmFree(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!CanRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        ValidationResult vmDuringSnapshotResult = new SnapshotsValidator().vmNotDuringSnapshot(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else {
            List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vmId);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            returnValue = ImagesHandler.PerformImagesChecks(vmId, messages, DbFacade.getInstance().getVmDAO().getById(vmId).getstorage_pool_id(), storageDomainId, false, true, false, false, true, false, !storageDomainId.equals(Guid.Empty));
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACHE_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected static boolean CanRunPoolVm(Guid vmId, java.util.ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDAO().getById(vmId);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getvm_os().isLinux() || vm.getvm_type() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getdedicated_vm_for_vds(), true);
    return RunVmCommand.CanRunVm(vm, messages, runVmParams, vdsSelector);
}
#method_after
protected static boolean CanRunPoolVm(Guid vmId, java.util.ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDAO().getById(vmId);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getvm_os().isLinux() || vm.getvm_type() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getdedicated_vm_for_vds(), true);
    return RunVmCommand.CanRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator());
}
#end_block

#method_before
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getVmPoolId() == null ? null : getVmPoolId().getValue(), VdcObjectType.VmPool);
}
#method_after
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVmPoolId() == null ? null : getVmPoolId().getValue(), VdcObjectType.VmPool, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    synchronized (_lockObject) {
        // no available VMs:
        if (GetVmToAttach(getParameters().getVmPoolId()).equals(Guid.Empty)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
            returnValue = false;
        }
    }
    // check user isn't already attached to vm from this pool
    if (returnValue) {
        List<VM> vmsForUser = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_USER_ATTACHED_TO_POOL);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ALLOCATE_AND_RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_FROM_VM_POOL);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    synchronized (_lockObject) {
        // no available VMs:
        if (Guid.Empty.equals(GetVmToAttach(getParameters().getVmPoolId()))) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
            returnValue = false;
        }
    }
    // check user isn't already attached to vm from this pool
    if (returnValue) {
        List<VM> vmsForUser = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_USER_ATTACHED_TO_POOL);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ALLOCATE_AND_RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_FROM_VM_POOL);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    /**
     * TODO: check users throw their groups as well
     */
    initUser();
    boolean isPrestartedVm = false;
    synchronized (_lockObject) {
        // check vm is not attached to user and attach
        List<permissions> vmUserPermissions = DbFacade.getInstance().getPermissionDAO().getAllForRoleAndObject(PredefinedRoles.ENGINE_USER.getId(), getVmId());
        if (vmUserPermissions == null || vmUserPermissions.isEmpty()) {
            setVmId(getPrestartedVmToAttach(getParameters().getVmPoolId()));
            if (!getVmId().equals(Guid.Empty)) {
                isPrestartedVm = true;
            } else {
                setVmId(getNonPrestartedVmToAttach(getParameters().getVmPoolId()));
            }
            if (!getVmId().equals(Guid.Empty)) {
                getParameters().setEntityId(getVmId());
                permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), getVmId(), VdcObjectType.VM);
                PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
                permParams.setShouldBeLogged(false);
                permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
                VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, getCompensationContext());
                if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                    log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), getVmId());
                    setActionReturnValue(vdcReturnValueFromAddPerm);
                    return;
                }
                log.infoFormat("Vm {0} was attached to user {1} ", getVmId(), getAdUserId());
            } else {
                log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
                throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
            }
        }
    }
    if (getVmId().equals(Guid.Empty)) {
        log.infoFormat("No free Vms in pool. Cannot allocate for user {1} ", getAdUserId());
        throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        // Used to be when it was CreateAllSnapshotsCommand tempVar.setEntityId(getParameters().getEntityId());
        RunVmParams runVmParams = new RunVmParams(getVm().getvm_guid());
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setUseVnc(getVm().getvm_type() == VmType.Server);
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
        // Are the following necessary ?
        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(getVmId());
        getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
    }
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    initUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach = Guid.Empty;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach(getParameters().getVmPoolId());
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach(getParameters().getVmPoolId());
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityId(vmToAttach);
            setVmId(vmToAttach);
            permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
            VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, new CommandContext(getCompensationContext()));
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.infoFormat("Succceeded giving user {0} permission to Vm {1} ", getAdUserId(), vmToAttach);
            }
        } else {
            log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
            throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setUseVnc(getVm().getvm_type() == VmType.Server);
        runVmParams.setParentParemeters(getParameters());
        runVmParams.setEntityId(vmToAttach);
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams);
        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    if (getVm() != null) {
        // next line is for retrieving the VmPool from the DB
        // so we won't get a log-deadlock because of the transaction.
        vm_pools vmPool = getVmPool();
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getvm_guid()).size() > 0) {
            setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, getParameters().getImagesParameters().get(0), getCompensationContext()).getSucceeded());
            if (!getSucceeded()) {
                log.warn("EndSuccessfully: EndAction of RunVm failed, detaching user from Vm");
                // just in case.
                detachUserFromVmFromPool();
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // Pool-snapshot is gone (probably due to ProcessVmPoolOnStopVm
        // treatment) ->
        // no point in running the VM or trying to run again the EndAction
        // method:
        {
            log.warn("EndSuccessfully: No images were created for Vm, detaching user from Vm");
            // just in case.
            detachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndSuccessfully: Vm is null - not performing full EndAction");
        setSucceeded(true);
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    if (getVm() != null) {
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() > 0) {
            setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext())).getSucceeded());
            if (!getSucceeded()) {
                log.warn("EndSuccessfully: EndAction of RunVm failed, detaching user from Vm");
                // just in case.
                detachUserFromVmFromPool();
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // Pool-snapshot is gone (probably due to ProcessVmPoolOnStopVm
        // treatment) ->
        // no point in running the VM or trying to run again the EndAction
        // method:
        {
            log.warn("EndSuccessfully: No images were created for Vm, detaching user from Vm");
            // just in case.
            detachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndSuccessfully: Vm is null - not performing full EndAction");
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    // next line is for retrieving the VmPool (and Vm, implicitly) from
    // the DB so we won't get a log-deadlock because of the transaction.
    vm_pools vmPool = getVmPool();
    setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, getParameters().getImagesParameters().get(0), getCompensationContext()).getSucceeded());
    if (!getSucceeded()) {
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndWitFailure: EndAction of RunVm Failed");
    }
    detachUserFromVmFromPool();
}
#method_after
@Override
protected void EndWithFailure() {
    setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext())).getSucceeded());
    if (!getSucceeded()) {
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndWitFailure: EndAction of RunVm Failed");
    }
    detachUserFromVmFromPool();
}
#end_block

#method_before
protected void detachUserFromVmFromPool() {
    // Detach user from vm from pool:
    if (!getAdUserId().equals(Guid.Empty)) {
        permissions perm = DbFacade.getInstance().getPermissionDAO().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), getVmId());
        if (perm != null) {
            DbFacade.getInstance().getPermissionDAO().remove(perm.getId());
        }
    }
}
#method_after
protected void detachUserFromVmFromPool() {
    // Detach user from vm from pool:
    if (!Guid.Empty.equals(getAdUserId())) {
        permissions perm = DbFacade.getInstance().getPermissionDAO().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), getVmId());
        if (perm != null) {
            DbFacade.getInstance().getPermissionDAO().remove(perm.getId());
        }
    }
}
#end_block

#method_before
@Override
public void setSession(Session session) {
    super.setSession(session);
    imageDAO.setSession(session);
    dynamicDAO.setSession(session);
    templateDAO.setSession(session);
    imageVmMapDAO.setSession(session);
}
#method_after
@Override
public void setSession(Session session) {
    super.setSession(session);
    imageDAO.setSession(session);
    dynamicDAO.setSession(session);
    imageVmMapDAO.setSession(session);
}
#end_block

#method_before
@Override
public List<DiskImage> getAllForVm(Guid id) {
    return imageDAO.getAllForVm(id);
}
#method_after
@Override
public List<DiskImage> getAllForVm(Guid id, Guid userID, boolean isFiltered) {
    throw new NotImplementedException("This method is not implemented for Hibernate yet");
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("hypervisor_type", template.gethypervisor_type()).addValue("operation_mode", template.getoperation_mode()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("hypervisor_type", template.gethypervisor_type()).addValue("operation_mode", template.getoperation_mode()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId());
}
#end_block

#method_before
@Override
public void save(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem());
    getCallsHandler().executeModification("InsertVmStatic", parameterSource);
}
#method_after
@Override
public void save(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId());
    getCallsHandler().executeModification("InsertVmStatic", parameterSource);
}
#end_block

#method_before
@Override
public void update(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem());
    getCallsHandler().executeModification("UpdateVmStatic", parameterSource);
}
#method_after
@Override
public void update(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId());
    getCallsHandler().executeModification("UpdateVmStatic", parameterSource);
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setmem_size_mb(rs.getInt("mem_size_mb"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setdomain(rs.getString("domain"));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setmem_size_mb(rs.getInt("mem_size_mb"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setdomain(rs.getString("domain"));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    return entity;
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    for (DiskImage diskImage : mImages) {
        diskImage.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (mImages.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Guid srcStorageDomainId = mImages.get(0).getstorage_id().getValue();
    // or populate storage domain id from the vm domain (of the first disk)
    if (getParameters().getDestinationStorageDomainId() != null) {
        setStorageDomainId(getParameters().getDestinationStorageDomainId());
    } else {
        setStorageDomainId(srcStorageDomainId);
    }
    if (!ImagesHandler.PerformImagesChecks(getParameters().getMasterVm().getId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, true, true, true, true, true, false, true)) {
        return false;
    }
    VM vm = DbFacade.getInstance().getVmDAO().getById(getParameters().getMasterVm().getId());
    if (vm.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    if (getStorageDomainId() != null) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(getStorageDomainId().getValue(), getVm().getstorage_pool_id());
        // if source and destination domains are different we need to check destination domain also
        if (!srcStorageDomainId.equals(getStorageDomainId().getValue())) {
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDAO().get(getStorageDomainId().getValue()) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        // update vm snapshots for storage free space check
        for (DiskImage diskImage : getVm().getDiskMap().values()) {
            diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        }
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(storage, (int) getVm().getActualDiskWithSnapshotsSize())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    if (!AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (mImages.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Guid srcStorageDomainId = mImages.get(0).getstorage_ids().get(0);
    // or populate storage domain id from the vm domain (of the first disk)
    if (getParameters().getDestinationStorageDomainId() != null) {
        setStorageDomainId(getParameters().getDestinationStorageDomainId());
    } else {
        setStorageDomainId(srcStorageDomainId);
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!ImagesHandler.PerformImagesChecks(getParameters().getMasterVm().getId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, true, true, true, true, true, false, true)) {
        return false;
    }
    VM vm = DbFacade.getInstance().getVmDAO().getById(getParameters().getMasterVm().getId());
    if (vm.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    if (getStorageDomainId() != null) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(getStorageDomainId().getValue(), getVm().getstorage_pool_id());
        // if source and destination domains are different we need to check destination domain also
        if (!srcStorageDomainId.equals(getStorageDomainId().getValue())) {
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDAO().get(getStorageDomainId().getValue()) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        // update vm snapshots for storage free space check
        for (DiskImage diskImage : getVm().getDiskMap().values()) {
            diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        }
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(storage, (int) getVm().getActualDiskWithSnapshotsSize())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    if (!AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(executionContext));
        QuotaManager.reduceCommandStorageSize(createParams.getStorageDomainId(), diskImage.getsize(), getStoragePool().getQuotaEnforcementType(), getCommandId(), getParameters().getQuotaId());
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_ids().get(0);
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!Guid.Empty.equals(diskImage.getstorage_ids().get(0))) {
            createParams.setStorageDomainId(diskImage.getstorage_ids().get(0));
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> list = new ArrayList<PermissionSubject>();
    Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
    list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId());
    return list;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> list = new ArrayList<PermissionSubject>();
    Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
    list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    list = QuotaHelper.getInstance().addQuotaPermissionSubject(list, getStoragePool(), getVm().getStaticData().getQuotaId());
    list = setPermissionListForDiskImage(list);
    return list;
}
#end_block

#method_before
protected CompensationContext getCompensationContext() {
    return compensationContext;
}
#method_after
protected CompensationContext getCompensationContext() {
    return context.getCompensationContext();
}
#end_block

#method_before
public void setCompensationContext(CompensationContext compensationContext) {
    this.compensationContext = compensationContext;
}
#method_after
public void setCompensationContext(CompensationContext compensationContext) {
    context.setCompensationContext(compensationContext);
}
#end_block

#method_before
public VdcReturnValueBase ExecuteAction() {
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    boolean actionAllowed = false;
    Step validatingStep = ExecutionHandler.addStep(executionContext, StepEnum.VALIDATING, null);
    try {
        actionAllowed = acquireLock() && (getReturnValue().getCanDoAction() || InternalCanDoAction());
        ExecutionHandler.endStep(executionContext, validatingStep, actionAllowed);
        if (actionAllowed) {
            getReturnValue().setCanDoAction(true);
            getReturnValue().setIsSyncronious(true);
            getParameters().setTaskStartTime(System.currentTimeMillis());
            Execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLock();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase ExecuteAction() {
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    boolean actionAllowed = false;
    Step validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    try {
        actionAllowed = acquireLock() && (getReturnValue().getCanDoAction() || InternalCanDoAction());
        ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        if (actionAllowed) {
            getReturnValue().setCanDoAction(true);
            getReturnValue().setIsSyncronious(true);
            getParameters().setTaskStartTime(System.currentTimeMillis());
            Execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLock();
    }
    return getReturnValue();
}
#end_block

#method_before
public VdcReturnValueBase EndAction() {
    ExecutionHandler.startFinalizingStep(executionContext);
    try {
        SetActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        if (getCommandShouldBeLogged()) {
            LogCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase EndAction() {
    ExecutionHandler.startFinalizingStep(getExecutionContext());
    try {
        SetActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        if (getCommandShouldBeLogged()) {
            LogCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (compensationContext == null) {
        compensationContext = createCompensationContext(scope, forceCompensation);
    }
}
#method_after
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.setCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#end_block

#method_before
protected boolean checkUserAuthorization(final ActionGroup action, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final NGuid permId = DbFacade.getInstance().getEntityPermissions(getCurrentUser().getUserId(), action, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), action, object);
    }
    return false;
}
#method_after
protected boolean checkUserAuthorization(final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final NGuid permId = DbFacade.getInstance().getEntityPermissions(getCurrentUser().getUserId(), actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean IsUserAutorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!Config.<Boolean>GetValue(ConfigValues.IsMultilevelAdministrationOn)) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        if (objectActionGroup == ActionGroup.CONSUME_QUOTA) {
            if (!isUserAuthorizedToConsumeQuota(objectId, objectType, objectActionGroup)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_USER_IS_NOT_PERMITTED);
                return false;
            }
            return true;
        }
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(objectActionGroup, objectId, objectType)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#method_after
protected boolean IsUserAutorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!Config.<Boolean>GetValue(ConfigValues.IsMultilevelAdministrationOn)) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(objectActionGroup, objectId, objectType)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#end_block

#method_before
private void Execute() {
    ExecutionHandler.addStep(executionContext, StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            freeLock();
            if (getCommandShouldBeLogged()) {
                LogCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                UpdateTasksWithActionParameters();
                StartPollingAsyncTasks();
            }
        } finally {
            if (getReturnValue().getTaskIdList().isEmpty()) {
                ExecutionHandler.endJob(executionContext, getSucceeded());
            }
        }
    }
}
#method_after
private void Execute() {
    ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            freeLock();
            if (getCommandShouldBeLogged()) {
                LogCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                UpdateTasksWithActionParameters();
                StartPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected Guid CreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        Step taskStep = ExecutionHandler.addTaskStep(executionContext, StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        retValue = ConcreteCreateTask(asyncTaskCreationInfo, parentCommand);
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#method_after
protected Guid CreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        Step taskStep = ExecutionHandler.addTaskStep(getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        retValue = ConcreteCreateTask(asyncTaskCreationInfo, parentCommand);
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#end_block

#method_before
private void cancelTasks() {
    if (!getReturnValue().getTaskIdList().isEmpty()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                Thread.currentThread().setName("Rollback-" + threadName);
                TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        try {
                            AsyncTaskManager.getInstance().CancelTasks(getReturnValue().getTaskIdList());
                        } catch (Exception e) {
                            log.errorFormat("Failed to cancel tasks for command: {0}.", CommandBase.this.getClass().getName());
                        }
                        return null;
                    }
                });
            }
        });
    }
}
#method_after
private void cancelTasks() {
    if (hasTasks()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                Thread.currentThread().setName("Rollback-" + threadName);
                TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        try {
                            AsyncTaskManager.getInstance().CancelTasks(getReturnValue().getTaskIdList());
                        } catch (Exception e) {
                            log.errorFormat("Failed to cancel tasks for command: {0}.", CommandBase.this.getClass().getName());
                        }
                        return null;
                    }
                });
            }
        });
    }
}
#end_block

#method_before
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = new HashMap<String, String>();
        List<PermissionSubject> subjects = getPermissionCheckSubjects();
        if (!subjects.isEmpty()) {
            VdcObjectType entityType;
            Guid entityId;
            String value;
            for (PermissionSubject permSubject : subjects) {
                ActionGroup actionGroup = permSubject.getActionGroup();
                entityType = permSubject.getObjectType();
                entityId = permSubject.getObjectId();
                if (entityType != null && entityId != null && actionGroup != ActionGroup.CONSUME_QUOTA) {
                    value = DbFacade.getInstance().getEntityNameByIdAndType(entityId, entityType);
                    if (value == null) {
                        value = entityId.toString();
                    }
                    jobProperties.put(entityType.name().toLowerCase(), value);
                }
            }
        }
    }
    return jobProperties;
}
#method_after
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = new HashMap<String, String>();
        List<PermissionSubject> subjects = getPermissionCheckSubjects();
        if (!subjects.isEmpty()) {
            VdcObjectType entityType;
            Guid entityId;
            String value;
            for (PermissionSubject permSubject : subjects) {
                entityType = permSubject.getObjectType();
                entityId = permSubject.getObjectId();
                if (entityType != null && entityId != null) {
                    value = DbFacade.getInstance().getEntityNameByIdAndType(entityId, entityType);
                    if (value == null) {
                        value = entityId.toString();
                    }
                    jobProperties.put(entityType.name().toLowerCase(), value);
                }
            }
        }
    }
    return jobProperties;
}
#end_block

#method_before
public void setExecutionContext(ExecutionContext executionContext) {
    if (executionContext != null) {
        this.executionContext = executionContext;
    }
}
#method_after
public void setExecutionContext(ExecutionContext executionContext) {
    context.setExecutionContext(executionContext);
}
#end_block

#method_before
public ExecutionContext getExecutionContext() {
    return executionContext;
}
#method_after
public ExecutionContext getExecutionContext() {
    return context.getExecutionContext();
}
#end_block

#method_before
@Test
public void canRunVmFailNodisk() {
    initMocks(new ArrayList<DiskImage>(), new HashMap<VDSCommandType, Boolean>(), new ArrayList<VmDevice>());
    final VM vm = new VM();
    final ArrayList<String> messages = new ArrayList<String>();
    Assert.assertFalse(RunVmCommand.CanRunVm(vm, messages, new RunVmParams(), new VdsSelector(vm, new NGuid(), true)));
    Assert.assertTrue(messages.contains("VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK"));
}
#method_after
@Test
public void canRunVmFailNodisk() {
    initMocks(new ArrayList<DiskImage>(), new HashMap<VDSCommandType, Boolean>(), new ArrayList<VmDevice>());
    final VM vm = new VM();
    final ArrayList<String> messages = new ArrayList<String>();
    Assert.assertFalse(RunVmCommand.CanRunVm(vm, messages, new RunVmParams(), new VdsSelector(vm, new NGuid(), true), mockSuccessfulSnapshotValidator()));
    Assert.assertTrue(messages.contains("VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK"));
}
#end_block

#method_before
@Test
public void canRunVmFailVmRunning() {
    final ArrayList<DiskImage> disks = new ArrayList<DiskImage>();
    final DiskImage diskImage = new DiskImage();
    diskImage.setstorage_id(new Guid());
    disks.add(diskImage);
    final VmDevice vmDevice = new VmDevice();
    vmDevice.setIsPlugged(true);
    initMocks(disks, new HashMap<VDSCommandType, Boolean>(), Collections.singletonList(vmDevice));
    final VM vm = new VM();
    vm.setstatus(VMStatus.Up);
    final ArrayList<String> messages = new ArrayList<String>();
    Assert.assertFalse(RunVmCommand.CanRunVm(vm, messages, new RunVmParams(), new VdsSelector(vm, new NGuid(), true)));
    Assert.assertTrue(messages.contains("ACTION_TYPE_FAILED_VM_IS_RUNNING"));
}
#method_after
@Test
public void canRunVmFailVmRunning() {
    final ArrayList<DiskImage> disks = new ArrayList<DiskImage>();
    final DiskImage diskImage = new DiskImage();
    diskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(new Guid())));
    disks.add(diskImage);
    final VmDevice vmDevice = new VmDevice();
    vmDevice.setIsPlugged(true);
    initMocks(disks, new HashMap<VDSCommandType, Boolean>(), Collections.singletonList(vmDevice));
    final VM vm = new VM();
    vm.setstatus(VMStatus.Up);
    final ArrayList<String> messages = new ArrayList<String>();
    Assert.assertFalse(RunVmCommand.CanRunVm(vm, messages, new RunVmParams(), new VdsSelector(vm, new NGuid(), true), mockSuccessfulSnapshotValidator()));
    Assert.assertTrue(messages.contains("ACTION_TYPE_FAILED_VM_IS_RUNNING"));
}
#end_block

#method_before
private void canRunStatelessVmTest(boolean autoStartUp, boolean isVmStateless, Boolean isStatelessParam, boolean shouldPass) {
    final ArrayList<DiskImage> disks = new ArrayList<DiskImage>();
    final DiskImage diskImage = new DiskImage();
    diskImage.setstorage_id(new Guid());
    disks.add(diskImage);
    final VmDevice vmDevice = new VmDevice();
    vmDevice.setIsPlugged(true);
    final HashMap<VDSCommandType, Boolean> calls = new HashMap<VDSCommandType, Boolean>();
    final VdsSelector vdsSelector = Mockito.mock(VdsSelector.class);
    Mockito.when(vdsSelector.CanFindVdsToRunOn(any(ArrayList.class), anyBoolean())).thenReturn(true);
    calls.put(VDSCommandType.IsVmDuringInitiating, false);
    initMocks(disks, calls, Collections.singletonList(vmDevice));
    final VM vm = new VM();
    // set stateless and HA
    vm.setis_stateless(isVmStateless);
    vm.setauto_startup(autoStartUp);
    final ArrayList<String> messages = new ArrayList<String>();
    final RunVmParams runParams = new RunVmParams();
    runParams.setRunAsStateless(isStatelessParam);
    boolean canRunVm = RunVmCommand.CanRunVm(vm, messages, runParams, vdsSelector);
    if (shouldPass) {
        Assert.assertTrue(canRunVm);
        Assert.assertFalse(messages.contains("VM_CANNOT_RUN_STATELESS_HA"));
    } else {
        Assert.assertFalse(canRunVm);
        Assert.assertTrue(messages.contains("VM_CANNOT_RUN_STATELESS_HA"));
    }
}
#method_after
private void canRunStatelessVmTest(boolean autoStartUp, boolean isVmStateless, Boolean isStatelessParam, boolean shouldPass) {
    final ArrayList<DiskImage> disks = new ArrayList<DiskImage>();
    final DiskImage diskImage = new DiskImage();
    diskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList((new Guid()))));
    disks.add(diskImage);
    final VmDevice vmDevice = new VmDevice();
    vmDevice.setIsPlugged(true);
    final HashMap<VDSCommandType, Boolean> calls = new HashMap<VDSCommandType, Boolean>();
    final VdsSelector vdsSelector = Mockito.mock(VdsSelector.class);
    Mockito.when(vdsSelector.CanFindVdsToRunOn(any(ArrayList.class), anyBoolean())).thenReturn(true);
    calls.put(VDSCommandType.IsVmDuringInitiating, false);
    initMocks(disks, calls, Collections.singletonList(vmDevice));
    final VM vm = new VM();
    // set stateless and HA
    vm.setis_stateless(isVmStateless);
    vm.setauto_startup(autoStartUp);
    final ArrayList<String> messages = new ArrayList<String>();
    final RunVmParams runParams = new RunVmParams();
    runParams.setRunAsStateless(isStatelessParam);
    boolean canRunVm = RunVmCommand.CanRunVm(vm, messages, runParams, vdsSelector, mockSuccessfulSnapshotValidator());
    if (shouldPass) {
        Assert.assertTrue(canRunVm);
        Assert.assertFalse(messages.contains("VM_CANNOT_RUN_STATELESS_HA"));
    } else {
        Assert.assertFalse(canRunVm);
        Assert.assertTrue(messages.contains("VM_CANNOT_RUN_STATELESS_HA"));
    }
}
#end_block

#method_before
protected boolean InitVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getstatus() == VMStatus.ImageIllegal) || (getVm().getstatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getstatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getstatus());
        return false;
    } else {
        HandleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setkvm_enable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause());
        getVm().setacpi_enable(getParameters().getAcpiEnable());
        getParameters().setRunAsStateless(shouldVmRunAsStateless(getParameters(), getVm()));
        // once command
        if (getParameters().getUseVnc() != null) {
            getVm().setdisplay_type(getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl);
        } else {
            getVm().setdisplay_type(getVm().getdefault_display_type());
        }
        if (getParameters().getReinitialize()) {
            getVm().setUseSysPrep(true);
        }
        // if we attach floppy we don't need the sysprep
        if (!StringHelper.isNullOrEmpty(getVm().getFloppyPath())) {
            DbFacade.getInstance().getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setvds_group_cpu_flags_data(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getvds_group_cpu_name(), getVm().getvds_group_compatibility_version()));
        return true;
    }
}
#method_after
protected boolean InitVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getstatus() == VMStatus.ImageIllegal) || (getVm().getstatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getstatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getstatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        HandleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setkvm_enable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause());
        getVm().setacpi_enable(getParameters().getAcpiEnable());
        getParameters().setRunAsStateless(shouldVmRunAsStateless(getParameters(), getVm()));
        // once command
        if (getParameters().getUseVnc() != null) {
            getVm().setdisplay_type(getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl);
        } else {
            getVm().setdisplay_type(getVm().getdefault_display_type());
        }
        if (getParameters().getReinitialize()) {
            getVm().setUseSysPrep(true);
        }
        // if we attach floppy we don't need the sysprep
        if (!StringHelper.isNullOrEmpty(getVm().getFloppyPath())) {
            DbFacade.getInstance().getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setvds_group_cpu_flags_data(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getvds_group_cpu_name(), getVm().getvds_group_compatibility_version()));
        return true;
    }
}
#end_block

#method_before
public boolean CanRunVm() {
    return CanRunVm(getVm(), getReturnValue().getCanDoActionMessages(), getParameters(), getVdsSelector());
}
#method_after
public boolean CanRunVm() {
    return CanRunVm(getVm(), getReturnValue().getCanDoActionMessages(), getParameters(), getVdsSelector(), getSnapshotsValidator());
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    Guid storageDomainId = vmImages.get(0).getstorage_id().getValue();
                    // if VM is not HA VM
                    if (!ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                        retValue = false;
                    } else // Check if iso and floppy path exists
                    if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    Guid storageDomainId = vmImages.get(0).getstorage_ids().get(0);
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                        retValue = false;
                    } else // Check if iso and floppy path exists
                    if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_DISK);
}
#method_after
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RUN);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getQuotaId(), getStoragePool()));
    if (!isInternalExecution()) {
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), getQuotaConsumeMap(), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#method_after
@Override
protected boolean validateQuota() {
    // Set default quota id if storage pool enforcement is disabled.
    getParameters().setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getVmStaticData().getQuotaId(), getStoragePool()));
    for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
        dit.setQuotaId(QuotaHelper.getInstance().getQuotaIdToConsume(getParameters().getVmStaticData().getQuotaId(), getStoragePool()));
    }
    if (!isInternalExecution()) {
        // TODO: Should be changed when multiple storage domain will be implemented and the desired quotas will be transferred.
        return QuotaManager.validateMultiStorageQuota(getStoragePool().getQuotaEnforcementType(), QuotaHelper.getInstance().getQuotaConsumeMap(getVmTemplate().getDiskList()), getCommandId(), getReturnValue().getCanDoActionMessages());
    }
    return true;
}
#end_block

#method_before
protected boolean AddVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getId(), getParameters().getVmStaticData().getId());
            tempVar.setStorageDomainId(getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParemeters(getParameters());
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            reduceQuotaCommand(getStorageDomainId().getValue(), dit.getsize(), getStoragePool().getQuotaEnforcementType(), getCommandId(), getParameters().getQuotaId());
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldnt create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
            }
        }
    }
    return true;
}
#method_after
protected boolean AddVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getVmTemplate().getDiskMap().values()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getId(), getParameters().getVmStaticData().getId());
            tempVar.setStorageDomainId(getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParemeters(getParameters());
            tempVar.setQuotaId(dit.getQuotaId());
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldnt create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void removeQuotaCommandLeftOver() {
    if (!isInternalExecution()) {
        QuotaManager.removeMultiStorageDeltaQuotaCommand(getQuotaConsumeMap(), getStoragePool().getQuotaEnforcementType(), getCommandId());
    }
}
#method_after
protected void removeQuotaCommandLeftOver() {
    if (!isInternalExecution()) {
        QuotaManager.removeMultiStorageDeltaQuotaCommand(QuotaHelper.getInstance().getQuotaConsumeMap(getVmTemplate().getDiskList()), getStoragePool().getQuotaEnforcementType(), getCommandId());
    }
}
#end_block

#method_before
public Map<Pair<Guid, Guid>, Double> getQuotaConsumeMap(List<DiskImage> diskImageList) {
    Map<Pair<Guid, Guid>, Double> quotaForStorageConsumption = new HashMap<Pair<Guid, Guid>, Double>();
    for (DiskImage disk : diskImageList) {
        Pair<Guid, Guid> quotaForStorageKey = new Pair<Guid, Guid>(disk.getQuotaId(), disk.getstorage_id().getValue());
        Double storageRequest = quotaForStorageConsumption.get(quotaForStorageKey);
        if (storageRequest != null) {
            storageRequest += disk.getsize();
        } else {
            storageRequest = new Double(disk.getsize());
        }
        quotaForStorageConsumption.put(quotaForStorageKey, storageRequest);
    }
    return quotaForStorageConsumption;
}
#method_after
public Map<Pair<Guid, Guid>, Double> getQuotaConsumeMap(List<DiskImage> diskImageList) {
    Map<Pair<Guid, Guid>, Double> quotaForStorageConsumption = new HashMap<Pair<Guid, Guid>, Double>();
    for (DiskImage disk : diskImageList) {
        Pair<Guid, Guid> quotaForStorageKey = new Pair<Guid, Guid>(disk.getQuotaId(), disk.getstorage_ids().get(0).getValue());
        Double storageRequest = quotaForStorageConsumption.get(quotaForStorageKey);
        if (storageRequest != null) {
            storageRequest += disk.getsize();
        } else {
            storageRequest = new Double(disk.getsize());
        }
        quotaForStorageConsumption.put(quotaForStorageKey, storageRequest);
    }
    return quotaForStorageConsumption;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
    }
    Quota quota = getQuotaDAO().getById(getParameters().getQuotaId());
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // Check if there is attempt to delete the default quota while storage pool enforcement type is disabled.
    if (getStoragePool().getQuotaEnforcementType() == QuotaEnforcmentTypeEnum.DISABLED && quota.getIsDefaultQuota()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_CAN_NOT_HAVE_DEFAULT_INDICATION);
    }
    // Check If we try to delete the last quota in the DC.
    List<Quota> quotaList = getQuotaDAO().getQuotaByStoragePoolGuid(getParameters().getStoragePoolId());
    if (quotaList.size() <= 1) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_MUST_HAVE_AT_LEAST_ONE_QUOTA);
    }
    // TODO : Add Check if there are no VMs/images that are part of the Quota.
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
    }
    Quota quota = getQuota();
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // Check if there is attempt to delete the default quota while storage pool enforcement type is disabled.
    if (getStoragePoolDAO().get(quota.getStoragePoolId()).getQuotaEnforcementType() == QuotaEnforcmentTypeEnum.DISABLED && quota.getIsDefaultQuota()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_CAN_NOT_HAVE_DEFAULT_INDICATION);
    }
    // Check If we try to delete the last quota in the DC.
    List<Quota> quotaList = getQuotaDAO().getQuotaByStoragePoolGuid(getParameters().getStoragePoolId());
    if (quotaList.size() <= 1) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_MUST_HAVE_AT_LEAST_ONE_QUOTA);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    } else if (getParameters().getQuota().getId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        return false;
    } else if (getQuotaDAO().getById(getParameters().getQuota().getId()) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null) {
        return false;
    } else if (!QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    return (QuotaHelper.getInstance().checkQuotaValidationForAddEdit(getParameters().getQuota(), getReturnValue().getCanDoActionMessages()));
}
#end_block

#method_before
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getQuotaId() == null ? null : getQuotaId().getValue(), VdcObjectType.Quota);
}
#method_after
@Override
public Map<Guid, VdcObjectType> getPermissionCheckSubjects() {
    return Collections.singletonMap(getStoragePoolId() == null ? null : getStoragePoolId().getValue(), VdcObjectType.StoragePool);
}
#end_block

#method_before
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    setQuotaId(Guid.NewGuid());
    setQuotaName(quotaParameter.getQuotaName());
    if (quotaParameter.getQuotaStorages() != null) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (quotaParameter.getQuotaVdsGroups() != null) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#method_after
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    quotaParameter.setId(Guid.NewGuid());
    setStoragePoolId(quotaParameter.getStoragePoolId());
    setQuotaName(quotaParameter.getQuotaName());
    if (quotaParameter.getQuotaStorages() != null) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (quotaParameter.getQuotaVdsGroups() != null) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#end_block

#method_before
private boolean InsertUniqueId(String message) {
    String uniqueId = message.trim();
    UpdateUniqueId(uniqueId);
    if (VdsInstallHelper.isVdsUnique(_vds.getvds_id(), uniqueId)) {
        log.infoFormat("Installation of {0}. Assigning unique id {1} to Host. (Stage: {2})", _serverName, uniqueId, getCurrentInstallStage());
        _vds.setUniqueId(uniqueId);
        DbFacade.getInstance().getVdsStaticDAO().update(_vds.getStaticData());
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        return true;
    }
    log.errorFormat("Installation of {0}. Host with unique id {1} is already present in system. (Stage: {2})", _serverName, uniqueId, getCurrentInstallStage());
    return false;
}
#method_after
private boolean InsertUniqueId(String message) {
    String uniqueId = message.trim();
    UpdateUniqueId(uniqueId);
    if (VdsInstallHelper.isVdsUnique(_vds.getId(), uniqueId)) {
        log.infoFormat("Installation of {0}. Assigning unique id {1} to Host. (Stage: {2})", _serverName, uniqueId, getCurrentInstallStage());
        _vds.setUniqueId(uniqueId);
        DbFacade.getInstance().getVdsStaticDAO().update(_vds.getStaticData());
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        return true;
    }
    log.errorFormat("Installation of {0}. Host with unique id {1} is already present in system. (Stage: {2})", _serverName, uniqueId, getCurrentInstallStage());
    return false;
}
#end_block

#method_before
@Override
protected void onLogin(final LoginModel loginModel) {
    // init reports
    ReportInit.getInstance().init();
    ReportInit.getInstance().getReportsInitEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // UiCommon login preparation
            Frontend.setLoggedInUser(loginModel.getLoggedUser());
            beforeUiCommonInitEvent(loginModel);
            UiCommonInitEvent.fire(eventBus);
            // UI login actions
            user.onUserLogin(loginModel.getLoggedUser().getUserName());
            clearPassword(loginModel);
        }
    });
}
#method_after
@Override
protected void onLogin(final LoginModel loginModel) {
    // init reports
    ReportInit.getInstance().init();
    ReportInit.getInstance().getReportsInitEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ApplicationInit.super.onLogin(loginModel);
        }
    });
}
#end_block

#method_before
public void init() {
    parseReportsXML();
}
#method_after
public void init() {
    AsyncDataProvider.GetRedirectServletReportsPage(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            setReportBaseUrl((String) returnValue);
        }
    }));
    parseReportsXML();
}
#end_block

#method_before
private void checkIfInitFinished() {
    if (xmlInitialized && urlInitialized) {
        // Check if the reports should be enabled in this system
        if (!reportBaseUrl.equals("") && !resourceMap.isEmpty()) {
            setReportsEnabled(true);
        } else {
            setReportsEnabled(false);
        }
        reportsInitEvent.raise(this, null);
    }
}
#method_after
private void checkIfInitFinished() {
    if (xmlInitialized && urlInitialized) {
        // Check if the reports should be enabled in this system
        if (!reportBaseUrl.equals("") && !resourceMap.isEmpty()) {
            setReportsEnabled(true);
        } else {
            setReportsEnabled(false);
        }
        // The initialization process blocks on this event after the login
        reportsInitEvent.raise(this, null);
    }
}
#end_block

#method_before
public Map<String, List<String>> getReportParams() {
    return Collections.unmodifiableMap(reportParams);
}
#method_after
public Map<String, List<String>> getReportParams() {
    return paramsMap.getParameters();
}
#end_block

#method_before
public void setDataCenterID(final String uuid) {
    reportParams.put("P_DataCenter_ID", Collections.singletonList(uuid));
}
#method_after
public void setDataCenterID(final String uuid) {
    paramsMap.setParameter("P_DataCenter_ID", uuid);
}
#end_block

#method_before
public void addDataCenterID(final String uuid) {
    List<String> ids = reportParams.get("P_DataCenter_ID");
    if (ids == null) {
        setDataCenterID(uuid);
    } else {
        ids.add(uuid);
    }
}
#method_after
public void addDataCenterID(final String uuid) {
    paramsMap.addParameter("P_DataCenter_ID", uuid);
}
#end_block

#method_before
public void setPassword(String password) {
    reportParams.put("j_password", Collections.singletonList(password));
}
#method_after
public void setPassword(String password) {
    paramsMap.setParameter("j_password", password);
}
#end_block

#method_before
public void setReportEndDate(String date) {
    reportParams.put("P_End_Date", Collections.singletonList(date));
}
#method_after
public void setReportEndDate(String date) {
    paramsMap.setParameter("P_End_Date", date);
}
#end_block

#method_before
public void setReportStartDate(String date) {
    reportParams.put("P_Start_Date", Collections.singletonList(date));
}
#method_after
public void setReportStartDate(String date) {
    paramsMap.setParameter("P_Start_Date", date);
}
#end_block

#method_before
public void setUser(String user) {
    reportParams.put("j_username", Collections.singletonList(user));
}
#method_after
public void setUser(String user) {
    paramsMap.setParameter("j_username", user);
}
#end_block

#method_before
public void setReportUnit(String uri) {
    reportParams.put("reportUnit", Collections.singletonList(uri));
}
#method_after
public void setReportUnit(String uri) {
    paramsMap.setParameter("reportUnit", uri);
}
#end_block

#method_before
public void setResourceId(String idParamName, String id) {
    reportParams.put(idParamName, Collections.singletonList(id));
}
#method_after
public void setResourceId(String idParamName, String id) {
    paramsMap.setParameter(idParamName, id);
}
#end_block

#method_before
public void addResourceId(String idParamName, String id) {
    List<String> ids = reportParams.get(idParamName);
    if (ids == null) {
        setResourceId(idParamName, id);
    } else {
        ids.add(id);
    }
}
#method_after
public void addResourceId(String idParamName, String id) {
    paramsMap.addParameter(idParamName, id);
}
#end_block

#method_before
@Override
public GridTimer getTimer() {
    if (gettimer() == null) {
        settimer(new GridTimer(getListName()) {

            @Override
            public void execute() {
                performSearch();
            }
        });
        gettimer().setRefreshRate(getConfigurator().getPollingTimerInterval());
    }
    return gettimer();
}
#method_after
@Override
public GridTimer getTimer() {
    if (gettimer() == null) {
        settimer(new GridTimer(getListName()) {

            @Override
            public void execute() {
                logger.info(SearchableListModel.this.getClass().getName() + ": Executing search");
                if (getIsAsync()) {
                    AsyncSearch();
                } else {
                    SyncSearch();
                }
            }
        });
        gettimer().setRefreshRate(getConfigurator().getPollingTimerInterval());
    }
    return gettimer();
}
#end_block

#method_before
@Override
public void refresh() {
    performSearch();
}
#method_after
@Override
public void refresh() {
    getForceRefreshCommand().Execute();
}
#end_block

#method_before
public void SignOut() {
    // Stop search on all list models.
    for (SearchableListModel listModel : getItems()) {
        listModel.EnsureAsyncSearchStopped();
    }
    getEventList().EnsureAsyncSearchStopped();
    getAlertList().EnsureAsyncSearchStopped();
    if (Frontend.getIsUserLoggedIn()) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setHandleFailure(true);
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object ReturnValue) {
                CommonModel commonModel = (CommonModel) model;
                commonModel.setLoggedInUser(null);
                commonModel.getSignedOutEvent().raise(commonModel, EventArgs.Empty);
            }
        };
        Frontend.LogoffAsync(Frontend.getLoggedInUser(), _asyncQuery);
    }
}
#method_after
public void SignOut() {
    // Stop search on all list models.
    for (SearchableListModel listModel : getItems()) {
        listModel.EnsureAsyncSearchStopped();
    }
    getEventList().EnsureAsyncSearchStopped();
    getAlertList().EnsureAsyncSearchStopped();
    getTaskList().EnsureAsyncSearchStopped();
    if (Frontend.getIsUserLoggedIn()) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setHandleFailure(true);
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object ReturnValue) {
                CommonModel commonModel = (CommonModel) model;
                commonModel.setLoggedInUser(null);
                commonModel.getSignedOutEvent().raise(commonModel, EventArgs.Empty);
            }
        };
        Frontend.LogoffAsync(Frontend.getLoggedInUser(), _asyncQuery);
    }
}
#end_block

#method_before
public Map<String, List<String>> getCommonParams() {
    return Collections.unmodifiableMap(reportParams);
}
#method_after
public Map<String, List<String>> getCommonParams() {
    return htmlParams.getParameters();
}
#end_block

#method_before
public void setDataCenterID(final String uuid) {
    reportParams.put("P_DataCenter_ID", Collections.singletonList(uuid));
}
#method_after
public void setDataCenterID(final String uuid) {
    htmlParams.setParameter("P_DataCenter_ID", uuid);
}
#end_block

#method_before
public void setPassword(String password) {
    reportParams.put("j_password", Collections.singletonList(password));
}
#method_after
public void setPassword(String password) {
    htmlParams.setParameter("j_password", password);
}
#end_block

#method_before
public void setReportEndDate(String date) {
    reportParams.put("P_End_Date", Collections.singletonList(date));
}
#method_after
public void setReportEndDate(String date) {
    htmlParams.setParameter("P_End_Date", date);
}
#end_block

#method_before
public void setReportStartDate(String date) {
    reportParams.put("P_Start_Date", Collections.singletonList(date));
}
#method_after
public void setReportStartDate(String date) {
    htmlParams.setParameter("P_Start_Date", date);
}
#end_block

#method_before
public void setUser(String user) {
    reportParams.put("j_username", Collections.singletonList(user));
}
#method_after
public void setUser(String user) {
    htmlParams.setParameter("j_username", user);
}
#end_block

#method_before
public void setReportUnit(String uri) {
    reportParams.put("reportUnit", Collections.singletonList(uri));
}
#method_after
public void setReportUnit(String uri) {
    htmlParams.setParameter("reportUnit", uri);
}
#end_block

#method_before
public void setResourceId(String idParamName, String id) {
    reportParams.put(idParamName, Collections.singletonList(id));
    lastResourceId = idParamName;
}
#method_after
public void setResourceId(String idParamName, String id) {
    htmlParams.setParameter(idParamName, id);
    lastResourceId = idParamName;
}
#end_block

#method_before
public void addResourceId(String idParamName, String id) {
    List<String> ids = reportParams.get(idParamName);
    if (ids == null) {
        setResourceId(idParamName, id);
    } else {
        ids.add(id);
    }
}
#method_after
public void addResourceId(String idParamName, String id) {
    htmlParams.addParameter(idParamName, id);
}
#end_block

#method_before
public void removeParam(String paramName) {
    reportParams.remove(paramName);
}
#method_after
public void removeParam(String paramName) {
    htmlParams.removeParameter(paramName);
}
#end_block

#method_before
@Test
public void testExecuteQuery() {
    Guid storagePoolID = new Guid(UUID.randomUUID());
    storage_pool expectedResult = mock(storage_pool.class);
    StoragePoolQueryParametersBase paramsMock = getQueryParameters();
    when(paramsMock.getStoragePoolId()).thenReturn(storagePoolID);
    StoragePoolDAO storagePoolDAOMock = mock(StoragePoolDAO.class);
    when(storagePoolDAOMock.get(storagePoolID, getUser().getUserId(), paramsMock.isFiltered())).thenReturn(expectedResult);
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    when(dbFacadeMock.getStoragePoolDAO()).thenReturn(storagePoolDAOMock);
    getQuery().executeQueryCommand();
    storage_pool result = (storage_pool) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong storage pool returned", expectedResult, result);
    verify(storagePoolDAOMock, times(1)).get(storagePoolID, getUser().getUserId(), paramsMock.isFiltered());
    verifyNoMoreInteractions(storagePoolDAOMock);
}
#method_after
@Test
public void testExecuteQuery() {
    Guid storagePoolID = new Guid(UUID.randomUUID());
    storage_pool expectedResult = mock(storage_pool.class);
    StoragePoolQueryParametersBase paramsMock = getQueryParameters();
    when(paramsMock.getStoragePoolId()).thenReturn(storagePoolID);
    StoragePoolDAO storagePoolDAOMock = mock(StoragePoolDAO.class);
    when(storagePoolDAOMock.get(storagePoolID, getUser().getUserId(), paramsMock.isFiltered())).thenReturn(expectedResult);
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    when(dbFacadeMock.getStoragePoolDAO()).thenReturn(storagePoolDAOMock);
    getQuery().executeQueryCommand();
    storage_pool result = (storage_pool) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong storage pool returned", expectedResult, result);
}
#end_block

#method_before
@Test
public void testGetAllForCluster() {
    List<network> result = dao.getAllForCluster(cluster);
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#method_after
@Test
public void testGetAllForCluster() {
    List<network> result = dao.getAllForCluster(cluster);
    assertGetAllForClusterResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForClusterFilteredWithPermissions() {
    // A use with permissions
    List<network> result = dao.getAllForCluster(cluster, PRIVILEGED_USER_ID, true);
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#method_after
@Test
public void testGetAllForClusterFilteredWithPermissions() {
    // A use with permissions
    List<network> result = dao.getAllForCluster(cluster, PRIVILEGED_USER_ID, true);
    assertGetAllForClusterResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForClusterFilteredWithPermissionsNoPermissionsAndNoFilter() {
    // A use with permissions
    List<network> result = dao.getAllForCluster(cluster, UNPRIVILEGED_USER_ID, false);
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#method_after
@Test
public void testGetAllForClusterFilteredWithPermissionsNoPermissionsAndNoFilter() {
    // A use with permissions
    List<network> result = dao.getAllForCluster(cluster, UNPRIVILEGED_USER_ID, false);
    assertGetAllForClusterResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForDataCenter() {
    List<network> result = dao.getAllForDataCenter(datacenter);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (network net : result) {
        assertEquals(datacenter, net.getstorage_pool_id());
    }
}
#method_after
@Test
public void testGetAllForDataCenter() {
    List<network> result = dao.getAllForDataCenter(datacenter);
    assertGetAllForClusterResult(result);
    for (network net : result) {
        assertEquals(datacenter, net.getstorage_pool_id());
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid tryingImage = Guid.Empty;
    Guid vmId = getParameters().getId();
    String drive = getParameters().getDrive();
    DiskImage inactiveDisk = null;
    DiskImage activeDisk = null;
    RefObject<DiskImage> refActive = new RefObject<DiskImage>(activeDisk);
    RefObject<DiskImage> refInactive = new RefObject<DiskImage>(inactiveDisk);
    int count = ImagesHandler.getImagesMappedToDrive(vmId, drive, refActive, refInactive);
    activeDisk = refActive.argvalue;
    inactiveDisk = refInactive.argvalue;
    if ((count == 0 || count > 2 || activeDisk == null || (count == 2 && inactiveDisk == null))) {
        log.warnFormat("Vm {0} images data incorrect", vmId);
        getQueryReturnValue().setReturnValue(new ArrayList<DiskImage>());
    } else {
        if (inactiveDisk != null) {
            tryingImage = activeDisk.getParentId();
        }
        Guid topmostImageGuid = inactiveDisk == null ? activeDisk.getId() : inactiveDisk.getId();
        getQueryReturnValue().setReturnValue(ImagesHandler.getAllImageSnapshots(topmostImageGuid, activeDisk.getit_guid()));
        ((GetAllVmSnapshotsByDriveQueryReturnValue) getQueryReturnValue()).setTryingImage(tryingImage);
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid tryingImage = Guid.Empty;
    Guid vmId = getParameters().getId();
    String drive = getParameters().getDrive();
    DiskImage inactiveDisk = null;
    DiskImage activeDisk = null;
    RefObject<DiskImage> refActive = new RefObject<DiskImage>(activeDisk);
    RefObject<DiskImage> refInactive = new RefObject<DiskImage>(inactiveDisk);
    int count = ImagesHandler.getImagesMappedToDrive(vmId, drive, refActive, refInactive);
    activeDisk = refActive.argvalue;
    inactiveDisk = refInactive.argvalue;
    if ((count == 0 || count > 2 || activeDisk == null || (count == 2 && inactiveDisk == null))) {
        log.warnFormat("Vm {0} images data incorrect", vmId);
        getQueryReturnValue().setReturnValue(new ArrayList<DiskImage>());
    } else {
        if (inactiveDisk != null) {
            tryingImage = activeDisk.getParentId();
        }
        Guid topmostImageGuid = inactiveDisk == null ? activeDisk.getId() : inactiveDisk.getId();
        getQueryReturnValue().setReturnValue(ImagesHandler.getAllImageSnapshots(topmostImageGuid, activeDisk.getit_guid()));
        getQueryReturnValue().setTryingImage(tryingImage);
    }
}
#end_block

#method_before
@Test
public void testExecuteQueryCommand() {
    // Mock the parameters
    Guid vmID = new Guid(UUID.randomUUID());
    GetAllDisksByVmIdParameters params = getQueryParameters();
    when(params.getVmId()).thenReturn(vmID);
    // Mock some disks
    DiskImage pluggedDisk = createDiskImage(vmID, true);
    DiskImage unpluggedDisk = createDiskImage(vmID, true);
    DiskImage inactiveDisk = createDiskImage(vmID, false);
    // Mock some devices
    VmDevice pluggedDevice = new VmDevice(new VmDeviceId(pluggedDisk.getId(), vmID), "disk", "disk", "", 1, "", true, true, true);
    // Mock the DAOs
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    // Disk Image DAO
    DiskImageDAO diskImageDAOMock = mock(DiskImageDAO.class);
    when(dbFacadeMock.getDiskImageDAO()).thenReturn(diskImageDAOMock);
    when(diskImageDAOMock.getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Arrays.asList(pluggedDisk, unpluggedDisk, inactiveDisk));
    // VM Device DAO
    VmDeviceDAO vmDeviceDAOMock = mock(VmDeviceDAO.class);
    when(dbFacadeMock.getVmDeviceDAO()).thenReturn(vmDeviceDAOMock);
    when(vmDeviceDAOMock.getVmDeviceByVmIdTypeAndDevice(vmID, "disk", "disk", getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(pluggedDevice));
    // Image handler
    mockStatic(ImagesHandler.class);
    int numDisks = 3;
    when(ImagesHandler.getAllImageSnapshots(pluggedDisk.getId(), pluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(numDisks, pluggedDisk)));
    when(ImagesHandler.getAllImageSnapshots(unpluggedDisk.getId(), unpluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(numDisks, unpluggedDisk)));
    GetAllDisksByVmIdQuery<GetAllDisksByVmIdParameters> query = getQuery();
    query.executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<DiskImage> disks = (List<DiskImage>) query.getQueryReturnValue().getReturnValue();
    // Assert the correct disks are returned
    assertTrue("plugged disk should be in the return value", disks.contains(pluggedDisk));
    assertTrue("unplugged disk should be in the return value", disks.contains(unpluggedDisk));
    assertFalse("inactive disk should not be in the return value", disks.contains(inactiveDisk));
    // Assert the disks have the correct snapshots
    for (int i = 0; i < numDisks; ++i) {
        assertEquals("Wrong snapshot " + i + " for plugged disk ", pluggedDisk, pluggedDisk.getSnapshots().get(i));
        assertEquals("Wrong snapshot " + i + " for unplugged disk ", unpluggedDisk, unpluggedDisk.getSnapshots().get(i));
    }
    verify(diskImageDAOMock, times(1)).getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered());
    verify(vmDeviceDAOMock, times(1)).getVmDeviceByVmIdTypeAndDevice(vmID, "disk", "disk", getUser().getUserId(), getQueryParameters().isFiltered());
    verifyNoMoreInteractions(diskImageDAOMock, vmDeviceDAOMock);
}
#method_after
@Test
public void testExecuteQueryCommand() {
    GetAllDisksByVmIdParameters params = getQueryParameters();
    when(params.getVmId()).thenReturn(vmID);
    GetAllDisksByVmIdQuery<GetAllDisksByVmIdParameters> query = getQuery();
    query.executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<DiskImage> disks = (List<DiskImage>) query.getQueryReturnValue().getReturnValue();
    // Assert the correct disks are returned
    assertTrue("plugged disk should be in the return value", disks.contains(pluggedDisk));
    assertTrue("unplugged disk should be in the return value", disks.contains(unpluggedDisk));
    assertFalse("inactive disk should not be in the return value", disks.contains(inactiveDisk));
    // Assert the disks have the correct snapshots
    assertCorrectSnapshots(pluggedDisk);
    assertCorrectSnapshots(unpluggedDisk);
    verify(diskImageDAOMock).getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered());
    verify(vmDeviceDAOMock).getVmDeviceByVmIdTypeAndDevice(vmID, VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.DISK), getUser().getUserId(), getQueryParameters().isFiltered());
    verifyNoMoreInteractions(diskImageDAOMock, vmDeviceDAOMock);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // LINQ
    // DbFacade.Instance.GetImagesByVmGuid(GetParameters.VmId).Where(image=>image.active
    // == true).ToList();
    List<DiskImage> disks = LinqUtils.filter(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId(), getUserID(), getParameters().isFiltered()), new Predicate<DiskImage>() {

        @Override
        public boolean eval(DiskImage diskImage) {
            return (diskImage.getactive());
        }
    });
    Set<Guid> pluggedDiskIds = getPluggedDiskIds();
    for (DiskImage diskImage : disks) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        if (pluggedDiskIds.contains(diskImage.getId())) {
            diskImage.setPlugged(true);
        } else {
            diskImage.setPlugged(false);
        }
    }
    getQueryReturnValue().setReturnValue(disks);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<DiskImage> disks = LinqUtils.filter(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId(), getUserID(), getParameters().isFiltered()), new Predicate<DiskImage>() {

        @Override
        public boolean eval(DiskImage diskImage) {
            return (diskImage.getactive());
        }
    });
    Set<Guid> pluggedDiskIds = getPluggedDiskIds();
    for (DiskImage diskImage : disks) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        diskImage.setPlugged(pluggedDiskIds.contains(diskImage.getDisk().getId()));
    }
    getQueryReturnValue().setReturnValue(disks);
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceNoFiltering() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk");
    assertEquals("there should only be " + TOTAL_DEVICES + " disks", TOTAL_DEVICES, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceNoFiltering() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk");
    assertGetVMDeviceByIdTypeAndDeviceFullResult(devices);
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringSetToFlase() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", null, false);
    assertEquals("there should only be " + TOTAL_DEVICES + " disks", TOTAL_DEVICES, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringSetToFlase() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", null, false);
    assertGetVMDeviceByIdTypeAndDeviceFullResult(devices);
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithPermissions() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", PRIVILEGED_USER_ID, true);
    assertEquals("there should only be " + TOTAL_DEVICES + " disks", TOTAL_DEVICES, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithPermissions() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", PRIVILEGED_USER_ID, true);
    assertGetVMDeviceByIdTypeAndDeviceFullResult(devices);
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithoutPermissions() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", UNPRIVILEGED_USER_ID, true);
    assertEquals("there should only be 0 disks", 0, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithoutPermissions() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", UNPRIVILEGED_USER_ID, true);
    assertTrue("A user without any permissions should not see any devices", devices.isEmpty());
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithPermissionsNoFiltering() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", PRIVILEGED_USER_ID, false);
    assertEquals("there should only be " + TOTAL_DEVICES + " disks", TOTAL_DEVICES, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithPermissionsNoFiltering() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", PRIVILEGED_USER_ID, false);
    assertGetVMDeviceByIdTypeAndDeviceFullResult(devices);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testQueryCreation() throws Exception {
    for (VdcQueryType queryType : VdcQueryType.values()) {
        try {
            log.debug("evaluating " + queryType);
            // Get the query's class
            Class<? extends QueriesCommandBase<?>> clazz = (Class<? extends QueriesCommandBase<?>>) Class.forName(queryType.getPackageName() + "." + queryType.name() + "Query");
            // Create a new instance, parameters don't matter
            Constructor<? extends QueriesCommandBase<?>> cons = (Constructor<? extends QueriesCommandBase<?>>) clazz.getConstructors()[0];
            // Construct the parameter array
            Class<?>[] paramTypes = cons.getParameterTypes();
            Object[] params = new Object[paramTypes.length];
            for (int i = 0; i < paramTypes.length; ++i) {
                params[i] = mock(paramTypes[i]);
            }
            QueriesCommandBase<?> query = cons.newInstance(params);
            // get the getQueryType method - note that it's private.
            VdcQueryType type = TestHelperQueriesCommandType.getQueryTypeFieldValue(query);
            assertNotNull("could not find type", type);
            assertFalse("could not find type", type.equals(VdcQueryType.Unknown));
        } catch (ClassNotFoundException ignore) {
            log.debug("skipping");
        } catch (ExceptionInInitializerError ignore) {
            log.debug("skipping");
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testQueryCreation() throws Exception {
    for (VdcQueryType queryType : VdcQueryType.values()) {
        try {
            log.debug("evaluating " + queryType);
            // Get the query's class
            Class<? extends QueriesCommandBase<?>> clazz = (Class<? extends QueriesCommandBase<?>>) Class.forName(queryType.getPackageName() + "." + queryType.name() + "Query");
            // Create a new instance, parameters don't matter
            Constructor<? extends QueriesCommandBase<?>> cons = (Constructor<? extends QueriesCommandBase<?>>) clazz.getConstructors()[0];
            // Construct the parameter array
            Class<?>[] paramTypes = cons.getParameterTypes();
            Object[] params = new Object[paramTypes.length];
            for (int i = 0; i < paramTypes.length; ++i) {
                params[i] = mock(paramTypes[i]);
            }
            QueriesCommandBase<?> query = cons.newInstance(params);
            VdcQueryType type = TestHelperQueriesCommandType.getQueryTypeFieldValue(query);
            assertNotNull("could not find type", type);
            assertFalse("could not find type", type.equals(VdcQueryType.Unknown));
        } catch (ClassNotFoundException ignore) {
            log.debug("skipping");
        } catch (ExceptionInInitializerError ignore) {
            log.debug("skipping");
        }
    }
}
#end_block

#method_before
// TODO: Temporarily commented out until permission checking will be re-enabled, comment this back in when possible
// /** Tests Admin permission check */
// @Test
// public void testPermissionChecking() throws Exception {
// boolean[] booleans = { true, false };
// for (VdcQueryType queryType : VdcQueryType.values()) {
// for (boolean isFiltered : booleans) {
// for (boolean isUserAdmin : booleans) {
// for (boolean isInternalExecution : booleans) {
// boolean shouldBeAbleToRunQuery =
// isInternalExecution || isUserAdmin || (isFiltered && !queryType.isAdmin());
// 
// log.debug("Running on query: " + toString());
// 
// String sessionId = getClass().getSimpleName();
// 
// // Mock parameters
// VdcQueryParametersBase params = mock(VdcQueryParametersBase.class);
// when(params.isFiltered()).thenReturn(isFiltered);
// when(params.getSessionId()).thenReturn(sessionId);
// 
// Guid guid = mock(Guid.class);
// 
// PowerMockito.mockStatic(MultiLevelAdministrationHandler.class);
// when(MultiLevelAdministrationHandler.isAdminUser(guid)).thenReturn(isUserAdmin);
// 
// // Set up the user id env.
// IVdcUser user = mock(IVdcUser.class);
// when(user.getUserId()).thenReturn(guid);
// ThreadLocalParamsContainer.setHttpSessionId(sessionId);
// ThreadLocalParamsContainer.setVdcUser(user);
// 
// // Mock-Set the query as admin/user
// ThereIsNoSuchQuery query = new ThereIsNoSuchQuery(params);
// Field adminQueryField = getQueryTypeField();
// adminQueryField.set(query, queryType);
// 
// query.setInternalExecution(isInternalExecution);
// query.ExecuteCommand();
// assertEquals("Running with type=" + queryType + " isUserAdmin=" + isUserAdmin + " isFiltered="
// + isFiltered + " isInternalExecution=" + isInternalExecution + "\n " +
// "Query should succeed is: ", shouldBeAbleToRunQuery, query.getQueryReturnValue()
// .getSucceeded());
// 
// ThreadLocalParamsContainer.clean();
// SessionDataContainer.getInstance().removeSession();
// }
// }
// }
// }
// }
@Test
public void testGetUserID() {
    IVdcUser user = mock(IVdcUser.class);
    when(user.getUserId()).thenReturn(Guid.EVERYONE);
    ThreadLocalParamsContainer.setVdcUser(user);
    ThereIsNoSuchQuery query = new ThereIsNoSuchQuery(new VdcQueryParametersBase());
    assertEquals("wrong guid", Guid.EVERYONE, query.getUserID());
}
#method_after
@Test
public void testGetUserID() {
    IVdcUser user = mock(IVdcUser.class);
    when(user.getUserId()).thenReturn(Guid.EVERYONE);
    ThreadLocalParamsContainer.setVdcUser(user);
    ThereIsNoSuchQuery query = new ThereIsNoSuchQuery(new VdcQueryParametersBase());
    assertEquals("wrong guid", Guid.EVERYONE, query.getUserID());
}
#end_block

#method_before
@Test
public void testExectueQuery() {
    DbFacade dbFacadeMock = mock(DbFacade.class);
    mockStatic(DbFacade.class);
    when(DbFacade.getInstance()).thenReturn(dbFacadeMock);
    VmNetworkInterfaceDAO daoMock = mock(VmNetworkInterfaceDAO.class);
    when(dbFacadeMock.getVmNetworkInterfaceDAO()).thenReturn(daoMock);
    Guid guid = new Guid();
    Guid userID = new Guid();
    IVdcUser user = mock(IVdcUser.class);
    when(user.getUserId()).thenReturn(userID);
    GetVmByVmIdParameters params = mock(GetVmByVmIdParameters.class);
    when(params.getId()).thenReturn(guid);
    when(params.isFiltered()).thenReturn(true);
    GetVmInterfacesByVmIdQuery query = spy(new GetVmInterfacesByVmIdQuery(params));
    when(query.getUser()).thenReturn(user);
    query.executeQueryCommand();
    verify(daoMock, times(1)).getAllForVm(guid, userID, true);
}
#method_after
@Test
public void testExectueQuery() {
    DbFacade dbFacadeMock = mock(DbFacade.class);
    mockStatic(DbFacade.class);
    when(DbFacade.getInstance()).thenReturn(dbFacadeMock);
    VmNetworkInterfaceDAO daoMock = mock(VmNetworkInterfaceDAO.class);
    when(dbFacadeMock.getVmNetworkInterfaceDAO()).thenReturn(daoMock);
    Guid guid = new Guid();
    Guid userID = new Guid();
    IVdcUser user = mock(IVdcUser.class);
    when(user.getUserId()).thenReturn(userID);
    GetVmByVmIdParameters params = mock(GetVmByVmIdParameters.class);
    when(params.getId()).thenReturn(guid);
    when(params.isFiltered()).thenReturn(true);
    GetVmInterfacesByVmIdQuery query = spy(new GetVmInterfacesByVmIdQuery(params));
    when(query.getUser()).thenReturn(user);
    when(query.getUserID()).thenReturn(userID);
    query.executeQueryCommand();
    verify(daoMock).getAllForVm(guid, userID, true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    // Parameters.EntityId = VmId;
    synchronized (_lockObject) {
        if (// no
        GetVmToAttach(getParameters().getVmPoolId()).equals(Guid.Empty)) // available
        // VMs:
        {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
            returnValue = false;
        }
    }
    // check user isn't already attached to vm from this pool
    if (returnValue) {
        List<VM> vmsForUser = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_USER_ATTACHED_TO_POOL);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ALLOCATE_AND_RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_FROM_VM_POOL);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    synchronized (_lockObject) {
        // no available VMs:
        if (GetVmToAttach(getParameters().getVmPoolId()).equals(Guid.Empty)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
            returnValue = false;
        }
    }
    // check user isn't already attached to vm from this pool
    if (returnValue) {
        List<VM> vmsForUser = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_USER_ATTACHED_TO_POOL);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ALLOCATE_AND_RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_FROM_VM_POOL);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    /**
     * TODO: check users throw their groups as well
     */
    initUser();
    synchronized (_lockObject) {
        // check vm is not attached to user and attach
        List<permissions> vmUserPermissions = DbFacade.getInstance().getPermissionDAO().getAllForRoleAndObject(PredefinedRoles.ENGINE_USER.getId(), getVmId());
        if (vmUserPermissions == null || vmUserPermissions.isEmpty()) {
            setVmId(GetVmToAttach(getParameters().getVmPoolId()));
            if (!getVmId().equals(Guid.Empty)) {
                getParameters().setEntityId(getVmId());
                permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), getVmId(), VdcObjectType.VM);
                PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
                permParams.setShouldBeLogged(false);
                permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
                Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, getCompensationContext());
                log.infoFormat("Vm {0} was attached to user {1} ", getVmId(), getAdUserId());
            }
        }
    }
    if (getVmId().equals(Guid.Empty)) {
        log.infoFormat("No free Vms in pool. Cannot allocate for user {1} ", getAdUserId());
        throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
    }
    CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVmId(), "SnapshotForVmFromPool");
    tempVar.setShouldBeLogged(false);
    tempVar.setParentCommand(getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.AttachUserToVmFromPoolAndRun);
    tempVar.setSessionId(getParameters().getSessionId());
    tempVar.setEntityId(getParameters().getEntityId());
    CreateAllSnapshotsFromVmParameters p = tempVar;
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, getCompensationContext());
    getParameters().getImagesParameters().add(p);
    getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    setSucceeded(vdcReturnValue.getSucceeded());
    setActionReturnValue(getVmId());
    getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    /**
     * TODO: check users throw their groups as well
     */
    initUser();
    synchronized (_lockObject) {
        // check vm is not attached to user and attach
        List<permissions> vmUserPermissions = DbFacade.getInstance().getPermissionDAO().getAllForRoleAndObject(PredefinedRoles.ENGINE_USER.getId(), getVmId());
        if (vmUserPermissions == null || vmUserPermissions.isEmpty()) {
            setVmId(GetVmToAttach(getParameters().getVmPoolId()));
            if (!getVmId().equals(Guid.Empty)) {
                getParameters().setEntityId(getVmId());
                permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), getVmId(), VdcObjectType.VM);
                PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
                permParams.setShouldBeLogged(false);
                permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
                VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, (CommandContext) getCompensationContext());
                if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                    log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), getVmId());
                    setActionReturnValue(vdcReturnValueFromAddPerm);
                    return;
                }
                log.infoFormat("Vm {0} was attached to user {1} ", getVmId(), getAdUserId());
            } else {
                log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
                throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
            }
        }
    }
    CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVmId(), "SnapshotForVmFromPool");
    tempVar.setShouldBeLogged(false);
    tempVar.setParentCommand(getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.AttachUserToVmFromPoolAndRun);
    tempVar.setSessionId(getParameters().getSessionId());
    tempVar.setEntityId(getParameters().getEntityId());
    CreateAllSnapshotsFromVmParameters p = tempVar;
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, (CommandContext) getCompensationContext());
    getParameters().getImagesParameters().add(p);
    getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    setSucceeded(vdcReturnValue.getSucceeded());
    setActionReturnValue(getVmId());
    getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    if (getVm() != null) {
        // next line is for retrieving the VmPool from the DB
        // so we won't get a log-deadlock because of the transaction.
        vm_pools vmPool = getVmPool();
        if (DbFacade.getInstance().getDiskImageDAO().getImageVmPoolMapByVmId(getVm().getvm_guid()).size() > 0) {
            // From AttachUserToVmAndRunCommand
            Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext());
            setSucceeded(true);
            if (getSucceeded()) {
                // ParametersCurrentUser =
                // PoolUserParameters.ParametersCurrentUser,
                RunVmParams tempVar = new RunVmParams(getVm().getvm_guid());
                tempVar.setSessionId(getParameters().getSessionId());
                tempVar.setUseVnc(getVm().getvm_type() == VmType.Server);
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, tempVar);
                setSucceeded(vdcReturnValue.getSucceeded());
            }
        } else // Pool-snapshot is gone (probably due to ProcessVmPoolOnStopVm
        // treatment) ->
        // no point in running the VM or trying to run again the EndAction
        // method:
        {
            // just in case.
            DetachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndSuccessfully: Vm is null - not performing full EndAction");
        setSucceeded(true);
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    if (getVm() != null) {
        // next line is for retrieving the VmPool from the DB
        // so we won't get a log-deadlock because of the transaction.
        vm_pools vmPool = getVmPool();
        if (DbFacade.getInstance().getDiskImageDAO().getImageVmPoolMapByVmId(getVm().getId()).size() > 0) {
            setSucceeded(Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext()).getSucceeded());
            if (getSucceeded()) {
                // ParametersCurrentUser =
                // PoolUserParameters.ParametersCurrentUser,
                RunVmParams tempVar = new RunVmParams(getVm().getId());
                tempVar.setSessionId(getParameters().getSessionId());
                tempVar.setUseVnc(getVm().getvm_type() == VmType.Server);
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, tempVar);
                setSucceeded(vdcReturnValue.getSucceeded());
            } else {
                log.warn("EndSuccessfully: EndAction of CreateAllSnapshotsFromVm failed, detaching user from Vm");
                // just in case.
                detachUserFromVmFromPool();
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // Pool-snapshot is gone (probably due to ProcessVmPoolOnStopVm
        // treatment) ->
        // no point in running the VM or trying to run again the EndAction
        // method:
        {
            log.warn("EndSuccessfully: No images were created for Vm, detaching user from Vm");
            // just in case.
            detachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndSuccessfully: Vm is null - not performing full EndAction");
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    // next line is for retrieving the VmPool (and Vm, implicitly) from
    // the DB so we won't get a log-deadlock because of the transaction.
    vm_pools vmPool = getVmPool();
    // From AttachUserToVmAndRunCommand
    Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext());
    DetachUserFromVmFromPool();
    setSucceeded(true);
}
#method_after
@Override
protected void EndWithFailure() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    // next line is for retrieving the VmPool (and Vm, implicitly) from
    // the DB so we won't get a log-deadlock because of the transaction.
    vm_pools vmPool = getVmPool();
    // From AttachUserToVmAndRunCommand
    Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext());
    detachUserFromVmFromPool();
    setSucceeded(true);
}
#end_block

#method_before
public void LoadBalance() {
    setAllRelevantVdss(DbFacade.getInstance().getVdsDAO().getAllForVdsGroupWithoutMigrating(getVdsGroup().getID()));
    log.infoFormat("VdsLoadBalancer: number of relevant vdss (no migration, no pending): {0}.", getAllRelevantVdss().size());
    InitOverUtilizedList();
    InitReadyToMigrationList();
    InitUnderUtilizedList();
    if (getOverUtilizedServers().size() != 0 && (getReadyToMigrationServers().size() != 0 || getUnderUtilizedServers().size() != 0)) {
        ProceedOverUtilizedServers();
    }
    if (getUnderUtilizedServers().size() > 0 && (getReadyToMigrationServers().size() > 0 || getUnderUtilizedServers().size() > 1)) {
        ProceedUnderUtilizedServers();
    }
}
#method_after
public void LoadBalance() {
    setAllRelevantVdss(DbFacade.getInstance().getVdsDAO().getAllForVdsGroupWithoutMigrating(getVdsGroup().getId()));
    log.infoFormat("VdsLoadBalancer: number of relevant vdss (no migration, no pending): {0}.", getAllRelevantVdss().size());
    InitOverUtilizedList();
    InitReadyToMigrationList();
    InitUnderUtilizedList();
    if (getOverUtilizedServers().size() != 0 && (getReadyToMigrationServers().size() != 0 || getUnderUtilizedServers().size() != 0)) {
        ProceedOverUtilizedServers();
    }
    if (getUnderUtilizedServers().size() > 0 && (getReadyToMigrationServers().size() > 0 || getUnderUtilizedServers().size() > 1)) {
        ProceedUnderUtilizedServers();
    }
}
#end_block

#method_before
private void ProceedOverUtilizedServers() {
    // LINQ 29456
    // List<int> overUtilizedServersIds =
    // OverUtilizedServers.Values.Select(i => i.vds_id).ToList();
    List<Guid> overUtilizedServersIds = LinqUtils.foreach(getOverUtilizedServers().values(), new Function<VDS, Guid>() {

        @Override
        public Guid eval(VDS vds) {
            return vds.getvds_id();
        }
    });
    // LINQ 29456
    for (Guid vdsId : overUtilizedServersIds) {
        VDS vds = getOverUtilizedServers().get(vdsId);
        log.infoFormat("VdsLoadBalancer: Server {0} decided as overutilized", vds.getvds_name());
        java.util.List<VM> vms = getMigrableVmsRunningOnVds(vdsId);
        if (vms.size() != 0) {
            /**
             * Get random desktop from under utilized server and try to
             * migrate it to other server
             */
            VM vm = getBestVmToMigrate(vms, vdsId);
            Map<Guid, VDS> currentList = getReadyToMigrationServers();
            /**
             * Try to find server in Ready to Migration list for migrate
             * desktop to
             */
            List<VDS> candidates = GetMigrationCandidates(currentList, vm);
            VDS destinationVds = null;
            if (candidates.isEmpty()) {
                /**
                 * No available server in ReadyToMigrationList Try to find
                 * server from UnderUtilized list for migrate desktop to
                 */
                currentList = getUnderUtilizedServers();
                candidates = GetMigrationCandidates(currentList, vm);
                if (!candidates.isEmpty()) {
                    destinationVds = candidates.get(candidates.size() - 1);
                }
            } else {
                destinationVds = candidates.get(0);
            }
            if (destinationVds == null) {
                log.infoFormat("VdsLoadBalancer: Server {0} detected as overutilized. Failed to found another server to migrate its vms", vds.getvds_name());
            } else {
                Guid destinationVdsId = destinationVds.getvds_id();
                /**
                 * Migrate vm from OverUtilezed server
                 */
                MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), destinationVdsId);
                parameters.setShouldBeLogged(false);
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVmToServer, parameters);
                /**
                 * Remove server from list
                 */
                currentList.remove(destinationVdsId);
                log.infoFormat("VdsLoadBalancer: Desktop {0} migrated from overutilized server {1} to server {2}", vm.getvm_name(), vds.getvds_name(), destinationVds.getvds_name());
            }
        } else {
            log.info("VdsLoadBalancer: No vms found to migrate on this server");
        }
    }
}
#method_after
private void ProceedOverUtilizedServers() {
    // LINQ 29456
    // List<int> overUtilizedServersIds =
    // OverUtilizedServers.Values.Select(i => i.vds_id).ToList();
    List<Guid> overUtilizedServersIds = LinqUtils.foreach(getOverUtilizedServers().values(), new Function<VDS, Guid>() {

        @Override
        public Guid eval(VDS vds) {
            return vds.getId();
        }
    });
    // LINQ 29456
    for (Guid vdsId : overUtilizedServersIds) {
        VDS vds = getOverUtilizedServers().get(vdsId);
        log.infoFormat("VdsLoadBalancer: Server {0} decided as overutilized", vds.getvds_name());
        java.util.List<VM> vms = getMigrableVmsRunningOnVds(vdsId);
        if (vms.size() != 0) {
            /**
             * Get random desktop from under utilized server and try to
             * migrate it to other server
             */
            VM vm = getBestVmToMigrate(vms, vdsId);
            Map<Guid, VDS> currentList = getReadyToMigrationServers();
            /**
             * Try to find server in Ready to Migration list for migrate
             * desktop to
             */
            List<VDS> candidates = GetMigrationCandidates(currentList, vm);
            VDS destinationVds = null;
            if (candidates.isEmpty()) {
                /**
                 * No available server in ReadyToMigrationList Try to find
                 * server from UnderUtilized list for migrate desktop to
                 */
                currentList = getUnderUtilizedServers();
                candidates = GetMigrationCandidates(currentList, vm);
                if (!candidates.isEmpty()) {
                    destinationVds = candidates.get(candidates.size() - 1);
                }
            } else {
                destinationVds = candidates.get(0);
            }
            if (destinationVds == null) {
                log.infoFormat("VdsLoadBalancer: Server {0} detected as overutilized. Failed to found another server to migrate its vms", vds.getvds_name());
            } else {
                Guid destinationVdsId = destinationVds.getId();
                /**
                 * Migrate vm from OverUtilezed server
                 */
                MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), destinationVdsId);
                parameters.setShouldBeLogged(false);
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVmToServer, parameters);
                /**
                 * Remove server from list
                 */
                currentList.remove(destinationVdsId);
                log.infoFormat("VdsLoadBalancer: Desktop {0} migrated from overutilized server {1} to server {2}", vm.getvm_name(), vds.getvds_name(), destinationVds.getvds_name());
            }
        } else {
            log.info("VdsLoadBalancer: No vms found to migrate on this server");
        }
    }
}
#end_block

#method_before
private void ProceedUnderUtilizedServers() {
    // LINQ 29456
    // List<int> underUtilizedServersIds =
    // UnderUtilizedServers.Values.Select(i => i.vds_id).ToList();
    List<Guid> underUtilizedServersIds = LinqUtils.foreach(getUnderUtilizedServers().values(), new Function<VDS, Guid>() {

        @Override
        public Guid eval(VDS vds) {
            return vds.getvds_id();
        }
    });
    Set<Guid> processed = new HashSet<Guid>();
    for (Guid vdsId : underUtilizedServersIds) {
        if (!processed.contains(vdsId)) {
            VDS vds = getUnderUtilizedServers().get(vdsId);
            java.util.List<VM> vms = getMigrableVmsRunningOnVds(vdsId);
            if (vms.size() != 0) {
                VM vm = getBestVmToMigrate(vms, vdsId);
                /**
                 * Get random desktop from under utilized server and try to
                 * migrate it to other server
                 */
                Map<Guid, VDS> currentList = getReadyToMigrationServers();
                List<VDS> candidates = GetMigrationCandidates(currentList, vm);
                VDS destinationVds = null;
                if (candidates.isEmpty()) {
                    /**
                     * Ready to Migrate servers not contain server to
                     * migrate current desktop, Try to find other
                     * UnderUtilized server with maximum count of running
                     * desktops
                     */
                    currentList = getUnderUtilizedServers();
                    final Guid vdsId1 = vdsId;
                    // LINQ 29456
                    // candidates = GetMigrationCandidates(currentList, vm).
                    // Where(a => a.vds_id != vdsId1).
                    // OrderByDescending(a => a.vm_count).ToList();
                    candidates = LinqUtils.filter(GetMigrationCandidates(currentList, vm), new Predicate<VDS>() {

                        @Override
                        public boolean eval(VDS a) {
                            return !a.getvds_id().equals(vdsId1);
                        }
                    });
                    if (!candidates.isEmpty()) {
                        destinationVds = Collections.max(candidates, new Comparator<VDS>() {

                            @Override
                            public int compare(VDS o1, VDS o2) {
                                return o1.getvm_count() - o2.getvm_count();
                            }
                        });
                    }
                } else {
                    destinationVds = candidates.get(0);
                }
                if (destinationVds == null) {
                    log.infoFormat("Server {0} detected as underutilized. Failed to found another server to migrate its vms", vds.getvds_name());
                } else {
                    Guid destinationVdsId = destinationVds.getvds_id();
                    MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), destinationVdsId);
                    parameters.setShouldBeLogged(false);
                    Backend.getInstance().runInternalAction(VdcActionType.MigrateVmToServer, parameters);
                    currentList.remove(destinationVdsId);
                    log.infoFormat("VdsLoadBalancer: Desktop {0} migrated from underutilized server {1} to server {2}", vm.getvm_name(), vds.getvds_name(), destinationVds.getvds_name());
                    processed.add(destinationVdsId);
                }
            } else {
                log.infoFormat("VdsLoadBalancer: No vms found to migrate on this server {0}", vds.getvds_name());
            }
            // remove the smallest
            getUnderUtilizedServers().remove(vdsId);
        // underutilized vds
        // which was already
        // processed, in
        // order to not
        // passed vm on it
        }
    }
}
#method_after
private void ProceedUnderUtilizedServers() {
    // LINQ 29456
    // List<int> underUtilizedServersIds =
    // UnderUtilizedServers.Values.Select(i => i.vds_id).ToList();
    List<Guid> underUtilizedServersIds = LinqUtils.foreach(getUnderUtilizedServers().values(), new Function<VDS, Guid>() {

        @Override
        public Guid eval(VDS vds) {
            return vds.getId();
        }
    });
    Set<Guid> processed = new HashSet<Guid>();
    for (Guid vdsId : underUtilizedServersIds) {
        if (!processed.contains(vdsId)) {
            VDS vds = getUnderUtilizedServers().get(vdsId);
            java.util.List<VM> vms = getMigrableVmsRunningOnVds(vdsId);
            if (vms.size() != 0) {
                VM vm = getBestVmToMigrate(vms, vdsId);
                /**
                 * Get random desktop from under utilized server and try to
                 * migrate it to other server
                 */
                Map<Guid, VDS> currentList = getReadyToMigrationServers();
                List<VDS> candidates = GetMigrationCandidates(currentList, vm);
                VDS destinationVds = null;
                if (candidates.isEmpty()) {
                    /**
                     * Ready to Migrate servers not contain server to
                     * migrate current desktop, Try to find other
                     * UnderUtilized server with maximum count of running
                     * desktops
                     */
                    currentList = getUnderUtilizedServers();
                    final Guid vdsId1 = vdsId;
                    // LINQ 29456
                    // candidates = GetMigrationCandidates(currentList, vm).
                    // Where(a => a.vds_id != vdsId1).
                    // OrderByDescending(a => a.vm_count).ToList();
                    candidates = LinqUtils.filter(GetMigrationCandidates(currentList, vm), new Predicate<VDS>() {

                        @Override
                        public boolean eval(VDS a) {
                            return !a.getId().equals(vdsId1);
                        }
                    });
                    if (!candidates.isEmpty()) {
                        destinationVds = Collections.max(candidates, new Comparator<VDS>() {

                            @Override
                            public int compare(VDS o1, VDS o2) {
                                return o1.getvm_count() - o2.getvm_count();
                            }
                        });
                    }
                } else {
                    destinationVds = candidates.get(0);
                }
                if (destinationVds == null) {
                    log.infoFormat("Server {0} detected as underutilized. Failed to found another server to migrate its vms", vds.getvds_name());
                } else {
                    Guid destinationVdsId = destinationVds.getId();
                    MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), destinationVdsId);
                    parameters.setShouldBeLogged(false);
                    Backend.getInstance().runInternalAction(VdcActionType.MigrateVmToServer, parameters);
                    currentList.remove(destinationVdsId);
                    log.infoFormat("VdsLoadBalancer: Desktop {0} migrated from underutilized server {1} to server {2}", vm.getvm_name(), vds.getvds_name(), destinationVds.getvds_name());
                    processed.add(destinationVdsId);
                }
            } else {
                log.infoFormat("VdsLoadBalancer: No vms found to migrate on this server {0}", vds.getvds_name());
            }
            // remove the smallest
            getUnderUtilizedServers().remove(vdsId);
        // underutilized vds
        // which was already
        // processed, in
        // order to not
        // passed vm on it
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    boolean retVal;
    // Load images from Import/Export domain
    GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    tempVar.setGetAll(true);
    VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    retVal = qretVal.getSucceeded();
    if (retVal) {
        List<VM> vms = (List) qretVal.getReturnValue();
        VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

            @Override
            public boolean eval(VM vm) {
                return vm.getId().equals(getParameters().getVm().getId());
            }
        });
        if (vm != null) {
            storage_domain_static destinationStorageDomainStatic = getStorageDomainStaticDAO().get(getParameters().getDestDomainId());
            // At this point we should work with the VM that was read from
            // the OVF
            setVm(vm);
            for (DiskImage image : getVm().getImages()) {
                // only if requested by the user
                if (getParameters().getCopyCollapse()) {
                    for (DiskImage p : imageList) {
                        if (p.getId().equals(image.getId())) {
                            if (p.getvolume_format() != null) {
                                image.setvolume_format(p.getvolume_format());
                            }
                            if (p.getvolume_type() != null) {
                                image.setvolume_type(p.getvolume_type());
                            }
                        }
                    }
                }
                retVal = ImagesHandler.CheckImageConfiguration(destinationStorageDomainStatic, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    // we put the source domain id in order that copy will
                    // work
                    // ok
                    // we fix it to DestDomainId in
                    // MoveOrCopyAllImageGroups();
                    image.setstorage_id(getParameters().getSourceDomainId());
                }
            }
            if (retVal) {
                Map<String, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                for (String drive : images.keySet()) {
                    List<DiskImage> list = images.get(drive);
                    getVm().addDriveToImageMap(drive, list.get(list.size() - 1));
                }
            }
        } else {
            retVal = false;
        }
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getSourceDomainId(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getDestDomainId(), getReturnValue().getCanDoActionMessages());
    }
    // TODO: checking disk target domains
    if (retVal) {
        if (!imageToDestinationDomainMap.isEmpty()) {
            for (Guid destGuid : imageToDestinationDomainMap.values()) {
                retVal = ImportExportCommon.CheckStorageDomain(destGuid, getReturnValue().getCanDoActionMessages());
                if (retVal && !domainIsValidDestination(getStorageDomain(destGuid))) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                    retVal = false;
                }
                if (!retVal)
                    break;
            }
        }
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStoragePool(getParameters().getStoragePoolId(), getReturnValue().getCanDoActionMessages());
    }
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getParameters().getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    // check that the imported vm name is not in engine
    if (retVal) {
        List<VmStatic> dupVmNames = getVmStaticDAO().getAllByName(getParameters().getVm().getvm_name());
        if (dupVmNames.size() >= 1) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", getVm().getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!IsDomainActive(getParameters().getSourceDomainId(), getParameters().getStoragePoolId()) || !IsDomainActive(getParameters().getDestDomainId(), getParameters().getStoragePoolId()) || !TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getDiskInfoList() != null) {
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<DiskImageBase>(getParameters().getDiskInfoList().values()), getReturnValue().getCanDoActionMessages());
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        getReturnValue().getCanDoActionMessages().add(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        if (!domainIsValidDestination(getStorageDomain())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        if (getSourceDomain() == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
            retVal = false;
        }
        if (getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getID().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (domainMap.isEmpty()) {
            domainMap.put(getStorageDomain(), (int) getVm().getDiskSize());
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    boolean retVal;
    // Load images from Import/Export domain
    GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    tempVar.setGetAll(true);
    VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    retVal = qretVal.getSucceeded();
    if (retVal) {
        List<VM> vms = (List) qretVal.getReturnValue();
        VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

            @Override
            public boolean eval(VM vm) {
                return vm.getId().equals(getParameters().getVm().getId());
            }
        });
        if (vm != null) {
            storage_domain_static destinationStorageDomainStatic = getStorageDomainStaticDAO().get(getParameters().getDestDomainId());
            // At this point we should work with the VM that was read from
            // the OVF
            setVm(vm);
            for (DiskImage image : getVm().getImages()) {
                // only if requested by the user
                if (getParameters().getCopyCollapse()) {
                    for (DiskImage p : imageList) {
                        if (p.getId().equals(image.getId())) {
                            if (p.getvolume_format() != null) {
                                image.setvolume_format(p.getvolume_format());
                            }
                            if (p.getvolume_type() != null) {
                                image.setvolume_type(p.getvolume_type());
                            }
                        }
                    }
                }
                retVal = ImagesHandler.CheckImageConfiguration(destinationStorageDomainStatic, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    // we put the source domain id in order that copy will
                    // work
                    // ok
                    // we fix it to DestDomainId in
                    // MoveOrCopyAllImageGroups();
                    image.setstorage_id(getParameters().getSourceDomainId());
                }
            }
            if (retVal) {
                Map<String, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                for (String drive : images.keySet()) {
                    List<DiskImage> list = images.get(drive);
                    getVm().addDriveToImageMap(drive, list.get(list.size() - 1));
                }
            }
        } else {
            retVal = false;
        }
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getSourceDomainId(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getDestDomainId(), getReturnValue().getCanDoActionMessages());
    }
    // TODO: checking disk target domains
    if (retVal) {
        if (!imageToDestinationDomainMap.isEmpty()) {
            for (Guid destGuid : imageToDestinationDomainMap.values()) {
                retVal = ImportExportCommon.CheckStorageDomain(destGuid, getReturnValue().getCanDoActionMessages());
                if (retVal && !domainIsValidDestination(getStorageDomain(destGuid))) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                    retVal = false;
                }
                if (!retVal)
                    break;
            }
        }
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStoragePool(getParameters().getStoragePoolId(), getReturnValue().getCanDoActionMessages());
    }
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getParameters().getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    // check that the imported vm name is not in engine
    if (retVal) {
        List<VmStatic> dupVmNames = getVmStaticDAO().getAllByName(getParameters().getVm().getvm_name());
        if (dupVmNames.size() >= 1) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", getVm().getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!IsDomainActive(getParameters().getSourceDomainId(), getParameters().getStoragePoolId()) || !IsDomainActive(getParameters().getDestDomainId(), getParameters().getStoragePoolId()) || !TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getDiskInfoList() != null) {
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<DiskImageBase>(getParameters().getDiskInfoList().values()), getReturnValue().getCanDoActionMessages());
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        getReturnValue().getCanDoActionMessages().add(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        if (!domainIsValidDestination(getStorageDomain())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        if (getSourceDomain() == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
            retVal = false;
        }
        if (getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (domainMap.isEmpty()) {
            domainMap.put(getStorageDomain(), (int) getVm().getDiskSize());
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
protected boolean CheckTemplateInStorageDomain() {
    boolean retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && CheckIfDisksExist(new ArrayList(getVm().getDiskMap().values()));
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getid();
            }
        });
        if (!domainsId.contains(getParameters().getStorageDomainId())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean CheckTemplateInStorageDomain() {
    boolean retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && CheckIfDisksExist(new ArrayList(getVm().getDiskMap().values()));
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (!domainsId.contains(getParameters().getStorageDomainId())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        Guid destinationDomain = (imageToDestinationDomainMap.get(disk.getId()) != null) ? imageToDestinationDomainMap.get(disk.getId()) : getParameters().getStorageDomainId();
        MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, disk.getimage_group_id().getValue(), disk.getId(), destinationDomain, getMoveOrCopyImageOperation());
        tempVar.setParentCommand(getActionType());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setUseCopyCollapse(getParameters().getCopyCollapse());
        tempVar.setCopyVolumeType(CopyVolumeType.LeafVol);
        tempVar.setPostZero(disk.getwipe_after_delete());
        tempVar.setForceOverride(true);
        MoveOrCopyImageGroupParameters p = tempVar;
        if (getParameters().getDiskInfoList() != null && getParameters().getDiskInfoList().containsKey(disk.getinternal_drive_mapping())) {
            p.setVolumeType(getParameters().getDiskInfoList().get(disk.getinternal_drive_mapping()).getvolume_type());
            p.setVolumeFormat(getParameters().getDiskInfoList().get(disk.getinternal_drive_mapping()).getvolume_format());
        }
        p.setParentParemeters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p);
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
    }
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        Guid destinationDomain = (imageToDestinationDomainMap.get(disk.getId()) != null) ? imageToDestinationDomainMap.get(disk.getId()) : getParameters().getStorageDomainId();
        MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, disk.getimage_group_id().getValue(), disk.getId(), destinationDomain, getMoveOrCopyImageOperation());
        tempVar.setParentCommand(getActionType());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setUseCopyCollapse(getParameters().getCopyCollapse());
        tempVar.setCopyVolumeType(CopyVolumeType.LeafVol);
        tempVar.setPostZero(disk.getwipe_after_delete());
        tempVar.setForceOverride(true);
        MoveOrCopyImageGroupParameters p = tempVar;
        if (getParameters().getDiskInfoList() != null && getParameters().getDiskInfoList().containsKey(disk.getinternal_drive_mapping())) {
            p.setVolumeType(getParameters().getDiskInfoList().get(disk.getinternal_drive_mapping()).getvolume_type());
            p.setVolumeFormat(getParameters().getDiskInfoList().get(disk.getinternal_drive_mapping()).getvolume_format());
        }
        p.setParentParemeters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(executionContext));
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
protected void AddVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(getNow());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(ComputeMinAllocatedMem());
    if (getParameters().getCopyCollapse()) {
        getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDAO().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#method_after
protected void AddVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(ComputeMinAllocatedMem());
    if (getParameters().getCopyCollapse()) {
        getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDAO().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean returnVal = true;
    List<stateless_vm_image_map> statelessMap = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
    List<DiskImage> imagesList = new java.util.ArrayList<DiskImage>(statelessMap.size());
    for (stateless_vm_image_map sMap : statelessMap) {
        imagesList.add(DbFacade.getInstance().getDiskImageDAO().getSnapshotById(sMap.getimage_guid()));
        /**
         * remove from db
         */
        DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(sMap.getimage_guid());
    }
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(getVm().getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        VdcReturnValueBase vdcReturn = Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar);
        returnVal = vdcReturn.getSucceeded();
    }
    setSucceeded(returnVal);
}
#method_after
@Override
protected void executeCommand() {
    boolean returnVal = true;
    List<stateless_vm_image_map> statelessMap = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
    List<DiskImage> imagesList = new java.util.ArrayList<DiskImage>(statelessMap.size());
    for (stateless_vm_image_map sMap : statelessMap) {
        imagesList.add(DbFacade.getInstance().getDiskImageDAO().getSnapshotById(sMap.getimage_guid()));
        /**
         * remove from db
         */
        DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(sMap.getimage_guid());
    }
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(getVm().getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        VdcReturnValueBase vdcReturn = Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar, ExecutionHandler.createDefaultContexForTasks(executionContext));
        returnVal = vdcReturn.getSucceeded();
    }
    setSucceeded(returnVal);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that vm is down and images are ok
    // not checking storage domain, there is a check in
    // CheckTemplateInStorageDomain later
    retValue = retValue && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, true, true, true, true, false);
    setStoragePoolId(getVm().getstorage_pool_id());
    VmHandler.updateDisksFromDb(getVm());
    retValue = retValue && CheckTemplateInStorageDomain();
    if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getid(), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && getVm().getDiskMap().size() <= 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retValue = false;
    }
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    retValue = retValue && destinationHasSpace();
    if (!retValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__MOVE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that vm is down and images are ok
    // not checking storage domain, there is a check in
    // CheckTemplateInStorageDomain later
    retValue = retValue && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, true, true, true, true, false);
    setStoragePoolId(getVm().getstorage_pool_id());
    VmHandler.updateDisksFromDb(getVm());
    retValue = retValue && CheckTemplateInStorageDomain();
    if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && getVm().getDiskMap().size() <= 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retValue = false;
    }
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    retValue = retValue && destinationHasSpace();
    if (!retValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__MOVE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retValue;
}
#end_block

#method_before
protected boolean CheckTemplateInStorageDomain() {
    boolean retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && // LINQ 32934 && CheckIfDisksExist(Vm.DiskMap.Values.ToList());
    CheckIfDisksExist(getVm().getDiskMap().values());
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid())) {
        List<storage_domains> domains = (List) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        // LINQ 32934 if (!domains.Select(a =>
        // a.id).Contains(MoveParameters.StorageDomainId))
        List<Guid> list = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains a) {
                return a.getid();
            }
        });
        if (!list.contains(getParameters().getStorageDomainId())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean CheckTemplateInStorageDomain() {
    boolean retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && // LINQ 32934 && CheckIfDisksExist(Vm.DiskMap.Values.ToList());
    CheckIfDisksExist(getVm().getDiskMap().values());
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid())) {
        List<storage_domains> domains = (List) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        // LINQ 32934 if (!domains.Select(a =>
        // a.id).Contains(MoveParameters.StorageDomainId))
        List<Guid> list = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains a) {
                return a.getId();
            }
        });
        if (!list.contains(getParameters().getStorageDomainId())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups() {
    MoveMultipleImageGroupsParameters tempVar = new MoveMultipleImageGroupsParameters(getVm().getId(), Helper.ToList(getVm().getDiskMap().values()), getParameters().getStorageDomainId());
    tempVar.setParentCommand(getActionType());
    tempVar.setEntityId(getParameters().getEntityId());
    MoveMultipleImageGroupsParameters p = tempVar;
    VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveMultipleImageGroups, p);
    getParameters().getImagesParameters().add(p);
    getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups() {
    MoveMultipleImageGroupsParameters tempVar = new MoveMultipleImageGroupsParameters(getVm().getId(), Helper.ToList(getVm().getDiskMap().values()), getParameters().getStorageDomainId());
    tempVar.setParentCommand(getActionType());
    tempVar.setEntityId(getParameters().getEntityId());
    MoveMultipleImageGroupsParameters p = tempVar;
    VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveMultipleImageGroups, p, ExecutionHandler.createDefaultContexForTasks(executionContext));
    getParameters().getImagesParameters().add(p);
    getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
}
#end_block

#method_before
@XmlElement(name = "vm_guid")
public Guid getId() {
    return this.mVmStatic.getId();
}
#method_after
@XmlElement(name = "vm_guid")
@Override
public Guid getId() {
    return this.mVmStatic.getId();
}
#end_block

#method_before
public void setId(Guid value) {
    this.mVmStatic.setId(value);
    this.mVmDynamic.setId(value);
    this.mVmStatistics.setId(value);
}
#method_after
@Override
public void setId(Guid value) {
    this.mVmStatic.setId(value);
    this.mVmDynamic.setId(value);
    this.mVmStatistics.setId(value);
}
#end_block

#method_before
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (VM.isStatusUpOrPausedOrSuspended(getVm().getstatus())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if (_oldDisk.getdisk_interface() != getParameters().getDiskInfo().getdisk_interface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        List allVmDisks = getDiskImageDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<DiskImageBase>() {

            @Override
            public boolean eval(DiskImageBase o) {
                return o.getinternal_drive_mapping().equals(_oldDisk.getinternal_drive_mapping());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!CheckPCIAndIDELimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    if (retValue && getParameters().getDiskInfo().getboot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (DiskImage disk : getVm().getDiskMap().values()) {
            if (disk.getboot() && !getParameters().getImageId().equals(disk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getinternal_drive_mapping()));
                break;
            }
        }
    }
    if (retValue && Boolean.FALSE.equals(getParameters().getDiskInfo().getPlugged()) && _oldDisk.getdisk_type() == DiskType.System) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_UNPLUG_SYSTEM_DISK);
    }
    return retValue;
}
#method_after
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (VM.isStatusUpOrPausedOrSuspended(getVm().getstatus())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if (_oldDisk.getdisk_interface() != getParameters().getDiskInfo().getdisk_interface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        List allVmDisks = getDiskImageDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<DiskImageBase>() {

            @Override
            public boolean eval(DiskImageBase o) {
                return o.getinternal_drive_mapping().equals(_oldDisk.getinternal_drive_mapping());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!CheckPCIAndIDELimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    if (retValue && getParameters().getDiskInfo().getboot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (DiskImage disk : getVm().getDiskMap().values()) {
            if (disk.getboot() && !getParameters().getImageId().equals(disk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getinternal_drive_mapping()));
                break;
            }
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean checkCanPerformPlugUnPlugDisk() {
    boolean returnValue = true;
    if (!Config.<Boolean>GetValue(ConfigValues.HotPlugEnabled, getVds().getvds_group_compatibility_version().getValue())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_SUPPORTED);
    } else if (!isOsSupported(getVm())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    } else if (!DiskInterface.VirtIO.equals(_oldDisk.getdisk_interface())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_VIRTIO);
    } else {
        if (oldVmDevice.getIsPlugged() == getParameters().getDiskInfo().getPlugged()) {
            if (oldVmDevice.getIsPlugged()) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
            } else {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
            }
        } else if (oldVmDevice.getIsPlugged() && _oldDisk.getdisk_type() == DiskType.System) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.HOT_UNPLUG_SYSTEM_DISK);
        }
    }
    if (returnValue) {
        plugAction = oldVmDevice.getIsPlugged() ? VDSCommandType.HotUnPlugDisk : VDSCommandType.HotUnPlugDisk;
    }
    return returnValue;
}
#method_after
private boolean checkCanPerformPlugUnPlugDisk() {
    boolean returnValue = true;
    if (!Config.<Boolean>GetValue(ConfigValues.HotPlugEnabled, getVds().getvds_group_compatibility_version().getValue())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_SUPPORTED);
    } else if (!isOsSupported(getVm())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    } else if (!DiskInterface.VirtIO.equals(_oldDisk.getdisk_interface())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_VIRTIO);
    } else if (oldVmDevice.getIsPlugged() == getParameters().getDiskInfo().getPlugged()) {
        if (oldVmDevice.getIsPlugged()) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
        } else {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
        }
    }
    if (returnValue) {
        plugAction = oldVmDevice.getIsPlugged() ? VDSCommandType.HotUnPlugDisk : VDSCommandType.HotPlugDisk;
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVm() == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that target domain exists
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getStorageDomainId(), getReturnValue().getCanDoActionMessages());
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    setStoragePoolId(getVm().getstorage_pool_id());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getid(), getVm().getstorage_pool_id())) == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    // check if template exists only if asked for
    if (retVal && getParameters().getTemplateMustExists()) {
        retVal = CheckTemplateInStorageDomain(getVm().getstorage_pool_id(), getParameters().getStorageDomainId(), getVm().getvmt_guid());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getvmt_name()));
        }
    }
    // check if Vm has disks
    if (retVal && getVm().getDiskMap().size() <= 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retVal = false;
    }
    if (retVal) {
        Map<String, ? extends DiskImageBase> images = getParameters().getDiskInfoList();
        if (images == null) {
            images = getVm().getDiskMap();
        }
        // check that the images requested format are valid (COW+Sparse)
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new java.util.ArrayList<DiskImageBase>(images.values()), getReturnValue().getCanDoActionMessages());
        if (retVal && getParameters().getCopyCollapse()) {
            for (DiskImage img : getVm().getDiskMap().values()) {
                if (images.containsKey(img.getinternal_drive_mapping())) {
                    // mode)
                    if (images.get(img.getinternal_drive_mapping()).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                        retVal = false;
                    }
                }
            }
        }
    }
    // check destination storage is active
    if (retVal) {
        retVal = IsDomainActive(getStorageDomain().getid(), getVm().getstorage_pool_id());
    }
    // check destination storage is Export domain
    if (retVal) {
        if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    // check destination storage have free space
    if (retVal) {
        int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
        retVal = StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB);
        if (!retVal)
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    // Set source domain
    if (retVal) {
        // DiskImage image = null; //LINQ Vm.DiskMap.First().Value;
        DiskImage image = LinqUtils.first(getVm().getDiskMap().values());
        if (image == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
            retVal = false;
        }
        if (retVal) {
            SetSourceDomainId(image.getstorage_id().getValue());
            if (getSourceDomain() == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                retVal = false;
            }
        }
    }
    // check soource domain is active
    if (retVal) {
        retVal = IsDomainActive(getSourceDomain().getid(), getVm().getstorage_pool_id());
    }
    // check that source domain is not ISO or Export domain
    if (retVal) {
        if (getSourceDomain().getstorage_domain_type() == StorageDomainType.ISO || getSourceDomain().getstorage_domain_type() == StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    // check if Vm exists in export domain
    if (retVal) {
        retVal = CheckVmInStorageDomain();
    }
    if (retVal) {
        // check that vm is down and images are ok
        retVal = retVal && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, false, false, true, true, false);
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EXPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVm() == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that target domain exists
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getStorageDomainId(), getReturnValue().getCanDoActionMessages());
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    setStoragePoolId(getVm().getstorage_pool_id());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    // check if template exists only if asked for
    if (retVal && getParameters().getTemplateMustExists()) {
        retVal = CheckTemplateInStorageDomain(getVm().getstorage_pool_id(), getParameters().getStorageDomainId(), getVm().getvmt_guid());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getvmt_name()));
        }
    }
    // check if Vm has disks
    if (retVal && getVm().getDiskMap().size() <= 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retVal = false;
    }
    if (retVal) {
        Map<String, ? extends DiskImageBase> images = getParameters().getDiskInfoList();
        if (images == null) {
            images = getVm().getDiskMap();
        }
        // check that the images requested format are valid (COW+Sparse)
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new java.util.ArrayList<DiskImageBase>(images.values()), getReturnValue().getCanDoActionMessages());
        if (retVal && getParameters().getCopyCollapse()) {
            for (DiskImage img : getVm().getDiskMap().values()) {
                if (images.containsKey(img.getinternal_drive_mapping())) {
                    // mode)
                    if (images.get(img.getinternal_drive_mapping()).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                        retVal = false;
                    }
                }
            }
        }
    }
    // check destination storage is active
    if (retVal) {
        retVal = IsDomainActive(getStorageDomain().getId(), getVm().getstorage_pool_id());
    }
    // check destination storage is Export domain
    if (retVal) {
        if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    // check destination storage have free space
    if (retVal) {
        int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
        retVal = StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB);
        if (!retVal)
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    // Set source domain
    if (retVal) {
        // DiskImage image = null; //LINQ Vm.DiskMap.First().Value;
        DiskImage image = LinqUtils.first(getVm().getDiskMap().values());
        if (image == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
            retVal = false;
        }
        if (retVal) {
            SetSourceDomainId(image.getstorage_id().getValue());
            if (getSourceDomain() == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                retVal = false;
            }
        }
    }
    // check soource domain is active
    if (retVal) {
        retVal = IsDomainActive(getSourceDomain().getId(), getVm().getstorage_pool_id());
    }
    // check that source domain is not ISO or Export domain
    if (retVal) {
        if (getSourceDomain().getstorage_domain_type() == StorageDomainType.ISO || getSourceDomain().getstorage_domain_type() == StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    // check if Vm exists in export domain
    if (retVal) {
        retVal = CheckVmInStorageDomain();
    }
    if (retVal) {
        // check that vm is down and images are ok
        retVal = retVal && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, false, false, true, true, false);
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EXPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, disk.getimage_group_id().getValue(), disk.getId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
        tempVar.setParentCommand(getActionType());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setUseCopyCollapse(getParameters().getCopyCollapse());
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(disk);
        tempVar.setVolumeFormat(diskForVolumeInfo.getvolume_format());
        tempVar.setVolumeType(diskForVolumeInfo.getvolume_type());
        tempVar.setCopyVolumeType(CopyVolumeType.LeafVol);
        tempVar.setPostZero(disk.getwipe_after_delete());
        tempVar.setForceOverride(getParameters().getForceOverride());
        MoveOrCopyImageGroupParameters p = tempVar;
        p.setParentParemeters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p);
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
    }
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, disk.getimage_group_id().getValue(), disk.getId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
        tempVar.setParentCommand(getActionType());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setUseCopyCollapse(getParameters().getCopyCollapse());
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(disk);
        tempVar.setVolumeFormat(diskForVolumeInfo.getvolume_format());
        tempVar.setVolumeType(diskForVolumeInfo.getvolume_type());
        tempVar.setCopyVolumeType(CopyVolumeType.LeafVol);
        tempVar.setPostZero(disk.getwipe_after_delete());
        tempVar.setForceOverride(getParameters().getForceOverride());
        MoveOrCopyImageGroupParameters p = tempVar;
        p.setParentParemeters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(executionContext));
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
protected void RestartVdsVms() {
    java.util.ArrayList<VdcActionParametersBase> runVmParamsList = new java.util.ArrayList<VdcActionParametersBase>();
    // restart all running vms of a failed vds.
    for (VM vm : mVmList) {
        DestroyVmOnDestination(vm);
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
        // Write that this VM was shut down by host rebbot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            LogSettingVmToDown(getVds().getvds_id(), vm.getId());
        }
        // ResourceManager.Instance.removeRunningVm(vm.vm_guid, VdsId);
        setVmId(vm.getId());
        setVmName(vm.getvm_name());
        setVm(vm);
        // Handle highly available VMs
        if (vm.getauto_startup()) {
            runVmParamsList.add(new RunVmParams(vm.getId(), true));
        }
    }
    if (runVmParamsList.size() > 0) {
        Backend.getInstance().runInternalMultipleActions(VdcActionType.RunVm, runVmParamsList);
    }
    setVm(null);
    setVmId(Guid.Empty);
    setVmName(null);
}
#method_after
protected void RestartVdsVms() {
    java.util.ArrayList<VdcActionParametersBase> runVmParamsList = new java.util.ArrayList<VdcActionParametersBase>();
    // restart all running vms of a failed vds.
    for (VM vm : mVmList) {
        DestroyVmOnDestination(vm);
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
        // Write that this VM was shut down by host rebbot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            LogSettingVmToDown(getVds().getId(), vm.getId());
        }
        // ResourceManager.Instance.removeRunningVm(vm.vm_guid, VdsId);
        setVmId(vm.getId());
        setVmName(vm.getvm_name());
        setVm(vm);
        // Handle highly available VMs
        if (vm.getauto_startup()) {
            runVmParamsList.add(new RunVmParams(vm.getId(), true));
        }
    }
    if (runVmParamsList.size() > 0) {
        Backend.getInstance().runInternalMultipleActions(VdcActionType.RunVm, runVmParamsList);
    }
    setVm(null);
    setVmId(Guid.Empty);
    setVmName(null);
}
#end_block

#method_before
protected void setStatus(VDSStatus status) {
    if (getVds().getstatus() != status) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVds().getvds_id(), status));
    }
}
#method_after
protected void setStatus(VDSStatus status) {
    if (getVds().getstatus() != status) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVds().getId(), status));
    }
}
#end_block

#method_before
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.createVolume, p, false);
    return taskID;
}
#method_after
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters(), asyncTaskCreationInfo.getStepId()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.createVolume, p, false);
    return taskID;
}
#end_block

#method_before
private void RestoreVmFromBaseSnapshot(VM vm) {
    List<image_vm_pool_map> list = DbFacade.getInstance().getDiskImageDAO().getImageVmPoolMapByVmId(vm.getId());
    // java.util.ArrayList<DiskImage> imagesList = null; // LINQ 32934
    // list.Select(a =>
    // DbFacade.Instance.GetSnapshotById(a.image_guid)).ToList();
    List<DiskImage> imagesList = LinqUtils.foreach(list, new Function<image_vm_pool_map, DiskImage>() {

        @Override
        public DiskImage eval(image_vm_pool_map a) {
            return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(a.getimage_guid());
        }
    });
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(vm.getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar);
    }
}
#method_after
private void RestoreVmFromBaseSnapshot(VM vm) {
    List<image_vm_pool_map> list = DbFacade.getInstance().getDiskImageDAO().getImageVmPoolMapByVmId(vm.getId());
    // java.util.ArrayList<DiskImage> imagesList = null; // LINQ 32934
    // list.Select(a =>
    // DbFacade.Instance.GetSnapshotById(a.image_guid)).ToList();
    List<DiskImage> imagesList = LinqUtils.foreach(list, new Function<image_vm_pool_map, DiskImage>() {

        @Override
        public DiskImage eval(image_vm_pool_map a) {
            return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(a.getimage_guid());
        }
    });
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(vm.getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar, ExecutionHandler.createDefaultContexForTasks(executionContext));
    }
}
#end_block

#method_before
@Override
public void ProcessOnVmStop(Guid vmId) {
    VmPoolHandler.ProcessVmPoolOnStopVm(vmId);
/**
 * Vitaly wating for Vm.ExitStatus in DB.
 * //HighAvailableVmsDirector.TryRunHighAvailableVmsOnVmDown(vmId);
 */
}
#method_after
@Override
public void ProcessOnVmStop(Guid vmId) {
    VmPoolHandler.ProcessVmPoolOnStopVm(vmId, null);
/**
 * Vitaly wating for Vm.ExitStatus in DB.
 * //HighAvailableVmsDirector.TryRunHighAvailableVmsOnVmDown(vmId);
 */
}
#end_block

#method_before
@Override
public void VdsNotResponding(final VDS vds) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getvds_id(), vds.gethost_name());
            Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getvds_id(), FenceActionType.Restart));
        }
    });
}
#method_after
@Override
public void VdsNotResponding(final VDS vds) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getId(), vds.gethost_name());
            Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getId(), FenceActionType.Restart));
        }
    });
}
#end_block

#method_before
@Override
public void ProcessOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(vmId);
    // clients, so we won't need to handle migration errors
    if (!StringHelper.isNullOrEmpty(vmDynamic.getclient_ip())) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                RunVmCommandBase.DoCompressionCheck(vds, vmDynamic);
                // Run PowerClientMigrateOnConnectCheck if configured.
                if (Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateToPowerClientOnConnect) || Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateFromPowerClientToVdsWhenConnectingFromRegularClient)) {
                    Backend.getInstance().runInternalAction(VdcActionType.PowerClientMigrateOnConnectCheck, new PowerClientMigrateOnConnectCheckParameters(false, vmDynamic.getId(), vmDynamic.getclient_ip(), vds.getvds_id()));
                }
            }
        });
    } else // in case of empty clientIp we clear the logged in user.
    // (this happened when user close the console to spice/vnc)
    {
        vmDynamic.setguest_cur_user_id(null);
        vmDynamic.setguest_cur_user_name(null);
        DbFacade.getInstance().getVmDynamicDAO().update(vmDynamic);
    }
}
#method_after
@Override
public void ProcessOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(vmId);
    // clients, so we won't need to handle migration errors
    if (!StringHelper.isNullOrEmpty(vmDynamic.getclient_ip())) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                RunVmCommandBase.DoCompressionCheck(vds, vmDynamic);
                // Run PowerClientMigrateOnConnectCheck if configured.
                if (Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateToPowerClientOnConnect) || Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateFromPowerClientToVdsWhenConnectingFromRegularClient)) {
                    Backend.getInstance().runInternalAction(VdcActionType.PowerClientMigrateOnConnectCheck, new PowerClientMigrateOnConnectCheckParameters(false, vmDynamic.getId(), vmDynamic.getclient_ip(), vds.getId()));
                }
            }
        });
    } else // in case of empty clientIp we clear the logged in user.
    // (this happened when user close the console to spice/vnc)
    {
        vmDynamic.setguest_cur_user_id(null);
        vmDynamic.setguest_cur_user_name(null);
        DbFacade.getInstance().getVmDynamicDAO().update(vmDynamic);
    }
}
#end_block

#method_before
@Override
public void RemoveAsyncRunningCommand(Guid vmId) {
    Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(vmId);
}
#method_after
@Override
public void RemoveAsyncRunningCommand(Guid vmId) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(vmId);
    if (command != null) {
        command.reportCompleted();
    }
}
#end_block

#method_before
public static void ProcessStorageOnVdsInactive(VDS vds) {
    // Clear the problematic timers since the VDS is in maintenance so it doesn't make sense to check it
    // anymore.
    IrsBrokerCommand.clearVdsFromCache(vds.getstorage_pool_id(), vds.getvds_id(), vds.getvds_name());
    if (!vds.getstorage_pool_id().equals(Guid.Empty) && StoragePoolStatus.Uninitialized != DbFacade.getInstance().getStoragePoolDAO().get(vds.getstorage_pool_id()).getstatus() && Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getvds_id(), vds.getstorage_pool_id(), vds.getvds_spm_id())).getSucceeded()) {
        StoragePoolParametersBase tempVar = new StoragePoolParametersBase(vds.getstorage_pool_id());
        tempVar.setVdsId(vds.getvds_id());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        Backend.getInstance().runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, tempVar);
    }
}
#method_after
public static void ProcessStorageOnVdsInactive(VDS vds) {
    // Clear the problematic timers since the VDS is in maintenance so it doesn't make sense to check it
    // anymore.
    IrsBrokerCommand.clearVdsFromCache(vds.getstorage_pool_id(), vds.getId(), vds.getvds_name());
    if (!vds.getstorage_pool_id().equals(Guid.Empty) && StoragePoolStatus.Uninitialized != DbFacade.getInstance().getStoragePoolDAO().get(vds.getstorage_pool_id()).getstatus() && Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getId(), vds.getstorage_pool_id(), vds.getvds_spm_id())).getSucceeded()) {
        StoragePoolParametersBase tempVar = new StoragePoolParametersBase(vds.getstorage_pool_id());
        tempVar.setVdsId(vds.getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        Backend.getInstance().runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, tempVar);
    }
}
#end_block

#method_before
public static void updateDisksFromDb(VM vm) {
    List<DiskImage> imageList = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
    for (DiskImage image : imageList) {
        if (image.getactive() != null && image.getactive()) {
            vm.getDiskMap().put(image.getinternal_drive_mapping(), image);
            vm.getDiskList().add(image);
        }
    }
}
#method_after
public static void updateDisksFromDb(VM vm) {
    List<DiskImage> imageList = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
    updateDisksForVm(vm, imageList);
}
#end_block

#method_before
public static boolean IsNotDuplicateInterfaceName(List<VmNetworkInterface> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREAY_IN_USE.name());
        return false;
    }
    return true;
}
#method_after
public static boolean IsNotDuplicateInterfaceName(List<VmNetworkInterface> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#end_block

#method_before
private java.util.ArrayList<Guid> getRunVdssList() {
    return getVdsSelector().getRunVdssList();
}
#method_after
private ArrayList<Guid> getRunVdssList() {
    return getVdsSelector().getRunVdssList();
}
#end_block

#method_before
public static boolean hasCapacityToRunVM(VDS curVds) {
    boolean hasCapacity = true;
    if (curVds.getvds_type() == VDSType.PowerClient) {
        log.infoFormat("Checking capacity for a power client - id:{0}, name:{1}, host_name(ip):{2}, vds.vm_count:{3}, PowerClientMaxNumberOfConcurrentVMs:{4}", curVds.getvds_id(), curVds.getvds_name(), curVds.gethost_name(), curVds.getvm_count(), Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs));
        int pending_vm_count = 0;
        if (Config.<Boolean>GetValue(ConfigValues.PowerClientRunVmShouldVerifyPendingVMsAsWell) && _vds_pending_vm_count.containsKey(curVds.getvds_id())) {
            pending_vm_count = _vds_pending_vm_count.get(curVds.getvds_id());
        }
        if ((curVds.getvm_count() + pending_vm_count + 1) > Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs)) {
            log.infoFormat("No capacity for a power client - id:{0}, name:{1}, host_name(ip):{2}, vds.vm_count:{3}, PowerClientMaxNumberOfConcurrentVMs:{4}", curVds.getvds_id(), curVds.getvds_name(), curVds.gethost_name(), curVds.getvm_count(), Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs));
            hasCapacity = false;
        }
    }
    return hasCapacity;
}
#method_after
public static boolean hasCapacityToRunVM(VDS curVds) {
    boolean hasCapacity = true;
    if (curVds.getvds_type() == VDSType.PowerClient) {
        log.infoFormat("Checking capacity for a power client - id:{0}, name:{1}, host_name(ip):{2}, vds.vm_count:{3}, PowerClientMaxNumberOfConcurrentVMs:{4}", curVds.getId(), curVds.getvds_name(), curVds.gethost_name(), curVds.getvm_count(), Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs));
        int pending_vm_count = 0;
        if (Config.<Boolean>GetValue(ConfigValues.PowerClientRunVmShouldVerifyPendingVMsAsWell) && _vds_pending_vm_count.containsKey(curVds.getId())) {
            pending_vm_count = _vds_pending_vm_count.get(curVds.getId());
        }
        if ((curVds.getvm_count() + pending_vm_count + 1) > Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs)) {
            log.infoFormat("No capacity for a power client - id:{0}, name:{1}, host_name(ip):{2}, vds.vm_count:{3}, PowerClientMaxNumberOfConcurrentVMs:{4}", curVds.getId(), curVds.getvds_name(), curVds.gethost_name(), curVds.getvm_count(), Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs));
            hasCapacity = false;
        }
    }
    return hasCapacity;
}
#end_block

#method_before
public static void DoCompressionCheck(VDS vds, VmDynamic vm) {
    if (Config.<Boolean>GetValue(ConfigValues.PowerClientSpiceDynamicCompressionManagement)) {
        // comrpession allways enabled on VDS
        if (vds.getvds_type() != VDSType.PowerClient) {
            return;
        } else {
            String compression_enabled = "on";
            if (StringHelper.EqOp(vds.gethost_name(), vm.getclient_ip())) {
                compression_enabled = "off";
            }
            log.infoFormat("VdcBLL.VmHandler.DoCompressionCheck - sending monitor command for vmid: {0} - set_red_image_compression and set_red_streaming_video to {1}", vm.getId(), compression_enabled);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getvds_id(), vm.getId(), "set_red_image_compression " + compression_enabled));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getvds_id(), vm.getId(), "set_red_streaming_video " + compression_enabled));
        }
    }
}
#method_after
public static void DoCompressionCheck(VDS vds, VmDynamic vm) {
    if (Config.<Boolean>GetValue(ConfigValues.PowerClientSpiceDynamicCompressionManagement)) {
        // compression always enabled on VDS
        if (vds.getvds_type() != VDSType.PowerClient) {
            return;
        } else {
            String compression_enabled = "on";
            if (StringHelper.EqOp(vds.gethost_name(), vm.getclient_ip())) {
                compression_enabled = "off";
            }
            log.infoFormat("VdcBLL.VmHandler.DoCompressionCheck - sending monitor command for vmid: {0} - set_red_image_compression and set_red_streaming_video to {1}", vm.getId(), compression_enabled);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getId(), vm.getId(), "set_red_image_compression " + compression_enabled));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getId(), vm.getId(), "set_red_streaming_video " + compression_enabled));
        }
    }
}
#end_block

#method_before
protected void rerunInternal() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getvds_id() : getCurrentVdsId();
    DecreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        _isRerun = true;
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        log();
        ExecuteAction();
        if (!getReturnValue().getCanDoAction()) {
            _isRerun = false;
            log();
            FailedToRunVm();
        }
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        FailedToRunVm();
        _isRerun = false;
    }
}
#method_after
protected void rerunInternal() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    DecreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        _isRerun = true;
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        log();
        ExecuteAction();
        if (!getReturnValue().getCanDoAction()) {
            _isRerun = false;
            log();
            FailedToRunVm();
        }
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        FailedToRunVm();
        _isRerun = false;
    }
}
#end_block

#method_before
protected void FailedToRunVm() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            AnonymousMethod1();
        }
    });
}
#method_after
protected void FailedToRunVm() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            processVmPoolOnStopVm();
        }
    });
    ExecutionHandler.setAsyncJob(executionContext, false);
    ExecutionHandler.endJob(executionContext, false);
}
#end_block

#method_before
@Override
public void RunningSucceded() {
    DecreasePendingVms(getCurrentVdsId());
    setSucceeded(true);
    setActionReturnValue(VMStatus.Up);
    log();
    for (Guid vdsId : getRunVdssList()) {
        if (!getCurrentVdsId().equals(vdsId)) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
        }
    }
    if (getVm().getlast_vds_run_on() == null || !getVm().getlast_vds_run_on().equals(getCurrentVdsId())) {
        getVm().setlast_vds_run_on(getCurrentVdsId());
    }
    if (!StringHelper.isNullOrEmpty(getVm().gethibernation_vol_handle())) {
        HandleHibernatedVm(VdcActionType.RunVm, true);
        // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
        // this method (which is a part of the cached VM command,
        // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
        // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
        // status to up.
        getVm().setstatus(VMStatus.Up);
        getVm().sethibernation_vol_handle(null);
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
    }
}
#method_after
@Override
public void RunningSucceded() {
    DecreasePendingVms(getCurrentVdsId());
    setSucceeded(true);
    setActionReturnValue(VMStatus.Up);
    log();
    ExecutionHandler.setAsyncJob(executionContext, false);
    ExecutionHandler.endJob(executionContext, true);
    for (Guid vdsId : getRunVdssList()) {
        if (!getCurrentVdsId().equals(vdsId)) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
        }
    }
    if (getVm().getlast_vds_run_on() == null || !getVm().getlast_vds_run_on().equals(getCurrentVdsId())) {
        getVm().setlast_vds_run_on(getCurrentVdsId());
    }
    if (!StringHelper.isNullOrEmpty(getVm().gethibernation_vol_handle())) {
        HandleHibernatedVm(VdcActionType.RunVm, true);
        // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
        // this method (which is a part of the cached VM command,
        // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
        // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
        // status to up.
        getVm().setstatus(VMStatus.Up);
        getVm().sethibernation_vol_handle(null);
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
    }
}
#end_block

#method_before
protected Guid getCurrentVdsId() {
    return getVds().getvds_id();
}
#method_after
protected Guid getCurrentVdsId() {
    return getVds().getId();
}
#end_block

#method_before
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters());
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#method_after
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(executionContext));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    // NOTE: Assuming that we need to lock the vm before adding a disk!
    VmHandler.checkStatusAndLockVm(getVm().getId(), getCompensationContext());
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getVmId(), getParameters().getDiskInfo());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setVmSnapshotId(calculateSnapshotId());
    parameters.setParentCommand(VdcActionType.AddDiskToVm);
    parameters.setEntityId(getParameters().getEntityId());
    getParameters().getImagesParameters().add(parameters);
    getParameters().setVmSnapshotId(parameters.getVmSnapshotId());
    parameters.setParentParemeters(getParameters());
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters);
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    getReturnValue().setActionReturnValue(tmpRetValue.getActionReturnValue());
    getReturnValue().setFault(tmpRetValue.getFault());
    if (tmpRetValue.getSucceeded()) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId((Guid) getActionReturnValue(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, "", true, false);
    }
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
@Override
protected void ExecuteVmCommand() {
    // NOTE: Assuming that we need to lock the vm before adding a disk!
    VmHandler.checkStatusAndLockVm(getVm().getId(), getCompensationContext());
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getVmId(), getParameters().getDiskInfo());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setVmSnapshotId(calculateSnapshotId());
    parameters.setParentCommand(VdcActionType.AddDiskToVm);
    parameters.setEntityId(getParameters().getEntityId());
    getParameters().getImagesParameters().add(parameters);
    getParameters().setVmSnapshotId(parameters.getVmSnapshotId());
    parameters.setParentParemeters(getParameters());
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(executionContext));
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    getReturnValue().setActionReturnValue(tmpRetValue.getActionReturnValue());
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private void InitRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringHelper.isNullOrEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getstorage_pool_id());
    }
    if (!StringHelper.isNullOrEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getstorage_pool_id());
    }
    if (getVm() != null) {
        Guid destVdsId = (getDestinationVds() != null) ? (Guid) getDestinationVds().getvds_id() : null;
        setVdsSelector(new VdsSelector(getVm(), destVdsId, true));
        refreshBootParameters(runVmParameters);
    }
}
#method_after
private void InitRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringHelper.isNullOrEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getstorage_pool_id());
    }
    if (!StringHelper.isNullOrEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getstorage_pool_id());
    }
    if (getVm() != null) {
        Guid destVdsId = (getDestinationVds() != null) ? (Guid) getDestinationVds().getId() : null;
        setVdsSelector(new VdsSelector(getVm(), destVdsId, true));
        refreshBootParameters(runVmParameters);
    }
}
#end_block

#method_before
private void ResumeVm() {
    mResume = true;
    // Vds = ResourceManager.Instance.getVds(Vm.run_on_vds.Value);
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            IncrementVdsPendingVmsCount();
            VDSReturnValue result = Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
        } finally {
            DecrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
private void ResumeVm() {
    mResume = true;
    // Vds = ResourceManager.Instance.getVds(Vm.run_on_vds.Value);
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            IncrementVdsPendingVmsCount();
            VDSReturnValue result = Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(executionContext, true);
        } finally {
            DecrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
protected void RunVm() {
    setActionReturnValue(VMStatus.Down);
    if (GetVdsToRunOn()) {
        VMStatus status;
        try {
            IncrementVdsPendingVmsCount();
            AttachCd();
            status = CreateVm();
        } finally {
            DecrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            Rerun();
        }
    } else {
        FailedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void RunVm() {
    setActionReturnValue(VMStatus.Down);
    if (GetVdsToRunOn()) {
        VMStatus status;
        try {
            IncrementVdsPendingVmsCount();
            AttachCd();
            status = CreateVm();
            ExecutionHandler.setAsyncJob(executionContext, true);
        } finally {
            DecrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            Rerun();
        }
    } else {
        FailedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
private void AttachCd() {
    Guid storagePoolId = getVm().getstorage_pool_id();
    boolean isIsoFound = (findActiveISODomain(storagePoolId) != null);
    if (isIsoFound) {
        if (StringHelper.isNullOrEmpty(getVm().getCdPath())) {
            getVm().setCdPath(getVm().getiso_path());
            GuestToolsVersionTreatment();
            // LINQ Vm.boot_sequence.toString().Contains(cd))
            refreshBootSequenceParameter(getParameters());
            if (getVm().getboot_sequence().toString().indexOf(cd) > -1) {
                getVm().setCdPath(getVm().getiso_path());
            }
            getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(getVm().getCdPath(), getVm().getstorage_pool_id()));
        }
    } else if (!StringHelper.isNullOrEmpty(getVm().getiso_path())) {
        getVm().setCdPath("");
        log.error("Can not attach CD without active ISO domain");
    }
}
#method_after
private void AttachCd() {
    Guid storagePoolId = getVm().getstorage_pool_id();
    boolean isIsoFound = (findActiveISODomain(storagePoolId) != null);
    if (isIsoFound) {
        if (StringHelper.isNullOrEmpty(getVm().getCdPath())) {
            getVm().setCdPath(getVm().getiso_path());
            GuestToolsVersionTreatment();
            refreshBootSequenceParameter(getParameters());
            if (getVm().getboot_sequence() == BootSequence.CD) {
                getVm().setCdPath(getVm().getiso_path());
            }
            getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(getVm().getCdPath(), getVm().getstorage_pool_id()));
        }
    } else if (!StringHelper.isNullOrEmpty(getVm().getiso_path())) {
        getVm().setCdPath("");
        log.error("Can not attach CD without active ISO domain");
    }
}
#end_block

#method_before
private void StatelessVmTreatment() {
    /**
     * if one of vm's images is in the DB dont do anything.
     */
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() == 0) {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        lockVmWithCompensationIfNeeded();
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, getCompensationContext());
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            // RestoreAllSnapshots)
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * add new stateless vm image to db
                 */
                DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(disk.getId(), disk.getinternal_drive_mapping(), getVm().getId()));
            }
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getReturnValue().setFault(vdcReturnValue.getFault());
            }
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    } else {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    }
}
#method_after
private void StatelessVmTreatment() {
    /**
     * if one of vm's images is in the DB dont do anything.
     */
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() == 0) {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        lockVmWithCompensationIfNeeded();
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            // RestoreAllSnapshots)
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * add new stateless vm image to db
                 */
                DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(disk.getId(), disk.getinternal_drive_mapping(), getVm().getId()));
            }
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getReturnValue().setFault(vdcReturnValue.getFault());
            }
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    } else {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    }
}
#end_block

#method_before
private void removeVmStatlessImages() {
    isFailedStatlessSnapshot = true;
    VmPoolHandler.removeVmStatelessImages(getVm().getId());
    setSucceeded(true);
}
#method_after
private void removeVmStatlessImages() {
    isFailedStatlessSnapshot = true;
    VmPoolHandler.removeVmStatelessImages(getVm().getId(), new CommandContext(executionContext));
    setSucceeded(true);
}
#end_block

#method_before
private void GuestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    storage_domains isoDomain = null;
    if (!getVm().getvm_os().isLinux() && (null != (isoDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getVm().getstorage_pool_id()), new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains domain) {
            return domain.getstorage_domain_type() == StorageDomainType.ISO;
        }
    })) && isoDomain.getstatus() == StorageDomainStatus.Active && StringHelper.isNullOrEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoFileMetaData> repoFilesMap = IsoDomainListSyncronizer.getInstance().getCachedIsoListByDomainId(isoDomain.getid(), FileTypeExtension.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoFileMetaData map : repoFilesMap) {
            String fileName = map.getRepoFileName() != null ? map.getRepoFileName() : "";
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.regexToolPattern).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                // TODO: Should be group name string support in java7.
                Version clusterVer = new Version(matchToolPattern.group(1));
                int toolVersion = Integer.parseInt(matchToolPattern.group(3));
                if (clusterVer.compareTo(getVm().getvds_group_compatibility_version()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        // if minimalVdsRev isn't empty use new iso files name convention
        // string qumranetToolsPath = minimalVdsRev == string.Empty
        // ?
        // string.Format("{0}{1}.iso", GuestToolsSetupIsoPrefix, revision)
        // :
        // // format is RHEV-ToolsSetup_tools_ver_vds_min_ver
        // string.Format("{0}{1}_{2}.iso", GuestToolsSetupIsoPrefix,
        // revision,
        // minimalVdsRev);
        String qumranetToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.guestToolsSetupIsoPrefix, selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getstorage_pool_id())).getReturnValue();
        qumranetToolsPath = Path.Combine(isoDir, qumranetToolsPath);
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(qumranetToolsPath, getVm().getstorage_pool_id()));
    }
}
#method_after
private void GuestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    storage_domains isoDomain = null;
    if (!getVm().getvm_os().isLinux() && (null != (isoDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getVm().getstorage_pool_id()), new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains domain) {
            return domain.getstorage_domain_type() == StorageDomainType.ISO;
        }
    })) && isoDomain.getstatus() == StorageDomainStatus.Active && StringHelper.isNullOrEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoFileMetaData> repoFilesMap = IsoDomainListSyncronizer.getInstance().getCachedIsoListByDomainId(isoDomain.getId(), FileTypeExtension.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoFileMetaData map : repoFilesMap) {
            String fileName = map.getRepoFileName() != null ? map.getRepoFileName() : "";
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.regexToolPattern).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                // TODO: Should be group name string support in java7.
                Version clusterVer = new Version(matchToolPattern.group(1));
                int toolVersion = Integer.parseInt(matchToolPattern.group(3));
                if (clusterVer.compareTo(getVm().getvds_group_compatibility_version()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        // if minimalVdsRev isn't empty use new iso files name convention
        // string qumranetToolsPath = minimalVdsRev == string.Empty
        // ?
        // string.Format("{0}{1}.iso", GuestToolsSetupIsoPrefix, revision)
        // :
        // // format is RHEV-ToolsSetup_tools_ver_vds_min_ver
        // string.Format("{0}{1}_{2}.iso", GuestToolsSetupIsoPrefix,
        // revision,
        // minimalVdsRev);
        String qumranetToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.guestToolsSetupIsoPrefix, selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getstorage_pool_id())).getReturnValue();
        qumranetToolsPath = Path.Combine(isoDir, qumranetToolsPath);
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(qumranetToolsPath, getVm().getstorage_pool_id()));
    }
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        Guid storagePoolId = vm.getstorage_pool_id();
        // and no other boot devices are configured
        if (vmImages.isEmpty() && StringHelper.EqOp(boot_sequence.toString(), BootSequence.C.toString())) {
            message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString());
            retValue = false;
        } else {
            if ((findActiveISODomain(storagePoolId) == null) && boot_sequence.toString().length() > 0 && (boot_sequence.toString().charAt(0) == cd)) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else {
                    if (vmImages.size() > 0) {
                        Guid storageDomainId = vmImages.get(0).getstorage_id().getValue();
                        // if VM is not HA VM
                        if (!ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                            retValue = false;
                        } else // Check if iso and floppy path exists
                        if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                            retValue = false;
                        } else {
                            boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                            if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                                }
                            } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                                VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                                if (vds.getstatus() != VDSStatus.Up) {
                                    retValue = false;
                                    if (message != null) {
                                        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                    }
                                }
                            }
                            boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                            if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                                retValue = false;
                                message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                            }
                            // if the VM itself is stateless or run once as stateless
                            if (retValue && isStatelessVm && vm.getauto_startup()) {
                                retValue = false;
                                message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                            }
                            retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                            /**
                             * only if can do action ok then check with actions matrix that status is valid for this
                             * action
                             */
                            if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                                retValue = false;
                            }
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    Guid storageDomainId = vmImages.get(0).getstorage_id().getValue();
                    // if VM is not HA VM
                    if (!ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                        retValue = false;
                    } else // Check if iso and floppy path exists
                    if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId()).size() > 0) {
            VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
            if (createSnapshotParameters != null) {
                createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
            }
            Backend.getInstance().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
            getParameters().setShouldBeLogged(false);
            getParameters().setRunAsStateless(false);
            getParameters().setIsInternal(true);
            setSucceeded(Backend.getInstance().runInternalAction(VdcActionType.RunVm, getParameters()).getSucceeded());
            if (!getSucceeded()) {
                // could not run the vm don't try to run the end action
                // again
                log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // the stateless-snapshot no longer exists (probably due to
        // ProcessVmPoolOnStopVm
        // treatment) -> no point in running the VM or retrying to
        // EndAction:
        {
            getReturnValue().setEndActionTryAgain(false);
        }
    } else /**
     * Hibernation (VMStatus.Suspended) treatment:
     */
    {
        super.EndSuccessfully();
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        Backend.getInstance().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        getParameters().setIsInternal(true);
        setSucceeded(Backend.getInstance().runInternalAction(VdcActionType.RunVm, getParameters()).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else /**
     * Hibernation (VMStatus.Suspended) treatment:
     */
    {
        super.EndSuccessfully();
    }
}
#end_block

#method_before
public static Guid findActiveISODomain(Guid storagePoolId) {
    Guid isoGuid = null;
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(storagePoolId);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == StorageDomainType.ISO) {
            storage_domains sd = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domain.getid(), storagePoolId);
            if (sd != null && sd.getstatus() == StorageDomainStatus.Active) {
                isoGuid = sd.getid();
                break;
            }
        }
    }
    return isoGuid;
}
#method_after
public static Guid findActiveISODomain(Guid storagePoolId) {
    Guid isoGuid = null;
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(storagePoolId);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == StorageDomainType.ISO) {
            storage_domains sd = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domain.getId(), storagePoolId);
            if (sd != null && sd.getstatus() == StorageDomainStatus.Active) {
                isoGuid = sd.getId();
                break;
            }
        }
    }
    return isoGuid;
}
#end_block

#method_before
@Override
protected VdsGroupDAO getVdsGroupDAO() {
    VdsGroupDAO d = mock(VdsGroupDAO.class);
    List<VDSGroup> list = new ArrayList<VDSGroup>();
    VDSGroup g = new VDSGroup();
    g.setID(getParameters().getVdsGroupId());
    Version v = new Version("2.2");
    g.setcompatibility_version(v);
    list.add(g);
    when(d.getAllForStoragePool(any(Guid.class))).thenReturn(list);
    when(d.get(any(Guid.class))).thenReturn(g);
    return d;
}
#method_after
@Override
protected VdsGroupDAO getVdsGroupDAO() {
    VdsGroupDAO d = mock(VdsGroupDAO.class);
    List<VDSGroup> list = new ArrayList<VDSGroup>();
    VDSGroup g = new VDSGroup();
    g.setId(getParameters().getVdsGroupId());
    Version v = new Version("2.2");
    g.setcompatibility_version(v);
    list.add(g);
    when(d.getAllForStoragePool(any(Guid.class))).thenReturn(list);
    when(d.get(any(Guid.class))).thenReturn(g);
    return d;
}
#end_block

#method_before
private boolean CanFindVdsToRun(java.util.ArrayList<String> messages, boolean isMigrate, Iterable<VDS> vdss) {
    VdcBllMessages message = VdcBllMessages.Unassigned;
    VdcBllMessages messageToReturn = VdcBllMessages.Unassigned;
    /**
     * save vdsVersion in order to know vds version that was wrong
     */
    VdsVersion vdsVersion = null;
    boolean noVDSs = true;
    for (VDS curVds : vdss) {
        if (isMigrate && getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getvds_id())) {
            continue;
        }
        noVDSs = false;
        RefObject<VdcBllMessages> tempRefObject = new RefObject<VdcBllMessages>(message);
        boolean tempVar = isReadyToRun(curVds, tempRefObject);
        message = tempRefObject.argvalue;
        if (tempVar) {
            return true;
        } else {
            if (// messageToReturn
            messageToReturn.getValue() < message.getValue()) // <
            // message)
            {
                messageToReturn = message;
                /**
                 * save version of current vds for later use
                 */
                vdsVersion = curVds.getVersion();
            }
        }
    }
    if (noVDSs) {
        if (messages != null) {
            messageToReturn = VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_AVAILABLE_IN_CLUSTER;
        }
    }
    if (messages != null) {
        messages.add(messageToReturn.toString());
        /**
         * if error due to versions, add versions information to can do
         * action message
         */
        if (messageToReturn == VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_VERSION && vdsVersion != null) {
            VmHandler.UpdateVmGuestAgentVersion(getVm());
            messages.add("$toolsVersion " + getVm().getPartialVersion());
            messages.add("$serverVersion " + vdsVersion.getPartialVersion());
        }
    }
    return false;
}
#method_after
private boolean CanFindVdsToRun(java.util.ArrayList<String> messages, boolean isMigrate, Iterable<VDS> vdss) {
    VdcBllMessages message = VdcBllMessages.Unassigned;
    VdcBllMessages messageToReturn = VdcBllMessages.Unassigned;
    /**
     * save vdsVersion in order to know vds version that was wrong
     */
    VdsVersion vdsVersion = null;
    boolean noVDSs = true;
    for (VDS curVds : vdss) {
        if (isMigrate && getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getId())) {
            continue;
        }
        noVDSs = false;
        RefObject<VdcBllMessages> tempRefObject = new RefObject<VdcBllMessages>(message);
        boolean tempVar = isReadyToRun(curVds, tempRefObject);
        message = tempRefObject.argvalue;
        if (tempVar) {
            return true;
        } else {
            if (// messageToReturn
            messageToReturn.getValue() < message.getValue()) // <
            // message)
            {
                messageToReturn = message;
                /**
                 * save version of current vds for later use
                 */
                vdsVersion = curVds.getVersion();
            }
        }
    }
    if (noVDSs) {
        if (messages != null) {
            messageToReturn = VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_AVAILABLE_IN_CLUSTER;
        }
    }
    if (messages != null) {
        messages.add(messageToReturn.toString());
        /**
         * if error due to versions, add versions information to can do
         * action message
         */
        if (messageToReturn == VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_VERSION && vdsVersion != null) {
            VmHandler.UpdateVmGuestAgentVersion(getVm());
            messages.add("$toolsVersion " + getVm().getPartialVersion());
            messages.add("$serverVersion " + vdsVersion.getPartialVersion());
        }
    }
    return false;
}
#end_block

#method_before
private boolean isReadyToRun(VDS vds, RefObject<VdcBllMessages> message) {
    boolean returnValue = true;
    if ((!vds.getvds_group_id().equals(getVm().getvds_group_id())) || (vds.getstatus() != VDSStatus.Up) || isVdsFailedToRunVm(vds.getvds_id())) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CLUSTER;
    } else // If Vm in Paused mode - no additional memory allocation needed
    if (getVm().getstatus() != VMStatus.Paused && !RunVmCommandBase.hasMemoryToRunVM(vds, getVm())) {
        // not enough memory
        // In case we are using this function in migration we make sure we
        // don't allocate the same VDS
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_MEMORY;
    } else // if vm has more vCpus then vds physical cpus - dont allow to run
    if (vds.getcpu_cores() != null && getVm().getnum_of_cpus() > vds.getcpu_cores()) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CPUS;
    } else // }
    if (!IsVMSwapValueLegal(vds)) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_SWAP;
    }
    return returnValue;
}
#method_after
private boolean isReadyToRun(VDS vds, RefObject<VdcBllMessages> message) {
    boolean returnValue = true;
    if ((!vds.getvds_group_id().equals(getVm().getvds_group_id())) || (vds.getstatus() != VDSStatus.Up) || isVdsFailedToRunVm(vds.getId())) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CLUSTER;
    } else // If Vm in Paused mode - no additional memory allocation needed
    if (getVm().getstatus() != VMStatus.Paused && !RunVmCommandBase.hasMemoryToRunVM(vds, getVm())) {
        // not enough memory
        // In case we are using this function in migration we make sure we
        // don't allocate the same VDS
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_MEMORY;
    } else // if vm has more vCpus then vds physical cpus - dont allow to run
    if (vds.getcpu_cores() != null && getVm().getnum_of_cpus() > vds.getcpu_cores()) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CPUS;
    } else // }
    if (!IsVMSwapValueLegal(vds)) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_SWAP;
    }
    return returnValue;
}
#end_block

#method_before
private Guid getVdsToRunOn(Iterable<VDS> vdss) {
    java.util.ArrayList<VDS> readyToRun = new java.util.ArrayList<VDS>();
    for (VDS curVds : vdss) {
        // vds must be in the correct group
        if (!curVds.getvds_group_id().equals(getVm().getvds_group_id()))
            continue;
        // vds must be up to run a vm
        if (curVds.getstatus() != VDSStatus.Up)
            continue;
        // apply limit on vds memory over commit.
        if (!RunVmCommandBase.hasMemoryToRunVM(curVds, getVm()))
            continue;
        // don't allocate the same VDS
        if ((getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getvds_id())) || isVdsFailedToRunVm(curVds.getvds_id()) || // RunVmCommandBase.isVdsVersionOld(curVds, getVm()) ||
        !RunVmCommandBase.hasCapacityToRunVM(curVds))
            continue;
        // vds must have at least cores as the vm
        if (curVds.getcpu_cores() != null && getVm().getnum_of_cpus() > curVds.getcpu_cores()) {
            continue;
        }
        if (!IsVMSwapValueLegal(curVds))
            continue;
        readyToRun.add(curVds);
    }
    return readyToRun.isEmpty() ? Guid.Empty : getBestVdsToRun(readyToRun);
}
#method_after
private Guid getVdsToRunOn(Iterable<VDS> vdss) {
    java.util.ArrayList<VDS> readyToRun = new java.util.ArrayList<VDS>();
    for (VDS curVds : vdss) {
        // vds must be in the correct group
        if (!curVds.getvds_group_id().equals(getVm().getvds_group_id()))
            continue;
        // vds must be up to run a vm
        if (curVds.getstatus() != VDSStatus.Up)
            continue;
        // apply limit on vds memory over commit.
        if (!RunVmCommandBase.hasMemoryToRunVM(curVds, getVm()))
            continue;
        // don't allocate the same VDS
        if ((getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getId())) || isVdsFailedToRunVm(curVds.getId()) || // RunVmCommandBase.isVdsVersionOld(curVds, getVm()) ||
        !RunVmCommandBase.hasCapacityToRunVM(curVds))
            continue;
        // vds must have at least cores as the vm
        if (curVds.getcpu_cores() != null && getVm().getnum_of_cpus() > curVds.getcpu_cores()) {
            continue;
        }
        if (!IsVMSwapValueLegal(curVds))
            continue;
        readyToRun.add(curVds);
    }
    return readyToRun.isEmpty() ? Guid.Empty : getBestVdsToRun(readyToRun);
}
#end_block

#method_before
private Guid getBestVdsToRun(java.util.ArrayList<VDS> list) {
    VdsComparer comparer = VdsComparer.CreateComparer(list.get(0).getselection_algorithm());
    VDS bestVDS = list.get(0);
    for (int i = 1; i < list.size(); i++) {
        VDS curVds = list.get(i);
        if (comparer.IsBetter(bestVDS, curVds, getVm())) // if (((bestVDS.physical_mem_mb - bestVDS.mem_commited) <
        // (curVds.physical_mem_mb - curVds.mem_commited)))
        {
            bestVDS = curVds;
        }
    }
    /**
     * add chosen vds to running vdss list.
     */
    comparer.BestVdsProcedure(bestVDS);
    getRunVdssList().add(bestVDS.getvds_id());
    return bestVDS.getvds_id();
}
#method_after
private Guid getBestVdsToRun(java.util.ArrayList<VDS> list) {
    VdsComparer comparer = VdsComparer.CreateComparer(list.get(0).getselection_algorithm());
    VDS bestVDS = list.get(0);
    for (int i = 1; i < list.size(); i++) {
        VDS curVds = list.get(i);
        if (comparer.IsBetter(bestVDS, curVds, getVm())) // if (((bestVDS.physical_mem_mb - bestVDS.mem_commited) <
        // (curVds.physical_mem_mb - curVds.mem_commited)))
        {
            bestVDS = curVds;
        }
    }
    /**
     * add chosen vds to running vdss list.
     */
    comparer.BestVdsProcedure(bestVDS);
    getRunVdssList().add(bestVDS.getId());
    return bestVDS.getId();
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, getNow(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    DbFacade.getInstance().getVmTemplateDAO().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    DbFacade.getInstance().getVmTemplateDAO().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams);
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(executionContext));
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
private void createVm() {
    VmStatic vm = new VmStatic();
    Date now = new Date(System.currentTimeMillis());
    vm.setvds_group_id(cluster.getID());
    vm.setId(new Guid(""));
    vm.setmem_size_mb(256);
    vm.setvm_type(VmType.Desktop);
    vm.setvmt_guid(Guid.Empty);
    vm.setdedicated_vm_for_vds(null);
    vm.setvm_type(VmType.Desktop);
    vm.setos(VmOsType.RHEL5);
    vm.setvm_name("vm" + testSequence);
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm.setcreation_date(now);
    ArrayList<DiskImageBase> diskInfoList = new ArrayList<DiskImageBase>();
    VmManagementParametersBase addVmFromScratchParams = new AddVmFromScratchParameters(vm, diskInfoList, getStorage().getid());
    // 
    // diskInfoList.add(disk);
    addVmFromScratchParams.setDontCheckTemplateImages(true);
    VdcReturnValueBase addVmAction = backend.runInternalAction(VdcActionType.AddVmFromScratch, addVmFromScratchParams);
    Assert.assertTrue(addVmAction.getSucceeded());
    this.vm = DB_FACADE.getVmDAO().get(vm.getId());
    Assert.assertNotNull(this.vm);
    createVmDiskImage(vm, now);
}
#method_after
private void createVm() {
    VmStatic vm = new VmStatic();
    Date now = new Date(System.currentTimeMillis());
    vm.setvds_group_id(cluster.getId());
    vm.setId(new Guid(""));
    vm.setmem_size_mb(256);
    vm.setvm_type(VmType.Desktop);
    vm.setvmt_guid(Guid.Empty);
    vm.setdedicated_vm_for_vds(null);
    vm.setvm_type(VmType.Desktop);
    vm.setos(VmOsType.RHEL5);
    vm.setvm_name("vm" + testSequence);
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm.setcreation_date(now);
    ArrayList<DiskImageBase> diskInfoList = new ArrayList<DiskImageBase>();
    VmManagementParametersBase addVmFromScratchParams = new AddVmFromScratchParameters(vm, diskInfoList, getStorage().getId());
    // 
    // diskInfoList.add(disk);
    addVmFromScratchParams.setDontCheckTemplateImages(true);
    VdcReturnValueBase addVmAction = backend.runInternalAction(VdcActionType.AddVmFromScratch, addVmFromScratchParams);
    Assert.assertTrue(addVmAction.getSucceeded());
    this.vm = DB_FACADE.getVmDAO().get(vm.getId());
    Assert.assertNotNull(this.vm);
    createVmDiskImage(vm, now);
}
#end_block

#method_before
private void createVmDiskImage(VmStatic vm, Date now) {
    Guid vmId = vm.getId();
    Guid ImageId = Guid.NewGuid();
    DiskImageBase disk = new DiskImage(false, now, now, 100, Long.toString(AbstractBackendTest.testSequenceNumber), ImageId, "", Guid.NewGuid(), 100, vmId, vmId, ImageStatus.OK, now, "");
    disk.setvolume_type(VolumeType.Sparse);
    disk.setvolume_format(VolumeFormat.COW);
    disk.setdisk_type(DiskType.Data);
    disk.setsize(100);
    disk.setinternal_drive_mapping(Long.toString(AbstractBackendTest.testSequenceNumber));
    disk.setdisk_interface(DiskInterface.IDE);
    disk.setboot(false);
    disk.setwipe_after_delete(false);
    disk.setpropagate_errors(PropagateErrors.Off);
    DiskImage image = new DiskImage(disk);
    image.setId(ImageId);
    image.setimageStatus(ImageStatus.OK);
    image.setvm_guid(vmId);
    image.setcreation_date(now);
    AddImageFromScratchParameters addImageParams = new AddImageFromScratchParameters(ImageId, vmId, disk);
    addImageParams.setStorageDomainId(storage.getid());
    addImageParams.setVmSnapshotId(Guid.NewGuid());
    addImageParams.setParentCommand(VdcActionType.AddDiskToVm);
    addImageParams.setEntityId(ImageId);
    addImageParams.setDestinationImageId(ImageId);
    AddImageFromScratchParameters parameters = addImageParams;
    VdcReturnValueBase addImageAction = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters);
    Assert.assertTrue(addImageAction.getSucceeded());
}
#method_after
private void createVmDiskImage(VmStatic vm, Date now) {
    Guid vmId = vm.getId();
    Guid ImageId = Guid.NewGuid();
    DiskImageBase disk = new DiskImage(false, now, now, 100, Long.toString(AbstractBackendTest.testSequenceNumber), ImageId, "", Guid.NewGuid(), 100, vmId, vmId, ImageStatus.OK, now, "");
    disk.setvolume_type(VolumeType.Sparse);
    disk.setvolume_format(VolumeFormat.COW);
    disk.setdisk_type(DiskType.Data);
    disk.setsize(100);
    disk.setinternal_drive_mapping(Long.toString(AbstractBackendTest.testSequenceNumber));
    disk.setdisk_interface(DiskInterface.IDE);
    disk.setboot(false);
    disk.setwipe_after_delete(false);
    disk.setpropagate_errors(PropagateErrors.Off);
    DiskImage image = new DiskImage(disk);
    image.setId(ImageId);
    image.setimageStatus(ImageStatus.OK);
    image.setvm_guid(vmId);
    image.setcreation_date(now);
    AddImageFromScratchParameters addImageParams = new AddImageFromScratchParameters(ImageId, vmId, disk);
    addImageParams.setStorageDomainId(storage.getId());
    addImageParams.setVmSnapshotId(Guid.NewGuid());
    addImageParams.setParentCommand(VdcActionType.AddDiskToVm);
    addImageParams.setEntityId(ImageId);
    addImageParams.setDestinationImageId(ImageId);
    AddImageFromScratchParameters parameters = addImageParams;
    VdcReturnValueBase addImageAction = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters);
    Assert.assertTrue(addImageAction.getSucceeded());
}
#end_block

#method_before
private void createStorage() {
    storage_server_connections connection = new storage_server_connections();
    connection.setconnection("1.1.1.1/common");
    connection.setstorage_type(StorageType.NFS);
    StorageServerConnectionParametersBase addStorgeConnectionParams = new StorageServerConnectionParametersBase(connection, host.getvds_id());
    addStorgeConnectionParams.setStoragePoolId(dataCenter.getId());
    VdcReturnValueBase runInternalAction = backend.runInternalAction(VdcActionType.AddStorageServerConnection, addStorgeConnectionParams);
    Assert.assertTrue(runInternalAction.getSucceeded());
    storage_domain_static storageDomainStatic = new storage_domain_static();
    storageDomainStatic.setConnection(connection);
    storageDomainStatic.setstorage_domain_type(StorageDomainType.Data);
    storageDomainStatic.setstorage_type(StorageType.NFS);
    storageDomainStatic.setstorage_name(testSequence + "storage");
    storageDomainStatic.setstorage_pool_name(dataCenter.getname());
    Guid storageDomainId = Guid.NewGuid();
    storageDomainStatic.setId(storageDomainId);
    storage_domains storageDomain = new storage_domains(storageDomainId, connection.getconnection(), "storage" + testSequence, dataCenter.getId(), 2, 1, StorageDomainStatus.Active, dataCenter.getname(), dataCenter.getstorage_pool_type().getValue(), StorageType.NFS.getValue());
    storageDomain.setstatus(StorageDomainStatus.Active);
    storageDomain.setstorage_domain_type(StorageDomainType.Data);
    storage_domain_dynamic dynamicStorageDomain = new storage_domain_dynamic(null, storageDomainId, null);
    dynamicStorageDomain.setavailable_disk_size(50000);
    dynamicStorageDomain.setused_disk_size(10);
    storageDomain.setStorageDynamicData(dynamicStorageDomain);
    DB_FACADE.getStorageDomainStaticDAO().save(storageDomain.getStorageStaticData());
    DB_FACADE.getStorageDomainDynamicDAO().save(dynamicStorageDomain);
    DB_FACADE.getStorageDomainDynamicDAO().update(storageDomain.getStorageDynamicData());
    VdcReturnValueBase attachAction = backend.runInternalAction(VdcActionType.AttachStorageDomainToPool, new StorageDomainPoolParametersBase(storageDomainId, dataCenter.getId()));
    Assert.assertTrue(attachAction.getSucceeded());
    storage_pool_iso_map isoMap = DB_FACADE.getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(storageDomainId, dataCenter.getId()));
    isoMap.setstatus(StorageDomainStatus.Active);
    DB_FACADE.getStoragePoolIsoMapDAO().updateStatus(isoMap.getId(), isoMap.getstatus());
    storage = storageDomain;
}
#method_after
private void createStorage() {
    storage_server_connections connection = new storage_server_connections();
    connection.setconnection("1.1.1.1/common");
    connection.setstorage_type(StorageType.NFS);
    StorageServerConnectionParametersBase addStorgeConnectionParams = new StorageServerConnectionParametersBase(connection, host.getId());
    addStorgeConnectionParams.setStoragePoolId(dataCenter.getId());
    VdcReturnValueBase runInternalAction = backend.runInternalAction(VdcActionType.AddStorageServerConnection, addStorgeConnectionParams);
    Assert.assertTrue(runInternalAction.getSucceeded());
    storage_domain_static storageDomainStatic = new storage_domain_static();
    storageDomainStatic.setConnection(connection);
    storageDomainStatic.setstorage_domain_type(StorageDomainType.Data);
    storageDomainStatic.setstorage_type(StorageType.NFS);
    storageDomainStatic.setstorage_name(testSequence + "storage");
    storageDomainStatic.setstorage_pool_name(dataCenter.getname());
    Guid storageDomainId = Guid.NewGuid();
    storageDomainStatic.setId(storageDomainId);
    storage_domains storageDomain = new storage_domains(storageDomainId, connection.getconnection(), "storage" + testSequence, dataCenter.getId(), 2, 1, StorageDomainStatus.Active, dataCenter.getname(), dataCenter.getstorage_pool_type().getValue(), StorageType.NFS.getValue());
    storageDomain.setstatus(StorageDomainStatus.Active);
    storageDomain.setstorage_domain_type(StorageDomainType.Data);
    storage_domain_dynamic dynamicStorageDomain = new storage_domain_dynamic(null, storageDomainId, null);
    dynamicStorageDomain.setavailable_disk_size(50000);
    dynamicStorageDomain.setused_disk_size(10);
    storageDomain.setStorageDynamicData(dynamicStorageDomain);
    DB_FACADE.getStorageDomainStaticDAO().save(storageDomain.getStorageStaticData());
    DB_FACADE.getStorageDomainDynamicDAO().save(dynamicStorageDomain);
    DB_FACADE.getStorageDomainDynamicDAO().update(storageDomain.getStorageDynamicData());
    VdcReturnValueBase attachAction = backend.runInternalAction(VdcActionType.AttachStorageDomainToPool, new StorageDomainPoolParametersBase(storageDomainId, dataCenter.getId()));
    Assert.assertTrue(attachAction.getSucceeded());
    storage_pool_iso_map isoMap = DB_FACADE.getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(storageDomainId, dataCenter.getId()));
    isoMap.setstatus(StorageDomainStatus.Active);
    DB_FACADE.getStoragePoolIsoMapDAO().updateStatus(isoMap.getId(), isoMap.getstatus());
    storage = storageDomain;
}
#end_block

#method_before
private void createHost() {
    Guid hostId = Guid.NewGuid();
    String hostName = "host" + testSequence;
    VdsStatic vdsStatic = new VdsStatic(hostName, "1.1.1.1", hostName, 22, cluster.getID(), hostId, hostName, false, VDSType.VDS);
    AddVdsActionParameters addHostParams = new AddVdsActionParameters(vdsStatic, "root");
    // Hack certificate path check
    Config.getConfigUtils().SetStringValue(ConfigValues.UseSecureConnectionWithServers.toString(), "false");
    Boolean isMLA = Config.<Boolean>GetValue(ConfigValues.IsMultilevelAdministrationOn);
    setIsMultiLevelAdministrationOn(Boolean.FALSE);
    mockVdsInstallerHelper();
    AddVdsCommand<AddVdsActionParameters> addVdsCommand = createAddVdsCommand(addHostParams);
    VdcReturnValueBase addHostAction = addVdsCommand.ExecuteAction();
    setIsMultiLevelAdministrationOn(isMLA);
    Assert.assertTrue(addHostAction.getSucceeded());
    hostId = (Guid) addHostAction.getActionReturnValue();
    host = (VDS) backend.runInternalQuery(VdcQueryType.GetVdsByVdsId, new GetVdsByVdsIdParameters(hostId)).getReturnValue();
    Assert.assertNotNull(host);
    VDS vds = DB_FACADE.getVdsDAO().get(hostId);
    vds.setstatus(VDSStatus.Up);
    DB_FACADE.getVdsDynamicDAO().update(vds.getDynamicData());
}
#method_after
private void createHost() {
    Guid hostId = Guid.NewGuid();
    String hostName = "host" + testSequence;
    VdsStatic vdsStatic = new VdsStatic(hostName, "1.1.1.1", hostName, 22, cluster.getId(), hostId, hostName, false, VDSType.VDS);
    AddVdsActionParameters addHostParams = new AddVdsActionParameters(vdsStatic, "root");
    // Hack certificate path check
    Config.getConfigUtils().SetStringValue(ConfigValues.UseSecureConnectionWithServers.toString(), "false");
    Boolean isMLA = Config.<Boolean>GetValue(ConfigValues.IsMultilevelAdministrationOn);
    setIsMultiLevelAdministrationOn(Boolean.FALSE);
    mockVdsInstallerHelper();
    AddVdsCommand<AddVdsActionParameters> addVdsCommand = createAddVdsCommand(addHostParams);
    VdcReturnValueBase addHostAction = addVdsCommand.ExecuteAction();
    setIsMultiLevelAdministrationOn(isMLA);
    Assert.assertTrue(addHostAction.getSucceeded());
    hostId = (Guid) addHostAction.getActionReturnValue();
    host = (VDS) backend.runInternalQuery(VdcQueryType.GetVdsByVdsId, new GetVdsByVdsIdParameters(hostId)).getReturnValue();
    Assert.assertNotNull(host);
    VDS vds = DB_FACADE.getVdsDAO().get(hostId);
    vds.setstatus(VDSStatus.Up);
    DB_FACADE.getVdsDynamicDAO().update(vds.getDynamicData());
}
#end_block

#method_before
private void removeCluster() {
    // DbFacade.getInstance().RemoveVDSGroups(cluster.getID());
    backend.RunAction(VdcActionType.RemoveVdsGroup, new VdsGroupParametersBase(cluster.getID()));
    System.out.println("-- removed cluster " + cluster.getname() + " -- ");
}
#method_after
private void removeCluster() {
    // DbFacade.getInstance().RemoveVDSGroups(cluster.getID());
    backend.RunAction(VdcActionType.RemoveVdsGroup, new VdsGroupParametersBase(cluster.getId()));
    System.out.println("-- removed cluster " + cluster.getname() + " -- ");
}
#end_block

#method_before
private void removeHost() {
    DB_FACADE.getVdsDynamicDAO().remove(host.getvds_id());
    DB_FACADE.getVdsStatisticsDAO().remove(host.getvds_id());
    DB_FACADE.getVdsStaticDAO().remove(host.getvds_id());
    System.out.println("-- removed Host " + host.gethost_name() + " -- ");
}
#method_after
private void removeHost() {
    DB_FACADE.getVdsDynamicDAO().remove(host.getId());
    DB_FACADE.getVdsStatisticsDAO().remove(host.getId());
    DB_FACADE.getVdsStaticDAO().remove(host.getId());
    System.out.println("-- removed Host " + host.gethost_name() + " -- ");
}
#end_block

#method_before
private void removeStorage() {
    Guid id = storage.getid();
    DB_FACADE.getStorageDomainDynamicDAO().remove(id);
    List<DiskImage> snapshots = DB_FACADE.getDiskImageDAO().getAllSnapshotsForStorageDomain(id);
    for (DiskImage i : snapshots) {
        DB_FACADE.getDiskImageDAO().remove(i.getId());
    }
    DB_FACADE.getStorageDomainStaticDAO().remove(id);
    System.out.println("-- removed storage " + storage.getstorage_name() + " and its snapshots -- ");
}
#method_after
private void removeStorage() {
    Guid id = storage.getId();
    DB_FACADE.getStorageDomainDynamicDAO().remove(id);
    List<DiskImage> snapshots = DB_FACADE.getDiskImageDAO().getAllSnapshotsForStorageDomain(id);
    for (DiskImage i : snapshots) {
        DB_FACADE.getDiskImageDAO().remove(i.getId());
    }
    DB_FACADE.getStorageDomainStaticDAO().remove(id);
    System.out.println("-- removed storage " + storage.getstorage_name() + " and its snapshots -- ");
}
#end_block

#method_before
protected void AddVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setcreation_date(getNow());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.parseProperties(vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    DbFacade.getInstance().getVmStaticDAO().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void AddVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setcreation_date(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.parseProperties(vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    DbFacade.getInstance().getVmStaticDAO().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
private void buildVmDrives() {
    int[] ideIndexSlots = new int[] { 0, 1, 3 };
    int ideCount = 0, pciCount = 0;
    int i = 0;
    if (!StringHelper.isNullOrEmpty(vm.getCdPath())) {
        createInfo.add(VdsProperties.CDRom, vm.getCdPath());
    }
    if (!StringHelper.isNullOrEmpty(vm.getFloppyPath())) {
        createInfo.add(VdsProperties.Floppy, vm.getFloppyPath());
    }
    // order first by drive numbers and then order by boot for the bootable
    // drive to be first (important for IDE to be index 0) !
    List<DiskImage> diskImages = new ArrayList<DiskImage>(vm.getDiskMap().values());
    Collections.sort(diskImages, new DiskImageByDriveMappingComparator());
    Collections.sort(diskImages, Collections.reverseOrder(new DiskImageByBootComparator()));
    List<VmDevice> diskVmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.DISK));
    Set<Guid> pluggedDiskIds = new HashSet<Guid>();
    for (VmDevice diskVmDevice : diskVmDevices) {
        if (diskVmDevice.getIsPlugged()) {
            pluggedDiskIds.add(diskVmDevice.getDeviceId());
        }
    }
    Map[] drives = new Map[pluggedDiskIds.size()];
    for (DiskImage disk : diskImages) {
        if (pluggedDiskIds.contains(disk.getId())) {
            Map drive = new HashMap();
            drive.put("domainID", disk.getstorage_id().toString());
            drive.put("poolID", disk.getstorage_pool_id().toString());
            drive.put("volumeID", disk.getId().toString());
            drive.put("imageID", disk.getimage_group_id().toString());
            drive.put("format", disk.getvolume_format().toString().toLowerCase());
            drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
            switch(disk.getdisk_interface()) {
                case IDE:
                    drive.put("if", "ide");
                    drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                    ideCount++;
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    break;
            }
            drives[i] = drive;
            i++;
        }
    }
    createInfo.add("drives", drives);
}
#method_after
private void buildVmDrives() {
    int[] ideIndexSlots = new int[] { 0, 1, 3 };
    int ideCount = 0, pciCount = 0;
    int i = 0;
    if (!StringHelper.isNullOrEmpty(vm.getCdPath())) {
        createInfo.add(VdsProperties.CDRom, vm.getCdPath());
    }
    if (!StringHelper.isNullOrEmpty(vm.getFloppyPath())) {
        createInfo.add(VdsProperties.Floppy, vm.getFloppyPath());
    }
    // order first by drive numbers and then order by boot for the bootable
    // drive to be first (important for IDE to be index 0) !
    List<DiskImage> diskImages = new ArrayList<DiskImage>(vm.getDiskMap().values());
    Collections.sort(diskImages, new DiskImageByDriveMappingComparator());
    Collections.sort(diskImages, Collections.reverseOrder(new DiskImageByBootComparator()));
    List<VmDevice> diskVmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.DISK));
    Set<Guid> pluggedDiskIds = new HashSet<Guid>();
    for (VmDevice diskVmDevice : diskVmDevices) {
        if (diskVmDevice.getIsPlugged()) {
            pluggedDiskIds.add(diskVmDevice.getDeviceId());
        }
    }
    Map[] drives = new Map[pluggedDiskIds.size()];
    for (DiskImage disk : diskImages) {
        if (pluggedDiskIds.contains(disk.getDisk().getId())) {
            Map drive = new HashMap();
            drive.put("domainID", disk.getstorage_id().toString());
            drive.put("poolID", disk.getstorage_pool_id().toString());
            drive.put("volumeID", disk.getId().toString());
            drive.put("imageID", disk.getimage_group_id().toString());
            drive.put("format", disk.getvolume_format().toString().toLowerCase());
            drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
            switch(disk.getdisk_interface()) {
                case IDE:
                    drive.put("if", "ide");
                    drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                    ideCount++;
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    break;
            }
            drives[i] = drive;
            i++;
        }
    }
    createInfo.add("drives", drives);
}
#end_block

#method_before
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.deleteImage, p, false);
    return taskID;
}
#method_after
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters(), asyncTaskCreationInfo.getStepId()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.deleteImage, p, false);
    return taskID;
}
#end_block

#method_before
private void OnSave() {
    VM vm = (VM) getEntity();
    DiskModel model = (DiskModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.Validate()) {
        return;
    }
    // Save changes.
    storage_domains storageDomain = (storage_domains) model.getStorageDomain().getSelectedItem();
    DiskImage disk = model.getIsNew() ? new DiskImage() : (DiskImage) getSelectedItem();
    disk.setSizeInGigabytes(Integer.parseInt(model.getSize().getEntity().toString()));
    DiskImageBase preset = (DiskImageBase) model.getPreset().getSelectedItem();
    disk.setdisk_type(preset.getdisk_type());
    disk.setdisk_interface((DiskInterface) model.getInterface().getSelectedItem());
    disk.setvolume_type((VolumeType) model.getVolumeType().getSelectedItem());
    disk.setvolume_format(model.getVolumeFormat());
    disk.setwipe_after_delete((Boolean) model.getWipeAfterDelete().getEntity());
    disk.setboot((Boolean) model.getIsBootable().getEntity());
    // NOTE: Since we doesn't support partial snapshots in GUI, propagate errors flag always must be set false.
    // disk.propagate_errors = model.PropagateErrors.ValueAsBoolean() ? PropagateErrors.On : PropagateErrors.Off;
    disk.setpropagate_errors(PropagateErrors.Off);
    model.StartProgress(null);
    if (model.getIsNew()) {
        AddDiskToVmParameters tempVar = new AddDiskToVmParameters(vm.getId(), disk);
        tempVar.setStorageDomainId(storageDomain.getid());
        Frontend.RunAction(VdcActionType.AddDiskToVm, tempVar, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmDiskListModel localModel = (VmDiskListModel) result.getState();
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        Frontend.RunAction(VdcActionType.UpdateVmDisk, new UpdateVmDiskParameters(vm.getId(), disk.getId(), disk), new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmDiskListModel localModel = (VmDiskListModel) result.getState();
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }, this);
    }
}
#method_after
private void OnSave() {
    VM vm = (VM) getEntity();
    DiskModel model = (DiskModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.Validate()) {
        return;
    }
    // Save changes.
    storage_domains storageDomain = (storage_domains) model.getStorageDomain().getSelectedItem();
    DiskImage disk = model.getIsNew() ? new DiskImage() : (DiskImage) getSelectedItem();
    disk.setSizeInGigabytes(Integer.parseInt(model.getSize().getEntity().toString()));
    DiskImageBase preset = (DiskImageBase) model.getPreset().getSelectedItem();
    disk.setdisk_type(preset.getdisk_type());
    disk.setdisk_interface((DiskInterface) model.getInterface().getSelectedItem());
    disk.setvolume_type((VolumeType) model.getVolumeType().getSelectedItem());
    disk.setvolume_format(model.getVolumeFormat());
    disk.setwipe_after_delete((Boolean) model.getWipeAfterDelete().getEntity());
    disk.setboot((Boolean) model.getIsBootable().getEntity());
    disk.setPlugged((Boolean) model.getIsPlugged().getEntity());
    // NOTE: Since we doesn't support partial snapshots in GUI, propagate errors flag always must be set false.
    // disk.propagate_errors = model.PropagateErrors.ValueAsBoolean() ? PropagateErrors.On : PropagateErrors.Off;
    disk.setpropagate_errors(PropagateErrors.Off);
    model.StartProgress(null);
    if (model.getIsNew()) {
        AddDiskToVmParameters tempVar = new AddDiskToVmParameters(vm.getId(), disk);
        tempVar.setStorageDomainId(storageDomain.getid());
        Frontend.RunAction(VdcActionType.AddDiskToVm, tempVar, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmDiskListModel localModel = (VmDiskListModel) result.getState();
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        Frontend.RunAction(VdcActionType.UpdateVmDisk, new UpdateVmDiskParameters(vm.getId(), disk.getId(), disk), new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmDiskListModel localModel = (VmDiskListModel) result.getState();
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }, this);
    }
}
#end_block

#method_before
private void UpdateActionAvailability() {
    VM vm = (VM) getEntity();
    boolean isDown = vm != null && vm.getstatus() == VMStatus.Down;
    getNewCommand().setIsExecutionAllowed(isDown);
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1 && isDown);
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0 && isDown);
}
#method_after
private void UpdateActionAvailability() {
    VM vm = (VM) getEntity();
    DiskImage disk = (DiskImage) getSelectedItem();
    getNewCommand().setIsExecutionAllowed(isVmDown());
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1 && isVmDown());
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0 && isVmDown());
    getPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(true));
    getUnPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(false));
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (command == getPlugCommand()) {
        Plug(true);
    } else if (command == getUnPlugCommand()) {
        Plug(false);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllRunningForVds(getVdsId());
    Collections.sort(vms, Collections.reverseOrder(new VmsComparer()));
    java.util.ArrayList<VdcActionParametersBase> runVmParamsList = new java.util.ArrayList<VdcActionParametersBase>();
    for (VM vm : vms) {
        if (vm.getauto_startup()) {
            runVmParamsList.add(new RunVmParams(vm.getId()));
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
        // Write that this VM was shut down by host rebbot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            LogSettingVmToDown(getVds().getvds_id(), vm.getId());
        }
        VmPoolHandler.ProcessVmPoolOnStopVm(vm.getId());
    }
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVdsVMsCleared, new UpdateVdsVMsClearedVDSCommandParameters(getVdsId()));
    if (runVmParamsList.size() > 0) {
        Backend.getInstance().runInternalMultipleActions(VdcActionType.RunVm, runVmParamsList);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllRunningForVds(getVdsId());
    Collections.sort(vms, Collections.reverseOrder(new VmsComparer()));
    java.util.ArrayList<VdcActionParametersBase> runVmParamsList = new java.util.ArrayList<VdcActionParametersBase>();
    for (VM vm : vms) {
        if (vm.getauto_startup()) {
            runVmParamsList.add(new RunVmParams(vm.getId()));
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
        // Write that this VM was shut down by host rebbot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            LogSettingVmToDown(getVds().getId(), vm.getId());
        }
        VmPoolHandler.ProcessVmPoolOnStopVm(vm.getId(), ExecutionHandler.createDefaultContexForTasks(executionContext));
    }
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVdsVMsCleared, new UpdateVdsVMsClearedVDSCommandParameters(getVdsId()));
    if (runVmParamsList.size() > 0) {
        Backend.getInstance().runInternalMultipleActions(VdcActionType.RunVm, runVmParamsList);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void testIsFiltered() {
    assertFalse("By default, query should not be run as user", base.isFiltered());
    base.setIsFiltered(true);
    assertTrue("Query should have been set to be run as user", base.isFiltered());
    base.setIsFiltered(false);
    assertFalse("Query should have been set to be NOT run as user", base.isFiltered());
}
#method_after
@Test
public void testIsFiltered() {
    assertFalse("By default, query should not be run as user", base.isFiltered());
    base.setFiltered(true);
    assertTrue("Query should have been set to be run as user", base.isFiltered());
    base.setFiltered(false);
    assertFalse("Query should have been set to be NOT run as user", base.isFiltered());
}
#end_block

#method_before
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return _resourceManger;
}
#method_after
@Override
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return _resourceManger;
}
#end_block

#method_before
private void checkDBConnectivity() {
    boolean dbUp = false;
    long expectedTimeout = System.currentTimeMillis() + DbFacade.getInstance().getOnStartConnectionTimeout();
    long waitBetweenInterval = DbFacade.getInstance().getConnectionCheckInterval();
    while (!dbUp && System.currentTimeMillis() < expectedTimeout) {
        try {
            dbUp = DbFacade.getInstance().CheckDBConnection();
            try {
                Thread.sleep(waitBetweenInterval);
            } catch (InterruptedException e) {
                log.warn("Failed to wait between connection polling attempts. " + "Original exception is: " + ExceptionUtils.getMessage(e));
            }
        } catch (RuntimeException ex) {
            log.error("Error in getting DB connection. The database is inaccessible. " + "Original exception is: " + ExceptionUtils.getMessage(ex));
        }
    }
    if (!dbUp) {
        throw new IllegalStateException("Could not obtain connection to the database." + " Please make sure that DB is up and accepting connections, and " + "restart the application.");
    }
}
#method_after
private static void checkDBConnectivity() {
    boolean dbUp = false;
    long expectedTimeout = System.currentTimeMillis() + DbFacade.getInstance().getOnStartConnectionTimeout();
    long waitBetweenInterval = DbFacade.getInstance().getConnectionCheckInterval();
    while (!dbUp && System.currentTimeMillis() < expectedTimeout) {
        try {
            dbUp = DbFacade.getInstance().CheckDBConnection();
            try {
                Thread.sleep(waitBetweenInterval);
            } catch (InterruptedException e) {
                log.warn("Failed to wait between connection polling attempts. " + "Original exception is: " + ExceptionUtils.getMessage(e));
            }
        } catch (RuntimeException ex) {
            log.error("Error in getting DB connection. The database is inaccessible. " + "Original exception is: " + ExceptionUtils.getMessage(ex));
        }
    }
    if (!dbUp) {
        throw new IllegalStateException("Could not obtain connection to the database." + " Please make sure that DB is up and accepting connections, and " + "restart the application.");
    }
}
#end_block

#method_before
public DateTime getStartedAt() {
    return _startedAt;
}
#method_after
@Override
public DateTime getStartedAt() {
    return _startedAt;
}
#end_block

#method_before
public void Initialize() {
    log.infoFormat("Start time: {0}", new java.util.Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new java.util.Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new java.util.Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new java.util.Date());
    TagsDirector.getInstance();
    log.infoFormat("TagsDirector: {0}", new java.util.Date());
    ImagesSyncronizer.getInstance();
    log.infoFormat("ImagesSyncronizer: {0}", new java.util.Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new java.util.Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new java.util.Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new java.util.Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new java.util.Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#method_after
@Override
public void Initialize() {
    log.infoFormat("Start time: {0}", new Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new Date());
    TagsDirector.getInstance();
    log.infoFormat("TagsDirector: {0}", new Date());
    ImagesSyncronizer.getInstance();
    log.infoFormat("ImagesSyncronizer: {0}", new Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#end_block

#method_before
private void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = DbFacade.getInstance().getBusinessEntitySnapshotDAO().getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        CommandBase<?> cmd = CommandsFactory.CreateCommand(commandSnapshot.getValue().toString(), (Guid) commandSnapshot.getKey());
        if (cmd != null) {
            cmd.compensate();
            log.infoFormat("Running compensation on startup for Command : {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        } else {
            log.errorFormat("Failed to run compensation on startup for Command {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        }
    }
}
#method_after
private static void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = DbFacade.getInstance().getBusinessEntitySnapshotDAO().getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        CommandBase<?> cmd = CommandsFactory.CreateCommand(commandSnapshot.getValue().toString(), (Guid) commandSnapshot.getKey());
        if (cmd != null) {
            cmd.compensate();
            log.infoFormat("Running compensation on startup for Command : {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        } else {
            log.errorFormat("Failed to run compensation on startup for Command {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        }
    }
}
#end_block

#method_before
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#end_block

#method_before
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CompensationContext context) {
    switch(actionType) {
        case AutoLogin:
            VdcReturnValueBase returnValue = new VdcReturnValueBase();
            returnValue.setCanDoAction(false);
            returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
            return returnValue;
        default:
            {
                CommandBase command = CommandsFactory.CreateCommand(actionType, parameters);
                command.setInternalExecution(runAsInternal);
                if (context != null) {
                    command.setCompensationContext(context);
                }
                return command.ExecuteAction();
            }
    }
}
#method_after
private static VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CompensationContext context) {
    switch(actionType) {
        case AutoLogin:
            VdcReturnValueBase returnValue = new VdcReturnValueBase();
            returnValue.setCanDoAction(false);
            returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
            return returnValue;
        default:
            {
                CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
                command.setInternalExecution(runAsInternal);
                if (context != null) {
                    command.setCompensationContext(context);
                }
                return command.ExecuteAction();
            }
    }
}
#end_block

#method_before
public VdcReturnValueBase EndAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#method_after
@Override
public VdcReturnValueBase EndAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#end_block

#method_before
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#end_block

#method_before
public VdcQueryReturnValue RunQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#method_after
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#end_block

#method_before
private VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringHelper.isNullOrEmpty(sessionId) || SessionDataContainer.getInstance().GetData(sessionId, "VdcUser", parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
    return command.getQueryReturnValue();
}
#method_after
private static VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringHelper.isNullOrEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
public void RunAsyncQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    addSessionToContext(parameters);
    QueriesCommandBase command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
}
#method_after
@Override
public void RunAsyncQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    addSessionToContext(parameters);
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
}
#end_block

#method_before
private String addSessionToContext(VdcQueryParametersBase parameters) {
    String sessionId = parameters.getHttpSessionId();
    boolean isAddToContext = true;
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = parameters.getSessionId();
    }
    // request
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = ThreadLocalParamsContainer.getHttpSessionId();
        isAddToContext = false;
    }
    if (!StringHelper.isNullOrEmpty(sessionId) && isAddToContext) {
        ThreadLocalParamsContainer.setHttpSessionId(sessionId);
    }
    return sessionId;
}
#method_after
private static String addSessionToContext(VdcQueryParametersBase parameters) {
    String sessionId = parameters.getHttpSessionId();
    boolean isAddToContext = true;
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = parameters.getSessionId();
    }
    // request
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = ThreadLocalParamsContainer.getHttpSessionId();
        isAddToContext = false;
    }
    if (!StringHelper.isNullOrEmpty(sessionId) && isAddToContext) {
        ThreadLocalParamsContainer.setHttpSessionId(sessionId);
    }
    return sessionId;
}
#end_block

#method_before
@Override
public java.util.ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, false);
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, false);
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public java.util.ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true);
}
#method_after
@Override
@ExcludeClassInterceptors
public ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true);
}
#end_block

#method_before
public java.util.ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters, boolean isInternal) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringHelper.isNullOrEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringHelper.isNullOrEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.CreateMultipleActionsRunner(actionType, parameters, isInternal);
    return runner.Execute();
}
#method_after
public ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringHelper.isNullOrEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringHelper.isNullOrEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.CreateMultipleActionsRunner(actionType, parameters, isInternal);
    return runner.Execute();
}
#end_block

#method_before
@ExcludeClassInterceptors
public ErrorTranslator getErrorsTranslator() {
    return errorsTranslator;
}
#method_after
@Override
@ExcludeClassInterceptors
public ErrorTranslator getErrorsTranslator() {
    return errorsTranslator;
}
#end_block

#method_before
@ExcludeClassInterceptors
public ErrorTranslator getVdsErrorsTranslator() {
    return _vdsErrorsTranslator;
}
#method_after
@Override
@ExcludeClassInterceptors
public ErrorTranslator getVdsErrorsTranslator() {
    return _vdsErrorsTranslator;
}
#end_block

#method_before
public VdcReturnValueBase Login(LoginUserParameters parameters) {
    switch(parameters.getActionType()) {
        case AutoLogin:
        case LoginAdminUser:
            {
                CommandBase command = CommandsFactory.CreateCommand(parameters.getActionType(), parameters);
                return command.ExecuteAction();
            }
        default:
            {
                return NotAutorizedError();
            }
    }
}
#method_after
@Override
public VdcReturnValueBase Login(LoginUserParameters parameters) {
    switch(parameters.getActionType()) {
        case AutoLogin:
        case LoginAdminUser:
            {
                CommandBase<?> command = CommandsFactory.CreateCommand(parameters.getActionType(), parameters);
                return command.ExecuteAction();
            }
        default:
            {
                return NotAutorizedError();
            }
    }
}
#end_block

#method_before
private VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#method_after
private static VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#end_block

#method_before
public VdcReturnValueBase Logoff(LogoutUserParameters parameters) {
    return RunAction(VdcActionType.LogoutUser, parameters);
}
#method_after
@Override
public VdcReturnValueBase Logoff(LogoutUserParameters parameters) {
    return RunAction(VdcActionType.LogoutUser, parameters);
}
#end_block

#method_before
public tags GetTagByTagName(String tagName) {
    throw new NotImplementedException();
}
#method_after
public tags GetTagByTagName(@SuppressWarnings("unused") String tagName) {
    throw new NotImplementedException();
}
#end_block

#method_before
public String GetTagIdsAndChildrenIdsByRegExp(String tagNameRegExp) {
    throw new NotImplementedException();
}
#method_after
public String GetTagIdsAndChildrenIdsByRegExp(@SuppressWarnings("unused") String tagNameRegExp) {
    throw new NotImplementedException();
}
#end_block

#method_before
public String GetTagIdAndChildrenIds(int tagId) {
    throw new NotImplementedException();
}
#method_after
public String GetTagIdAndChildrenIds(@SuppressWarnings("unused") int tagId) {
    throw new NotImplementedException();
}
#end_block

#method_before
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion) {
                    return runQueryImpl(actionType, parameters, false);
                } else {
                    VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                    returnValue.setSucceeded(false);
                    returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                    return returnValue;
                }
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion) {
                    return runQueryImpl(actionType, parameters, false);
                }
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#end_block

#method_before
public VdcReturnValueBase RunUserAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    if (StringHelper.isNullOrEmpty(parameters.getHttpSessionId())) {
        return NotAutorizedError();
    } else {
        return RunAction(actionType, parameters);
    }
}
#method_after
public VdcReturnValueBase RunUserAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    if (StringHelper.isNullOrEmpty(parameters.getHttpSessionId())) {
        return NotAutorizedError();
    }
    return RunAction(actionType, parameters);
}
#end_block

#method_before
public java.util.ArrayList<VdcReturnValueBase> RunUserMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    for (VdcActionParametersBase parameter : parameters) {
        if (StringHelper.isNullOrEmpty(parameter.getHttpSessionId())) {
            java.util.ArrayList<VdcReturnValueBase> returnValues = new java.util.ArrayList<VdcReturnValueBase>();
            for (int i = 0; i < parameters.size(); i++) {
                returnValues.add(NotAutorizedError());
            }
            return returnValues;
        }
    }
    return runInternalMultipleActions(actionType, parameters);
}
#method_after
public ArrayList<VdcReturnValueBase> RunUserMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    for (VdcActionParametersBase parameter : parameters) {
        if (StringHelper.isNullOrEmpty(parameter.getHttpSessionId())) {
            ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
            for (int i = 0; i < parameters.size(); i++) {
                returnValues.add(NotAutorizedError());
            }
            return returnValues;
        }
    }
    return runInternalMultipleActions(actionType, parameters);
}
#end_block

#method_before
public VdcReturnValueBase RunAutoAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return RunAction(actionType, parameters);
}
#method_after
@Override
public VdcReturnValueBase RunAutoAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return RunAction(actionType, parameters);
}
#end_block

#method_before
public VdcQueryReturnValue RunAutoQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runInternalQuery(actionType, parameters);
}
#method_after
@Override
public VdcQueryReturnValue RunAutoQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runInternalQuery(actionType, parameters);
}
#end_block

#method_before
public AsyncQueryResults GetAsyncQueryResults() {
    return BackendCallBacksDirector.getInstance().GetAsyncQueryResults();
}
#method_after
@Override
public AsyncQueryResults GetAsyncQueryResults() {
    return BackendCallBacksDirector.getInstance().GetAsyncQueryResults();
}
#end_block

#method_before
public void initialize(String bundleBaseName) {
    ResourceBundle bundle = ResourceBundle.getBundle(bundleBaseName);
    final int jobMessagePrefixLength = JOB_MESSAGE_PREFIX.length();
    final int stepMessagePrefixLength = STEP_MESSAGE_PREFIX.length();
    for (String key : bundle.keySet()) {
        if (key.startsWith(JOB_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), jobMessages, VdcActionType.class, jobMessagePrefixLength);
        } else if (key.startsWith(STEP_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), stepMessages, StepEnum.class, stepMessagePrefixLength);
        } else {
            log.errorFormat("The message key {0} cannot be categorized since not started with {1} nor {2}", key, JOB_MESSAGE_PREFIX, STEP_MESSAGE_PREFIX);
            throw new IllegalArgumentException("Illegal argument with key " + key);
        }
    }
}
#method_after
public void initialize(String bundleBaseName) {
    ResourceBundle bundle = ResourceBundle.getBundle(bundleBaseName);
    final int jobMessagePrefixLength = JOB_MESSAGE_PREFIX.length();
    final int stepMessagePrefixLength = STEP_MESSAGE_PREFIX.length();
    for (String key : bundle.keySet()) {
        if (key.startsWith(JOB_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), jobMessages, VdcActionType.class, jobMessagePrefixLength);
        } else if (key.startsWith(STEP_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), stepMessages, StepEnum.class, stepMessagePrefixLength);
        } else {
            log.errorFormat("The message key {0} cannot be categorized since not started with {1} nor {2}", key, JOB_MESSAGE_PREFIX, STEP_MESSAGE_PREFIX);
        }
    }
}
#end_block

#method_before
private <T extends Enum<T>> void addMessage(String key, String value, Map<T, String> messagesMap, Class<T> enumClass, int prefixLength) {
    T enumKey = T.valueOf(enumClass, key.substring(prefixLength));
    if (!messagesMap.containsKey(key)) {
        messagesMap.put(enumKey, value);
    } else {
        log.warnFormat("Code {0} appears more then once in {1} table.", key, enumClass.getSimpleName());
    }
}
#method_after
private <T extends Enum<T>> void addMessage(String key, String value, Map<T, String> messagesMap, Class<T> enumClass, int prefixLength) {
    T enumKey = null;
    try {
        enumKey = T.valueOf(enumClass, key.substring(prefixLength));
    } catch (IllegalArgumentException e) {
        log.errorFormat("Message key {0} is not valid for enum {1}", key, enumClass.getSimpleName());
        return;
    }
    if (!messagesMap.containsKey(key)) {
        messagesMap.put(enumKey, value);
    } else {
        log.warnFormat("Code {0} appears more then once in {1} table.", key, enumClass.getSimpleName());
    }
}
#end_block

#method_before
@Test
public void verifyEngineMessagesSupported() throws FileNotFoundException, IOException {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(ExecutionMessageDirector.EXECUTION_MESSAGES_FILE_PATH);
}
#method_after
@Test
public void verifyEngineMessagesSupported() throws FileNotFoundException, IOException {
    ResourceBundle bundle = ResourceBundle.getBundle(EXECUTION_MESSAGES_FILE_PATH);
    String testKey = null;
    Class<?> testEnum = null;
    try {
        for (String key : bundle.keySet()) {
            testKey = key;
            if (key.startsWith(ExecutionMessageDirector.JOB_MESSAGE_PREFIX)) {
                testEnum = VdcActionType.class;
                VdcActionType.valueOf(key.substring(JOB_MESSAGE_PREFIX.length()));
            } else if (key.startsWith(ExecutionMessageDirector.STEP_MESSAGE_PREFIX)) {
                testEnum = StepEnum.class;
                StepEnum.valueOf(key.substring(STEP_MESSAGE_PREFIX.length()));
            }
        }
    } catch (RuntimeException e) {
        fail("Missing entry in enum " + testEnum.getSimpleName() + " for key " + testKey);
    }
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void readMissingMessageKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_KEY_TEST_BUNDLE_NAME);
}
#method_after
@Test
public void readMissingMessageKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_KEY_TEST_BUNDLE_NAME);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void readMissingMessageJobKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_JOB_KEY_TEST_BUNDLE_NAME);
}
#method_after
@Test
public void readMissingMessageJobKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_JOB_KEY_TEST_BUNDLE_NAME);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void readMissingMessageStepKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_STEP_KEY_TEST_BUNDLE_NAME);
}
#method_after
@Test
public void readMissingMessageStepKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_STEP_KEY_TEST_BUNDLE_NAME);
}
#end_block

#method_before
public static Job createJob(VdcActionType actionType, CommandBase<?> command) {
    Job job = new Job();
    job.setId(Guid.NewGuid());
    job.setActionType(actionType);
    job.setCommandId(command.getCommandId());
    job.setJobSubjectEntities(command.getPermissionCheckSubjects());
    job.setCommandId(command.getCommandId());
    job.setOwnerId(command.getUserId());
    job.setStatus(ExecutionStatus.STARTED);
    job.setStartTime(new Date());
    job.setJobRepository(JobRepositoryFactory.getJobRepository());
    // TODO: set actual value of correlation-ID
    job.setCorrelationId(Guid.NewGuid().toString());
    return job;
}
#method_after
public static Job createJob(VdcActionType actionType, CommandBase<?> command) {
    Job job = new Job();
    job.setId(Guid.NewGuid());
    job.setActionType(actionType);
    // TODO: create job description by resource bundle
    job.setDescription(actionType.name());
    job.setJobSubjectEntities(command.getPermissionCheckSubjects());
    job.setOwnerId(command.getUserId());
    job.setStatus(JobExecutionStatus.STARTED);
    job.setStartTime(new Date());
    // TODO: set actual value of correlation-ID
    job.setCorrelationId(Guid.NewGuid().toString());
    return job;
}
#end_block

#method_before
public static void endStep(ExecutionContext context, Step step, boolean exitStatus) {
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (step != null) {
                step.endStep(exitStatus);
            }
            if (exitStatus == false) {
                context.getJob().endJob(false);
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
            if (context.getStep() != null) {
                context.getStep().endStep(false);
            }
        }
    }
}
#method_after
public static void endStep(ExecutionContext context, Step step, boolean exitStatus) {
    if (context.isMonitored()) {
        Job job = context.getJob();
        try {
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                if (exitStatus) {
                    if (step != null) {
                        step.markStepEnded(exitStatus);
                        JobRepositoryFactory.getJobRepository().updateStep(step);
                    }
                } else {
                    // step failure will cause the job to be marked as failed
                    job.markJobEnded(false);
                    JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
                }
            } else {
                Step parentStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && parentStep != null) {
                    if (exitStatus) {
                        if (step != null) {
                            step.markStepEnded(exitStatus);
                            JobRepositoryFactory.getJobRepository().updateStep(step);
                        }
                    }
                }
            }
        } catch (Exception e) {
            log.error(e);
        }
    }
}
#end_block

#method_before
public static void prepareCommandForMonitoring(CommandBase<?> command, VdcActionType actionType, boolean runAsInternal) {
    ExecutionContext context = new ExecutionContext();
    try {
        boolean isMonitored = shouldMonitorCommand(actionType, runAsInternal);
        context.setMonitored(isMonitored);
        // A monitored job is created for monitored external flows
        if (isMonitored) {
            Job job = createJob(actionType, command);
            JobRepositoryFactory.getJobRepository().saveJob(job);
            context.setExecutionMethod(ExecutionMethod.AsJob);
            context.setJob(job);
            command.setExecutionContext(context);
        }
    } catch (Exception e) {
        log.errorFormat("Failed to prepare command of type {0} for monitoring due to error {1}", actionType.name(), ExceptionUtils.getMessage(e), e);
    }
}
#method_after
public static void prepareCommandForMonitoring(CommandBase<?> command, VdcActionType actionType, boolean runAsInternal) {
    ExecutionContext context = command.getExecutionContext();
    if (context == null) {
        context = new ExecutionContext();
    }
    try {
        boolean isMonitored = shouldMonitorCommand(actionType, runAsInternal);
        context.setMonitored(isMonitored);
        // A monitored job is created for monitored external flows
        if (isMonitored) {
            Job job = createJob(actionType, command);
            JobRepositoryFactory.getJobRepository().saveJob(job);
            context.setExecutionMethod(ExecutionMethod.AsJob);
            context.setJob(job);
            command.setExecutionContext(context);
        }
    } catch (Exception e) {
        log.errorFormat("Failed to prepare command of type {0} for monitoring due to error {1}", actionType.name(), ExceptionUtils.getMessage(e), e);
    }
}
#end_block

#method_before
public static Step addStep(ExecutionContext context, StepEnum stepName, String description) {
    Step step = null;
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            step = context.getJob().addStep(stepName, description);
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
        // TODO: Implement adding a step under the step which represent the monitored internal command.
        }
    }
    return step;
}
#method_after
public static Step addStep(ExecutionContext context, StepEnum stepName, String description) {
    Step step = null;
    if (context.isMonitored()) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        try {
            Job job = context.getJob();
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                step = job.addStep(stepName, description);
                try {
                    JobRepositoryFactory.getJobRepository().saveStep(step);
                } catch (Exception e) {
                    log.errorFormat("Failed to save new step {0} for job {1}, {2}.", stepName.name(), job.getId(), job.getActionType().name(), e);
                    job.getSteps().remove(step);
                    step = null;
                }
            } else {
                Step contextStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && contextStep != null) {
                    step = addSubStep(contextStep, stepName, description);
                }
            }
        } catch (Exception e) {
            log.error(e);
        }
    }
    return step;
}
#end_block

#method_before
public static Step addTaskStep(ExecutionContext context, StepEnum stepName, String description) {
    Step step = null;
    if (context != null) {
        Step parentTaskStep = context.getParentTasksStep();
        if (parentTaskStep != null) {
            parentTaskStep.addStep(stepName, description);
        }
    }
    return step;
}
#method_after
public static Step addTaskStep(ExecutionContext context, StepEnum stepName, String description) {
    Step step = null;
    if (context != null && context.isTasksMonitored()) {
        Step parentTaskStep = context.getParentTasksStep();
        if (parentTaskStep != null) {
            step = addSubStep(parentTaskStep, stepName, description);
        }
    }
    return step;
}
#end_block

#method_before
public static Step addSubStep(ExecutionContext context, Step parentStep, StepEnum newStepName, String description) {
    Step step = null;
    if (parentStep == null) {
        return null;
    }
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (DbFacade.getInstance().getStepDao().exists(parentStep.getId())) {
                if (parentStep.getJobId().equals(context.getJob().getId())) {
                    step = parentStep.addStep(newStepName, description);
                }
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
        // TODO: Implement adding a step under the step which represent the monitored internal command.
        }
    }
    return step;
}
#method_after
private static Step addSubStep(Step parentStep, StepEnum stepName, String description) {
    Step step = null;
    if (parentStep != null) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        step = parentStep.addStep(stepName, description);
        try {
            JobRepositoryFactory.getJobRepository().saveStep(step);
        } catch (Exception e) {
            log.errorFormat("Failed to save new step {0} for step {1}, {2}.", stepName.name(), parentStep.getId(), parentStep.getStepType().name(), e);
            parentStep.getSteps().remove(step);
            step = null;
        }
    }
    return step;
}
#end_block

#method_before
public static Step addSubStep(ExecutionContext context, Step parentStep, StepEnum newStepName, String description) {
    Step step = null;
    if (parentStep == null) {
        return null;
    }
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (DbFacade.getInstance().getStepDao().exists(parentStep.getId())) {
                if (parentStep.getJobId().equals(context.getJob().getId())) {
                    step = parentStep.addStep(newStepName, description);
                }
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
        // TODO: Implement adding a step under the step which represent the monitored internal command.
        }
    }
    return step;
}
#method_after
public static Step addSubStep(ExecutionContext context, Step parentStep, StepEnum newStepName, String description) {
    Step step = null;
    if (parentStep == null) {
        return null;
    }
    try {
        if (context.isMonitored()) {
            if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
                if (DbFacade.getInstance().getStepDao().exists(parentStep.getId())) {
                    if (parentStep.getJobId().equals(context.getJob().getId())) {
                        step = parentStep.addStep(newStepName, description);
                    }
                }
            } else if (parentStep != null && context.getExecutionMethod() == ExecutionMethod.AsStep) {
                step = parentStep.addStep(newStepName, description);
            }
        }
        if (step != null) {
            JobRepositoryFactory.getJobRepository().saveStep(step);
        }
    } catch (Exception e) {
        log.error(e);
    }
    return step;
}
#end_block

#method_before
public static void endJob(ExecutionContext context, boolean exitStatus) {
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (!context.getJob().isAsyncJob()) {
                context.getJob().endJob(exitStatus);
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
            if (context.shouldEndJob()) {
                Job job = JobRepositoryFactory.getJobRepository().getJob(context.getStep().getJobId());
                job.endJob(exitStatus);
            }
        }
    }
}
#method_after
public static void endJob(ExecutionContext context, boolean exitStatus) {
    Job job = context.getJob();
    try {
        if (context.isMonitored()) {
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                if (!(job.isAsyncJob() && exitStatus)) {
                    endJob(exitStatus, job);
                }
            } else {
                Step step = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && step != null) {
                    if (context.shouldEndJob()) {
                        if (job == null) {
                            job = JobRepositoryFactory.getJobRepository().getJob(step.getJobId());
                        }
                        if (job != null) {
                            endJob(exitStatus, job);
                        }
                    }
                }
            }
        }
    } catch (Exception e) {
        log.error(e);
    }
}
#end_block

#method_before
public static void endJob(ExecutionContext context, boolean exitStatus) {
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (!context.getJob().isAsyncJob()) {
                context.getJob().endJob(exitStatus);
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
            if (context.shouldEndJob()) {
                Job job = JobRepositoryFactory.getJobRepository().getJob(context.getStep().getJobId());
                job.endJob(exitStatus);
            }
        }
    }
}
#method_after
private static void endJob(boolean exitStatus, Job job) {
    job.markJobEnded(exitStatus);
    try {
        JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
    } catch (Exception e) {
        log.errorFormat("Failed to end Job {0}, {1}", job.getId(), job.getActionType().name(), e);
    }
}
#end_block

#method_before
public static ExecutionContext createDefaultContexForTasks(ExecutionContext parentContext) {
    ExecutionContext context = new ExecutionContext();
    if (parentContext != null) {
        if (parentContext.getJob() != null) {
            Step parentStep = parentContext.getParentTasksStep();
            if (parentStep != null) {
                context.setParentTasksStep(parentStep);
            }
        } else {
            context.setParentTasksStep(parentContext.getParentTasksStep());
        }
    }
    return context;
}
#method_after
public static CommandContext createDefaultContexForTasks(ExecutionContext parentContext) {
    ExecutionContext executionContext = new ExecutionContext();
    if (parentContext != null) {
        if (parentContext.getJob() != null) {
            Step parentStep = parentContext.getParentTasksStep();
            if (parentStep != null) {
                executionContext.setParentTasksStep(parentStep);
            }
        } else {
            executionContext.setParentTasksStep(parentContext.getParentTasksStep());
        }
    }
    return new CommandContext(executionContext);
}
#end_block

#method_before
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return _resourceManger;
}
#method_after
@Override
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return _resourceManger;
}
#end_block

#method_before
private void checkDBConnectivity() {
    boolean dbUp = false;
    long expectedTimeout = System.currentTimeMillis() + DbFacade.getInstance().getOnStartConnectionTimeout();
    long waitBetweenInterval = DbFacade.getInstance().getConnectionCheckInterval();
    while (!dbUp && System.currentTimeMillis() < expectedTimeout) {
        try {
            dbUp = DbFacade.getInstance().CheckDBConnection();
            try {
                Thread.sleep(waitBetweenInterval);
            } catch (InterruptedException e) {
                log.warn("Failed to wait between connection polling attempts. " + "Original exception is: " + ExceptionUtils.getMessage(e));
            }
        } catch (RuntimeException ex) {
            log.error("Error in getting DB connection. The database is inaccessible. " + "Original exception is: " + ExceptionUtils.getMessage(ex));
        }
    }
    if (!dbUp) {
        throw new IllegalStateException("Could not obtain connection to the database." + " Please make sure that DB is up and accepting connections, and " + "restart the application.");
    }
}
#method_after
private static void checkDBConnectivity() {
    boolean dbUp = false;
    long expectedTimeout = System.currentTimeMillis() + DbFacade.getInstance().getOnStartConnectionTimeout();
    long waitBetweenInterval = DbFacade.getInstance().getConnectionCheckInterval();
    while (!dbUp && System.currentTimeMillis() < expectedTimeout) {
        try {
            dbUp = DbFacade.getInstance().CheckDBConnection();
            try {
                Thread.sleep(waitBetweenInterval);
            } catch (InterruptedException e) {
                log.warn("Failed to wait between connection polling attempts. " + "Original exception is: " + ExceptionUtils.getMessage(e));
            }
        } catch (RuntimeException ex) {
            log.error("Error in getting DB connection. The database is inaccessible. " + "Original exception is: " + ExceptionUtils.getMessage(ex));
        }
    }
    if (!dbUp) {
        throw new IllegalStateException("Could not obtain connection to the database." + " Please make sure that DB is up and accepting connections, and " + "restart the application.");
    }
}
#end_block

#method_before
public DateTime getStartedAt() {
    return _startedAt;
}
#method_after
@Override
public DateTime getStartedAt() {
    return _startedAt;
}
#end_block

#method_before
public void Initialize() {
    log.infoFormat("Start time: {0}", new java.util.Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new java.util.Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new java.util.Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new java.util.Date());
    TagsDirector.getInstance();
    log.infoFormat("TagsDirector: {0}", new java.util.Date());
    ImagesSyncronizer.getInstance();
    log.infoFormat("ImagesSyncronizer: {0}", new java.util.Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new java.util.Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new java.util.Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new java.util.Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new java.util.Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    initJobRepository();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#method_after
@Override
public void Initialize() {
    log.infoFormat("Start time: {0}", new Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new Date());
    TagsDirector.getInstance();
    log.infoFormat("TagsDirector: {0}", new Date());
    ImagesSyncronizer.getInstance();
    log.infoFormat("ImagesSyncronizer: {0}", new Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#end_block

#method_before
private void initJobRepository() {
    JobRepositoryFactory.getJobRepository().finalizeJobs();
}
#method_after
private void initJobRepository() {
    try {
        JobRepositoryFactory.getJobRepository().finalizeJobs();
    } catch (Exception e) {
        log.error("Failed to finalize running Jobs", e);
    }
}
#end_block

#method_before
private void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = DbFacade.getInstance().getBusinessEntitySnapshotDAO().getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        CommandBase<?> cmd = CommandsFactory.CreateCommand(commandSnapshot.getValue().toString(), (Guid) commandSnapshot.getKey());
        if (cmd != null) {
            cmd.compensate();
            log.infoFormat("Running compensation on startup for Command : {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        } else {
            log.errorFormat("Failed to run compensation on startup for Command {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        }
    }
}
#method_after
private static void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = DbFacade.getInstance().getBusinessEntitySnapshotDAO().getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        CommandBase<?> cmd = CommandsFactory.CreateCommand(commandSnapshot.getValue().toString(), (Guid) commandSnapshot.getKey());
        if (cmd != null) {
            cmd.compensate();
            log.infoFormat("Running compensation on startup for Command : {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        } else {
            log.errorFormat("Failed to run compensation on startup for Command {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        }
    }
}
#end_block

#method_before
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#end_block

#method_before
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
public VdcReturnValueBase EndAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#method_after
@Override
public VdcReturnValueBase EndAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#end_block

#method_before
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#end_block

#method_before
public VdcQueryReturnValue RunQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#method_after
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#end_block

#method_before
private VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringHelper.isNullOrEmpty(sessionId) || SessionDataContainer.getInstance().GetData(sessionId, "VdcUser", parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
    return command.getQueryReturnValue();
}
#method_after
private static VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringHelper.isNullOrEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
public void RunAsyncQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    addSessionToContext(parameters);
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
}
#method_after
@Override
public void RunAsyncQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    addSessionToContext(parameters);
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
}
#end_block

#method_before
private String addSessionToContext(VdcQueryParametersBase parameters) {
    String sessionId = parameters.getHttpSessionId();
    boolean isAddToContext = true;
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = parameters.getSessionId();
    }
    // request
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = ThreadLocalParamsContainer.getHttpSessionId();
        isAddToContext = false;
    }
    if (!StringHelper.isNullOrEmpty(sessionId) && isAddToContext) {
        ThreadLocalParamsContainer.setHttpSessionId(sessionId);
    }
    return sessionId;
}
#method_after
private static String addSessionToContext(VdcQueryParametersBase parameters) {
    String sessionId = parameters.getHttpSessionId();
    boolean isAddToContext = true;
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = parameters.getSessionId();
    }
    // request
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = ThreadLocalParamsContainer.getHttpSessionId();
        isAddToContext = false;
    }
    if (!StringHelper.isNullOrEmpty(sessionId) && isAddToContext) {
        ThreadLocalParamsContainer.setHttpSessionId(sessionId);
    }
    return sessionId;
}
#end_block

#method_before
@Override
public java.util.ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, false);
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, false);
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public java.util.ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true);
}
#method_after
@Override
@ExcludeClassInterceptors
public ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true);
}
#end_block

#method_before
public java.util.ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters, boolean isInternal) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringHelper.isNullOrEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringHelper.isNullOrEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.CreateMultipleActionsRunner(actionType, parameters, isInternal);
    return runner.Execute();
}
#method_after
public ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringHelper.isNullOrEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringHelper.isNullOrEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.CreateMultipleActionsRunner(actionType, parameters, isInternal);
    return runner.Execute();
}
#end_block

#method_before
@ExcludeClassInterceptors
public ErrorTranslator getErrorsTranslator() {
    return errorsTranslator;
}
#method_after
@Override
@ExcludeClassInterceptors
public ErrorTranslator getErrorsTranslator() {
    return errorsTranslator;
}
#end_block

#method_before
@ExcludeClassInterceptors
public ErrorTranslator getVdsErrorsTranslator() {
    return _vdsErrorsTranslator;
}
#method_after
@Override
@ExcludeClassInterceptors
public ErrorTranslator getVdsErrorsTranslator() {
    return _vdsErrorsTranslator;
}
#end_block

#method_before
public VdcReturnValueBase Login(LoginUserParameters parameters) {
    switch(parameters.getActionType()) {
        case AutoLogin:
        case LoginAdminUser:
            {
                CommandBase<?> command = CommandsFactory.CreateCommand(parameters.getActionType(), parameters);
                return command.ExecuteAction();
            }
        default:
            {
                return NotAutorizedError();
            }
    }
}
#method_after
@Override
public VdcReturnValueBase Login(LoginUserParameters parameters) {
    switch(parameters.getActionType()) {
        case AutoLogin:
        case LoginAdminUser:
            {
                CommandBase<?> command = CommandsFactory.CreateCommand(parameters.getActionType(), parameters);
                return command.ExecuteAction();
            }
        default:
            {
                return NotAutorizedError();
            }
    }
}
#end_block

#method_before
private VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#method_after
private static VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#end_block

#method_before
public VdcReturnValueBase Logoff(LogoutUserParameters parameters) {
    return RunAction(VdcActionType.LogoutUser, parameters);
}
#method_after
@Override
public VdcReturnValueBase Logoff(LogoutUserParameters parameters) {
    return RunAction(VdcActionType.LogoutUser, parameters);
}
#end_block

#method_before
public tags GetTagByTagName(String tagName) {
    throw new NotImplementedException();
}
#method_after
public tags GetTagByTagName(@SuppressWarnings("unused") String tagName) {
    throw new NotImplementedException();
}
#end_block

#method_before
public String GetTagIdsAndChildrenIdsByRegExp(String tagNameRegExp) {
    throw new NotImplementedException();
}
#method_after
public String GetTagIdsAndChildrenIdsByRegExp(@SuppressWarnings("unused") String tagNameRegExp) {
    throw new NotImplementedException();
}
#end_block

#method_before
public String GetTagIdAndChildrenIds(int tagId) {
    throw new NotImplementedException();
}
#method_after
public String GetTagIdAndChildrenIds(@SuppressWarnings("unused") int tagId) {
    throw new NotImplementedException();
}
#end_block

#method_before
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion) {
                    return runQueryImpl(actionType, parameters, false);
                } else {
                    VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                    returnValue.setSucceeded(false);
                    returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                    return returnValue;
                }
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion) {
                    return runQueryImpl(actionType, parameters, false);
                }
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#end_block

#method_before
public VdcReturnValueBase RunUserAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    if (StringHelper.isNullOrEmpty(parameters.getHttpSessionId())) {
        return NotAutorizedError();
    } else {
        return RunAction(actionType, parameters);
    }
}
#method_after
public VdcReturnValueBase RunUserAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    if (StringHelper.isNullOrEmpty(parameters.getHttpSessionId())) {
        return NotAutorizedError();
    }
    return RunAction(actionType, parameters);
}
#end_block

#method_before
public java.util.ArrayList<VdcReturnValueBase> RunUserMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    for (VdcActionParametersBase parameter : parameters) {
        if (StringHelper.isNullOrEmpty(parameter.getHttpSessionId())) {
            java.util.ArrayList<VdcReturnValueBase> returnValues = new java.util.ArrayList<VdcReturnValueBase>();
            for (int i = 0; i < parameters.size(); i++) {
                returnValues.add(NotAutorizedError());
            }
            return returnValues;
        }
    }
    return runInternalMultipleActions(actionType, parameters);
}
#method_after
public ArrayList<VdcReturnValueBase> RunUserMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    for (VdcActionParametersBase parameter : parameters) {
        if (StringHelper.isNullOrEmpty(parameter.getHttpSessionId())) {
            ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
            for (int i = 0; i < parameters.size(); i++) {
                returnValues.add(NotAutorizedError());
            }
            return returnValues;
        }
    }
    return runInternalMultipleActions(actionType, parameters);
}
#end_block

#method_before
public VdcReturnValueBase RunAutoAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return RunAction(actionType, parameters);
}
#method_after
@Override
public VdcReturnValueBase RunAutoAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return RunAction(actionType, parameters);
}
#end_block

#method_before
public VdcQueryReturnValue RunAutoQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runInternalQuery(actionType, parameters);
}
#method_after
@Override
public VdcQueryReturnValue RunAutoQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runInternalQuery(actionType, parameters);
}
#end_block

#method_before
public AsyncQueryResults GetAsyncQueryResults() {
    return BackendCallBacksDirector.getInstance().GetAsyncQueryResults();
}
#method_after
@Override
public AsyncQueryResults GetAsyncQueryResults() {
    return BackendCallBacksDirector.getInstance().GetAsyncQueryResults();
}
#end_block

#method_before
public VdcReturnValueBase ExecuteAction() {
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    boolean isCanDoActionPassed = false;
    Step validatingStep = ExecutionHandler.addStep(executionContext, StepEnum.VALIDATING, null);
    try {
        isCanDoActionPassed = acquireLock() && (getReturnValue().getCanDoAction() || InternalCanDoAction());
    } finally {
        ExecutionHandler.endStep(executionContext, validatingStep, isCanDoActionPassed);
    }
    if (isCanDoActionPassed) {
        getReturnValue().setCanDoAction(true);
        getReturnValue().setIsSyncronious(true);
        getParameters().setTaskStartTime(System.currentTimeMillis());
        Execute();
    } else {
        getReturnValue().setCanDoAction(false);
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase ExecuteAction() {
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    boolean actionAllowed = false;
    Step validatingStep = ExecutionHandler.addStep(executionContext, StepEnum.VALIDATING, null);
    try {
        actionAllowed = acquireLock() && (getReturnValue().getCanDoAction() || InternalCanDoAction());
        ExecutionHandler.endStep(executionContext, validatingStep, actionAllowed);
        if (actionAllowed) {
            getReturnValue().setCanDoAction(true);
            getReturnValue().setIsSyncronious(true);
            getParameters().setTaskStartTime(System.currentTimeMillis());
            Execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLock();
    }
    return getReturnValue();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected void compensate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
public VdcReturnValueBase EndAction() {
    try {
        SetActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        if (getCommandShouldBeLogged()) {
            LogCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase EndAction() {
    ExecutionHandler.startFinalizingStep(executionContext);
    try {
        SetActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        if (getCommandShouldBeLogged()) {
            LogCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
protected boolean validateInputs() {
    List<Class<?>> validationGroupList = getValidationGroups();
    Set<ConstraintViolation<T>> violations = validator.validate(getParameters(), ((Class<?>[]) validationGroupList.toArray(new Class<?>[validationGroupList.size()])));
    if (!violations.isEmpty()) {
        ArrayList<String> msgs = getReturnValue().getCanDoActionMessages();
        for (ConstraintViolation<T> constraintViolation : violations) {
            msgs.add(constraintViolation.getMessage());
        }
        return false;
    }
    return true;
}
#method_after
protected boolean validateInputs() {
    List<Class<?>> validationGroupList = getValidationGroups();
    Set<ConstraintViolation<T>> violations = validator.validate(getParameters(), validationGroupList.toArray(new Class<?>[validationGroupList.size()]));
    if (!violations.isEmpty()) {
        ArrayList<String> msgs = getReturnValue().getCanDoActionMessages();
        for (ConstraintViolation<T> constraintViolation : violations) {
            msgs.add(constraintViolation.getMessage());
        }
        return false;
    }
    return true;
}
#end_block

#method_before
protected void setActionMessageParameters() {
}
#method_after
protected void setActionMessageParameters() {
// No-op method for inheritors to implement
}
#end_block

#method_before
private void Execute() {
    Step executionStep = ExecutionHandler.addStep(executionContext, StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            freeLock();
            if (getCommandShouldBeLogged()) {
                LogCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                UpdateTasksWithActionParameters();
                StartPollingAsyncTasks();
            }
        } finally {
            if (getReturnValue().getTaskIdList().isEmpty()) {
                ExecutionHandler.endStep(executionContext, executionStep, getSucceeded());
                ExecutionHandler.endJob(executionContext, getSucceeded());
            }
        }
    }
}
#method_after
private void Execute() {
    ExecutionHandler.addStep(executionContext, StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            freeLock();
            if (getCommandShouldBeLogged()) {
                LogCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                UpdateTasksWithActionParameters();
                StartPollingAsyncTasks();
            }
        } finally {
            if (getReturnValue().getTaskIdList().isEmpty()) {
                ExecutionHandler.endJob(executionContext, getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected Guid CreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        try {
            retValue = ConcreteCreateTask(asyncTaskCreationInfo, parentCommand);
        } catch (RuntimeException ex) {
            log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
        }
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#method_after
protected Guid CreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        // TODO: Set step description by resource bundle which holds the message and populate its properties by the
        // command.
        Step taskStep = ExecutionHandler.addTaskStep(executionContext, StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), null);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        retValue = ConcreteCreateTask(asyncTaskCreationInfo, parentCommand);
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#end_block

#method_before
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    throw new NotImplementedException();
}
#method_after
@SuppressWarnings("unused")
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    throw new NotImplementedException();
}
#end_block

#method_before
protected void RevertTasks() {
    if (getParameters().getTaskIds() != null) {
        // list to send to the PollTasks mathod
        java.util.ArrayList<Guid> taskIdAsList = new java.util.ArrayList<Guid>();
        for (Guid taskId : getParameters().getTaskIds()) {
            taskIdAsList.add(taskId);
            java.util.ArrayList<AsyncTaskStatus> tasksStatuses = AsyncTaskManager.getInstance().PollTasks(taskIdAsList);
            // call revert task only if ended succeesfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                SPMTaskGuidBaseVDSCommandParameters tempVar = new SPMTaskGuidBaseVDSCommandParameters(getStoragePool().getId(), taskId);
                tempVar.setCompatibilityVersion(getStoragePool().getcompatibility_version().toString());
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, tempVar);
            }
            taskIdAsList.clear();
        }
    }
}
#method_after
protected void RevertTasks() {
    if (getParameters().getTaskIds() != null) {
        // list to send to the PollTasks method
        java.util.ArrayList<Guid> taskIdAsList = new java.util.ArrayList<Guid>();
        for (Guid taskId : getParameters().getTaskIds()) {
            taskIdAsList.add(taskId);
            java.util.ArrayList<AsyncTaskStatus> tasksStatuses = AsyncTaskManager.getInstance().PollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                SPMTaskGuidBaseVDSCommandParameters tempVar = new SPMTaskGuidBaseVDSCommandParameters(getStoragePool().getId(), taskId);
                tempVar.setCompatibilityVersion(getStoragePool().getcompatibility_version().toString());
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, tempVar);
            }
            taskIdAsList.clear();
        }
    }
}
#end_block

#method_before
@Override
public Object runInTransaction() {
    if (_actionState == CommandActionState.EXECUTE) {
        executeActionInTransactionScope();
        return null;
    } else {
        endActionInTransactionScope();
        return null;
    }
}
#method_after
@Override
public Object runInTransaction() {
    if (_actionState == CommandActionState.EXECUTE) {
        executeActionInTransactionScope();
    } else {
        endActionInTransactionScope();
    }
    return null;
}
#end_block

#method_before
void initTable(ApplicationResources resources) {
    getTable().addColumn(new DcStatusColumn(), "", "30px");
    TextColumnWithTooltip<storage_pool> nameColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getname();
        }
    };
    getTable().addColumn(nameColumn, "Name");
    TextColumnWithTooltip<storage_pool> storageTypeColumn = new EnumColumn<storage_pool, StorageType>() {

        @Override
        public StorageType getRawValue(storage_pool object) {
            return object.getstorage_pool_type();
        }
    };
    getTable().addColumn(storageTypeColumn, "Storage Type");
    TextColumnWithTooltip<storage_pool> statusColumn = new EnumColumn<storage_pool, StoragePoolStatus>() {

        @Override
        public StoragePoolStatus getRawValue(storage_pool object) {
            return object.getstatus();
        }
    };
    getTable().addColumn(statusColumn, "Status");
    TextColumnWithTooltip<storage_pool> versionColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getcompatibility_version().getValue();
        }
    };
    getTable().addColumn(versionColumn, "Compatibility Version");
    TextColumnWithTooltip<storage_pool> descColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getdescription();
        }
    };
    getTable().addColumn(descColumn, "Description");
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("New") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Edit") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Remove") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Force Remove") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getForceRemoveCommand();
        }
    });
    List<ActionButtonDefinition<storage_pool>> resourceSubActions = ReportsHelper.getInstance().getResourceSubActions("DataCenter", getMainModel());
    if (resourceSubActions != null && resourceSubActions.size() > 0) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<storage_pool>("Show Report", resourceSubActions));
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<storage_pool>("Guide Me", resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#method_after
void initTable(ApplicationResources resources) {
    getTable().addColumn(new DcStatusColumn(), "", "30px");
    TextColumnWithTooltip<storage_pool> nameColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getname();
        }
    };
    getTable().addColumn(nameColumn, "Name");
    TextColumnWithTooltip<storage_pool> storageTypeColumn = new EnumColumn<storage_pool, StorageType>() {

        @Override
        public StorageType getRawValue(storage_pool object) {
            return object.getstorage_pool_type();
        }
    };
    getTable().addColumn(storageTypeColumn, "Storage Type");
    TextColumnWithTooltip<storage_pool> statusColumn = new EnumColumn<storage_pool, StoragePoolStatus>() {

        @Override
        public StoragePoolStatus getRawValue(storage_pool object) {
            return object.getstatus();
        }
    };
    getTable().addColumn(statusColumn, "Status");
    TextColumnWithTooltip<storage_pool> versionColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getcompatibility_version().getValue();
        }
    };
    getTable().addColumn(versionColumn, "Compatibility Version");
    TextColumnWithTooltip<storage_pool> descColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getdescription();
        }
    };
    getTable().addColumn(descColumn, "Description");
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("New") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Edit") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Remove") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Force Remove") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getForceRemoveCommand();
        }
    });
    List<ActionButtonDefinition<storage_pool>> resourceSubActions = ReportsHelper.getInstance().getResourceSubActions("DataCenter", getMainModel());
    if (resourceSubActions != null && resourceSubActions.size() > 0) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<storage_pool>("Show Report", resourceSubActions));
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<storage_pool>("Guide Me", resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Re-Initialize Data Center", true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRecoveryStorageCommand();
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters(ErrorPopupView.class, DefaultConfirmationPopupView.class);
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    // MAIN SECTION: -POPUPS-
    bindPresenterWidget(RemoveConfirmationPopupPresenterWidget.class, RemoveConfirmationPopupPresenterWidget.ViewDef.class, RemoveConfirmationPopupView.class);
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(DataCenterNetworkPopupPresenterWidget.class, DataCenterNetworkPopupPresenterWidget.ViewDef.class, DataCenterNetworkPopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNewNetworkPopupPresenterWidget.class, ClusterNewNetworkPopupPresenterWidget.ViewDef.class, ClusterNewNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters(ErrorPopupView.class, DefaultConfirmationPopupView.class);
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    // MAIN SECTION: -POPUPS-
    bindPresenterWidget(RemoveConfirmationPopupPresenterWidget.class, RemoveConfirmationPopupPresenterWidget.ViewDef.class, RemoveConfirmationPopupView.class);
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(DataCenterNetworkPopupPresenterWidget.class, DataCenterNetworkPopupPresenterWidget.ViewDef.class, DataCenterNetworkPopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNewNetworkPopupPresenterWidget.class, ClusterNewNetworkPopupPresenterWidget.ViewDef.class, ClusterNewNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
}
#end_block

#method_before
public String getItemsCountString() {
    if (getItems() == null) {
        return "";
    }
    int fromItemCount = getSearchPageSize() * (getSearchPageNumber() - 1) + 1;
    int toItemCount = (fromItemCount - 1) + ((ArrayList<Object>) getItems()).size();
    if (toItemCount == 0 || fromItemCount > toItemCount) {
        return "";
    }
    return fromItemCount + "-" + toItemCount;
}
#method_after
public String getItemsCountString() {
    if (getItems() == null) {
        return "";
    }
    int fromItemCount = getSearchPageSize() * (getSearchPageNumber() - 1) + 1;
    int toItemCount = (fromItemCount - 1) + ((List) getItems()).size();
    if (toItemCount == 0 || fromItemCount > toItemCount) {
        return "";
    }
    return fromItemCount + "-" + toItemCount;
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<storage_pool, DataCenterListModel> getDataCenterListProvider(ClientGinjector ginjector, final Provider<DataCenterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider) {
    return new MainTabModelProvider<storage_pool, DataCenterListModel>(ginjector, DataCenterListModel.class) {

        @Override
        protected AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else {
                return super.getModelPopup(lastExecutedCommand);
            }
        }

        @Override
        protected AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand() || lastExecutedCommand == getModel().getForceRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<storage_pool, DataCenterListModel> getDataCenterListProvider(ClientGinjector ginjector, final Provider<DataCenterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RecoveryStoragePopupPresenterWidget> recoveryStorageConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider) {
    return new MainTabModelProvider<storage_pool, DataCenterListModel>(ginjector, DataCenterListModel.class) {

        @Override
        protected AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else {
                return super.getModelPopup(lastExecutedCommand);
            }
        }

        @Override
        protected AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand() || lastExecutedCommand == getModel().getForceRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRecoveryStorageCommand()) {
                return recoveryStorageConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    // LINQ 29456
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNetworkInterface oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    // LINQ 29456
    if (!StringHelper.EqOp(oldIface.getName(), getParameters().getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check if user change the mac
    boolean macChanged = false;
    if (!StringHelper.EqOp(oldIface.getMacAddress(), getParameters().getInterface().getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getParameters().getInterface().getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        macChanged = true;
        MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses, getVm().getvds_group_compatibility_version().toString());
        if (!MacPoolManager.getInstance().AddMac(getParameters().getInterface().getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getParameters().getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    // LINQ 29456
    // List<DiskImageBase> allDisks =
    // DbFacade.Instance.GetImagesByVmGuid(AddVmInterfaceParameters.VmId).Select(a
    // => (DiskImageBase)a).ToList();
    // if (!CheckPCIAndIDELimit(vm.num_of_monitors, allInterfaces,
    // allDisks))
    // {
    // ReturnValue.CanDoActionMessages.Add(VdcBllMessages.VAR__ACTION__UPDATE.toString());
    // ReturnValue.CanDoActionMessages.Add(VdcBllMessages.VAR__TYPE__INTERFACE.toString());
    // return false;
    // }
    List allDisks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId());
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for versions 2.1, 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        List<VmNetworkInterface> ifaces = new ArrayList<VmNetworkInterface>(interfaces);
        interfaces.remove(oldIface);
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        interfaces.add(oldIface);
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that the exists in current cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    // AddVmInterfaceParameters.Interface.network_name))
    if (null == LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    // LINQ 29456
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNetworkInterface oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    // LINQ 29456
    if (!StringHelper.EqOp(oldIface.getName(), getParameters().getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check if user change the mac
    boolean macChanged = false;
    if (!StringHelper.EqOp(oldIface.getMacAddress(), getParameters().getInterface().getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getParameters().getInterface().getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        macChanged = true;
        MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        if (!MacPoolManager.getInstance().AddMac(getParameters().getInterface().getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getParameters().getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    // LINQ 29456
    // List<DiskImageBase> allDisks =
    // DbFacade.Instance.GetImagesByVmGuid(AddVmInterfaceParameters.VmId).Select(a
    // => (DiskImageBase)a).ToList();
    // if (!CheckPCIAndIDELimit(vm.num_of_monitors, allInterfaces,
    // allDisks))
    // {
    // ReturnValue.CanDoActionMessages.Add(VdcBllMessages.VAR__ACTION__UPDATE.toString());
    // ReturnValue.CanDoActionMessages.Add(VdcBllMessages.VAR__TYPE__INTERFACE.toString());
    // return false;
    // }
    List allDisks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId());
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for versions 2.1, 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        List<VmNetworkInterface> ifaces = new ArrayList<VmNetworkInterface>(interfaces);
        interfaces.remove(oldIface);
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        interfaces.add(oldIface);
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that the exists in current cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    // AddVmInterfaceParameters.Interface.network_name))
    if (null == LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        String mac = null;
        RefObject<String> tempRefObject = new RefObject<String>(mac);
        MacPoolManager.getInstance().allocateNewMac(tempRefObject);
        mac = tempRefObject.argvalue;
        getParameters().getInterface().setMacAddress(mac);
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDAO().save(getParameters().getInterface());
    dbFacade.getVmNetworkStatisticsDAO().save(getParameters().getInterface().getStatistics());
    VmDevice iface = new VmDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmId()), VmDeviceType.getName(VmDeviceType.INTERFACE), VmDeviceType.getName(VmDeviceType.BRIDGE), "", 0, "", true, false, false, false);
    dbFacade.getVmDeviceDAO().save(iface);
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        String mac = null;
        RefObject<String> tempRefObject = new RefObject<String>(mac);
        MacPoolManager.getInstance().allocateNewMac(tempRefObject);
        mac = tempRefObject.argvalue;
        getParameters().getInterface().setMacAddress(mac);
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDAO().save(getParameters().getInterface());
    dbFacade.getVmNetworkStatisticsDAO().save(getParameters().getInterface().getStatistics());
    VmDevice iface = new VmDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmId()), VmDeviceType.getName(VmDeviceType.INTERFACE), VmDeviceType.getName(VmDeviceType.BRIDGE), "", 0, "", true, true, false);
    dbFacade.getVmDeviceDAO().save(iface);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down && vmDynamic.getstatus() != VMStatus.ImageLocked) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    // LINQ 29456
    // List<DiskImageBase> allDisks =
    // DbFacade.Instance.GetImagesByVmGuid(AddVmInterfaceParameters.VmId).Select(a
    // => (DiskImageBase)a).ToList();
    // if (!CheckPCIAndIDELimit(vm.num_of_monitors, allInterfaces,
    // allDisks))
    // {
    // return false;
    // }
    List<DiskImageBase> allDisks = LinqUtils.foreach(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId()), new Function<DiskImage, DiskImageBase>() {

        @Override
        public DiskImageBase eval(DiskImage diskImage) {
            return diskImage;
        }
    });
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // this must be the last check because it's add mac to the pool
    if (!StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getParameters().getInterface().getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses, getVm().getvds_group_compatibility_version().toString());
        if (!MacPoolManager.getInstance().AddMac(getParameters().getInterface().getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    // check that the exists in current cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    // AddVmInterfaceParameters.Interface.network_name))
    if (null == LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down && vmDynamic.getstatus() != VMStatus.ImageLocked) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    // LINQ 29456
    // List<DiskImageBase> allDisks =
    // DbFacade.Instance.GetImagesByVmGuid(AddVmInterfaceParameters.VmId).Select(a
    // => (DiskImageBase)a).ToList();
    // if (!CheckPCIAndIDELimit(vm.num_of_monitors, allInterfaces,
    // allDisks))
    // {
    // return false;
    // }
    List<DiskImageBase> allDisks = LinqUtils.foreach(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId()), new Function<DiskImage, DiskImageBase>() {

        @Override
        public DiskImageBase eval(DiskImage diskImage) {
            return diskImage;
        }
    });
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // this must be the last check because it's add mac to the pool
    if (!StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getParameters().getInterface().getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        if (!MacPoolManager.getInstance().AddMac(getParameters().getInterface().getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    // check that the exists in current cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    // AddVmInterfaceParameters.Interface.network_name))
    if (null == LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return super.canDoAction();
}
#end_block

#method_before
@XmlElement(name = "runAsUser", defaultValue = "false")
public boolean isRunAsUser() {
    return isRunAsUser;
}
#method_after
public boolean isRunAsUser() {
    return runAsUser;
}
#end_block

#method_before
public void setRunAsUser(boolean isRunAsUser) {
    this.isRunAsUser = isRunAsUser;
}
#method_after
public void setRunAsUser(boolean isRunAsUser) {
    this.runAsUser = isRunAsUser;
}
#end_block

#method_before
private static Field getQueryTypeField() {
    for (Field f : QueriesCommandBase.class.getDeclaredFields()) {
        if (f.getName().equals("type")) {
            f.setAccessible(true);
            return f;
        }
    }
    fail("Can't find the _type field");
    return null;
}
#method_after
private static Field getQueryTypeField() {
    for (Field f : QueriesCommandBase.class.getDeclaredFields()) {
        if (f.getName().equals("type")) {
            f.setAccessible(true);
            return f;
        }
    }
    fail("Can't find the type field");
    return null;
}
#end_block

#method_before
private static Field getQueryTypeField() {
    for (Field f : QueriesCommandBase.class.getDeclaredFields()) {
        if (f.getName().equals("type")) {
            f.setAccessible(true);
            return f;
        }
    }
    fail("Can't find the _type field");
    return null;
}
#method_after
private static Field getQueryTypeField() {
    for (Field f : QueriesCommandBase.class.getDeclaredFields()) {
        if (f.getName().equals("type")) {
            f.setAccessible(true);
            return f;
        }
    }
    fail("Can't find the type field");
    return null;
}
#end_block

#method_before
/**
 * Update the vm devices according to changes made in vm static for new VM
 */
public static void updateVmDevices(Guid newVmId) {
    VmStatic newVmStatic = DbFacade.getInstance().getVmDAO().get(newVmId).getStaticData();
    updateCdInVmDevice(newVmStatic);
    updateBootOrderInVmDevice(newVmStatic);
    updateNumOfMonitorsInVmDevice(newVmStatic);
}
#method_after
/**
 * Update the vm devices according to changes made in vm static for new VM
 */
public static void updateVmDevices(Guid newVmId) {
    vm = DbFacade.getInstance().getVmDAO().get(newVmId);
    VmStatic newVmStatic = vm.getStaticData();
    updateCdInVmDevice(newVmStatic);
    updateBootOrderInVmDevice(newVmStatic);
    updateNumOfMonitorsInVmDevice(newVmStatic);
}
#end_block

#method_before
private static void updateCdInVmDevice(VmStatic oldVmStatic, VmStatic newVmStatic) {
    if (oldVmStatic.getiso_path().isEmpty() && !newVmStatic.getiso_path().isEmpty()) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmStatic.getId()), VmDeviceCommonUtils.DISK, VmDeviceCommonUtils.CDROM, "", 0, newVmStatic.getiso_path(), true, false, false, false);
        DbFacade.getInstance().getVmDeviceDAO().save(cd);
    } else if (!oldVmStatic.getiso_path().isEmpty() && newVmStatic.getiso_path().isEmpty()) {
        // existing CD was removed
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmStatic.getId(), VmDeviceCommonUtils.DISK, VmDeviceCommonUtils.CDROM);
        DbFacade.getInstance().getVmDeviceDAO().remove(list.get(0).getId());
    } else {
        // CD was changed
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmStatic.getId(), VmDeviceCommonUtils.DISK, VmDeviceCommonUtils.CDROM);
        VmDevice cd = list.get(0);
        cd.setSpecParams(newVmStatic.getiso_path());
        DbFacade.getInstance().getVmDeviceDAO().save(cd);
    }
}
#method_after
private static void updateCdInVmDevice(VmStatic oldVmStatic, VmStatic newVmStatic) {
    if (oldVmStatic.getiso_path().isEmpty() && !newVmStatic.getiso_path().isEmpty()) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmStatic.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmStatic.getiso_path(), true, false, false, false);
        DbFacade.getInstance().getVmDeviceDAO().save(cd);
    } else if (!oldVmStatic.getiso_path().isEmpty() && newVmStatic.getiso_path().isEmpty()) {
        // existing CD was removed
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmStatic.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
        DbFacade.getInstance().getVmDeviceDAO().remove(list.get(0).getId());
    } else {
        // CD was changed
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmStatic.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
        VmDevice cd = list.get(0);
        cd.setSpecParams(newVmStatic.getiso_path());
        DbFacade.getInstance().getVmDeviceDAO().update(cd);
    }
}
#end_block

#method_before
/**
 * updates new VM CD ROM in vm_device
 * @param newVmStatic
 */
private static void updateCdInVmDevice(VmStatic newVmStatic) {
    // new CD was added
    VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmStatic.getId()), VmDeviceCommonUtils.DISK, VmDeviceCommonUtils.CDROM, "", 0, newVmStatic.getiso_path(), true, false, false, false);
    DbFacade.getInstance().getVmDeviceDAO().save(cd);
}
#method_after
/**
 * updates new VM CD ROM in vm_device
 * @param newVmStatic
 */
private static void updateCdInVmDevice(VmStatic newVmStatic) {
    // new CD was added
    VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmStatic.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmStatic.getiso_path(), true, false, false, false);
    DbFacade.getInstance().getVmDeviceDAO().save(cd);
}
#end_block

#method_before
private static void updateBootOrderInVmDevice(VmStatic newStatic) {
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmId(newStatic.getId());
    int bootOrder = 1;
    switch(newStatic.getdefault_boot_sequence()) {
        case C:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case CD:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
    }
    // update boot order in vm device
    for (VmDevice device : devices) {
        DbFacade.getInstance().getVmDeviceDAO().save(device);
    }
}
#method_after
private static void updateBootOrderInVmDevice(VmStatic newStatic) {
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmId(newStatic.getId());
    int bootOrder = 1;
    switch(newStatic.getdefault_boot_sequence()) {
        case C:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case CD:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
    }
    // update boot order in vm device
    for (VmDevice device : devices) {
        DbFacade.getInstance().getVmDeviceDAO().update(device);
    }
}
#end_block

#method_before
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceCommonUtils.INTERFACE) && device.getDevice().equals(VmDeviceCommonUtils.BRIDGE)) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.BRIDGE))) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceCommonUtils.DISK) && device.getDevice().equals(VmDeviceCommonUtils.CDROM)) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#method_after
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM))) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceCommonUtils.DISK) && device.getDevice().equals(VmDeviceCommonUtils.DISK)) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm);
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK))) {
            if (isOldCluster) {
                // old version.
                if (DbFacade.getInstance().getDiskDao().get(device.getDeviceId()).getDiskType().equals(DiskType.System)) {
                    device.setBootOrder(bootOrder++);
                    break;
                }
            } else {
                // supporting more than 1 bootable disk in 3.1 and up.
                device.setBootOrder(bootOrder++);
            }
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmStatic oldVmStatic, VmStatic newStatic) {
    if (newStatic.getnum_of_monitors() > oldVmStatic.getnum_of_monitors()) {
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        // monitors were added
        for (int i = oldVmStatic.getnum_of_monitors(); i <= newStatic.getnum_of_monitors(); i++) {
            VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceCommonUtils.VIDEO, DisplayType.qxl.name(), "", 0, mem, true, false, false, false);
            DbFacade.getInstance().getVmDeviceDAO().save(cd);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceCommonUtils.VIDEO);
        for (int i = 1; i <= (oldVmStatic.getnum_of_monitors() - newStatic.getnum_of_monitors()); i++) {
            DbFacade.getInstance().getVmDeviceDAO().remove(list.get(i).getId());
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmStatic oldVmStatic, VmStatic newStatic) {
    if (newStatic.getnum_of_monitors() > oldVmStatic.getnum_of_monitors()) {
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        // monitors were added
        for (int i = oldVmStatic.getnum_of_monitors(); i <= newStatic.getnum_of_monitors(); i++) {
            VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceType.getName(VmDeviceType.VIDEO), DisplayType.qxl.name(), "", 0, mem, true, false, false, false);
            DbFacade.getInstance().getVmDeviceDAO().save(cd);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.getName(VmDeviceType.VIDEO));
        for (int i = 1; i <= (oldVmStatic.getnum_of_monitors() - newStatic.getnum_of_monitors()); i++) {
            DbFacade.getInstance().getVmDeviceDAO().remove(list.get(i).getId());
        }
    }
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmStatic newStatic) {
    if (newStatic.getnum_of_monitors() > 0) {
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        // monitors were added
        for (int i = 1; i <= newStatic.getnum_of_monitors(); i++) {
            VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceCommonUtils.VIDEO, DisplayType.qxl.name(), "", 0, mem, true, false, false, false);
            DbFacade.getInstance().getVmDeviceDAO().save(cd);
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmStatic newStatic) {
    if (newStatic.getnum_of_monitors() > 0) {
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        // monitors were added
        for (int i = 1; i <= newStatic.getnum_of_monitors(); i++) {
            VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceType.getName(VmDeviceType.VIDEO), DisplayType.qxl.name(), "", 0, mem, true, false, false, false);
            DbFacade.getInstance().getVmDeviceDAO().save(cd);
        }
    }
}
#end_block

#method_before
public static boolean isNetwork(VmDevice device) {
    return (device.getType().equals(INTERFACE));
}
#method_after
public static boolean isNetwork(VmDevice device) {
    return (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)));
}
#end_block

#method_before
public static boolean isDisk(VmDevice device) {
    return (device.getType().equals(DISK) && device.getDevice().equals(DISK));
}
#method_after
public static boolean isDisk(VmDevice device) {
    return (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK)));
}
#end_block

#method_before
public static boolean isCD(VmDevice device) {
    return (device.getType().equals(DISK) && device.getDevice().equals(CDROM));
}
#method_after
public static boolean isCD(VmDevice device) {
    return (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM)));
}
#end_block

#method_before
public static BootSequence getBootSequence(List<VmDevice> devices) {
    BootSequence ret = BootSequence.C;
    String seq = "";
    for (VmDevice device : devices) {
        if (device.getBootOrder() > 0) {
            if (isNetwork(device) && seq.indexOf('N') < 0) {
                seq.concat("N");
            }
            if (isDisk(device) && seq.indexOf('C') < 0) {
                seq.concat("C");
            }
            if (isCD(device) && seq.indexOf('D') < 0) {
                seq.concat("D");
            }
            // maximum string is 3 characters, so, if reached , exit loop.
            if (seq.length() == 3) {
                break;
            }
        }
    }
    for (BootSequence bs : BootSequence.values()) {
        if (bs.name().equals(seq)) {
            ret = bs;
        }
    }
    return ret;
}
#method_after
public static BootSequence getBootSequence(List<VmDevice> devices) {
    BootSequence ret = BootSequence.C;
    String seq = "";
    for (VmDevice device : devices) {
        if (device.getBootOrder() > 0) {
            if (isNetwork(device) && seq.indexOf('N') < 0) {
                seq.concat("N");
            }
            if (isDisk(device) && seq.indexOf('C') < 0) {
                seq.concat("C");
            }
            if (isCD(device) && seq.indexOf('D') < 0) {
                seq.concat("D");
            }
            // maximum string is 3 characters, so, if reached , exit loop.
            if (seq.length() == 3) {
                break;
            }
        }
    }
    for (BootSequence bs : BootSequence.values()) {
        if (bs.name().equals(seq)) {
            ret = bs;
            break;
        }
    }
    return ret;
}
#end_block

#method_before
@XmlElement(name = "guest_requested_memory")
public String getHash() {
    return mVmDynamic.getHash();
}
#method_after
@XmlElement(name = "hash")
public String getHash() {
    return mVmDynamic.getHash();
}
#end_block

#method_before
public static String getDefaultNamingContextFromNameingContexts(Attribute namingContexts) {
    for (int index = 0; index < namingContexts.size(); ++index) {
        String namingContext;
        try {
            namingContext = (String) namingContexts.get(index);
        } catch (NamingException e) {
            log.error("Failed getting naming contexts from root DSE", e);
            return null;
        }
        if (!namingContext.equalsIgnoreCase("o=netscaperoot")) {
            return namingContext;
        }
    }
    return null;
}
#method_after
public static String getDefaultNamingContextFromNameingContexts(Attribute namingContexts) {
    for (int index = 0; index < namingContexts.size(); ++index) {
        String namingContext;
        try {
            namingContext = (String) namingContexts.get(index);
        } catch (NamingException e) {
            log.error("Failed getting naming contexts from root DSE", e);
            return null;
        }
        if (!RHDS_NAMING_CONTEXT.equalsIgnoreCase(namingContext)) {
            return namingContext;
        }
    }
    return null;
}
#end_block

#method_before
public LdapProviderType retrieveLdapProviderType(String domain) {
    Attributes attributes = getDomainAttributes(LdapProviderType.general, domain);
    if (attributes != null) {
        if (attributes.get(ADRootDSEAttributes.domainControllerFunctionality.name()) != null) {
            return LdapProviderType.activeDirectory;
        } else if (attributes.get(RHDSRootDSEAttributes.netscapemdsuffix.name()) != null) {
            return LdapProviderType.rhds;
        } else {
            return LdapProviderType.ipa;
        }
    } else {
        return LdapProviderType.general;
    }
}
#method_after
public LdapProviderType retrieveLdapProviderType(String domain) {
    LdapProviderType retVal = LdapProviderType.general;
    Attributes attributes = getDomainAttributes(LdapProviderType.general, domain);
    if (attributes != null) {
        if (attributes.get(ADRootDSEAttributes.domainControllerFunctionality.name()) != null) {
            retVal = LdapProviderType.activeDirectory;
        } else if (attributes.get(RHDSRootDSEAttributes.netscapemdsuffix.name()) != null) {
            retVal = LdapProviderType.rhds;
        } else if (attributes.get(IPARootDSEAttributes.namingContexts.name()) != null) {
            retVal = LdapProviderType.ipa;
        }
    }
    return retVal;
}
#end_block

#method_before
private static void prepareQueryFormatters() {
    activeDirectorySearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "sAMAccountType=805306368");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "userPrincipalName");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "ObjectCategory=Group");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "name");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "samaccountname");
    ipaSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=posixAccount)(objectClass=krbPrincipalAux)");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "krbPrincipalName");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=ipaUserGroup");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    dsSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    // We put here a duplicate. Need to solve it in another way.
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "uid");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupofuniquenames");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
}
#method_after
private static void prepareQueryFormatters() {
    activeDirectorySearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "sAMAccountType=805306368");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "userPrincipalName");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "ObjectCategory=Group");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "name");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "samaccountname");
    ipaSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=posixAccount)(objectClass=krbPrincipalAux)");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "krbPrincipalName");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=ipaUserGroup");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    dsSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    // We put here a duplicate. Need to solve it in another way.
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "uid");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupOfUniqueNames");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
}
#end_block

#method_before
private InstallVdsCommand<InstallVdsParameters> createCommand(InstallVdsParameters params) {
    InstallVdsCommand<InstallVdsParameters> command = spy(new InstallVdsCommand<InstallVdsParameters>(params));
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(vdsDynamicDAO).when(command).getVdsDynamicDAO();
    return command;
}
#method_after
private InstallVdsCommand<InstallVdsParameters> createCommand(InstallVdsParameters params) {
    return new InstallVdsCommand<InstallVdsParameters>(params);
}
#end_block

#method_before
@Test
public void canDoActionSucceeds() {
    mockVdsDynamicWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertTrue(command.canDoAction());
}
#method_after
@Test
public void canDoActionSucceeds() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertTrue(command.canDoAction());
}
#end_block

#method_before
@Test
public void canDoActionFailsNullParameterForIsoFile() {
    mockVdsDynamicWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(null);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#method_after
@Test
public void canDoActionFailsNullParameterForIsoFile() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(null);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#end_block

#method_before
@Test
public void canDoActionFailsMissingIsoFile() {
    mockVdsDynamicWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(INVALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#method_after
@Test
public void canDoActionFailsMissingIsoFile() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(INVALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#end_block

#method_before
@Test
public void canDoActionFailsIsoVersionNotCompatible() {
    mockVdsDynamicWithOsVersion(INVALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
}
#method_after
@Test
public void canDoActionFailsIsoVersionNotCompatible() {
    mockVdsWithOsVersion(INVALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVdsId() == null || getVdsId().equals(Guid.Empty)) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        retValue = false;
    } else if (isOvirtReInstallOrUpgrade()) {
        String isoFile = getParameters().getoVirtIsoFile();
        if (!isIsoFileValid(isoFile)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
            retValue = false;
        } else if (!isIsoVersionCompatible(isoFile)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
            retValue = false;
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVdsId() == null || getVdsId().equals(Guid.Empty)) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        retValue = false;
    } else if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        retValue = false;
    } else if (isOvirtReInstallOrUpgrade()) {
        String isoFile = getParameters().getoVirtIsoFile();
        if (!isIsoFileValid(isoFile)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
            retValue = false;
        } else {
            RpmVersion ovirtHostOsVersion = VdsHandler.getOvirtHostOsVersion(getVds());
            if (ovirtHostOsVersion != null && !isIsoVersionCompatible(ovirtHostOsVersion, isoFile)) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
                addCanDoActionMessage(String.format("$IsoVersion %1$s", ovirtHostOsVersion.getMajor()));
                retValue = false;
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null) {
        if (getVds().getvds_type() == VDSType.VDS) {
            _vdsInstaller = new VdsInstaller(getVds(), getParameters().getRootPassword(), getParameters().getOverrideFirewall());
        } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
            log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
            if (getParameters().getOverrideFirewall()) {
                log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Installing));
            if (isOvirtReInstallOrUpgrade()) {
                _vdsInstaller = new OVirtInstaller(getVds(), getParameters().getoVirtIsoFile());
            } else {
                _vdsInstaller = new CBCInstaller(getVds());
            }
        }
        log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
        setSucceeded(_vdsInstaller.Install());
        log.infoFormat("After Installation {0}", Thread.currentThread().getName());
        if (!getSucceeded()) {
            AddCustomValue("FailedInstallMessage", getErrorMessage(_vdsInstaller.getErrorMessage()));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.InstallFailed));
        } else {
            if (_vdsInstaller.isAddOvirtFlow()) {
                log.debugFormat("Add manual oVirt flow ended successfully for {0}.", getVds().getvds_name());
                return;
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Reboot));
            if (getVds().getvds_type() == VDSType.VDS || (getVds().getvds_type() == VDSType.oVirtNode && getParameters().getIsReinstallOrUpgrade())) {
                RunSleepOnReboot();
            } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
                ThreadPoolUtil.execute(new Runnable() {

                    @Override
                    public void run() {
                        CBCSetStatus();
                    }
                });
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() != null) {
        if (getVds().getvds_type() == VDSType.VDS) {
            _vdsInstaller = new VdsInstaller(getVds(), getParameters().getRootPassword(), getParameters().getOverrideFirewall());
        } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
            log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
            if (getParameters().getOverrideFirewall()) {
                log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Installing));
            if (isOvirtReInstallOrUpgrade()) {
                _vdsInstaller = new OVirtInstaller(getVds(), getParameters().getoVirtIsoFile());
            } else {
                _vdsInstaller = new CBCInstaller(getVds());
            }
        }
        log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
        boolean installResult = false;
        try {
            installResult = _vdsInstaller.Install();
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getvds_id(), getVds().getvds_name(), e);
        }
        setSucceeded(installResult);
        log.infoFormat("After Installation {0}", Thread.currentThread().getName());
        if (!getSucceeded()) {
            AddCustomValue("FailedInstallMessage", getErrorMessage(_vdsInstaller.getErrorMessage()));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.InstallFailed));
        } else {
            if (_vdsInstaller.isAddOvirtFlow()) {
                log.debugFormat("Add manual oVirt flow ended successfully for {0}.", getVds().getvds_name());
                return;
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Reboot));
            if (getVds().getvds_type() == VDSType.VDS || isOvirtReInstallOrUpgrade()) {
                RunSleepOnReboot();
            } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
                ThreadPoolUtil.execute(new Runnable() {

                    @Override
                    public void run() {
                        CBCSetStatus();
                    }
                });
            }
        }
    }
}
#end_block

#method_before
private boolean isIsoVersionCompatible(String isoFile) {
    boolean retValue = true;
    VdsDynamic vdsDynamic = getVdsDynamicDAO().get(getVdsId());
    try {
        RpmVersion vdsOsVersion = new RpmVersion(vdsDynamic.gethost_os(), "RHEV Hypervisor -", true);
        RpmVersion isoVersion = new RpmVersion(isoFile, Config.<String>GetValue(ConfigValues.OvirtIsoPrefix), true);
        if (isoVersion.getMajor() != vdsOsVersion.getMajor() && vdsOsVersion.getMajor() != -1 && isoVersion.getMajor() != -1) {
            retValue = false;
        }
    } catch (RuntimeException e) {
        log.errorFormat("Failed to parse iso version {0} or ovirt os version {1} with error {2}", vdsDynamic.gethost_os(), isoFile, ExceptionUtils.getMessage(e));
    }
    return retValue;
}
#method_after
public boolean isIsoVersionCompatible(RpmVersion ovirtOsVersion, String isoFile) {
    boolean retValue = true;
    if (ovirtOsVersion != null) {
        try {
            RpmVersion isoVersion = new RpmVersion(isoFile, Config.<String>GetValue(ConfigValues.OvirtIsoPrefix), true);
            if (!VdsHandler.isIsoVersionCompatibleForUpgrade(ovirtOsVersion, isoVersion)) {
                retValue = false;
            }
        } catch (RuntimeException e) {
            log.warnFormat("Failed to parse ISO file version {0} with error {1}", isoFile, ExceptionUtils.getMessage(e));
        }
    }
    return retValue;
}
#end_block

#method_before
@Before
public void setUp() {
    ConfigMocker cfgMocker = new ConfigMocker();
    cfgMocker.mockOVirtISOsRepositoryPath(OVIRT_ISOS_REPOSITORY_PATH);
    cfgMocker.mockConfigOvirtIsoPrefix(OVIRT_ISO_PREFIX);
    cfgMocker.mockConfigOvirtInitialSupportedIsoVersion(OVIRT_INIT_SUPPORTED_VERSION);
}
#method_after
@Before
public void setUp() {
    initMocks(this);
    ConfigMocker cfgMocker = new ConfigMocker();
    cfgMocker.mockOVirtISOsRepositoryPath(OVIRT_ISOS_REPOSITORY_PATH);
    cfgMocker.mockConfigOvirtIsoPrefix(OVIRT_ISO_PREFIX);
    cfgMocker.mockConfigOvirtInitialSupportedIsoVersion(OVIRT_INIT_SUPPORTED_VERSION);
    mockStatic(DbFacade.class);
    when(DbFacade.getInstance()).thenReturn(dbFacade);
    when(dbFacade.getVdsDAO()).thenReturn(vdsDAO);
    when(vdsDAO.get(any(Guid.class))).thenReturn(null);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void checkReturnValue(GetoVirtISOsQuery<VdcQueryParametersBase> query) {
    List<RpmVersion> isosList = (List<RpmVersion>) query.getQueryReturnValue().getReturnValue();
    assertTrue(!isosList.isEmpty());
}
#method_after
@SuppressWarnings("unchecked")
private void checkReturnValue(GetoVirtISOsQuery<VdsIdParametersBase> query) {
    List<RpmVersion> isosList = (List<RpmVersion>) query.getQueryReturnValue().getReturnValue();
    assertTrue(!isosList.isEmpty());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    File directory = new File(Config.resolveOVirtISOsRepositoryPath());
    if (directory.isDirectory()) {
        List<String> listOfIsoFiles = getListOfIsoFiles(directory);
        if (!listOfIsoFiles.isEmpty()) {
            File[] ovirtVersionFiles = filterOvirtFiles(directory, isoVersionPattern);
            for (File versionFile : ovirtVersionFiles) {
                try {
                    String isoVersionText = readIsoVersion(versionFile);
                    if (StringUtils.isBlank(isoVersionText)) {
                        log.debugFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String[] versionParts = isoVersionText.split(",");
                    if (versionParts.length < 2) {
                        log.debugFormat("Iso version file {0} contains invalid content. Excpected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String majorVersionStr = versionParts[0];
                    String releaseStr = versionParts[1];
                    String isoFileName = getIsoFileNameByVersion(listOfIsoFiles, majorVersionStr, releaseStr);
                    if (isoFileName == null) {
                        log.debugFormat("Iso version file {0} has no matching iso file searched by version parts: {1} and {2}.", versionFile.getAbsolutePath(), majorVersionStr, releaseStr);
                        continue;
                    }
                    RpmVersion isoVersion = parseIsoFileVersion(isoFileName, majorVersionStr);
                    if (isoVersion != null) {
                        if (isIsoVersionSupported(isoVersion)) {
                            availableISOsList.add(isoVersion);
                        }
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to parse ovirt iso version {0} with error {1}", versionFile.getAbsolutePath(), ExceptionUtils.getMessage(e));
                }
            }
        }
    } else {
        log.errorFormat("ovirt ISOs directory not found. Search in: {0}", directory.getPath());
    }
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#method_after
@Override
protected void executeQueryCommand() {
    RpmVersion vdsOsVersion = getOvirtOsVersion();
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    File directory = new File(Config.resolveOVirtISOsRepositoryPath());
    if (directory.isDirectory()) {
        List<String> listOfIsoFiles = getListOfIsoFiles(directory);
        if (!listOfIsoFiles.isEmpty()) {
            File[] ovirtVersionFiles = filterOvirtFiles(directory, isoVersionPattern);
            for (File versionFile : ovirtVersionFiles) {
                try {
                    String isoVersionText = readIsoVersion(versionFile);
                    if (StringUtils.isBlank(isoVersionText)) {
                        log.debugFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String[] versionParts = isoVersionText.split(",");
                    if (versionParts.length < 2) {
                        log.debugFormat("Iso version file {0} contains invalid content. Excpected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String majorVersionStr = versionParts[0];
                    String releaseStr = versionParts[1];
                    String isoFileName = getIsoFileNameByVersion(listOfIsoFiles, majorVersionStr, releaseStr);
                    if (isoFileName == null) {
                        log.debugFormat("Iso version file {0} has no matching iso file searched by version parts: {1} and {2}.", versionFile.getAbsolutePath(), majorVersionStr, releaseStr);
                        continue;
                    }
                    RpmVersion isoVersion = parseIsoFileVersion(isoFileName, majorVersionStr);
                    boolean shouldAdd = false;
                    if (isoVersion != null && isIsoVersionSupported(isoVersion)) {
                        if (vdsOsVersion != null) {
                            if (VdsHandler.isIsoVersionCompatibleForUpgrade(vdsOsVersion, isoVersion)) {
                                shouldAdd = true;
                            }
                        } else {
                            shouldAdd = true;
                        }
                    }
                    if (shouldAdd) {
                        availableISOsList.add(isoVersion);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to parse ovirt iso version {0} with error {1}", versionFile.getAbsolutePath(), ExceptionUtils.getMessage(e));
                }
            }
        }
    } else {
        log.errorFormat("ovirt ISOs directory not found. Search in: {0}", directory.getPath());
    }
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#end_block

#method_before
public void init(String configFilePath) throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(configFilePath);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl(utilityConfiguration);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (ConnectException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (ClassNotFoundException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (SQLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#method_after
public void init(String configFilePath) throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(configFilePath);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl(utilityConfiguration);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (ConnectException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (ClassNotFoundException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (SQLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (XPathExpressionException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#end_block

#method_before
public void addDomain(String domainName, String userName, String password, String mode) throws ManageDomainsResult {
    String authMode = DEFAULT_AUTH_MODE;
    if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
        authMode = LdapAuthModeEnum.SIMPLE.name();
    } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
        authMode = LdapAuthModeEnum.GSSAPI.name();
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String domainNameEntryString = domainNameEntry.getDomainsConfigurationEntry();
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    }
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "added", domainName));
}
#method_after
public void addDomain(String domainName, String userName, String password, String mode) throws ManageDomainsResult {
    String authMode = DEFAULT_AUTH_MODE;
    if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
        authMode = LdapAuthModeEnum.SIMPLE.name();
    } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
        authMode = LdapAuthModeEnum.GSSAPI.name();
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String domainNameEntryString = domainNameEntry.getDomainsConfigurationEntry();
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else {
        System.out.println(WARNING_NOT_ADDING_PERMISSIONS);
    }
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "added", domainName));
}
#end_block

#method_before
public void editDomain(String domainName, String userName, String password, String mode) throws ManageDomainsResult {
    String authMode;
    if (mode == null) {
        authMode = getDomainAuthMode(domainName);
    } else {
        authMode = DEFAULT_AUTH_MODE;
        if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
            authMode = LdapAuthModeEnum.SIMPLE.name();
        } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
            authMode = LdapAuthModeEnum.GSSAPI.name();
        }
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String domainNameEntryString = domainNameEntry.getDomainsConfigurationEntry();
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    if (mode != null) {
        authModeEntry.setValueForDomain(domainName, authMode);
    }
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    }
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "edited", domainName));
}
#method_after
public void editDomain(String domainName, String userName, String password, String mode) throws ManageDomainsResult {
    String authMode;
    if (mode == null) {
        authMode = getDomainAuthMode(domainName);
    } else {
        authMode = DEFAULT_AUTH_MODE;
        if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
            authMode = LdapAuthModeEnum.SIMPLE.name();
        } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
            authMode = LdapAuthModeEnum.GSSAPI.name();
        }
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String domainNameEntryString = domainNameEntry.getDomainsConfigurationEntry();
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    if (mode != null) {
        authModeEntry.setValueForDomain(domainName, authMode);
    }
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else {
        System.out.println(WARNING_NOT_ADDING_PERMISSIONS);
    }
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "edited", domainName));
}
#end_block

#method_before
@Override
public void performRemove(String id) {
    StorageDomain storageDomain = getAttachedStorageDomainSubResource(id).get();
    if (storageDomain.getStorage().getType().equals(StorageType.LOCALFS.value())) {
        RemoveStorageDomainParameters params = new RemoveStorageDomainParameters(asGuid(id));
        params.setDoFormat(true);
        performAction(VdcActionType.RemoveStorageDomain, params);
    } else {
        performAction(VdcActionType.DetachStorageDomainFromPool, new DetachStorageDomainFromPoolParameters(asGuid(id), dataCenterId));
    }
}
#method_after
@Override
public Response performRemove(String id) {
    StorageDomain storageDomain = getAttachedStorageDomainSubResource(id).get();
    if (storageDomain.getStorage().getType().equals(StorageType.LOCALFS.value())) {
        RemoveStorageDomainParameters params = new RemoveStorageDomainParameters(asGuid(id));
        params.setDoFormat(true);
        return (performAction(VdcActionType.RemoveStorageDomain, params));
    } else {
        return (performAction(VdcActionType.DetachStorageDomainFromPool, new DetachStorageDomainFromPoolParameters(asGuid(id), dataCenterId)));
    }
}
#end_block

#method_before
@Test
public void testRemove() throws Exception {
    setUpGetConnection(2);
    setUpGetEntityExpectations(GUIDS[0], 2, getEntity(0));
    setUriInfo(setUpActionExpectations(VdcActionType.DetachStorageDomainFromPool, DetachStorageDomainFromPoolParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, true, true));
    collection.remove(GUIDS[0].toString());
}
#method_after
@Test
public void testRemove() throws Exception {
    setUpGetConnection(2);
    setUpGetEntityExpectations(GUIDS[0], 2, getEntity(0));
    setUriInfo(setUpActionExpectations(VdcActionType.DetachStorageDomainFromPool, DetachStorageDomainFromPoolParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
@Test
public void testRemoveLocalStorage() throws Exception {
    setUpGetConnection(2);
    setUpGetEntityExpectations(GUIDS[0], 2, getEntity(0, StorageType.LOCALFS));
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveStorageDomain, RemoveStorageDomainParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true));
    collection.remove(GUIDS[0].toString());
}
#method_after
@Test
public void testRemoveLocalStorage() throws Exception {
    setUpGetConnection(2);
    setUpGetEntityExpectations(GUIDS[0], 2, getEntity(0, StorageType.LOCALFS));
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveStorageDomain, RemoveStorageDomainParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
private boolean refreshCallBackQuery(CallBackData callBackData) {
    if (callBackData != null) {
        boolean toRemove = false;
        try {
            int refreshCyclesSinceLastPolling = callBackData.RefreshCyclesWithoutPolling.incrementAndGet();
            if (refreshCyclesSinceLastPolling < Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend)) {
                callBackData.RefreshQueries();
            } else // }
            if (refreshCyclesSinceLastPolling == Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend))
                log.warnFormat("Client did not poll async queries updates for {1} cycles, suspending server side updates for session id = {0}", callBackData.getSessionId(), Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend));
            else if (refreshCyclesSinceLastPolling > Config.<Integer>GetValue(// enough,
            ConfigValues.AsyncPollingCyclesBeforeCallbackCleanup)) // assume
            // client
            // is
            // gone
            {
                log.warnFormat("Client did not poll async queries updates for {1} cycles sessionId = {0}. Callback will be removed.", callBackData.getSessionId(), Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeCallbackCleanup));
                toRemove = true;
            }
        } catch (RuntimeException ex) {
            log.infoFormat("Communication with client has aborted sessionId = {0}. Callback will be removed.", callBackData.getSessionId());
            if (Config.<Boolean>GetValue(ConfigValues.DebugSearchLogging)) {
                log.info("Problem with refreshing callback query", ex);
            }
            toRemove = true;
        }
        if (toRemove) {
            for (Guid QueryId : callBackData.getQueryIDs()) {
                callBackData.UnregisterQuery(QueryId);
            }
        }
        return toRemove;
    }
    return false;
}
#method_after
private boolean refreshCallBackQuery(CallBackData callBackData) {
    if (callBackData != null) {
        boolean toRemove = false;
        try {
            int refreshCyclesSinceLastPolling = callBackData.RefreshCyclesWithoutPolling.incrementAndGet();
            if (refreshCyclesSinceLastPolling < Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend)) {
                callBackData.RefreshQueries();
            } else // }
            if (refreshCyclesSinceLastPolling == Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend))
                log.debugFormat("Client did not poll async queries updates for {1} cycles, suspending server side updates for session id = {0}", callBackData.getSessionId(), Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend));
            else if (refreshCyclesSinceLastPolling > Config.<Integer>GetValue(// enough,
            ConfigValues.AsyncPollingCyclesBeforeCallbackCleanup)) // assume
            // client
            // is
            // gone
            {
                log.debugFormat("Client did not poll async queries updates for {1} cycles sessionId = {0}. Callback will be removed.", callBackData.getSessionId(), Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeCallbackCleanup));
                toRemove = true;
            }
        } catch (RuntimeException ex) {
            log.infoFormat("Communication with client has aborted sessionId = {0}. Callback will be removed.", callBackData.getSessionId());
            if (Config.<Boolean>GetValue(ConfigValues.DebugSearchLogging)) {
                log.info("Problem with refreshing callback query", ex);
            }
            toRemove = true;
        }
        if (toRemove) {
            for (Guid QueryId : callBackData.getQueryIDs()) {
                callBackData.UnregisterQuery(QueryId);
            }
        }
        return toRemove;
    }
    return false;
}
#end_block

#method_before
public static SearchControls createSearchControls() {
    SearchControls searchControls = new SearchControls();
    searchControls.setSearchScope(SearchControls.OBJECT_SCOPE);
    searchControls.setReturningObjFlag(true);
    return searchControls;
}
#method_after
public static SearchControls createSearchControls() {
    SearchControls searchControls = new SearchControls();
    searchControls.setSearchScope(SearchControls.OBJECT_SCOPE);
    // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
    searchControls.setReturningObjFlag(true);
    return searchControls;
}
#end_block

#method_before
@Override
public Object run() {
    Hashtable env = new Hashtable(11);
    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.ldap.attributes.binary", "objectGUID");
    env.put(Context.SECURITY_AUTHENTICATION, "GSSAPI");
    // Send an SRV record DNS query to retrieve all the LDAP servers in the domain
    LdapSRVLocator locator = new LdapSRVLocator();
    DnsSRVResult ldapDnsResult;
    try {
        ldapDnsResult = locator.getLdapServers(domainName);
    } catch (Exception ex) {
        return KerberosUtils.convertDNSException(ex);
    }
    DirContext ctx = null;
    boolean foundUser = false;
    String currentLdapServer = null;
    if (ldapDnsResult == null || ldapDnsResult.getNumOfValidAddresses() == 0) {
        return AuthenticationResult.CANNOT_FIND_LDAP_SERVER_FOR_DOMAIN;
    }
    // Goes over all the retrieved LDAP servers
    for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
        String address = ldapDnsResult.getAddresses()[counter];
        try {
            // Constructs an LDAP url in a format of ldap://hostname:port (based on the data in the SRV record
            // This URL is not enough in order to query for user - as for querying users, we should also provide a
            // base dn, for example: ldap://hostname:389/DC=abc,DC=com . However, this URL (ldap:hostname:port)
            // suffices for
            // getting the rootDSE information, which includes the baseDN.
            URI uri = locator.constructURI("LDAP", address);
            env.put(Context.PROVIDER_URL, uri.toString());
            ctx = new InitialDirContext(env);
            // Get the base DN from rootDSE
            String domainDN = getDomainDN(ctx);
            if (domainDN != null) {
                // Append the base DN to the ldap URL in order to construct a full ldap URL (in form of
                // ldap:hostname:port/baseDN ) to query for the user
                StringBuilder ldapQueryPath = new StringBuilder(uri.toString());
                ldapQueryPath.append("/").append(domainDN);
                SearchControls controls = new SearchControls();
                controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
                controls.setReturningObjFlag(true);
                currentLdapServer = ldapQueryPath.toString();
                env.put(Context.PROVIDER_URL, currentLdapServer);
                // Run the LDAP query to get the user
                ctx = new InitialDirContext(env);
                NamingEnumeration<SearchResult> answer = executeQuery(ctx, controls, prepareQuery());
                while (answer.hasMoreElements()) {
                    // Print the objectGUID for the user
                    userGuid.append(guidFromResults(answer.next()));
                    log.debug("User guid is: " + userGuid.toString());
                    foundUser = true;
                    return AuthenticationResult.OK;
                }
                System.out.println("No user in Directory was found for " + userName + ". Trying next LDAP server in list");
            } else {
                System.out.println(InstallerConstants.ERROR_PREFIX + " Failed to query rootDSE in order to get the baseDN. Could not query for user " + userName + " in domain" + domainName);
            }
        } catch (CommunicationException ex) {
            System.out.println("Cannot connect to LDAP URL: " + currentLdapServer + ". Trying next LDAP server in list (if exists)");
        } catch (AuthenticationException ex) {
            ex.printStackTrace();
            AuthenticationResult result = AuthenticationResult.OTHER;
            KerberosReturnCodeParser parser = new KerberosReturnCodeParser();
            result = parser.parse(ex.toString());
            String errorMsg = result.getDetailedMessage().replace("Authentication Failed", "LDAP query Failed");
            System.out.println(InstallerConstants.ERROR_PREFIX + errorMsg);
        } catch (Exception ex) {
            System.out.println("General error has occured" + ex.getMessage());
            ex.printStackTrace();
            break;
        } finally {
            if (ctx != null) {
                try {
                    ctx.close();
                } catch (NamingException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
    return AuthenticationResult.NO_USER_INFORMATION_WAS_FOUND_FOR_USER;
}
#method_after
@Override
public Object run() {
    Hashtable env = new Hashtable(11);
    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.ldap.attributes.binary", "objectGUID");
    env.put(Context.SECURITY_AUTHENTICATION, "GSSAPI");
    // Send an SRV record DNS query to retrieve all the LDAP servers in the domain
    LdapSRVLocator locator = new LdapSRVLocator();
    DnsSRVResult ldapDnsResult;
    try {
        ldapDnsResult = locator.getLdapServers(domainName);
    } catch (Exception ex) {
        return KerberosUtils.convertDNSException(ex);
    }
    DirContext ctx = null;
    String currentLdapServer = null;
    if (ldapDnsResult == null || ldapDnsResult.getNumOfValidAddresses() == 0) {
        return AuthenticationResult.CANNOT_FIND_LDAP_SERVER_FOR_DOMAIN;
    }
    // Goes over all the retrieved LDAP servers
    for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
        String address = ldapDnsResult.getAddresses()[counter];
        try {
            // Constructs an LDAP url in a format of ldap://hostname:port (based on the data in the SRV record
            // This URL is not enough in order to query for user - as for querying users, we should also provide a
            // base dn, for example: ldap://hostname:389/DC=abc,DC=com . However, this URL (ldap:hostname:port)
            // suffices for
            // getting the rootDSE information, which includes the baseDN.
            URI uri = locator.constructURI("LDAP", address);
            env.put(Context.PROVIDER_URL, uri.toString());
            ctx = new InitialDirContext(env);
            // Get the base DN from rootDSE
            String domainDN = getDomainDN(ctx);
            if (domainDN != null) {
                // Append the base DN to the ldap URL in order to construct a full ldap URL (in form of
                // ldap:hostname:port/baseDN ) to query for the user
                StringBuilder ldapQueryPath = new StringBuilder(uri.toString());
                ldapQueryPath.append("/").append(domainDN);
                SearchControls controls = new SearchControls();
                controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
                // Adding all the three attributes possible, as RHDS doesn't return the nsUniqueId by default
                controls.setReturningAttributes(new String[] { "nsUniqueId", "ipaUniqueId", "objectGuid" });
                // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
                controls.setReturningObjFlag(true);
                currentLdapServer = ldapQueryPath.toString();
                env.put(Context.PROVIDER_URL, currentLdapServer);
                // Run the LDAP query to get the user
                ctx = new InitialDirContext(env);
                NamingEnumeration<SearchResult> answer = executeQuery(ctx, controls, prepareQuery());
                while (answer.hasMoreElements()) {
                    // Print the objectGUID for the user
                    userGuid.append(guidFromResults(answer.next()));
                    log.debug("User guid is: " + userGuid.toString());
                    return AuthenticationResult.OK;
                }
                System.out.println("No user in Directory was found for " + userName + ". Trying next LDAP server in list");
            } else {
                System.out.println(InstallerConstants.ERROR_PREFIX + " Failed to query rootDSE in order to get the baseDN. Could not query for user " + userName + " in domain" + domainName);
            }
        } catch (CommunicationException ex) {
            System.out.println("Cannot connect to LDAP URL: " + currentLdapServer + ". Trying next LDAP server in list (if exists)");
        } catch (AuthenticationException ex) {
            ex.printStackTrace();
            AuthenticationResult result = AuthenticationResult.OTHER;
            KerberosReturnCodeParser parser = new KerberosReturnCodeParser();
            result = parser.parse(ex.toString());
            String errorMsg = result.getDetailedMessage().replace("Authentication Failed", "LDAP query Failed");
            System.out.println(InstallerConstants.ERROR_PREFIX + errorMsg);
        } catch (Exception ex) {
            System.out.println("General error has occured" + ex.getMessage());
            ex.printStackTrace();
            break;
        } finally {
            if (ctx != null) {
                try {
                    ctx.close();
                } catch (NamingException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
    return AuthenticationResult.NO_USER_INFORMATION_WAS_FOUND_FOR_USER;
}
#end_block

#method_before
private String guidFromResults(SearchResult sr) throws NamingException {
    String guidString = "";
    if (isIPA) {
        String ipaUniqueId = (String) sr.getAttributes().get("ipaUniqueId").get();
        guidString += ipaUniqueId;
    } else {
        Object objectGuid = sr.getAttributes().get("objectGUID").get();
        byte[] guid = (byte[]) objectGuid;
        guidString += ((new org.ovirt.engine.core.compat.Guid(guid, false)).toString());
    }
    return guidString;
}
#method_after
private String guidFromResults(SearchResult sr) throws NamingException {
    String guidString = "";
    if (ldapProviderType.equals(LdapProviderType.ipa)) {
        String ipaUniqueId = (String) sr.getAttributes().get("ipaUniqueId").get();
        guidString += ipaUniqueId;
    } else if (ldapProviderType.equals(LdapProviderType.rhds)) {
        String nsUniqueId = (String) sr.getAttributes().get("nsUniqueId").get();
        guidString += RHDSUserContextMapper.getGuidFromNsUniqueId(nsUniqueId);
    } else {
        Object objectGuid = sr.getAttributes().get("objectGUID").get();
        byte[] guid = (byte[]) objectGuid;
        guidString += ((new org.ovirt.engine.core.compat.Guid(guid, false)).toString());
    }
    return guidString;
}
#end_block

#method_before
private String prepareQuery() {
    String query;
    if (isIPA) {
        userName = userName.split("@")[0];
        query = "(&(objectClass=posixAccount)(objectClass=krbPrincipalAux)(uid=" + userName + "))";
    } else {
        StringBuilder queryBase = new StringBuilder("(&(sAMAccountType=805306368)(");
        if (userName.contains("@")) {
            queryBase.append("userPrincipalName=" + userName);
        } else {
            if (userName.length() > 20) {
                queryBase.append("userPrincipalName=").append(userName).append("@").append(domainName.toUpperCase());
            } else {
                queryBase.append("sAMAccountName=").append(userName);
            }
        }
        query = queryBase.append("))").toString();
    }
    return query;
}
#method_after
private String prepareQuery() {
    String query;
    if (ldapProviderType.equals(LdapProviderType.ipa)) {
        userName = userName.split("@")[0];
        query = "(&(objectClass=posixAccount)(objectClass=krbPrincipalAux)(uid=" + userName + "))";
    } else if (ldapProviderType.equals(LdapProviderType.rhds)) {
        userName = userName.split("@")[0];
        query = "(&(objectClass=person)(uid=" + userName + "))";
    } else {
        StringBuilder queryBase = new StringBuilder("(&(sAMAccountType=805306368)(");
        if (userName.contains("@")) {
            queryBase.append("userPrincipalName=" + userName);
        } else {
            if (userName.length() > 20) {
                queryBase.append("userPrincipalName=").append(userName).append("@").append(domainName.toUpperCase());
            } else {
                queryBase.append("sAMAccountName=").append(userName);
            }
        }
        query = queryBase.append("))").toString();
    }
    return query;
}
#end_block

#method_before
private String getDomainDN(DirContext ctx) throws NamingException {
    // Queries the rootDSE and get the "defaultNamingContext" attribute value -
    // this attribute will be a part of the LDAP URL to perform users queries (i.e - search for a user)
    SearchControls controls = RootDSEQueryInfo.createSearchControls();
    String query = RootDSEQueryInfo.ROOT_DSE_LDAP_QUERY;
    NamingEnumeration<SearchResult> searchResults = executeQuery(ctx, controls, query);
    // The information on base DN is located in the attribute "defaultNamingContext"
    while (searchResults.hasMoreElements()) {
        SearchResult searchResult = searchResults.nextElement();
        Attributes attributes = searchResult.getAttributes();
        Attribute attribute = attributes.get(RootDSEQueryInfo.DEFAULT_NAMING_CONTEXT_RESULT_ATTRIBUTE);
        if (attribute != null) {
            String domainDN = (String) attribute.get();
            return domainDN;
        } else {
            Attribute ipaAttribute = attributes.get(RootDSEQueryInfo.NAMING_CONTEXTS_RESULT_ATTRIBUTE);
            if (ipaAttribute != null) {
                isIPA = true;
                String domainDN = (String) ipaAttribute.get(0);
                return domainDN;
            }
            return null;
        }
    }
    return null;
}
#method_after
private String getDomainDN(DirContext ctx) throws NamingException {
    RootDSEData rootDSEData = new RootDSEData(ctx);
    ldapProviderType = rootDSEData.getLdapProviderType();
    return rootDSEData.getDomainDN();
}
#end_block

#method_before
@Override
public List call() throws Exception {
    ContextMapperCallbackHandler cmCallback = new NotNullContextMapperCallbackHandler(queryExecution.getContextMapper());
    SearchControls controls = new SearchControls();
    if (queryExecution.getReturningAttributes() != null) {
        controls.setReturningAttributes(queryExecution.getReturningAttributes());
    }
    controls.setSearchScope(queryExecution.getSearchScope());
    controls.setCountLimit(resultcount);
    controls.setReturningObjFlag(true);
    ldapTemplate.search("", queryExecution.getFilter(), queryExecution.getDisplayFilter(), controls, cmCallback);
    return cmCallback.getList();
}
#method_after
@Override
public List call() throws Exception {
    ContextMapperCallbackHandler cmCallback = new NotNullContextMapperCallbackHandler(queryExecution.getContextMapper());
    SearchControls controls = new SearchControls();
    if (queryExecution.getReturningAttributes() != null) {
        controls.setReturningAttributes(queryExecution.getReturningAttributes());
    }
    controls.setSearchScope(queryExecution.getSearchScope());
    controls.setCountLimit(resultcount);
    // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
    controls.setReturningObjFlag(true);
    ldapTemplate.search("", queryExecution.getFilter(), queryExecution.getDisplayFilter(), controls, cmCallback);
    return cmCallback.getList();
}
#end_block

#method_before
private List<Class<?>> discoverClasses(String packageName) {
    List<Class<?>> ret = new ArrayList<Class<?>>();
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    try {
        Enumeration<URL> resources = classLoader.getResources(toPath(packageName));
        List<File> dirs = new ArrayList<File>();
        List<JarInputStream> jars = new ArrayList<JarInputStream>();
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            if (isJar(resource)) {
                jars.add(new JarInputStream(resource.openStream()));
            } else if (containsJar(resource)) {
                jars.add(getContainingResource(classLoader, resource));
            } else {
                dirs.add(new File(resource.getFile()));
            }
        }
        walkJars(ret, packageName, jars);
        walkDirs(ret, packageName, dirs);
    } catch (Exception e) {
        ret = Collections.emptyList();
    }
    return ret;
}
#method_after
private List<Class<?>> discoverClasses(String packageName) {
    List<Class<?>> ret = new ArrayList<Class<?>>();
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    try {
        Enumeration<URL> resources = classLoader.getResources(toPath(packageName));
        List<File> dirs = new ArrayList<File>();
        List<JarInputStream> jars = new ArrayList<JarInputStream>();
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            if (isJar(resource)) {
                jars.add(new JarInputStream(new FileInputStream(getJarName(resource))));
            } else if (containsJar(resource)) {
                jars.add(getContainingResource(classLoader, resource));
            } else {
                dirs.add(new File(resource.getFile()));
            }
        }
        walkJars(ret, packageName, jars);
        walkDirs(ret, packageName, dirs);
    } catch (Exception e) {
        ret = Collections.emptyList();
    }
    return ret;
}
#end_block

#method_before
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        searchControls.setReturningObjFlag(true);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#method_after
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#end_block

#method_before
public LdapProviderType retrieveLdapProviderType(String domain) {
    Attributes attributes = getDomainAttributes(LdapProviderType.general, domain);
    if (attributes != null) {
        if (attributes.get(ADRootDSEAttributes.domainControllerFunctionality.name()) != null) {
            return LdapProviderType.activeDirectory;
        } else {
            return LdapProviderType.ipa;
        }
    } else {
        return LdapProviderType.general;
    }
}
#method_after
public LdapProviderType retrieveLdapProviderType(String domain) {
    LdapProviderType retVal = LdapProviderType.general;
    Attributes attributes = getDomainAttributes(LdapProviderType.general, domain);
    if (attributes != null) {
        if (attributes.get(ADRootDSEAttributes.domainControllerFunctionality.name()) != null) {
            retVal = LdapProviderType.activeDirectory;
        } else if (attributes.get(RHDSRootDSEAttributes.netscapemdsuffix.name()) != null) {
            retVal = LdapProviderType.rhds;
        } else if (attributes.get(IPARootDSEAttributes.namingContexts.name()) != null) {
            retVal = LdapProviderType.ipa;
        }
    }
    return retVal;
}
#end_block

#method_before
@Test
public void canDoActionSucceedsOnDiskDomainCheckWhenStorageGuidInParamsMismatches() throws Exception {
    Guid storageId = Guid.NewGuid();
    initializeCommand(storageId);
    mockVmWithDisk(Guid.NewGuid());
    mockVmNetworks();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    doReturn(storageDomainStaticDAO).when(command).getStorageDomainStaticDao();
    assertTrue(command.canDoAction());
    assertFalse(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_DOMAIN_MISMATCH.toString()));
}
#method_after
@Test
public void canDoActionSucceedsOnDiskDomainCheckWhenStorageGuidInParamsMismatches() throws Exception {
    Guid storageId = Guid.NewGuid();
    initializeCommand(storageId);
    mockVmWithDisk(Guid.NewGuid());
    mockVmNetworks();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    doReturn(storageDomainStaticDAO).when(command).getStorageDomainStaticDao();
    assertTrue(command.canDoAction());
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (diskImage.getstorage_id() != null && !diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams);
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams);
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValueBase;
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // execute StopVds action
    returnValueBase = executeStopVdsFenceAction(vdsId, sessionId);
    if (returnValueBase.getSucceeded()) {
        executeFenceVdsManulalyAction(vdsId, sessionId);
        // execute StartVds action
        returnValueBase = executeStartVdsFenceAction(vdsId, sessionId);
        setSucceeded(returnValueBase.getSucceeded());
        setFencingSucceeded(getSucceeded());
    } else {
        setSucceeded(false);
    }
}
#method_after
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValueBase;
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // execute StopVds action
    returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Stop, VdcActionType.StopVds);
    if (returnValueBase.getSucceeded()) {
        executeFenceVdsManulalyAction(vdsId, sessionId);
        // execute StartVds action
        returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Start, VdcActionType.StartVds);
        setSucceeded(returnValueBase.getSucceeded());
        setFencingSucceeded(getSucceeded());
    } else {
        setSucceeded(false);
    }
}
#end_block

#method_before
private void AddDefaultNetworks() {
    network net = new network();
    net.setId(Guid.NewGuid());
    net.setname(Config.<String>GetValue(ConfigValues.managementNetwork));
    net.setdescription(AddVdsGroupCommand.DefaultNetworkDescription);
    net.setstorage_pool_id(getStoragePool().getId());
    DbFacade.getInstance().getNetworkDAO().save(net);
}
#method_after
private void AddDefaultNetworks() {
    network net = new network();
    net.setId(Guid.NewGuid());
    net.setname(Config.<String>GetValue(ConfigValues.ManagementNetwork));
    net.setdescription(AddVdsGroupCommand.DefaultNetworkDescription);
    net.setstorage_pool_id(getStoragePool().getId());
    DbFacade.getInstance().getNetworkDAO().save(net);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // to prevent cases where low utilization > high utilization due to specific configuration defaults
    if (getVdsGroup().gethigh_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION || getVdsGroup().getlow_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION) {
        VdsSelectionAlgorithm selectionAlgorithm;
        try {
            selectionAlgorithm = VdsSelectionAlgorithm.valueOf(Config.<String>GetValue(ConfigValues.VdsSelectionAlgorithm));
        } catch (java.lang.Exception e) {
            selectionAlgorithm = VdsSelectionAlgorithm.None;
        }
        if (selectionAlgorithm == VdsSelectionAlgorithm.EvenlyDistribute) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute));
        } else if (selectionAlgorithm == VdsSelectionAlgorithm.PowerSave) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave));
        }
    }
    if (getVdsGroup().getcpu_over_commit_duration_minutes() == -1) {
        getVdsGroup().setcpu_over_commit_duration_minutes(Config.<Integer>GetValue(ConfigValues.CpuOverCommitDurationMinutes));
    }
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDAO().save(getVdsGroup());
    // add default network
    if (getParameters().getVdsGroup().getstorage_pool_id() != null) {
        final String networkName = Config.<String>GetValue(ConfigValues.managementNetwork);
        List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForDataCenter(getParameters().getVdsGroup().getstorage_pool_id().getValue());
        // network net = null; //LINQ 31899 networks.FirstOrDefault(n =>
        // n.name == networkName);
        network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

            @Override
            public boolean eval(network network) {
                return network.getname().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDAO().save(new network_cluster(getParameters().getVdsGroup().getID(), net.getId(), NetworkStatus.Operational.getValue(), false));
        }
    }
    setActionReturnValue(getVdsGroup().getID());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // to prevent cases where low utilization > high utilization due to specific configuration defaults
    if (getVdsGroup().gethigh_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION || getVdsGroup().getlow_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION) {
        VdsSelectionAlgorithm selectionAlgorithm;
        try {
            selectionAlgorithm = VdsSelectionAlgorithm.valueOf(Config.<String>GetValue(ConfigValues.VdsSelectionAlgorithm));
        } catch (java.lang.Exception e) {
            selectionAlgorithm = VdsSelectionAlgorithm.None;
        }
        if (selectionAlgorithm == VdsSelectionAlgorithm.EvenlyDistribute) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute));
        } else if (selectionAlgorithm == VdsSelectionAlgorithm.PowerSave) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave));
        }
    }
    if (getVdsGroup().getcpu_over_commit_duration_minutes() == -1) {
        getVdsGroup().setcpu_over_commit_duration_minutes(Config.<Integer>GetValue(ConfigValues.CpuOverCommitDurationMinutes));
    }
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDAO().save(getVdsGroup());
    // add default network
    if (getParameters().getVdsGroup().getstorage_pool_id() != null) {
        final String networkName = Config.<String>GetValue(ConfigValues.ManagementNetwork);
        List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForDataCenter(getParameters().getVdsGroup().getstorage_pool_id().getValue());
        // network net = null; //LINQ 31899 networks.FirstOrDefault(n =>
        // n.name == networkName);
        network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

            @Override
            public boolean eval(network network) {
                return network.getname().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDAO().save(new network_cluster(getParameters().getVdsGroup().getID(), net.getId(), NetworkStatus.Operational.getValue(), false));
        }
    }
    setActionReturnValue(getVdsGroup().getID());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAll();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__NETWORK);
    if (getStoragePool() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
        return false;
    }
    // check that network name not start with 'bond'
    if (getParameters().getNetwork().getname().toLowerCase().startsWith("bond")) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CONTAIN_BOND_NAME);
        return false;
    }
    // check vlan is valid
    if (getParameters().getNetwork().getvlan_id() != null) {
        if (!AddNetworkCommand.IsVlanInRange(getParameters().getNetwork().getvlan_id())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_VLAN_OUT_OF_RANGE);
            return false;
        } else // //LINQ && n.id != AddNetworkParameters.Network.id) != null)
        if (null != LinqUtils.firstOrNull(networks, new Predicate<network>() {

            @Override
            public boolean eval(network n) {
                if (n.getvlan_id() != null) {
                    return n.getvlan_id().equals(getParameters().getNetwork().getvlan_id()) && n.getstorage_pool_id().equals(getParameters().getNetwork().getstorage_pool_id()) && !n.getId().equals(getParameters().getNetwork().getId());
                }
                return false;
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_VLAN_IN_USE);
            return false;
        }
    }
    // check that network not exsits
    // network oldNetwork = null; //LINQ networks.FirstOrDefault(n => n.id
    // == AddNetworkParameters.Network.id);
    network oldNetwork = LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getId().equals(getParameters().getNetwork().getId());
        }
    });
    if (oldNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_NOT_EXISTS);
        return false;
    }
    // check defalut network name is not renamed
    String defaultNetwork = Config.<String>GetValue(ConfigValues.managementNetwork);
    if (oldNetwork.getname().equals(defaultNetwork) && !getParameters().getNetwork().getname().equals(defaultNetwork)) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CAN_NOT_REMOVE_DEFAULT_NETWORK);
        return false;
    }
    // network net = null; //LINQ networks.FirstOrDefault(n =>
    // n.name.Trim().ToLower() ==
    // AddNetworkParameters.Network.name.Trim().ToLower()
    // LINQ && n.id != AddNetworkParameters.Network.id &&
    // AddNetworkParameters.Network.storage_pool_id == n.storage_pool_id);
    network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getname().trim().toLowerCase().equals(getParameters().getNetwork().getname().trim().toLowerCase()) && !n.getId().equals(getParameters().getNetwork().getId()) && getParameters().getNetwork().getstorage_pool_id().equals(n.getstorage_pool_id());
        }
    });
    if (net != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_IN_USE);
        return false;
    }
    // check if the network in use with running vm
    _clusters = DbFacade.getInstance().getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
    for (VDSGroup cluster : _clusters) {
        List<VmStatic> vms = DbFacade.getInstance().getVmStaticDAO().getAllByGroupAndNetworkName(cluster.getID(), getParameters().getNetwork().getname());
        if (vms.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
            return false;
        }
    }
    return RemoveNetworkCommand.CommonNetworkValidation(oldNetwork, getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAll();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__NETWORK);
    if (getStoragePool() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
        return false;
    }
    // check that network name not start with 'bond'
    if (getParameters().getNetwork().getname().toLowerCase().startsWith("bond")) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CONTAIN_BOND_NAME);
        return false;
    }
    // check vlan is valid
    if (getParameters().getNetwork().getvlan_id() != null) {
        if (!AddNetworkCommand.IsVlanInRange(getParameters().getNetwork().getvlan_id())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_VLAN_OUT_OF_RANGE);
            return false;
        } else // //LINQ && n.id != AddNetworkParameters.Network.id) != null)
        if (null != LinqUtils.firstOrNull(networks, new Predicate<network>() {

            @Override
            public boolean eval(network n) {
                if (n.getvlan_id() != null) {
                    return n.getvlan_id().equals(getParameters().getNetwork().getvlan_id()) && n.getstorage_pool_id().equals(getParameters().getNetwork().getstorage_pool_id()) && !n.getId().equals(getParameters().getNetwork().getId());
                }
                return false;
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_VLAN_IN_USE);
            return false;
        }
    }
    // check that network not exsits
    // network oldNetwork = null; //LINQ networks.FirstOrDefault(n => n.id
    // == AddNetworkParameters.Network.id);
    network oldNetwork = LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getId().equals(getParameters().getNetwork().getId());
        }
    });
    if (oldNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_NOT_EXISTS);
        return false;
    }
    // check defalut network name is not renamed
    String defaultNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    if (oldNetwork.getname().equals(defaultNetwork) && !getParameters().getNetwork().getname().equals(defaultNetwork)) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CAN_NOT_REMOVE_DEFAULT_NETWORK);
        return false;
    }
    // network net = null; //LINQ networks.FirstOrDefault(n =>
    // n.name.Trim().ToLower() ==
    // AddNetworkParameters.Network.name.Trim().ToLower()
    // LINQ && n.id != AddNetworkParameters.Network.id &&
    // AddNetworkParameters.Network.storage_pool_id == n.storage_pool_id);
    network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getname().trim().toLowerCase().equals(getParameters().getNetwork().getname().trim().toLowerCase()) && !n.getId().equals(getParameters().getNetwork().getId()) && getParameters().getNetwork().getstorage_pool_id().equals(n.getstorage_pool_id());
        }
    });
    if (net != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_IN_USE);
        return false;
    }
    // check if the network in use with running vm
    _clusters = DbFacade.getInstance().getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
    for (VDSGroup cluster : _clusters) {
        List<VmStatic> vms = DbFacade.getInstance().getVmStaticDAO().getAllByGroupAndNetworkName(cluster.getID(), getParameters().getNetwork().getname());
        if (vms.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
            return false;
        }
    }
    return RemoveNetworkCommand.CommonNetworkValidation(oldNetwork, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // YAIRPOSTGRES - this code should be split to several blocks of run in new transaction + set states
    VDSGroup oldGroup = DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getVdsGroup().getID());
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id()) || oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null) {
        for (VdsStatic vds : DbFacade.getInstance().getVdsStaticDAO().getAllForVdsGroup(oldGroup.getID())) {
            VdsActionParameters parameters = new VdsActionParameters(vds.getId());
            if (oldGroup.getstorage_pool_id() != null) {
                VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, parameters);
                if (!removeVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
                    return;
                }
            }
            if (getVdsGroup().getstorage_pool_id() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVdsGroup().getID());
    boolean exists = false;
    for (network net : networks) {
        if (StringHelper.EqOp(net.getname(), Config.<String>GetValue(ConfigValues.managementNetwork))) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getstorage_pool_id() != null) {
            List<network> storagePoolNets = DbFacade.getInstance().getNetworkDAO().getAllForDataCenter(getVdsGroup().getstorage_pool_id().getValue());
            for (network net : storagePoolNets) {
                if (StringHelper.EqOp(net.getname(), Config.<String>GetValue(ConfigValues.managementNetwork))) {
                    DbFacade.getInstance().getNetworkClusterDAO().save(new network_cluster(getVdsGroup().getID(), net.getId(), NetworkStatus.Operational.getValue(), true));
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // YAIRPOSTGRES - this code should be split to several blocks of run in new transaction + set states
    VDSGroup oldGroup = DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getVdsGroup().getID());
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id()) || oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null) {
        for (VdsStatic vds : DbFacade.getInstance().getVdsStaticDAO().getAllForVdsGroup(oldGroup.getID())) {
            VdsActionParameters parameters = new VdsActionParameters(vds.getId());
            if (oldGroup.getstorage_pool_id() != null) {
                VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, parameters);
                if (!removeVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
                    return;
                }
            }
            if (getVdsGroup().getstorage_pool_id() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVdsGroup().getID());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (network net : networks) {
        if (StringHelper.EqOp(net.getname(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getstorage_pool_id() != null) {
            List<network> storagePoolNets = DbFacade.getInstance().getNetworkDAO().getAllForDataCenter(getVdsGroup().getstorage_pool_id().getValue());
            for (network net : storagePoolNets) {
                if (StringHelper.EqOp(net.getname(), managementNetwork)) {
                    DbFacade.getInstance().getNetworkClusterDAO().save(new network_cluster(getVdsGroup().getID(), net.getId(), NetworkStatus.Operational.getValue(), true));
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // check that we are not removing the management network
    if (StringHelper.EqOp(getParameters().getNetwork().getname(), Config.<String>GetValue(ConfigValues.managementNetwork))) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK);
        return false;
    }
    // check that there is no vm running with this network
    List<VmStatic> vms = DbFacade.getInstance().getVmStaticDAO().getAllByGroupAndNetworkName(getParameters().getVdsGroupId(), getParameters().getNetwork().getname());
    if (vms.size() > 0) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_VM);
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", getParameters().getNetwork().getname()));
        return false;
    }
    // chech that no template is using this network
    List<VmTemplate> templates = DbFacade.getInstance().getVmTemplateDAO().getAllForVdsGroup(getParameters().getVdsGroupId());
    for (VmTemplate tmpl : templates) {
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(tmpl.getId());
        // != null)
        if (LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

            @Override
            public boolean eval(VmNetworkInterface t) {
                return t.getNetworkName().equals(getParameters().getNetwork().getname());
            }
        }) != null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_TEMPLATE);
            return false;
        }
    }
    // check if network in use by vm
    String query = "Vms: cluster = " + getVdsGroup().getname();
    SearchParameters searchParams = new SearchParameters(query, SearchType.VM);
    searchParams.setMaxCount(Integer.MAX_VALUE);
    VdcQueryReturnValue tempVar = Backend.getInstance().runInternalQuery(VdcQueryType.Search, searchParams);
    SearchReturnValue ret = (SearchReturnValue) ((tempVar instanceof SearchReturnValue) ? tempVar : null);
    if (ret != null && ret.getSucceeded()) {
        List<IVdcQueryable> vmList = (List<IVdcQueryable>) ret.getReturnValue();
        for (IVdcQueryable vm_helper : vmList) {
            VM vm = (VM) vm_helper;
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getvm_guid());
            // Interface iface = null; //LINQ interfaces.FirstOrDefault(i =>
            // i.network_name ==
            // AttachNetworkToClusterParameter.Network.name);
            VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

                @Override
                public boolean eval(VmNetworkInterface i) {
                    return i.getNetworkName().equals(getParameters().getNetwork().getname());
                }
            });
            if (iface != null) {
                addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
                return false;
            }
        }
    }
    if (getParameters().getNetwork().getname().equals(NetworkUtils.EngineNetwork)) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.NETWORK_DEFAULT_UPDATE_NAME_INVALID.toString());
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // check that we are not removing the management network
    if (StringHelper.EqOp(getParameters().getNetwork().getname(), Config.<String>GetValue(ConfigValues.ManagementNetwork))) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK);
        return false;
    }
    // check that there is no vm running with this network
    List<VmStatic> vms = DbFacade.getInstance().getVmStaticDAO().getAllByGroupAndNetworkName(getParameters().getVdsGroupId(), getParameters().getNetwork().getname());
    if (vms.size() > 0) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_VM);
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", getParameters().getNetwork().getname()));
        return false;
    }
    // chech that no template is using this network
    List<VmTemplate> templates = DbFacade.getInstance().getVmTemplateDAO().getAllForVdsGroup(getParameters().getVdsGroupId());
    for (VmTemplate tmpl : templates) {
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(tmpl.getId());
        // != null)
        if (LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

            @Override
            public boolean eval(VmNetworkInterface t) {
                return t.getNetworkName().equals(getParameters().getNetwork().getname());
            }
        }) != null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_TEMPLATE);
            return false;
        }
    }
    // check if network in use by vm
    String query = "Vms: cluster = " + getVdsGroup().getname();
    SearchParameters searchParams = new SearchParameters(query, SearchType.VM);
    searchParams.setMaxCount(Integer.MAX_VALUE);
    VdcQueryReturnValue tempVar = Backend.getInstance().runInternalQuery(VdcQueryType.Search, searchParams);
    SearchReturnValue ret = (SearchReturnValue) ((tempVar instanceof SearchReturnValue) ? tempVar : null);
    if (ret != null && ret.getSucceeded()) {
        List<IVdcQueryable> vmList = (List<IVdcQueryable>) ret.getReturnValue();
        for (IVdcQueryable vm_helper : vmList) {
            VM vm = (VM) vm_helper;
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getvm_guid());
            // Interface iface = null; //LINQ interfaces.FirstOrDefault(i =>
            // i.network_name ==
            // AttachNetworkToClusterParameter.Network.name);
            VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

                @Override
                public boolean eval(VmNetworkInterface i) {
                    return i.getNetworkName().equals(getParameters().getNetwork().getname());
                }
            });
            if (iface != null) {
                addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
                return false;
            }
        }
    }
    if (getParameters().getNetwork().getname().equals(NetworkUtils.EngineNetwork)) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.NETWORK_DEFAULT_UPDATE_NAME_INVALID.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
synchronized private Set<Guid> removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<Guid>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<Guid>();
    Map<Guid, SPMAsyncTask> activeTaskMap = new HashMap<Guid, SPMAsyncTask>();
    boolean isShouldBeUpdated = false;
    for (SPMAsyncTask task : _tasks.values()) {
        if (!CachingOver(task)) {
            activeTaskMap.put(task.getTaskID(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            isShouldBeUpdated = true;
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (isShouldBeUpdated) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    return poolsOfClearedAndOldTasks;
}
#method_after
synchronized private Set<Guid> removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<Guid>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<Guid>();
    Map<Guid, SPMAsyncTask> activeTaskMap = new HashMap<Guid, SPMAsyncTask>();
    for (SPMAsyncTask task : _tasks.values()) {
        if (!CachingOver(task)) {
            activeTaskMap.put(task.getTaskID(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (poolsOfClearedAndOldTasks.size() > 0) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    return poolsOfClearedAndOldTasks;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getvds_id().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    model.setStorageManager(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    if (entity.getcpu_cores() != null) {
        CpuTopology cpuTopology = new CpuTopology();
        cpuTopology.setCores(entity.getcpu_cores());
        cpu.setTopology(cpuTopology);
    }
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE);
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getvds_id().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    model.setStorageManager(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    if (entity.getcpu_cores() != null) {
        CpuTopology cpuTopology = new CpuTopology();
        cpuTopology.setCores(entity.getcpu_cores());
        cpuTopology.setSockets(entity.getcpu_sockets());
        cpu.setTopology(cpuTopology);
    }
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE);
    return model;
}
#end_block

#method_before
@Test
public void testCpuMapping() {
    VDS vds = new VDS();
    vds.setvds_id(Guid.Empty);
    vds.setcpu_cores(2);
    vds.setcpu_model("some cpu model");
    vds.setcpu_speed_mh(5.5);
    Host host = HostMapper.map(vds, (Host) null);
    assertNotNull(host.getCpu());
    assertEquals(new Integer(host.getCpu().getTopology().getCores()), new Integer(2));
    assertEquals(host.getCpu().getName(), "some cpu model");
    assertEquals(host.getCpu().getSpeed(), new BigDecimal(5.5));
}
#method_after
@Test
public void testCpuMapping() {
    VDS vds = new VDS();
    vds.setvds_id(Guid.Empty);
    vds.setcpu_cores(2);
    vds.setcpu_sockets(3);
    vds.setcpu_model("some cpu model");
    vds.setcpu_speed_mh(5.5);
    Host host = HostMapper.map(vds, (Host) null);
    assertNotNull(host.getCpu());
    assertEquals(new Integer(host.getCpu().getTopology().getCores()), new Integer(2));
    assertEquals(new Integer(host.getCpu().getTopology().getSockets()), new Integer(3));
    assertEquals(host.getCpu().getName(), "some cpu model");
    assertEquals(host.getCpu().getSpeed(), new BigDecimal(5.5));
}
#end_block

#method_before
protected static <T> List<T> merge(List<T> list, List<T> items) {
    List<T> returnValue = list;
    if (list != null) {
        if (items != null) {
            for (T item : items) {
                if (!returnValue.contains(item)) {
                    returnValue.add(item);
                }
            }
        }
    } else {
        returnValue = items;
    }
    return returnValue;
}
#method_after
protected static <T> List<T> merge(List<T> list, List<T> items) {
    if (list != null) {
        if (items != null) {
            for (T item : items) {
                if (!list.contains(item)) {
                    list.add(item);
                }
            }
        }
    } else {
        return items;
    }
    return list;
}
#end_block

#method_before
@Override
public boolean acquireLock(EngineLock lock) {
    try {
        globalLock.lock();
        return acquireLockInternal(lock);
    } finally {
        globalLock.unlock();
    }
}
#method_after
@Override
public boolean acquireLock(EngineLock lock) {
    log.debugFormat("Before acquiring lock {0}", lock);
    globalLock.lock();
    try {
        return acquireLockInternal(lock);
    } finally {
        globalLock.unlock();
    }
}
#end_block

#method_before
@Override
public void acquireLockWait(EngineLock lock) {
    try {
        globalLock.lock();
        while (!acquireLockInternal(lock)) {
            releasedLock.await();
        }
    } catch (InterruptedException e) {
        releasedLock.signal();
    } finally {
        globalLock.unlock();
    }
}
#method_after
@Override
public void acquireLockWait(EngineLock lock) {
    log.debugFormat("Before acquiring and wait lock {0}", lock);
    globalLock.lock();
    try {
        boolean firstRun = true;
        while (!acquireLockInternal(lock)) {
            // In case of first try, just wait
            if (firstRun) {
                firstRun = false;
            } else {
                // This is a second try, we did not successes, but possible that release signal for other waiting thread
                // so try to signal to other thread
                releasedLock.signal();
            }
            releasedLock.await();
        }
    } catch (InterruptedException e) {
        releasedLock.signal();
    } finally {
        globalLock.unlock();
    }
}
#end_block

#method_before
@Override
public void releaseLock(EngineLock lock) {
    try {
        globalLock.lock();
        if (lock.getUpdateRegions() != null) {
            for (Entry<String, Guid> entry : lock.getUpdateRegions().entrySet()) {
                releaseUpdateLock(buildHashMapKey(entry));
            }
        }
        if (lock.getLockedRegions() != null) {
            for (Entry<String, Guid> entry : lock.getLockedRegions().entrySet()) {
                releaseLockedLock(buildHashMapKey(entry));
            }
        }
        releasedLock.signal();
    } finally {
        globalLock.unlock();
    }
}
#method_after
@Override
public void releaseLock(EngineLock lock) {
    log.debugFormat("Before releasing a lock {0}", lock);
    globalLock.lock();
    try {
        if (lock.getSharedLocks() != null) {
            for (Entry<String, Guid> entry : lock.getSharedLocks().entrySet()) {
                releaseSharedLock(buildHashMapKey(entry));
            }
        }
        if (lock.getExclusiveLocks() != null) {
            for (Entry<String, Guid> entry : lock.getExclusiveLocks().entrySet()) {
                releaseExclusiveLock(buildHashMapKey(entry));
            }
        }
        releasedLock.signal();
    } finally {
        globalLock.unlock();
    }
}
#end_block

#method_before
@Override
public void clear() {
    try {
        log.warn("All in memory locks are going to be cleaned");
        globalLock.lock();
        locks.clear();
        releasedLock.signalAll();
    } finally {
        globalLock.unlock();
    }
}
#method_after
@Override
public void clear() {
    log.warn("All in memory locks are going to be cleaned");
    globalLock.lock();
    try {
        locks.clear();
        releasedLock.signalAll();
    } finally {
        globalLock.unlock();
    }
}
#end_block

#method_before
private boolean acquireLockInternal(EngineLock lock) {
    boolean checkOnly = true;
    for (int i = 0; i < 2; i++) {
        if (lock.getUpdateRegions() != null) {
            for (Entry<String, Guid> entry : lock.getUpdateRegions().entrySet()) {
                if (!insertUpdateLock(buildHashMapKey(entry), checkOnly)) {
                    return false;
                }
            }
        }
        if (lock.getLockedRegions() != null) {
            for (Entry<String, Guid> entry : lock.getLockedRegions().entrySet()) {
                if (!insertLockedLock(buildHashMapKey(entry), checkOnly)) {
                    return false;
                }
            }
        }
        checkOnly = false;
    }
    return true;
}
#method_after
private boolean acquireLockInternal(EngineLock lock) {
    boolean checkOnly = true;
    for (int i = 0; i < 2; i++) {
        if (lock.getSharedLocks() != null) {
            for (Entry<String, Guid> entry : lock.getSharedLocks().entrySet()) {
                if (!insertSharedLock(buildHashMapKey(entry), checkOnly)) {
                    log.debugFormat("Failed to acquire a lock because of shared lock - key :{0} and value {1}", entry.getKey(), entry.getValue());
                    return false;
                }
            }
        }
        if (lock.getExclusiveLocks() != null) {
            for (Entry<String, Guid> entry : lock.getExclusiveLocks().entrySet()) {
                if (!insertExclusiveLock(buildHashMapKey(entry), checkOnly)) {
                    log.debugFormat("Failed to acquire a lock because of exclusive lock - key :{0} and value {1}", entry.getKey(), entry.getValue());
                    return false;
                }
            }
        }
        checkOnly = false;
    }
    log.debug("Successed to acquire a lock");
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm().getstatus() != VMStatus.MigratingFrom) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_CANCEL_MIGRATION_WHEN_VM_IS_NOT_MIGRATING);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CANCEL_MIGRATE);
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (getVm().getstatus() != VMStatus.MigratingFrom) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_CANCEL_MIGRATION_WHEN_VM_IS_NOT_MIGRATING);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((activeImage == null) ? 0 : activeImage.hashCode());
    result = prime * result + ((diskInterface == null) ? 0 : diskInterface.hashCode());
    result = prime * result + ((diskType == null) ? 0 : diskType.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((propagateErrors == null) ? 0 : propagateErrors.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + (wipeAfterDelete ? 1231 : 1237);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((activeImage == null) ? 0 : activeImage.hashCode());
    result = prime * result + ((diskInterface == null) ? 0 : diskInterface.hashCode());
    result = prime * result + ((diskType == null) ? 0 : diskType.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + internalDriveMapping;
    result = prime * result + ((propagateErrors == null) ? 0 : propagateErrors.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + (wipeAfterDelete ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof Disk)) {
        return false;
    }
    Disk other = (Disk) obj;
    if (activeImage == null) {
        if (other.activeImage != null) {
            return false;
        }
    } else if (!activeImage.equals(other.activeImage)) {
        return false;
    }
    if (diskInterface != other.diskInterface) {
        return false;
    }
    if (diskType != other.diskType) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (propagateErrors != other.propagateErrors) {
        return false;
    }
    if (status != other.status) {
        return false;
    }
    if (wipeAfterDelete != other.wipeAfterDelete) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof Disk)) {
        return false;
    }
    Disk other = (Disk) obj;
    if (activeImage == null) {
        if (other.activeImage != null) {
            return false;
        }
    } else if (!activeImage.equals(other.activeImage)) {
        return false;
    }
    if (diskInterface != other.diskInterface) {
        return false;
    }
    if (diskType != other.diskType) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (internalDriveMapping != other.internalDriveMapping) {
        return false;
    }
    if (propagateErrors != other.propagateErrors) {
        return false;
    }
    if (status != other.status) {
        return false;
    }
    if (wipeAfterDelete != other.wipeAfterDelete) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static String combine(String head, List<KeyValuePair> params) {
    String combined_params = "";
    if (params != null) {
        for (KeyValuePair pair : params) {
            combined_params += String.format(PARAMETER_TEMPLATE, pair.getKey(), pair.getValue());
        }
    }
    return head + combined_params;
}
#method_after
public static String combine(String head, Map<String, String> params) {
    String combined_params = "";
    if (params != null) {
        for (Entry<String, String> entry : params.entrySet()) {
            combined_params += String.format(PARAMETER_TEMPLATE, entry.getKey(), entry.getValue());
        }
    }
    return head + combined_params;
}
#end_block

#method_before
private RSDL construct() throws ClassNotFoundException, IOException {
    RSDL rsdl = new RSDL();
    for (DetailedLink link : getLinks()) {
        rsdl.getLinks().add(link);
    }
    return rsdl;
}
#method_after
private RSDL construct() throws ClassNotFoundException, IOException {
    RSDL rsdl = new RSDL();
    rsdl.setLinks(new DetailedLinks());
    for (DetailedLink link : getLinks()) {
        rsdl.getLinks().getLinks().add(link);
    }
    return rsdl;
}
#end_block

#method_before
@Override
public String toString() {
    return "RSDL Href: " + getHref() + ", Description:" + getDescription() + ", Links: " + (rsdl != null ? rsdl.getLinks().size() : "0") + ".";
}
#method_after
@Override
public String toString() {
    return "RSDL Href: " + getHref() + ", Description:" + getDescription() + ", Links: " + (rsdl != null ? (rsdl.isSetLinks() ? rsdl.getLinks().getLinks().size() : "0") : "0") + ".";
}
#end_block

#method_before
private API getApi() {
    API api = new API();
    for (DetailedLink link : getLinks()) {
        // add thin link
        api.getLinks().add(LinkHelper.createLink(link.getHref(), link.getRel()));
        // when required - add extra link for search
        if (link.isSetLinkCapabilities() && link.getLinkCapabilities().isSetSearchable() && link.getLinkCapabilities().isSearchable()) {
            api.getLinks().add(LinkHelper.createLink(link.getHref(), link.getRel(), link.getUrlParmeters()));
        }
    }
    return api;
}
#method_after
private API getApi() {
    API api = new API();
    for (DetailedLink detailedLink : getLinks()) {
        // add thin link
        api.getLinks().add(LinkHelper.createLink(detailedLink.getHref(), detailedLink.getRel()));
        // when required - add extra link for search
        if (detailedLink.isSetLinkCapabilities() && detailedLink.getLinkCapabilities().isSetSearchable() && detailedLink.getLinkCapabilities().isSearchable()) {
            api.getLinks().add(LinkHelper.createLink(detailedLink.getHref(), detailedLink.getRel(), detailedLink.getUrlParmeters()));
        }
    }
    return api;
}
#end_block

#method_before
@Override
public Response get() {
    BaseResource response = null;
    if (QueryHelper.hasConstraint(getUriInfo(), RSDL_CONSTRAINT_PARAMETER)) {
        response = addSystemVersion(getRSDL());
    } else {
        response = addSummary(addSystemVersion(getApi()));
    }
    return getResponseBuilder(response).entity(response).build();
}
#method_after
@Override
public Response get() {
    BaseResource response = null;
    if (QueryHelper.hasConstraint(getUriInfo(), RSDL_CONSTRAINT_PARAMETER)) {
        response = addSystemVersion(getRSDL());
    } else if (QueryHelper.hasConstraint(getUriInfo(), SCHEMA_CONSTRAINT_PARAMETER)) {
        return getSchema();
    } else {
        response = addSummary(addSystemVersion(getApi()));
    }
    return getResponseBuilder(response).entity(response).build();
}
#end_block

#method_before
private synchronized RSDL getRSDL() {
    if (rsdl == null) {
        rsdl = new RsdlBuilder(this).description(RSDL_DESCRIPTION).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + RSDL_CONSTRAINT_PARAMETER).build();
    }
    return rsdl;
}
#method_after
private synchronized RSDL getRSDL() {
    if (rsdl == null) {
        rsdl = new RsdlBuilder(this).description(RSDL_DESCRIPTION).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + RSDL_CONSTRAINT_PARAMETER).schema(new SchemaBuilder().rel(SCHEMA_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + SCHEMA_CONSTRAINT_PARAMETER).name(SCHEMA_NAME).description(SCHEMA_DESCRIPTION).build()).build();
    }
    return rsdl;
}
#end_block

#method_before
public static Link createLink(String url, String rel) {
    Link link = new Link();
    link.setRel(rel);
    // link.setHref(combine(url, rel));
    link.setHref(url);
    return link;
}
#method_after
public static Link createLink(String url, String rel) {
    Link link = new Link();
    link.setRel(rel);
    link.setHref(url);
    return link;
}
#end_block

#method_before
@Before
public void setUpEngineConfigLogicTest() throws Exception {
    engineConfigLogic = new EngineConfigLogic(parser);
}
#method_after
@BeforeClass
public static void setUpEngineConfigLogicTest() throws Exception {
    engineConfigLogic = new EngineConfigLogic(parser);
}
#end_block

#method_before
@Test
public void testGetValue() throws Exception {
    String key = "MaxNumberOfHostsInStoragePool";
    log.info("getValue: Testing fetch of " + key);
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    log.info("getValue: got: " + configKey);
    Assert.assertNotNull(configKey.getValue());
}
#method_after
@Test
public void testGetValue() throws Exception {
    final String key = "MaxNumberOfHostsInStoragePool";
    log.info("getValue: Testing fetch of " + key);
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    log.info("getValue: got: " + configKey);
    Assert.assertNotNull(configKey.getValue());
}
#end_block

#method_before
@Test
public void testSetIntValue() throws Exception {
    String key = "VdsRefreshRate";
    String newValue = "15";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setIntValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(Integer.parseInt(updatedValue), Integer.parseInt(newValue));
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#method_after
@Test
public void testSetIntValue() throws Exception {
    final String key = "VdsRefreshRate";
    final String newValue = "15";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setIntValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(Integer.parseInt(updatedValue), Integer.parseInt(newValue));
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#end_block

#method_before
@Test
public void testSetStringValue() throws Exception {
    String key = "DefaultWorkgroup";
    String newValue = "ExampleWorkGroup";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setStringValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(updatedValue, newValue);
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#method_after
@Test
public void testSetStringValue() throws Exception {
    final String key = "DefaultWorkgroup";
    final String newValue = "ExampleWorkGroup";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setStringValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(updatedValue, newValue);
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#end_block

#method_before
@Test
public void testGetNonExitingKey() throws Exception {
    String key = "NonExistignKeyDB";
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    Assert.assertTrue(configKey == null || configKey.getKey() == null);
}
#method_after
@Test
public void testGetNonExitingKey() throws Exception {
    final String key = "NonExistignKeyDB";
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    Assert.assertTrue(configKey == null || configKey.getKey() == null);
}
#end_block

#method_before
@Test(expected = IllegalAccessException.class)
public void testSetInvalidIntValue() throws Exception {
    String key = "VdsRefreshRate";
    // An exception should be thrown
    engineConfigLogic.persist(key, "Not A Number", "");
}
#method_after
@Test(expected = IllegalAccessException.class)
public void testSetInvalidIntValue() throws Exception {
    final String key = "VdsRefreshRate";
    // An exception should be thrown
    engineConfigLogic.persist(key, "Not A Number", "");
}
#end_block

#method_before
private String getOldValue(String key) {
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    return configKey.getValue();
}
#method_after
private String getOldValue(final String key) {
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    return configKey.getValue();
}
#end_block

#method_before
@BeforeClass
public static void setConfigFilePathProperty() {
    String path = ClassLoader.getSystemResource("engine-config.conf").getPath();
    System.setProperty(EngineConfig.CONFIG_FILE_PATH_PROPERTY, path);
}
#method_after
@BeforeClass
public static void setConfigFilePathProperty() {
    final String path = ClassLoader.getSystemResource("engine-config.conf").getPath();
    System.setProperty(EngineConfig.CONFIG_FILE_PATH_PROPERTY, path);
}
#end_block

#method_before
@Test
public void testConfigDirWithFlagSet() throws Exception {
    // get the real path of the config file
    String path = ClassLoader.getSystemResource("engine-config.conf").getPath();
    assertNotNull(path);
    EngineConfig.main("-a", "--config=" + path);
}
#method_after
@Test
public void testConfigDirWithFlagSet() throws Exception {
    // get the real path of the config file
    final String path = ClassLoader.getSystemResource("engine-config.conf").getPath();
    Assert.assertNotNull(path);
    EngineConfig.main("-a", "--config=" + path);
}
#end_block

#method_before
@Test
public void getValueWithMultipleVersions() throws Exception {
    String key = "MaxNumOfVmSockets";
    log.info("getValue: Testing fetch multiple version of " + key);
    List<ConfigKey> keys = config.getEngineConfigLogic().getConfigDAO().getKeysForName(key);
    for (ConfigKey configKey : keys) {
        log.info(configKey.getDisplayValue() + " version: " + configKey.getVersion());
    }
    Assert.assertTrue(keys.size() > 0);
}
#method_after
@Test
public void getValueWithMultipleVersions() throws Exception {
    final String key = "MaxNumOfVmSockets";
    log.info("getValue: Testing fetch multiple version of " + key);
    List<ConfigKey> keys = config.getEngineConfigLogic().getConfigDAO().getKeysForName(key);
    for (ConfigKey configKey : keys) {
        log.info(configKey.getDisplayValue() + " version: " + configKey.getVersion());
    }
    Assert.assertTrue(keys.size() > 0);
}
#end_block

#method_before
@Test(expected = IllegalAccessException.class)
public void setOutOfRangeValue() throws Exception {
    String key = "FenceQuietTimeBetweenOperationsInSec";
    // Should throw IllegalAccessException since the given value is out of range
    boolean setKeyValue = config.getEngineConfigLogic().persist(key, OUT_OF_RANGE_FOR_FENCE_QUIET_TIME, "");
}
#method_after
@Test(expected = IllegalAccessException.class)
public void setOutOfRangeValue() throws Exception {
    final String outOfRangeForFenceQuietTime = "601";
    final String key = "FenceQuietTimeBetweenOperationsInSec";
    // Should throw IllegalAccessException since the given value is out of range
    config.getEngineConfigLogic().persist(key, outOfRangeForFenceQuietTime, "");
}
#end_block

#method_before
@Test
public void setInvalidStringValue() throws Exception {
    String key = "LDAP_Security_mode";
    // not valid
    Assert.assertFalse(config.getEngineConfigLogic().persist(key, "GSSAPI-invalid-value"));
}
#method_after
@Test
public void setInvalidStringValue() throws Exception {
    final String key = "LDAP_Security_mode";
    // not valid
    Assert.assertFalse(config.getEngineConfigLogic().persist(key, "GSSAPI-invalid-value"));
}
#end_block

#method_before
@Test
public void setStringValueFromFlag() throws Exception {
    String certificateFileNameKey = "CertificateFileName";
    // Backing up current CertificateFileName
    ConfigKey originalAuthenticationMethod = config.getEngineConfigLogic().fetchConfigKey(certificateFileNameKey, "general");
    String certificateFileNameNewValue = "/certs/";
    String version = "general";
    setKeyAndValidate(certificateFileNameKey, certificateFileNameNewValue, version);
    // Restoring original value and making sure it was restored successfully
    restoreOriginalValue(certificateFileNameKey, originalAuthenticationMethod);
}
#method_after
@Test
public void setStringValueFromFlag() throws Exception {
    final String certificateFileNameKey = "CertificateFileName";
    // Backing up current CertificateFileName
    ConfigKey originalAuthenticationMethod = config.getEngineConfigLogic().fetchConfigKey(certificateFileNameKey, "general");
    final String certificateFileNameNewValue = "/certs/";
    setKeyAndValidate(certificateFileNameKey, certificateFileNameNewValue, "general");
    // Restoring original value and making sure it was restored successfully
    restoreOriginalValue(certificateFileNameKey, originalAuthenticationMethod);
}
#end_block

#method_before
private void setKeyAndValidate(String keyName, String value, String version) throws IllegalAccessException {
    boolean setKeyValue = config.getEngineConfigLogic().persist(keyName, value, version);
    ConfigKey currentConfigKey = config.getEngineConfigLogic().fetchConfigKey(keyName, "general");
    Assert.assertEquals(value, currentConfigKey.getValue());
}
#method_after
private void setKeyAndValidate(final String keyName, final String value, final String version) throws IllegalAccessException {
    config.getEngineConfigLogic().persist(keyName, value, version);
    ConfigKey currentConfigKey = config.getEngineConfigLogic().fetchConfigKey(keyName, "general");
    Assert.assertEquals(value, currentConfigKey.getValue());
}
#end_block

#method_before
private void restoreOriginalValue(String keyName, ConfigKey originialValue) throws IllegalAccessException {
    boolean setKeyValue = config.getEngineConfigLogic().persist(keyName, originialValue.getValue(), originialValue.getVersion());
    ConfigKey currentConfigKey = config.getEngineConfigLogic().fetchConfigKey(keyName, "general");
    Assert.assertEquals(originialValue.getValue(), currentConfigKey.getValue());
}
#method_after
private void restoreOriginalValue(final String keyName, ConfigKey originialValue) throws IllegalAccessException {
    config.getEngineConfigLogic().persist(keyName, originialValue.getValue(), originialValue.getVersion());
    ConfigKey currentConfigKey = config.getEngineConfigLogic().fetchConfigKey(keyName, "general");
    Assert.assertEquals(originialValue.getValue(), currentConfigKey.getValue());
}
#end_block

#method_before
@Test
public void testMemory() {
    storage_domains entity = new storage_domains();
    entity.setavailable_disk_size(3);
    entity.setused_disk_size(4);
    entity.setcommitted_disk_size(5);
    StorageDomain model = StorageDomainMapper.map(entity, (StorageDomain) null);
    assertEquals(model.getAvailable(), new Long(3221225472L));
    assertEquals(model.getUsed(), new Long(4294967296L));
    assertEquals(model.getCommitted(), Long.valueOf(5368709120L));
}
#method_after
@Test
public void testMemory() {
    storage_domains entity = new storage_domains();
    entity.setavailable_disk_size(3);
    entity.setused_disk_size(4);
    entity.setcommitted_disk_size(5);
    StorageDomain model = StorageDomainMapper.map(entity, (StorageDomain) null);
    assertEquals(model.getAvailable(), Long.valueOf(3221225472L));
    assertEquals(model.getUsed(), Long.valueOf(4294967296L));
    assertEquals(model.getCommitted(), Long.valueOf(5368709120L));
}
#end_block

#method_before
public boolean CheckFreeSpaceOnDestinationDomains() {
    boolean retValue = true;
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDAO().get(getParameters().getVmStaticData().getvmt_guid());
    VmTemplateHandler.UpdateDisksFromDb(vmTemplate);
    double size = 0.0;
    java.util.ArrayList<Guid> domainsList;
    if (getStorageDomainId() == null || getStorageDomainId().getValue().equals(Guid.Empty)) {
        domainsList = (java.util.ArrayList<Guid>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageDomainsList, new GetImageDomainsListVDSCommandParameters(vmTemplate.getstorage_pool_id().getValue(), vmTemplate.getDiskList().get(0).getimage_group_id().getValue())).getReturnValue();
    } else {
        domainsList = new java.util.ArrayList<Guid>();
        domainsList.add(getStorageDomainId().getValue());
    }
    for (Guid domainId : domainsList) {
        storage_domains domain = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domainId, vmTemplate.getstorage_pool_id());
        if (domain != null && domain.getstorage_domain_type() != StorageDomainType.ImportExport && domain.getstatus() == StorageDomainStatus.Active && domain.getavailable_disk_size() != null && StorageDomainSpaceChecker.hasSpaceForRequest(domain, getBlockSparseInitSizeInGB())) {
            size += domain.getavailable_disk_size() - Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
        }
    }
    if (size < (getBlockSparseInitSizeInGB() * getParameters().getVmsCount() * vmTemplate.getDiskMap().size())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    return retValue;
}
#method_after
public boolean CheckFreeSpaceOnDestinationDomains() {
    boolean retValue = true;
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDAO().get(getParameters().getVmStaticData().getvmt_guid());
    VmTemplateHandler.UpdateDisksFromDb(vmTemplate);
    double size = 0.0;
    java.util.ArrayList<Guid> domainsList;
    if (getStorageDomainId() == null || getStorageDomainId().getValue().equals(Guid.Empty)) {
        domainsList = (java.util.ArrayList<Guid>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageDomainsList, new GetImageDomainsListVDSCommandParameters(vmTemplate.getstorage_pool_id().getValue(), vmTemplate.getDiskList().get(0).getimage_group_id().getValue())).getReturnValue();
    } else {
        domainsList = new java.util.ArrayList<Guid>();
        domainsList.add(getStorageDomainId().getValue());
    }
    for (Guid domainId : domainsList) {
        storage_domains domain = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domainId, vmTemplate.getstorage_pool_id());
        if (domain != null && domain.getstorage_domain_type() != StorageDomainType.ImportExport && domain.getstatus() == StorageDomainStatus.Active && domain.getavailable_disk_size() != null && StorageDomainSpaceChecker.hasSpaceForRequest(domain, getBlockSparseInitSizeInGB())) {
            size += domain.getavailable_disk_size() - getFreeSpaceCriticalLowInGB();
        }
    }
    if (size < (getBlockSparseInitSizeInGB() * getParameters().getVmsCount() * vmTemplate.getDiskMap().size())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    return retValue;
}
#end_block

#method_before
public boolean CanAddVm(Object vmTemplateId, java.util.ArrayList<String> reasons) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = CanAddVm(vmTemplateId, reasons, 1, vmStaticFromParams.getvm_name(), getStoragePoolId().getValue(), vmStaticFromParams.getpriority());
    if (returnValue) {
        List<ValidationError> validationErrors = VmPropertiesUtils.validateVMProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    if (returnValue && getVmTemplate().getDiskMap().size() > 0 && !LinqUtils.firstOrNull(getVmTemplate().getDiskMap().values(), new All<DiskImageTemplate>()).getId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        storage_domains domain = DbFacade.getInstance().getStorageDomainDAO().get(getStorageDomainId().getValue());
        if (!StorageDomainSpaceChecker.isBelowThresholds(domain)) {
            returnValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
        } else if (!getStoragePoolId().equals(getVmTemplate().getstorage_pool_id().getValue())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else if (domain.getStorageDynamicData() != null) {
            // populate template disks for domain size check
            VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
            int diskSizeAmount = getParameters().getIsVmCloned() ? (int) getVmTemplate().getActualDiskSize() : getBlockSparseInitSizeInGB() * getVmTemplate().getDiskMap().size();
            returnValue = StorageDomainSpaceChecker.hasSpaceForRequest(domain, diskSizeAmount);
            if (!returnValue)
                reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
        }
    }
    // Check id dedicated host is same as VM cluster
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#method_after
public boolean CanAddVm(Object vmTemplateId, java.util.ArrayList<String> reasons) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = CanAddVm(vmTemplateId, reasons, 1, vmStaticFromParams.getvm_name(), getStoragePoolId().getValue(), vmStaticFromParams.getpriority());
    if (returnValue) {
        List<ValidationError> validationErrors = VmPropertiesUtils.validateVMProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    if (returnValue && getVmTemplate().getDiskMap().size() > 0 && !LinqUtils.firstOrNull(getVmTemplate().getDiskMap().values(), new All<DiskImageTemplate>()).getId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        storage_domains domain = DbFacade.getInstance().getStorageDomainDAO().get(getStorageDomainId().getValue());
        if (!StorageDomainSpaceChecker.isBelowThresholds(domain)) {
            returnValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
        } else if (!getStoragePoolId().equals(getVmTemplate().getstorage_pool_id().getValue())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else if (domain.getStorageDynamicData() != null) {
            // populate template disks for domain size check
            VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
            returnValue = StorageDomainSpaceChecker.hasSpaceForRequest(domain, getNeededDiskSize());
            if (!returnValue)
                reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
        }
    }
    // Check id dedicated host is same as VM cluster
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#end_block

#method_before
public static String encryptPassword(String password) {
    String result = password;
    String keyFile = Config.<String>GetValue(ConfigValues.keystoreUrl, Config.DefaultConfigurationVersion);
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        result = EncryptionUtils.encrypt((String) result, keyFile, passwd, alias);
    } catch (Exception e) {
        result = password;
    }
    return result;
}
#method_after
public static String encryptPassword(String password) {
    if (StringHelper.isEmpty(password)) {
        return password;
    }
    String result = password;
    String keyFile = Config.<String>GetValue(ConfigValues.keystoreUrl, Config.DefaultConfigurationVersion);
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        result = EncryptionUtils.encrypt((String) result, keyFile, passwd, alias);
    } catch (Exception e) {
        throw new SecurityException(e);
    }
    return result;
}
#end_block

#method_before
public static String decryptPassword(String password) {
    String result = password;
    String keyFile = Config.<String>GetValue(ConfigValues.keystoreUrl, Config.DefaultConfigurationVersion);
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        result = EncryptionUtils.decrypt((String) result, keyFile, passwd, alias);
    } catch (Exception e) {
        result = password;
    }
    return result;
}
#method_after
public static String decryptPassword(String password) {
    if (StringHelper.isEmpty(password)) {
        return password;
    }
    String result = password;
    String keyFile = Config.<String>GetValue(ConfigValues.keystoreUrl, Config.DefaultConfigurationVersion);
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        result = EncryptionUtils.decrypt((String) result, keyFile, passwd, alias);
    } catch (Exception e) {
        log.debugFormat("Failed to decrypt password, error message: {0}", e.getMessage());
        result = password;
    }
    return result;
}
#end_block

#method_before
@Test
public void statusMatches() {
    storageDomainIsInactive();
    assertTrue(cmd.CheckStorageDomainStatus(StorageDomainStatus.InActive));
    assertFalse(commandHasInvalidStatusMessage());
}
#method_after
@Test
public void statusMatches() {
    storageDomainIsInactive();
    assertTrue(cmd.checkStorageDomainStatus(StorageDomainStatus.InActive));
    assertFalse(commandHasInvalidStatusMessage());
}
#end_block

#method_before
@Test
public void statusNotMatch() {
    storageDomainIsInactive();
    assertFalse(cmd.CheckStorageDomainStatus(StorageDomainStatus.Active));
    assertTrue(commandHasInvalidStatusMessage());
}
#method_after
@Test
public void statusNotMatch() {
    storageDomainIsInactive();
    assertFalse(cmd.checkStorageDomainStatus(StorageDomainStatus.Active));
    assertTrue(commandHasInvalidStatusMessage());
}
#end_block

#method_before
private void createTestCommand() {
    StorageDomainParametersBase parameters = new StorageDomainParametersBase(Guid.NewGuid());
    cmd = spy(new TestStorageCommandBaseTest(new StorageDomainParametersBase()));
}
#method_after
private void createTestCommand() {
    StorageDomainParametersBase parameters = new StorageDomainParametersBase(Guid.NewGuid());
    cmd = spy(new TestStorageCommandBase(new StorageDomainParametersBase()));
}
#end_block

#method_before
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    boolean returnValue = CheckStoragePool() && CheckStorageDomain() && CheckStorageDomainStatus(StorageDomainStatus.InActive) && (getStorageDomain().getstorage_domain_type() == StorageDomainType.Master || isDestroyStoragePool || CheckMasterDomainIsUp());
    if (returnValue) {
        if (this.getStoragePool().getstorage_pool_type() == StorageType.LOCALFS && getStorageDomain().getstorage_domain_type() == StorageDomainType.Data && !isInternal) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DETACH_DATA_DOMAIN_FROM_LOCAL_STORAGE);
        }
    }
    if (returnValue) {
        if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getid(), getStoragePoolId())) == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
        } else if (DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForStorageDomain(getStorageDomain().getid()).size() != 0 || DbFacade.getInstance().getStorageDomainDAO().getAllImageGroupStorageDomainMapsForStorageDomain(getStorageDomain().getid()).size() != 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_STORAGE_DOMAIN_WITH_IMAGES);
        } else if (!isRemoveLast && getStorageDomain().getstorage_domain_type() == StorageDomainType.Master) {
            storage_domains storage_domains = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getstorage_pool_id().getValue()), new Predicate<storage_domains>() {

                @Override
                public boolean eval(storage_domains a) {
                    return a.getid().equals(getStorageDomain().getid()) && a.getstatus() == StorageDomainStatus.Active;
                }
            });
            if (storage_domains == null) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    boolean returnValue = CheckStoragePool() && CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.InActive) && (getStorageDomain().getstorage_domain_type() == StorageDomainType.Master || isDestroyStoragePool || CheckMasterDomainIsUp());
    if (returnValue) {
        if (this.getStoragePool().getstorage_pool_type() == StorageType.LOCALFS && getStorageDomain().getstorage_domain_type() == StorageDomainType.Data && !isInternal) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DETACH_DATA_DOMAIN_FROM_LOCAL_STORAGE);
        }
    }
    if (returnValue) {
        if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getid(), getStoragePoolId())) == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
        } else if (DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForStorageDomain(getStorageDomain().getid()).size() != 0 || DbFacade.getInstance().getStorageDomainDAO().getAllImageGroupStorageDomainMapsForStorageDomain(getStorageDomain().getid()).size() != 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_STORAGE_DOMAIN_WITH_IMAGES);
        } else if (!isRemoveLast && getStorageDomain().getstorage_domain_type() == StorageDomainType.Master) {
            storage_domains storage_domains = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getstorage_pool_id().getValue()), new Predicate<storage_domains>() {

                @Override
                public boolean eval(storage_domains a) {
                    return a.getid().equals(getStorageDomain().getid()) && a.getstatus() == StorageDomainStatus.Active;
                }
            });
            if (storage_domains == null) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    if (getStorageDomainStatus() != null) {
        valid = isStorageDomainStatusInList(getStorageDomainStatus(), statuses);
    }
    if (!valid) {
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#method_after
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    if (getStorageDomainStatus() != null) {
        valid = Arrays.asList(statuses).contains(getStorageDomainStatus());
    }
    if (!valid) {
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#end_block

#method_before
private StorageDomainStatus getStorageDomainStatus() {
    StorageDomainStatus status = null;
    if (getStorageDomain() != null && getStorageDomain().getstatus() != null) {
        status = getStorageDomain().getstatus();
    }
    return status;
}
#method_after
private StorageDomainStatus getStorageDomainStatus() {
    StorageDomainStatus status = null;
    if (getStorageDomain() != null) {
        status = getStorageDomain().getstatus();
    }
    return status;
}
#end_block

#method_before
public static String LocalDateToUtcDateString(java.util.Date date) {
    return getDateFormat(utcDateFormatStr).format(date);
}
#method_after
public static String LocalDateToUtcDateString(Date date) {
    return getDateFormat(utcDateFormatStr).format(date);
}
#end_block

